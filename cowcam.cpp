#include	<unistd.h>
#include	<sched.h>
#include	<time.h>
#include	<sys/time.h>
#include	<fcntl.h>
#include	<semaphore.h>
#include	<sys/sendfile.h>
#include	<signal.h>
#include	<link.h>
#include	<dlfcn.h>
#include	<dirent.h>
#include	<libgen.h>
#include	<magic.h>

#include <iostream>
#include <string>
#include <memory>
#include <thread>
#include <chrono>

#include	<sys/ioctl.h>
#include	<curl/curl.h>
#include	<linux/videodev2.h>

#include	<fftw3.h>

#include	<argv_split.h>

#include	<cjson/cJSON.h>

#include <osg/MatrixTransform>
#include <osgViewer/Viewer>
#include <osgViewer/CompositeViewer>
#include <osgViewer/ViewerEventHandlers>
#include <osgGA/TrackballManipulator>
#include <osgGA/TerrainManipulator>
#include <osgGA/FlightManipulator>
#include <osgGA/DriveManipulator>
#include <osgDB/ReadFile>

extern "C"
{
#include <libavutil/avassert.h>
#include <libavutil/channel_layout.h>
#include <libavutil/opt.h>
#include <libavutil/mathematics.h>
#include <libavutil/timestamp.h>
#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>
#include <libswscale/swscale.h>
#include <libswresample/swresample.h>
}

#include <cef_app.h>
#include <cef_client.h>
#include <cef_parser.h>
#include <cef_render_handler.h>
#include <cef_life_span_handler.h>
#include <cef_load_handler.h>
#include <wrapper/cef_helpers.h>

#include <opencv2/opencv.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <opencv2/dnn.hpp>

#include <opencv2/core/core_c.h>

#include <pulse/simple.h>
#include <pulse/volume.h>
#include <pulse/error.h>

#include <vlc/vlc.h>

#include <blend2d.h>

#include	<FL/Fl.H>
#include	<FL/platform.H>
#include	<Fl/Fl_Cairo.H>
#include	<FL/Fl_Window.H>
#include	<FL/Fl_Double_Window.H>
#include	<FL/Fl_Gl_Window.H>
#include	<FL/Fl_Tooltip.H>
#include	<FL/Fl_Input.H>
#include	<FL/Fl_Box.H>
#include	<FL/Fl_Button.H>
#include	<FL/Fl_Repeat_Button.H>
#include	<FL/Fl_Slider.H>
#include	<FL/Fl_Hor_Fill_Slider.H>
#include	<FL/Fl_Hor_Slider.H>
#include	<FL/Fl_Value_Slider.H>
#include	<FL/Fl_Hor_Nice_Slider.H>
#include	<FL/Fl_Input.H>
#include	<FL/Fl_Int_Input.H>
#include	<FL/Fl_Float_Input.H>
#include	<FL/Fl_Scroll.H>
#include	<FL/Fl_Pack.H>
#include	<FL/Fl_Flex.H>
#include	<FL/Fl_Menu_Button.H>
#include	<FL/Fl_Light_Button.H>
#include	<FL/Fl_Toggle_Button.H>
#include	<FL/Fl_Chart.H>
#include	<FL/Fl_Shared_Image.H>
#include	<FL/Fl_Choice.H>
#include	<FL/fl_draw.H>
#include	<FL/fl_ask.H>
#include	<FL/Fl_File_Chooser.H>
#include	<FL/Fl_Native_File_Chooser.H>
#include	<FL/Fl_Color_Chooser.H>
#include	<FL/Fl_Output.H>
#include	<FL/Fl_Multiline_Output.H>
#include	<FL/Fl_Multiline_Input.H>
#include	<FL/Fl_Browser.H>
#include	<FL/Fl_Hold_Browser.H>
#include	<FL/Fl_Select_Browser.H>
#include	<FL/Fl_Image_Surface.H>
#include	<FL/Fl_RGB_Image.H>
#include	<FL/Fl_PNG_Image.H>
#include	<FL/Fl_Pack.H>
#include	<FL/Fl_Copy_Surface.H>
#include	<FL/Fl_SVG_Image.H>

#include	<X11/Xlib.h>
#include	<X11/X.h>
#include	<sys/shm.h>
#include	<sys/ipc.h>
#include	<X11/extensions/XShm.h>
#include	<X11/extensions/Xfixes.h>
#include	<X11/extensions/Xcomposite.h>
#include	<X11/extensions/Xrender.h>
#include	<X11/extensions/Xrender.h>
#include	<X11/XKBlib.h>

#include	<visca/libvisca_ip.h>
#include	<cairo.h>

#include	<Processing.NDI.Lib.h>
#include	<Processing.NDI.DynamicLoad.h>

#include	<lunasvg.h>

#include	"osg.h"
#include	"libircclient.h"
#include	"irc.h"
#include	"intro.h"

#include	"folder.h"

extern "C"
{
	void			merge_av(char *, char *, char *);
	irc_session_t	*cow_irc_connect(char *server, int in_port, char *user_name, char *password, char *channel_name);
	int				cow_irc_run(irc_session_t *s, char *in_buffer);
}

using namespace cv;
using namespace dnn;
using namespace std;

#include	"image_memory.h"
#include	"PulseAudio.h"
#include	"vlc_window.h"
#include	"html_window.h"
#include	"embed_app.h"
#include	"cowcam.h"
#include	"muxer.h"

#define READ 0
#define WRITE 1

#define MAX_PROPERTY_VALUE_LEN 4096

// X11 Button Masks
#define BUTTON_1_MASK	 (1<<8)
#define BUTTON_2_MASK	 (1<<9)
#define BUTTON_3_MASK	 (1<<10)

#define	DISPLAYED_THUMB_CNT	5

int			pulse_list_devices(char *def_source, char *def_sink, int in_or_out, int limit, char **list, char **description, int *index, int *channels, int *rate);
void		*read_wave(char *filename, int *in_bits, int *in_channels, float *in_sample_rate, int *in_num_samples, float *in_seconds);
void		vlc_window_start_cb(void *);
int			my_find_codec_by_id(int type, int in_id, char *result);
void		slideshow_cb(void *v);

MyWin			*global_window = NULL;
int				global_audio_sudden_stop = 0;

StartWindow		*start_win = NULL;

char			*global_argv[1024];
int				global_argc;
int				global_html = 1;

extern MyFormat		*global_my_format[1024];
extern int			global_my_format_cnt;

void			*global_plugin_handle[1024];
void			*void_pseudo_camera = NULL;
void			*void_handle_events = NULL;

void			*void_filter_plugin[1024];
char			*global_filter_plugin[1024];
int				global_filter_plugin_cnt = 0;

void			*void_audio_filter_plugin[1024];
char			*global_audio_filter_plugin[1024];
int				global_audio_filter_plugin_cnt = 0;

void			*global_transition_plugin_handle[1024];
char			*global_transition_plugin_file[1024];
int				global_transition_plugin_file_cnt = 0;

char			*global_potential_transition[1024];
void			*global_potential_transition_handle[1024];
char			*global_transition_plugin;

void			*void_transition_plugin;
int				global_potential_transition_cnt = 0;

char			*global_filter_plugin_file[1024];
int				global_filter_plugin_file_cnt = 0;

char			*global_potential_filter[1024];
void			*global_potential_filter_handle[1024];
int				global_potential_filter_cnt = 0;

char			*global_potential_audio_filter[1024];
void			*global_potential_audio_filter_handle[1024];
int				global_potential_audio_filter_cnt = 0;

char			*global_potential_camera[1024];
void			*global_potential_camera_handle[1024];
int				global_potential_camera_cnt = 0;

char			*global_potential_fltk[1024];
void			*global_potential_fltk_handle[1024];
int				global_potential_fltk_cnt = 0;

void			*global_capture_plugin_handle = NULL;
void			*void_capture_init_capture = NULL;
void			*void_capture_capture = NULL;
void			*void_capture_finish_capture = NULL;
char			global_capture_plugin_file[4096];

void			*global_cef_handle = NULL;
void			*void_initialize_cef = NULL;
void			*void_shutdown_cef = NULL;
void			*void_MakeHTMLWindow_cef = NULL;
void			*void_delete_html_cef = NULL;
void			*void_get_image_cef = NULL;

void			*global_osg_handle = NULL;
void			*void_OSG_get_scene_data = NULL;
void			*void_OSG_Translate = NULL;
void			*void_OSG_Rotate = NULL;
void			*void_OSG_Scale = NULL;
void			*void_OSG_open_osg = NULL;
int				global_osg_enabled = 0;

int	global_palette_red[32];
int global_palette_green[32];
int global_palette_blue[32];
int global_palette_alpha[32];

cairo_matrix_t			global_cairo_matrix[128];
int						global_cairo_matrix_cnt = 0;

Mat						global_folder_mat;

pid_t			clock_pid = -1;

const NDIlib_v3		*NDILib;
void				*hNDILib;

Fl_Window		*global_log_window = NULL;

char	*available_scheme[] = {
	"alert://text_filename:trigger_mode#:display_mode#:duration#:opaque#:audio_filename",
	"alert://alert://one.txt:1:2:10:1:play.wav",
	"all://",
	"all://",
	"alternating://",
	"alternating://",
	"av://URL | filename",
	"av://www.example.org/video_file.mp4\nav://local_file.flv",
	"blank://rr#,gg#,bb#,aa#",
	"blank://92,27,124,255",
	"chroma://[(fact#)]alias",
	"chroma://(0.72)MyCamera1",
	"clock://mil#:clock format#:analog#:analog size#",
	"clock://0:1\n[military time (0=off, 1=on) clock formats from 0 to 2] analog (1=on) analog size",
	"desktop://",
	"desktop://",
	"dynamic://text",
	"dynamic://This is a sample",
	"edge://[(fact#)]alias",
	"edge://(0.24)MyCamera2",
	"html://URL[\\nCSS]",
	"html://www.example.net\n[optional CSS to be inserted]",
	"html source://html source code",
	"html source://<html><head></head><body><P>Title</P></body></html>\n[etc.]",
	"http://URL[\\nCSS]",
	"http://www.example.com\n[optional CSS to be inserted]",
	"https://URL[\\nCSS]",
	"https://www.example.com\n[optional CSS to be inserted]",
	"irc://\\nport\\nuser\\nPW\\nCH",
	"irc://\n6667\nirc.chat.com\nUserID\nThis is a password\n#hobbies",
	"ndi://stream",
	"ndi://NDI stream one",
	"ndi_rgbx://stream",
	"ndi_rgbx://NDI RGB stream 2",
	"ndi_bgrx://stream",
	"ndi_bgrx://NDI BGR stream 3",
	"ndi_i420://stream",
	"ndi_i420://NDI I420 stream",
	"ndi_p216://stream",
	"ndi_p216://NDI P216 stream",
	"ndi_uyva://stream",
	"ndi_uyva://NDI UYVA",
	"ndi_uyvy://stream",
	"ndi_uyvy://NDI UYVY",
	"osg://filename",
	"osg://my_local_3d_file.osg",
	"pipe://executable",
	"pipe://ls -l",
	"pseudo://alias",
	"pseudo://MyCamera1",
	"sff://filename",
	"sff://my_local_frame_file.sff",
	"slideshow://[directory | filename]",
	"slideshow://MyPictures",
	"sourced://[(fact#)]alias",
	"sourced://(0.55)]MyCamera12",
	"split://[width,height;source alias1,source alias2,...]",
	"split://3,2;cam1,street cam,office cam,hallway,[blank],front door",
	"timer://start[,stop][:format#]",
	"timer://0,3600:2\n[Start and stop specified in seconds. If start is greater than stop, count down. Timer format 0 to 2]",
	"vector://filename",
	"vector://vector_example.svg",
	"window://win#",
	"window://1600045",
	NULL,
	NULL
};

struct	NamedKeys named_key[] = {
	{"Space", 0x20},
	{"Alt L", 0xffe9},
	{"Alt R", 0xffea},
	{"Back", 0xEF26},
	{"BackSpace", 0xff08},
	{"Button", 0xfee8},
	{"Caps Lock", 0xffe5},
	{"Control L", 0xffe3},
	{"Control R", 0xffe4},
	{"Delete", 0xffff},
	{"Down", 0xff54},
	{"Eisu", 0xff2f},
	{"End", 0xff57},
	{"Enter", 0xff0d},
	{"Escape", 0xff1b},
	{"Function 1", 0xffbe},
	{"Function 2", 0xffbe + 1},
	{"Function 3", 0xffbe + 2},
	{"Function 4", 0xffbe + 3},
	{"Function 5", 0xffbe + 4},
	{"Function 6", 0xffbe + 5},
	{"Function 7", 0xffbe + 6},
	{"Function 8", 0xffbe + 7},
	{"Function 9", 0xffbe + 8},
	{"Function 10", 0xffbe + 9},
	{"Function 11", 0xffbe + 10},
	{"Function 12", 0xffbe + 11},
	{"Favorites", 0xEF30},
	{"Forward", 0xEF27},
	{"Help", 0xff68},
	{"Home", 0xff50},
	{"Home Page", 0xEF18},
	{"Insert", 0xff63},
	{"Iso Key", 0xff0c},
	{"JIS Underscore", 0xff31},
	{"Kana", 0xff2e},
	{"KP 1", 0xff80 + '1'},
	{"KP 2", 0xff80 + '2'},
	{"KP 3", 0xff80 + '3'},
	{"KP 4", 0xff80 + '4'},
	{"KP 5", 0xff80 + '5'},
	{"KP 6", 0xff80 + '6'},
	{"KP 7", 0xff80 + '7'},
	{"KP 8", 0xff80 + '8'},
	{"KP 9", 0xff80 + '9'},
	{"KP 0", 0xff80 + '0'},
	{"KP +", 0xff80 + '+'},
	{"KP -", 0xff80 + '-'},
	{"KP Enter", 0xff8d},
	{"Left", 0xff51},
	{"Mail", 0xEF19},
	{"Media Next", 0xEF17},
	{"Media Play", 0xEF14},
	{"Media Prev", 0xEF16},
	{"Media Stop", 0xEF15},
	{"Menu", 0xff67},
	{"Meta L", 0xffe7},
	{"Meta R", 0xffe8},
	{"Num Lock", 0xff7f},
	{"Page Down", 0xff56},
	{"Page Up", 0xff55},
	{"Pause", 0xff13},
	{"Print", 0xff61},
	{"Refresh", 0xEF29},
	{"Right", 0xff53},
	{"Scroll Lock", 0xff14},
	{"Search", 0xEF1B},
	{"Shift L", 0xffe1},
	{"Shift R", 0xffe2},
	{"Sleep", 0xEF2F},
	{"Stop", 0xEF28},
	{"Tab", 0xff09},
	{"Up", 0xff52},
	{"Volume Down", 0xEF11},
	{"Volume Mute", 0xEF12},
	{"Volume Up", 0xEF13},
	{"Yen", 0xff30},
	{"", 0}
};

#ifdef _WIN32
#include <windows.h>
#else
#include <wordexp.h>
#endif

// SECTION *********************************** UTILITY FUNCTIONS *******************************************

void force_crash() 
{
	raise(SIGTRAP);
}

void magic(char *filename, char *result) 
{
magic_t magic_cookie;
const char *filetype;

	strcpy(result, "");
	magic_cookie = magic_open(MAGIC_MIME_TYPE);
	if(magic_cookie != NULL) 
	{
		if(magic_load(magic_cookie, NULL) != -1) 
		{
			filetype = magic_file(magic_cookie, filename);
			if (filetype != NULL) 
			{
				strcpy(result, filetype);
			}
		}
		magic_close(magic_cookie);
	}
}

int	IsDirectory(char *path)
{
	int rr = 0;
	struct stat s;
	if(stat(path,&s) == 0)
	{
		if(s.st_mode & S_IFDIR)
		{
			rr = 1;
		}
	}
	return(rr);
}

void	strip_lf(char *in)
{
	char *cp = in;
	while(*cp != '\0')
	{
		if((*cp == 10) || (*cp == 13))
		{
			*cp = '\0';
		}
		cp++;
	}
}

int	test_for_ndi_path(char *str)
{
	int r = 0;
	if((strncasecmp(str, "ndi://", strlen("ndi://")) == 0)
	|| (strncasecmp(str, "ndi_rgbx://", strlen("ndi_rgbx://")) == 0)
	|| (strncasecmp(str, "ndi_bgrx://", strlen("ndi_bgrx://")) == 0)
	|| (strncasecmp(str, "ndi_i420://", strlen("ndi_i420://")) == 0)
	|| (strncasecmp(str, "ndi_p216://", strlen("ndi_p216://")) == 0)
	|| (strncasecmp(str, "ndi_uyva://", strlen("ndi_uyva://")) == 0)
	|| (strncasecmp(str, "ndi_uyvy://", strlen("ndi_uyvy://")) == 0))
	{
		r = 1;
	}
	return(r);
}

void	find_url_css_js(char *buf, char *url, char *css, char *js_once, char *js_always)
{
	*url = '\0';
	*css = '\0';
	*js_once = '\0';
	*js_always = '\0';

	char *cp = buf;
	char *cpo = url;
	while(*cp != '\0')
	{
		if(strncasecmp(cp, "url://", strlen("url://")) == 0)
		{
			cp += strlen("url://");
			*cpo = '\0';
			cpo = url;
		}
		if(strncasecmp(cp, "css://", strlen("css://")) == 0)
		{
			cp += strlen("css://");
			*cpo = '\0';
			cpo = css;
		}
		if(strncasecmp(cp, "js once://", strlen("js once://")) == 0)
		{
			cp += strlen("js once://");
			*cpo = '\0';
			cpo = js_once;
		}
		if(strncasecmp(cp, "js always://", strlen("js always://")) == 0)
		{
			cp += strlen("js always://");
			*cpo = '\0';
			cpo = js_always;
		}
		*cpo = *cp;
		cp++;
		cpo++;
	}
	*cpo = '\0';
}

int		mat_from_copy_buffer(Mat& out)
{
	int rr = 0;
	if(strcmp(Fl::event_clipboard_type(), Fl::clipboard_image) == 0) 
	{
		Fl_RGB_Image *im = (Fl_RGB_Image*)Fl::event_clipboard();
		if(im != NULL)
		{
			Mat local;
			unsigned char *ptr = (unsigned char *)im->data()[0];

			int ww = im->w();
			int hh = im->h();
			if((ww > 0) && (hh > 0) && (ptr != NULL))
			{
				Mat use;
				if(im->d() == 3)
				{
					Mat local(hh, ww, CV_8UC3, (void *)ptr);
					cv::resize(local, local, cv::Size(ww, hh));
					cvtColor(local, local, COLOR_RGB2RGBA);
					out = local.clone();
					rr = 1;
				}
				else if(im->d() == 4)
				{
					Mat local(hh, ww, CV_8UC4, (void *)ptr);
					cv::resize(local, local, cv::Size(ww, hh));
					out = local.clone();
					rr = 1;
				}
			}
		}
	}
	return(rr);
}

void	copy_to_clipboard(Camera *cam, int xx, int yy, int ww, int hh)
{
	MyWin *win = cam->my_window;
	Mat local;
	int use_x = xx;
	if(use_x < 0) use_x = 0;
	int use_y = yy;
	if(use_y < 0) use_y = 0;
	while((use_x + ww) >= cam->mat.cols)
	{
		ww--;
	}
	while((use_y + hh) >= cam->mat.rows)
	{
		hh--;
	}
	if((ww > 0) && (hh > 0))
	{
		float old_scale = Fl::screen_scale(0);
		Fl::screen_scale(0, 1.0);
		win->CropFrame(cam->mat, &local, use_x, use_y, ww, hh);
		Fl_Copy_Surface *copy_surf = new Fl_Copy_Surface(ww, hh);
		Fl_Surface_Device::push_current(copy_surf);
		fl_color(WHITE);
		fl_rectf(0, 0, ww, hh);

		Mat local_mat;
		cvtColor(local, local_mat, COLOR_RGBA2RGB);
		cv::resize(local_mat, local_mat, cv::Size(ww, hh));
		fl_draw_image(local_mat.ptr(), 0, 0, ww, hh, 3);
		Fl_Surface_Device::pop_current();
		delete copy_surf;
		Fl::screen_scale(0, old_scale);
	}
}

int	my_file_chooser(char *prompt, char *filter, char *start_path, char *current_selection, int select_dir = 0, int new_file = 0)
{
char	cwd[4096];

	getcwd(cwd, 4096);
	fl_chdir(start_path);
	FileSelector *fs = new FileSelector(prompt, filter, current_selection, select_dir, new_file);
	int xx = (global_window->w() / 2) - (fs->w() / 2);
	int yy = (global_window->h() / 2) - (fs->h() / 2);
	fs->resize(xx, yy, fs->w(), fs->h());
	fs->Update(".");
	fs->set_modal();
	fs->show();
	while(fs->visible())
	{
		Fl::wait(1);
	}
	if(fs->use_result != 1)
	{
		strcpy(current_selection, "");
	}
	Fl::delete_widget(fs);
	Fl::check();
	fl_chdir(cwd);
	int nn = strlen(current_selection);
	return(nn);
}

char	*json_parse_string(cJSON *parent, char *find)
{
	char *r = NULL;
	cJSON *item = cJSON_GetObjectItemCaseSensitive(parent, find);
	if(cJSON_IsString(item) && (item->valuestring != NULL))
	{
		r = item->valuestring;
	}
	return(r);
}

int	json_parse_int(cJSON *parent, char *find, int& val)
{
	int r = 0;
	cJSON *item = cJSON_GetObjectItemCaseSensitive(parent, find);
	if(cJSON_IsNumber(item))
	{
		val = item->valueint;
		r = 1;
	}
	return(r);
}

int	json_parse_int(cJSON *parent, char *find, long int& val)
{
	int r = 0;
	cJSON *item = cJSON_GetObjectItemCaseSensitive(parent, find);
	if(cJSON_IsNumber(item))
	{
		val = (long int)item->valueint;
		r = 1;
	}
	return(r);
}

int	json_parse_int(cJSON *parent, char *find, uchar& val)
{
	int r = 0;
	cJSON *item = cJSON_GetObjectItemCaseSensitive(parent, find);
	if(cJSON_IsNumber(item))
	{
		val = (uchar)item->valueint;
		r = 1;
	}
	return(r);
}

int	json_parse_int(cJSON *parent, char *find, char& val)
{
	int r = 0;
	cJSON *item = cJSON_GetObjectItemCaseSensitive(parent, find);
	if(cJSON_IsNumber(item))
	{
		val = (char)item->valueint;
		r = 1;
	}
	return(r);
}

int	json_parse_double(cJSON *parent, char *find, double& val)
{
	int r = 0;
	cJSON *item = cJSON_GetObjectItemCaseSensitive(parent, find);
	if(cJSON_IsNumber(item))
	{
		val = item->valuedouble;
		r = 1;
	}
	return(r);
}

cJSON	*json_parse_object(cJSON *parent, char *find)
{
	cJSON *r = NULL;
	cJSON *obj = cJSON_GetObjectItemCaseSensitive(parent, find);
	if(cJSON_IsObject(obj))
	{
		r = obj;
	}
	return(r);
}

cJSON	*json_parse_array(cJSON *parent, char *find)
{
	cJSON *r = NULL;
	cJSON *obj = cJSON_GetObjectItemCaseSensitive(parent, find);
	if(cJSON_IsArray(obj))
	{
		r = obj;
	}
	return(r);
}


char	*ReadWholeFile(char *filename)
{
struct stat sz;

	char *buf = NULL;
	int fd = open(filename, O_RDONLY);
	if(fd > -1)
	{
		fstat(fd, &sz);
		off_t size = sz.st_size;
		buf = (char *)malloc(size + 1);
		if(buf != NULL)
		{
			read(fd, buf, size);
			buf[size] = '\0';
		}
		close(fd);
	}
	return(buf);
}

int	find_label_position(Fl_Widget *in, int& xx, int& yy, int& ww, int& hh)
{
	int rr = 0;
	const char *lbl = in->label();
	if(lbl != NULL)
	{
		int lw = 0;
		int lh = 0;
		fl_font(in->labelfont(), in->labelsize());
		fl_measure(lbl, lw, lh);
		Fl_Align align = in->align();
		int horizontal = in->horizontal_label_margin();
		int vertical = in->vertical_label_margin();
		if((align & FL_ALIGN_INSIDE) != FL_ALIGN_INSIDE)
		{
			ww = lw;
			hh = lh;
			if((align & FL_ALIGN_LEFT_TOP) == FL_ALIGN_LEFT_TOP)
			{
				xx = in->x() - (lw + horizontal);
				yy = in->y();
				rr = 1;
			}
			if((align & FL_ALIGN_LEFT) == FL_ALIGN_LEFT)
			{
				xx = in->x() - (lw + horizontal);
				yy = in->y() + ((in->h() / 2) - (lh / 2));
				rr = 1;
			}
			if((align & FL_ALIGN_LEFT_BOTTOM) == FL_ALIGN_LEFT_BOTTOM)
			{
				xx = in->x() - (lw + horizontal);
				yy = in->y() + (in->h() - lh);
				rr = 1;
			}
			if((align & FL_ALIGN_RIGHT_TOP) == FL_ALIGN_RIGHT_TOP)
			{
				xx = in->x() + (in->w() + horizontal);
				yy = in->y();
				rr = 1;
			}
			if((align & FL_ALIGN_RIGHT) == FL_ALIGN_RIGHT)
			{
				xx = in->x() + (in->w() + horizontal);
				yy = in->y() + ((in->h() / 2) - (lh / 2));
				rr = 1;
			}
			if((align & FL_ALIGN_RIGHT_BOTTOM) == FL_ALIGN_RIGHT_BOTTOM)
			{
				xx = in->x() + (in->w() + horizontal);
				yy = in->y() + (in->h() - lh);
				rr = 1;
			}
			if((align & FL_ALIGN_TOP_LEFT) == FL_ALIGN_TOP_LEFT)
			{
				xx = in->x();
				yy = in->y() - (lh + vertical);
				rr = 1;
			}
			if((align & FL_ALIGN_TOP) == FL_ALIGN_TOP)
			{
				xx = in->x() + ((in->w() / 2) - (lw / 2));
				yy = in->y() - (lh + vertical);
				rr = 1;
			}
			if((align & FL_ALIGN_TOP_RIGHT) == FL_ALIGN_TOP_RIGHT)
			{
				xx = in->x() - lw;
				yy = in->y() - (lh + vertical);
				rr = 1;
			}
			if((align & FL_ALIGN_BOTTOM_LEFT) == FL_ALIGN_BOTTOM_LEFT)
			{
				xx = in->x();
				yy = in->y() + (in->h() + vertical);
				rr = 1;
			}
			if((align & FL_ALIGN_BOTTOM) == FL_ALIGN_BOTTOM)
			{
				xx = in->x() + ((in->w() / 2) - (lw / 2));
				yy = in->y() + (in->h() + vertical);
				rr = 1;
			}
			if((align & FL_ALIGN_BOTTOM_RIGHT) == FL_ALIGN_BOTTOM_RIGHT)
			{
				xx = in->x() - lw;
				yy = in->y() + (in->h() + vertical);
				rr = 1;
			}
		}
	}
	return(rr);
}

void	play_audio_file(MyWin *win, char *path)
{
SAMPLE	*interpolate_audio(int std_rate, int std_channels, int rate, int in_channels, int in_bits, int& sz_in_samples, SAMPLE *in_buf);
SAMPLE	*extract_audio_file_samples(char *filename, int& num_samples, int &channels, int& sample_rate);
int		create_task(int (*funct)(int *), void *flag);
int		play_audio_thread(int *flag);

	int channels = 0;
	int sample_rate = 0;
	int num_samples = 2048;
	global_audio_sudden_stop = 0;
	SAMPLE *wav = extract_audio_file_samples(path, num_samples, channels, sample_rate);
	if((wav != NULL) && (channels > 0) && (sample_rate > 0))
	{
		if((sample_rate != win->audio_sample_rate) || (channels != win->audio_channels))
		{
			SAMPLE *new_wav = interpolate_audio(win->audio_sample_rate, win->audio_channels, sample_rate, channels, 16, num_samples, wav);
			if(new_wav != NULL)
			{
				sample_rate = win->audio_sample_rate;
				channels = win->audio_channels;
				free(wav);
				wav = new_wav;
			}
		}
		if(wav != NULL)
		{
			AudioInfo *audio_info = new AudioInfo(win, num_samples, sample_rate, channels, wav);
			create_task((int (*)(int *))play_audio_thread, (void *)audio_info);
		}
	}
}

SAMPLE	*audio_8_to_16(int total_sz, unsigned char *in_buf)
{
int	loop;

	SAMPLE *out_buf = (SAMPLE *)malloc(total_sz * sizeof(SAMPLE));
	if(out_buf != NULL)
	{
		for(loop = 0;loop < total_sz;loop++)
		{
			char nn1 = (char)(in_buf[loop] - 128);
			double fact = (1.0 / 255.0) * (double)nn1;
			out_buf[loop] = (SAMPLE)(65536.0 * fact);
		}
	}
	return(out_buf);
}

SAMPLE	*interpolate_audio(int std_rate, int std_channels, int rate, int in_channels, int in_bits, int& sz_in_samples, SAMPLE *in_buf)
{
int	loop;
int	inner;

	SAMPLE *out_buf = NULL;
	double test_mult = (double)std_rate / (double)rate;
	if(test_mult >= 1.0)
	{
		int mult = std_rate / rate;
		if(mult > 0)
		{
			out_buf = (SAMPLE *)malloc(sz_in_samples * sizeof(SAMPLE) * (mult * std_channels));
			if(out_buf != NULL)
			{
				memset(out_buf, 0, sz_in_samples * sizeof(SAMPLE) * (mult * std_channels));
				int cnt = 0;
				SAMPLE save_avg[10];
				SAMPLE save_nn1 = 0;
				for(loop = 0;loop < (sz_in_samples * in_channels) - in_channels;loop++)
				{
					if(mult < 10)
					{
						SAMPLE avg[10];
						SAMPLE nn1 = in_buf[loop];
						SAMPLE nn2 = in_buf[loop + in_channels];
						double linear = ((double)nn2 - (double)nn1) / (double)mult;
						int ctl = mult - 1;
						for(inner = 0;inner < ctl;inner++)
						{
							avg[inner] = nn1 + (SAMPLE)(linear * (double)(inner + 1));
						}
						if(std_channels == 2)
						{
							if(in_channels == 1)
							{
								out_buf[cnt] = nn1;
								cnt++;
								out_buf[cnt] = nn1;
								cnt++;
								for(inner = 0;inner < ctl;inner++)
								{
									out_buf[cnt] = avg[inner];
									cnt++;
									out_buf[cnt] = avg[inner];
									cnt++;
								}
							}
							if(in_channels == 2)
							{
								out_buf[cnt] = nn1;
								cnt++;
								for(inner = 0;inner < ctl;inner++)
								{
									out_buf[cnt] = avg[inner];
									cnt++;
								}
							}
						}
						else
						{
							if(in_channels == 1)
							{
								out_buf[cnt] = nn1;
								cnt++;
								for(inner = 0;inner < ctl;inner++)
								{
									out_buf[cnt] = avg[inner];
									cnt++;
								}
							}
							if(in_channels == 2)
							{
								if((loop % 2) == 0) 
								{
									save_nn1 = nn1;
									for(inner = 0;inner < ctl;inner++)
									{
										save_avg[inner] = avg[inner];
									}
								}
								else
								{
									out_buf[cnt] = (save_nn1 + nn1) / 2;
									cnt++;
									for(inner = 0;inner < ctl;inner++)
									{
										out_buf[cnt] = (save_avg[inner] + avg[inner]) / 2;
										cnt++;
									}
								}
							}
						}
					}
				}
				sz_in_samples = (cnt / std_channels);
			}
		}
	}
	else
	{
		int limit = (int)((double)sz_in_samples * (double)std_channels * test_mult);
		int calced_sz = limit * sizeof(SAMPLE);
		if(calced_sz > 0)
		{ 
			int cnt = 0;
			int total = 0;
			out_buf = (SAMPLE *)malloc(calced_sz);
			if(out_buf != NULL)
			{
				double d_cnt = 0.0;
				for(loop = 0;loop < (sz_in_samples * in_channels);loop++)
				{
					if(in_channels == std_channels)
					{
						if(cnt < limit)
						{
							SAMPLE n1 = in_buf[loop];
							out_buf[cnt] = n1;
							d_cnt += test_mult;
							cnt = (int)d_cnt;
							total = cnt;
						}
					}
					else if(in_channels == 1)
					{
						if((cnt + 1) < limit)
						{
							SAMPLE n1 = in_buf[loop];
							out_buf[cnt] = n1;
							out_buf[cnt + 1] = n1;
							d_cnt += (test_mult * 2);
							cnt = (int)d_cnt;
							total = cnt;
						}
					}
					else if(in_channels == 2)
					{
						if(cnt < limit)
						{
							SAMPLE n1 = in_buf[loop];
							if(loop < (sz_in_samples * in_channels) - 1)
							{
								SAMPLE n2 = in_buf[loop + 1];
								SAMPLE avg = (n1 + n2) / 2;
								out_buf[cnt] = n1;
								d_cnt += test_mult;
								cnt = (int)d_cnt;
								total = cnt;
							}
						}
					}
				}
			}
			sz_in_samples = (total / std_channels);
		}
	}
	return(out_buf);
}

void	scale_mat_to_fit(Mat& input, Mat& output, int out_w, int out_h)
{
	int width = input.cols;
	int height = input.rows;
	if((width > out_w) || (height > out_h))
	{
		double aspect = (double)out_h / (double)height;
		int use_h = height * aspect;
		int use_w = width * aspect;
		if(out_h > out_w)
		{
			double aspect = (double)out_w / (double)width;
			use_w = width * aspect;
			use_h = height * aspect;
		}
		Mat tmp;
		cv::resize(input, tmp, cv::Size(use_w, use_h));
		cv::Rect roi(0, 0, use_w, use_h);
		Mat cow = cv::Mat(out_h, out_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
		tmp.copyTo(cow(roi));
		cow.copyTo(output);
	}
	else
	{
		input.copyTo(output);
	}
}

void rgb_to_yuv422_uyvy(const cv::Mat& rgb, cv::Mat& yuv) 
{
	assert(rgb.size() == yuv.size() &&
		   rgb.depth() == CV_8U &&
		   rgb.channels() == 3 &&
		   yuv.depth() == CV_8U &&
		   yuv.channels() == 2);
	for(int ih = 0; ih < rgb.rows; ih++) 
	{
		const uint8_t* rgbRowPtr = rgb.ptr<uint8_t>(ih);
		uint8_t* yuvRowPtr = yuv.ptr<uint8_t>(ih);

		for(int iw = 0; iw < rgb.cols; iw = iw + 2) 
		{
			const int rgbColIdxBytes = iw * rgb.elemSize();
			const int yuvColIdxBytes = iw * yuv.elemSize();

			const uint8_t R1 = rgbRowPtr[rgbColIdxBytes + 0];
			const uint8_t G1 = rgbRowPtr[rgbColIdxBytes + 1];
			const uint8_t B1 = rgbRowPtr[rgbColIdxBytes + 2];
			const uint8_t R2 = rgbRowPtr[rgbColIdxBytes + 3];
			const uint8_t G2 = rgbRowPtr[rgbColIdxBytes + 4];
			const uint8_t B2 = rgbRowPtr[rgbColIdxBytes + 5];

			const int Y  =  (0.257f * R1) + (0.504f * G1) + (0.098f * B1) + 16.0f ;
			const int U  = -(0.148f * R1) - (0.291f * G1) + (0.439f * B1) + 128.0f;
			const int V  =  (0.439f * R1) - (0.368f * G1) - (0.071f * B1) + 128.0f;
			const int Y2 =  (0.257f * R2) + (0.504f * G2) + (0.098f * B2) + 16.0f ;

			yuvRowPtr[yuvColIdxBytes + 0] = cv::saturate_cast<uint8_t>(U );
			yuvRowPtr[yuvColIdxBytes + 1] = cv::saturate_cast<uint8_t>(Y );
			yuvRowPtr[yuvColIdxBytes + 2] = cv::saturate_cast<uint8_t>(V );
			yuvRowPtr[yuvColIdxBytes + 3] = cv::saturate_cast<uint8_t>(Y2);
		}
	}
}

void	UYVY_BGR(Mat& out_mat, void *data, int ww, int hh)
{
	Mat frame = Mat(hh, ww, CV_8UC2, data);
	cvtColor(frame, out_mat, COLOR_YUV2BGRA_UYVY, 0);
}

void	I420_BGR(Mat& out_mat, void *data, int ww, int hh)
{
	Mat frame = Mat(hh, ww, CV_8UC2, data);
	cvtColor(frame, out_mat, COLOR_YUV420p2BGRA);
}

void	*BGRA_UYVA(Mat in_mat, int ww, int hh)
{
	Mat uyvy = Mat(hh, ww, CV_8UC2);
	Mat rgb;
	cvtColor(in_mat, rgb, COLOR_BGRA2BGR);
	rgb_to_yuv422_uyvy(rgb, uyvy); 

	void *result = (void *)malloc(((ww * 2) * hh) + (ww * hh));
	memcpy(result, uyvy.ptr(), ((ww * 2) * hh));
	char *cp = (char *)result + ((ww * 2) * hh);
	memset(cp, 255, (ww * hh));
	return(result);
}

void	BGRA_UYVY(Mat in_mat, Mat& out_mat, int ww, int hh)
{
	Mat uyvy = Mat(hh, ww, CV_8UC2);
	Mat rgb;
	cvtColor(in_mat, rgb, COLOR_BGRA2BGR);
	rgb_to_yuv422_uyvy(rgb, uyvy); 
	uyvy.copyTo(out_mat);
}

void	P216_BGR(Mat& out_mat, void *data, int ww, int hh)
{
int	xx, yy;

	Mat frame = cv::Mat(hh, ww, CV_8UC4, cv::Scalar(76, 89, 100, 255));
	unsigned char *ptr = (unsigned char *)frame.ptr();

	int16_t *p_y = (int16_t *)data; 
	int stride = ww * sizeof(int16_t);
	int offset = hh * stride; 
	int16_t *p_uv = (int16_t *)((char *)data + offset); 
	int16_t Y = 0;
	int16_t U = 0;
	int16_t V = 0;
	int cnt = 0;
	for(yy = 0;yy < hh;yy++)
	{
		for(xx = 0;xx < ww;xx++)
		{
			Y = *p_y++;
			Y -= 32768;
			if((cnt % 2) == 0)
			{
				U = *p_uv++;
				U -= 32768;
				V = *p_uv++;
				V -= 32768;
			}
			int16_t R = Y + 1.370705f * V;
			int16_t G = Y - (0.698001f * V) - (0.337633f * U);
			int16_t B = Y + 1.732446f * U;

			B /= 255;
			G /= 255;
			R /= 255;

			B += 128;
			G += 128;
			R += 128;

			if(B < 0) B = 0;
			else if(B > 255) B = 255;
			if(G < 0) G = 0;
			else if(G > 255) G = 255;
			if(R < 0) R = 0;
			else if(R > 255) R = 255;

			*ptr++ = (uchar)B;
			*ptr++ = (uchar)G;
			*ptr++ = (uchar)R;
			*ptr++ = 255;
			cnt++;
		}
	}
	out_mat = frame.clone();
}

NDIlib_recv_instance_t OpenNDI(NDIlib_source_t source, int format)
{
	NDIlib_recv_instance_t ndi_recv = NULL;
	if(NDILib != NULL)
	{
		NDIlib_recv_create_v3_t NDI_recv_create_desc;

		NDI_recv_create_desc.source_to_connect_to = source;
		NDI_recv_create_desc.p_ndi_recv_name = "NDI Source";
		if(format == 1)
		{
			NDI_recv_create_desc.color_format = NDIlib_recv_color_format_fastest;
		}
		else if(format == 2)
		{
			NDI_recv_create_desc.color_format = NDIlib_recv_color_format_best;
		}
		else if(format == 3)
		{
			NDI_recv_create_desc.color_format = NDIlib_recv_color_format_BGRX_BGRA;
		}
		else if(format == 3)
		{
			NDI_recv_create_desc.color_format = NDIlib_recv_color_format_RGBX_RGBA;
		}
		ndi_recv = NDILib->NDIlib_recv_create_v3(&NDI_recv_create_desc);

		NDIlib_metadata_frame_t enable_hw_accel;
		enable_hw_accel.p_data = "<ndi_hwaccel enabled=\"true\"/>";
		NDILib->NDIlib_recv_send_metadata(ndi_recv, &enable_hw_accel);
	}
	return(ndi_recv);
}

NDIlib_recv_instance_t	FindNDI(char *name, int format = 0)
{
int	loop;

	NDIlib_recv_instance_t ndi_recv = NULL;
	if(NDILib != NULL)
	{
		uint32_t num_sources = 0;
		const NDIlib_source_t *sources = NULL;
		const NDIlib_find_create_t NDI_find_create_desc;
		NDIlib_find_instance_t ndi_find = NDILib->NDIlib_find_create_v2(&NDI_find_create_desc);
		NDILib->NDIlib_find_wait_for_sources(ndi_find, 1000);
		sources = NDILib->NDIlib_find_get_current_sources(ndi_find, &num_sources);

		int done = 0;
		for(loop = 0;((loop < num_sources) && (done == 0));loop++)
		{
			if(strcmp(name, sources[loop].p_ndi_name) == 0)
			{
				ndi_recv = OpenNDI(sources[loop], format);
				done = 1;
			}
		}
		NDILib->NDIlib_find_destroy(ndi_find);
	}
	return(ndi_recv);
}

int	return_color_by_name(char *cp)
{
	int number = 0;
	if(strncmp(cp, "red", strlen("red")) == 0)
	{
		number = 0xff0000ff;
	}
	else if(strncmp(cp, "green", strlen("green")) == 0)
	{
		number = 0x00ff00ff;
	}
	else if(strncmp(cp, "blue", strlen("blue")) == 0)
	{
		number = 0x0000ffff;
	}
	else if(strncmp(cp, "black", strlen("black")) == 0)
	{
		number = 0x000000ff;
	}
	else if(strncmp(cp, "white", strlen("white")) == 0)
	{
		number = 0xffffffff;
	}
	else if(strncmp(cp, "silver", strlen("silver")) == 0)
	{
		number = 0x0c0c0c0ff;
	}
	else if(strncmp(cp, "gray", strlen("gray")) == 0)
	{
		number = 0x808080ff;
	}
	else if(strncmp(cp, "maroon", strlen("maroon")) == 0)
	{
		number = 0x800000ff;
	}
	else if(strncmp(cp, "yellow", strlen("yellow")) == 0)
	{
		number = 0xffff00ff;
	}
	else if(strncmp(cp, "olive", strlen("olive")) == 0)
	{
		number = 0x808000ff;
	}
	else if(strncmp(cp, "lime", strlen("lime")) == 0)
	{
		number = 0x00ff00ff;
	}
	else if(strncmp(cp, "aqua", strlen("aqua")) == 0)
	{
		number = 0x00ffffff;
	}
	else if(strncmp(cp, "teal", strlen("teal")) == 0)
	{
		number = 0x008080ff;
	}
	else if(strncmp(cp, "navy", strlen("navy")) == 0)
	{
		number = 0x000080ff;
	}
	else if(strncmp(cp, "fuchsia", strlen("fuchsia")) == 0)
	{
		number = 0xff00ffff;
	}
	else if(strncmp(cp, "purple", strlen("purple")) == 0)
	{
		number = 0x800080ff;
	}
	else if(strncmp(cp, "0x", strlen("0x")) == 0)
	{
		number = (int)strtol(cp, NULL, 0);
	}
	else
	{
		number = (int)atol(cp);
	}
	return(number);
}

void	time_seconds_eval(time_t in_secs, int& days, int& hours, int& minutes, int& seconds)
{
	days = in_secs / 86400;
	in_secs -= days * 86400;
	hours = in_secs / 3600;
	in_secs -= hours * 3600;
	minutes = in_secs / 60;
	in_secs -= minutes * 60;
	seconds = in_secs;
}

time_t	time_str_eval(char *str)
{
time_t	total_seconds = 0;

	int days = 0;
	int hours = 0;
	int minutes = 0;
	int seconds = 0;
	int colon_cnt = 0;
	char *cp = str;
	while(*cp != '\0')
	{
		if(*cp == ':')
		{
			colon_cnt++;
		}
		cp++;
	}
	if(colon_cnt == 3)
	{
		sscanf(str, "%d:%d:%d:%d", &days, &hours, &minutes, &seconds);
		total_seconds = (days * 86400) + (hours * 3600) + (minutes * 60) + seconds;
	}
	else if(colon_cnt == 2)
	{
		sscanf(str, "%d:%d:%d", &hours, &minutes, &seconds);
		total_seconds = (hours * 3600) + (minutes * 60) + seconds;
	}
	else if(colon_cnt == 1)
	{
		sscanf(str, "%d:%d", &minutes, &seconds);
		total_seconds = (minutes * 60) + seconds;
	}
	else if(colon_cnt == 0)
	{
		total_seconds = seconds;
	}
	return(total_seconds);
}

void	remove_superfluous_characters(char *in_str, char *out_str)
{
	int cnt = 0;
	char *cp = in_str;
	char last_cp = '\0';
	while(*cp != '\0')
	{
		if(isalnum(*cp))
		{
			out_str[cnt] = *cp;
			cnt++;
			last_cp = *cp;
		}
		else
		{
			if(last_cp != ' ')
			{
				out_str[cnt] = ' ';
				cnt++;
			}
			last_cp = ' ';
		}
		cp++;
	}
	out_str[cnt] = '\0';
}

int stick_this_thread_to_core(int core_id) 
{
   int num_cores = sysconf(_SC_NPROCESSORS_ONLN);
   if(core_id < 0 || core_id >= num_cores)
	  return EINVAL;

   cpu_set_t cpuset;
   CPU_ZERO(&cpuset);
   CPU_SET(core_id, &cpuset);

   pthread_t current_thread = pthread_self();	
   return pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);
}

void	my_video_settings_chooser(MyWin *in_win, double& contrast, double& brightness, double& saturation, double& hue, double& intensity)
{
	MiscVideoSettingsWindow *mvsw = in_win->misc_video_settings_window;
	if(mvsw != NULL)
	{
		mvsw->show();
		while(mvsw->visible())
		{
			contrast = mvsw->contrast;
			brightness = mvsw->brightness;
			saturation = mvsw->saturation;
			hue = mvsw->hue;
			intensity = mvsw->intensity;
			Fl::check();
		}
	}
}

int	my_color_chooser(char *title, int& red, int& green, int &blue, int& alpha)
{
static ColorDialog	*cd = NULL;

	if(cd == NULL)
	{
		cd = new ColorDialog(NULL, 420, 185, red, green, blue, alpha, title);
		cd->set_modal();
	}
	if(cd != NULL)
	{
		cd->show();
		while(cd->visible())
		{
			Fl::check();
		}
	}
	return(1);
}

static int xioctl(int fh, int request, void *arg)
{
int r;

	do
	{
		r = ioctl(fh, request, arg);
	}
	while((r == -1) && (errno == EINTR));
	return r;
}

void	hide_window_cb(Fl_Widget *w, void *v)
{
	Fl_Window *win = (Fl_Window *)v;
	win->hide();
}

char	*StrAllocCat(char *one, char *two)
{
	if(two != NULL)
	{
		int n = 0;
		if(one != NULL)
		{
			n = (int)strlen(one);
		}
		one = (char *)realloc(one, n + (int)strlen(two) + 1);
		if(one != NULL)
		{
			if(n > 0)
			{
				strcat(one, two);
			}
			else
			{
				strcpy(one, two);
			}
		}
	}
	return(one);
}

Mat	crop_section(Mat source, Mat& cropped, int xx, int yy, int ww, int hh)
{
	if(xx < -1) xx = 0;
	if(yy < -1) yy = 0;
	if((xx + ww) >= source.cols)
	{
		ww -= ((xx + ww + 1) - source.cols);
	}
	if((yy + hh) >= source.rows)
	{
		hh -= ((yy + hh + 1) - source.rows);
	}
	if(((xx + ww) < source.cols) && ((yy + hh) < source.rows))
	{
		Rect myROI(xx, yy, ww, hh);
		Mat croppedRef(source, myROI);
		cropped = croppedRef.clone();
	}
	else
	{
		cropped = source.clone();
	}
	return(cropped);
}

void overlayImage(Mat *src, Mat *overlay, const Point& location)
{
	for(int y = max(location.y, 0); y < src->rows; ++y)
	{
		int fY = y - location.y;
		if(fY >= overlay->rows)
			break;

		for(int x = max(location.x, 0); x < src->cols; ++x)
		{
			int fX = x - location.x;
			if(fX >= overlay->cols)
				break;

			double opacity = ((double)overlay->data[fY * overlay->step + fX * overlay->channels() + 3]) / 255;
			for(int c = 0; opacity > 0 && c < src->channels(); ++c)
			{
				unsigned char overlayPx = overlay->data[fY * overlay->step + fX * overlay->channels() + c];
				unsigned char srcPx = src->data[y * src->step + x * src->channels() + c];
				src->data[y * src->step + src->channels() * x + c] = srcPx * (1.0 - opacity) + overlayPx * opacity;
			}
		}
	}
}

void	rotate_mat(double angle, Mat& src)
{
	// get rotation matrix for rotating the image around its center in pixel coordinates
	cv::Point2f center((src.cols - 1) / 2.0, (src.rows - 1) / 2.0);
	cv::Mat rot = cv::getRotationMatrix2D(center, angle, 1.0);

	// determine bounding rectangle, center not relevant
	cv::Rect2f bbox = cv::RotatedRect(cv::Point2f(), src.size(), angle).boundingRect2f();

	// adjust transformation matrix
	rot.at<double>(0, 2) += bbox.width / 2.0 - src.cols / 2.0;
	rot.at<double>(1, 2) += bbox.height / 2.0 - src.rows / 2.0;

	cv::Mat dst;
	cv::warpAffine(src, dst, rot, bbox.size());
	src = dst.clone();
}

void	my_cairo_push_matrix(cairo_t *cr)
{
	if(global_cairo_matrix_cnt < 128)
	{
		cairo_get_matrix(cr, &global_cairo_matrix[global_cairo_matrix_cnt]);
		global_cairo_matrix_cnt++;
	}
}

void	my_cairo_pop_matrix(cairo_t *cr)
{
	if(global_cairo_matrix_cnt > 0)
	{
		global_cairo_matrix_cnt--;
		cairo_set_matrix(cr, &global_cairo_matrix[global_cairo_matrix_cnt]);
	}
}


void	blur_it(Camera *cam, int factor, int xx, int yy, int ww, int hh)
{
	Mat use;
	crop_section(cam->mat, use, xx, yy, ww, hh);
	blur(use, use, Size(factor, factor));
	cairo_surface_t *surface = cairo_image_surface_create_for_data(use.ptr(), CAIRO_FORMAT_ARGB32, use.cols, use.rows, use.step);
	if(surface != NULL)
	{
		cairo_set_source_surface(cam->cairo_context, surface, xx, yy);
		cairo_paint(cam->cairo_context);
		cairo_surface_destroy(surface);
	}
}

void	mask_polygon(Mat mat, Mat &out, int point_cnt, int xx[1024], int yy[1024])
{
int	loop;

	cv::Point corners[1][1024];
	for(loop = 0;loop < point_cnt;loop++)
	{
		corners[0][loop] = Point(xx[loop], yy[loop]);
	}
	const Point *corner_list[1] = { corners[0] };

	int num_points = point_cnt;
	int num_polygons = 1;
	int line_type = 8;
	cv::Mat mask(mat.rows, mat.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
	cv::fillPoly(mask, corner_list, &num_points, num_polygons, cv::Scalar(255, 255, 255, 255), line_type);

	cv::bitwise_and(mat, mask, out);
}

void	mask_mats(Mat mat, Mat mask, Mat &out)
{
	cv::bitwise_and(mat, mask, out);
}

void	erase_polygon(Mat mat, int point_cnt, int xx[1024], int yy[1024])
{
int	loop;

	cv::Point corners[1][1024];
	for(loop = 0;loop < point_cnt;loop++)
	{
		corners[0][loop] = Point(xx[loop], yy[loop]);
	}
	const Point *corner_list[1] = { corners[0] };

	int num_points = point_cnt;
	int num_polygons = 1;
	int line_type = 8;
	cv::fillPoly(mat, corner_list, &num_points, num_polygons, cv::Scalar(0, 0, 0, 0), line_type);
}

void	combine_on_color(Mat one, Mat two, int rr, int gg, int bb)
{
int	row, col;

	for(row = 0;row < two.rows;row++)
	{
		for(col = 0;col < two.cols;col++)
		{
			unsigned char *color1 = one.ptr(row, col);
			if((color1[0] == rr)
			&& (color1[1] == gg)
			&& (color1[2] == bb))
			{
				unsigned char *color2 = two.ptr(row, col);
				double r2 = (double)color2[0];
				double g2 = (double)color2[1];
				double b2 = (double)color2[2];

				color1[0] = r2;
				color1[1] = g2;
				color1[2] = b2;
			}
		}
	}
}

void	color_gradient(Mat& mat, int direction, Scalar start_color, Scalar end_color)
{
int	loop;
int	inner;

	if(direction == GRADIENT_DIRECTION_VERTICAL)
	{
		double red_inc = (end_color[0] - start_color[0]) / mat.rows;
		double green_inc = (end_color[1] - start_color[1]) / mat.rows;
		double blue_inc = (end_color[2] - start_color[2]) / mat.rows;
		double alpha_inc = (end_color[3] - start_color[3]) / mat.rows;
		for(loop = 0;loop < mat.rows;loop++)
		{
			double alpha = start_color[3] / 255.0;
			double beta = 1.0 - alpha;

			double sr2 = start_color[0];
			double sg2 = start_color[1];
			double sb2 = start_color[2];
			double r2 = sr2 * alpha;
			double g2 = sg2 * alpha;
			double b2 = sb2 * alpha;
			for(inner = 0;inner < mat.cols;inner++)
			{
				unsigned char *color1 = mat.ptr(loop, inner);
				double r1 = (double)color1[0] * beta;
				double g1 = (double)color1[1] * beta;
				double b1 = (double)color1[2] * beta;

				color1[0] = r1 + r2;
				color1[1] = g1 + g2;
				color1[2] = b1 + b2;
			}
			start_color[0] += red_inc;
			start_color[1] += green_inc;
			start_color[2] += blue_inc;
			start_color[3] += alpha_inc;
		}
	}
	else if(direction == GRADIENT_DIRECTION_HORIZONTAL)
	{
		double red_inc = (end_color[0] - start_color[0]) / mat.cols;
		double green_inc = (end_color[1] - start_color[1]) / mat.cols;
		double blue_inc = (end_color[2] - start_color[2]) / mat.cols;
		double alpha_inc = (end_color[3] - start_color[3]) / mat.cols;
		for(loop = 0;loop < mat.cols;loop++)
		{
			double alpha = start_color[3] / 255.0;
			double beta = 1.0 - alpha;

			double sr2 = start_color[0];
			double sg2 = start_color[1];
			double sb2 = start_color[2];
			double r2 = sr2 * alpha;
			double g2 = sg2 * alpha;
			double b2 = sb2 * alpha;
			for(inner = 0;inner < mat.rows;inner++)
			{
				unsigned char *color1 = mat.ptr(inner, loop);
				double r1 = (double)color1[0] * beta;
				double g1 = (double)color1[1] * beta;
				double b1 = (double)color1[2] * beta;

				color1[0] = r1 + r2;
				color1[1] = g1 + g2;
				color1[2] = b1 + b2;
			}
			start_color[0] += red_inc;
			start_color[1] += green_inc;
			start_color[2] += blue_inc;
			start_color[3] += alpha_inc;
		}
	}
}

void rounded_rectangle(Mat& src, Point topLeft, Point bottomRight, const Scalar lineColor, int thickness, const int lineType , const int cornerRadius)
{
	cv::Mat mat(src.rows, src.cols, CV_8UC3, cv::Scalar(0, 0, 0));

	Point p1 = topLeft;
	Point p2 = Point (bottomRight.x, topLeft.y);
	Point p3 = bottomRight;
	Point p4 = Point (topLeft.x, bottomRight.y);

	line(mat, Point(p1.x+cornerRadius,p1.y), Point(p2.x-cornerRadius,p2.y), lineColor, thickness, lineType);
	line(mat, Point(p2.x,p2.y+cornerRadius), Point(p3.x,p3.y-cornerRadius), lineColor, thickness, lineType);
	line(mat, Point(p4.x+cornerRadius,p4.y), Point(p3.x-cornerRadius,p3.y), lineColor, thickness, lineType);
	line(mat, Point(p1.x,p1.y+cornerRadius), Point(p4.x,p4.y-cornerRadius), lineColor, thickness, lineType);

	ellipse(mat, p1+Point(cornerRadius, cornerRadius), Size( cornerRadius, cornerRadius ), 180.0, 0, 90, lineColor, thickness, lineType);
	ellipse(mat, p2+Point(-cornerRadius, cornerRadius), Size( cornerRadius, cornerRadius ), 270.0, 0, 90, lineColor, thickness, lineType);
	ellipse(mat, p3+Point(-cornerRadius, -cornerRadius), Size( cornerRadius, cornerRadius ), 0.0, 0, 90, lineColor, thickness, lineType);
	ellipse(mat, p4+Point(cornerRadius, -cornerRadius), Size( cornerRadius, cornerRadius ), 90.0, 0, 90, lineColor, thickness, lineType);

	Point fillFrom(0, 0);
	floodFill(mat, fillFrom, lineColor);
	cvtColor(mat, mat, COLOR_RGB2RGBA);
	combine_on_color(mat, src, 0, 0, 0);
	src = mat.clone();
}

void	crop_mat(Mat& mat, int xx, int yy, int ww, int hh)
{
	cv::Rect roi;
	roi.x = xx;
	roi.y = yy;
	roi.width = ww;
	roi.height = hh;
	mat = mat(roi).clone();
}

void	brightness_mat(Mat& mat, double brightness)
{
	if(brightness != 0.5)
	{
		cvtColor(mat, mat, COLOR_RGBA2RGB);
		double rr = (400.0 * brightness) - 200.0;
		mat.convertTo(mat, -1, 1, rr);
		cvtColor(mat, mat, COLOR_RGB2RGBA);
	}
}

void	blur_mat(Mat& mat, double radius)
{
	if(radius > 1.0)
	{
		blur(mat, mat, Size(radius, radius));
	}
}

void	contrast_mat(Mat& mat, double contrast)
{
	if(contrast != 0.5)
	{
		double rr = 2.0 * contrast;
		mat.convertTo(mat, -1, rr, 0);
	}
}

void	clahe_mat(Mat& mat, double contrast)
{
	cv::Mat lab_image;
	cv::cvtColor(mat, lab_image, COLOR_BGR2Lab);

	std::vector<cv::Mat> lab_planes(3);
	cv::split(lab_image, lab_planes);  // now we have the L image in lab_planes[0]

	cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE();
	clahe->setClipLimit(contrast);
	cv::Mat dst;
	clahe->apply(lab_planes[0], dst);

	dst.copyTo(lab_planes[0]);
	cv::merge(lab_planes, lab_image);

	cv::Mat image_clahe;
	cv::cvtColor(lab_image, mat, COLOR_Lab2BGR);
	cv::cvtColor(mat, mat, COLOR_BGR2BGRA);
}

Mat	change_saturation(Mat& frame, double amount)
{
int	i, j;

	Mat hsv;
	cvtColor(frame, hsv, COLOR_RGB2HSV);
	const unsigned char hue_shift = 20;
	for(j = 0; j < frame.rows; j++)
	{
		for(i = 0; i < frame.cols; i++)
		{
			unsigned char h = hsv.at<Vec3b>(j, i)[1];
			double nn = h;
			nn *= amount;
			hsv.at<Vec3b>(j, i)[1] = (unsigned char)nn;
		}
	}
	cvtColor(hsv, frame, COLOR_HSV2RGB);
	cvtColor(frame, frame, COLOR_RGB2RGBA);
	return(frame);
}

Mat	change_hue(Mat frame, double amount)
{
int	i, j;

	Mat hsv;
	cvtColor(frame, hsv, COLOR_RGB2HSV);
	const unsigned char hue_shift = 20;
	for(j = 0; j < frame.rows; j++)
	{
		for(i = 0; i < frame.cols; i++)
		{
			unsigned char h = hsv.at<Vec3b>(j, i)[0];
			double nn = h;
			nn *= amount;
			hsv.at<Vec3b>(j, i)[0] = (unsigned char)nn;
		}
	}
	cvtColor(hsv, frame, COLOR_HSV2RGB);
	cvtColor(frame, frame, COLOR_RGB2RGBA);
	return(frame);
}

Mat	change_intensity(Mat frame, double amount)
{
int	i, j;

	Mat hsv;
	cvtColor(frame, hsv, COLOR_RGB2HSV);
	const unsigned char hue_shift = 20;
	for(j = 0; j < frame.rows; j++)
	{
		for(i = 0; i < frame.cols; i++)
		{
			unsigned char h = hsv.at<Vec3b>(j, i)[2];
			double nn = h;
			nn *= amount;
			hsv.at<Vec3b>(j, i)[2] = (unsigned char)nn;
		}
	}
	cvtColor(hsv, frame, COLOR_HSV2RGB);
	cvtColor(frame, frame, COLOR_RGB2RGBA);
	return(frame);
}

void sharpen2D(double amt, const cv::Mat &image, cv::Mat &result)
{
	Mat kernel(3, 3, CV_32F, cv::Scalar(0));

	kernel.at<float>(0, 0) = -1.0;
	kernel.at<float>(1, 0) = -1.0;
	kernel.at<float>(2, 0) = -1.0;
	kernel.at<float>(0, 1) = -1.0;
	kernel.at<float>(1, 1) = amt;
	kernel.at<float>(2, 1) = -1.0;
	kernel.at<float>(0, 2) = -1.0;
	kernel.at<float>(1, 2) = -1.0;
	kernel.at<float>(2, 2) = -1.0;

	filter2D(image, result, image.depth(), kernel);
}

char **split_command_line(const char *cmdline, int *argc)
{
int i;
char **argv = NULL;

	wordexp_t p;
	if(wordexp(cmdline, &p, 0))
	{
		return NULL;
	}
	*argc = p.we_wordc;
	if((argv = (char **)calloc(p.we_wordc + 1, sizeof(char *))))
	{
		for(i = 0; i < p.we_wordc;i++)
		{
			argv[i] = strdup(p.we_wordv[i]);
		}
	}
	argv[p.we_wordc] = NULL;
	wordfree(&p);
	return argv;
}

pid_t	popen2(const char *command, int *infp, int *outfp)
{
int p_stdin[2], p_stdout[2];
pid_t pid;
int loop;

	if(pipe(p_stdin) != 0 || pipe(p_stdout) != 0)
	{
		return(-1);
	}
	pid = fork();
	if(pid < 0)
	{
		return(pid);
	}
	else if(pid == 0)
	{
		close(p_stdin[WRITE]);
		dup2(p_stdin[READ], READ);
		close(p_stdout[READ]);
		dup2(p_stdout[WRITE], WRITE);

		int argc = 0;
		char **argv = split_command_line(command, &argc);
		execvp(argv[0], argv);
		exit(1);
	}
	if(infp == NULL)
	{
		close(p_stdin[WRITE]);
	}
	else
	{
		*infp = p_stdin[WRITE];
	}
	if(outfp == NULL)
	{
		close(p_stdout[READ]);
	}
	else
	{
		*outfp = p_stdout[READ];
	}
	return(pid);
}

void	my_cairo_set_line_style(cairo_t *context, int style, int width)
{
	cairo_set_line_cap(context, CAIRO_LINE_CAP_SQUARE);
	if((style & FL_CAP_ROUND) == FL_CAP_ROUND)
	{
		cairo_set_line_cap(context, CAIRO_LINE_CAP_ROUND);
	}
	if((style & FL_JOIN_ROUND) == FL_JOIN_ROUND)
	{
		cairo_set_line_join(context, CAIRO_LINE_JOIN_ROUND);
	}
	if((style & FL_JOIN_MITER) == FL_JOIN_MITER)
	{
		cairo_set_line_join(context, CAIRO_LINE_JOIN_MITER);
	}
	if((style & FL_JOIN_BEVEL) == FL_JOIN_BEVEL)
	{
		cairo_set_line_join(context, CAIRO_LINE_JOIN_BEVEL);
	}
	if((style & FL_DASH) == FL_DASH)
	{
  		static const double dashed2[] = {14.0, 12.0};
  		static int len2  = sizeof(dashed2) / sizeof(dashed2[0]);
		cairo_set_dash(context, dashed2, len2, 1);
		cairo_set_line_cap(context, CAIRO_LINE_CAP_SQUARE);
	}
	else if((style & FL_DOT) == FL_DOT)
	{
  		static const double dashed2[] = {1.0, 12.0};
  		static int len2  = sizeof(dashed2) / sizeof(dashed2[0]);
		cairo_set_dash(context, dashed2, len2, 1);
		cairo_set_line_cap(context, CAIRO_LINE_CAP_ROUND);
	}
	else
	{
		cairo_set_dash(context, NULL, 0, 1);
	}
	cairo_set_line_width(context, width);
}

void	my_cairo_set_source_rgb(cairo_t *context, int r, int g, int b)
{
	double rr = (double)r / 255.0;
	double gg = (double)g / 255.0;
	double bb = (double)b / 255.0;
	
	cairo_set_source_rgb(context, bb, gg, rr);
}

void	my_cairo_set_source_rgba(cairo_t *context, int r, int g, int b, int a)
{
	double rr = (double)r / 255.0;
	double gg = (double)g / 255.0;
	double bb = (double)b / 255.0;
	double aa = (double)a / 255.0;
	
	cairo_set_source_rgba(context, bb, gg, rr, aa);
}

void	my_cairo_set_source_rgba(cairo_t *context, unsigned long int val)
{
	int rr = (val & 0xff000000) >> 24;
	int gg = (val & 0xff0000) >> 16;
	int bb = (val & 0xff00) >> 8;
	int aa = val & 0xff;

	my_cairo_set_source_rgba(context, rr, gg, bb, aa);
}

int		parse_newlines(char *in, char **out)
{
	int cnt = 0;
	char *cp = in;
	out[cnt] = cp;
	cnt++;
	while(*cp != '\0')
	{
		if(*cp == 10)
		{
			*cp = '\0';
			cp++;
			out[cnt] = cp;
			cnt++;
		}
		cp++;
	}
	return(cnt);
}

size_t write_data(char *ptr, size_t size, size_t nmemb, void *userdata)
{
	vector<uchar> *stream = (vector<uchar>*)userdata;
	size_t count = size * nmemb;
	stream->insert(stream->end(), ptr, ptr + count);
	return count;
}

cv::Mat curlImg(const char *img_url, int timeout=10)
{
	vector<uchar> stream;
	CURL *curl = curl_easy_init();
	curl_easy_setopt(curl, CURLOPT_URL, img_url);
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &stream);
	curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);
	CURLcode res = curl_easy_perform(curl);
	curl_easy_cleanup(curl);
	return imdecode(stream, -1);
}

char	*text_string_commands(char *cp, MyWin *in_win, Camera *cam, cairo_t *cr, int& xx, int& yy, char *font_name, int& size, int r, int g, int b, int a)
{
int		create_task(int (*funct)(int *), void *flag);
int		play_audio_thread(int *flag);
char	font_face[256];
char	audio_filename[4096];
char	pipe_filename[4096];
char	image_filename[4096];

	FILE *pipe_fp = NULL;
	int	pipe_in = -1;
	int	pipe_out = -1;
	char tts[32768];

	cairo_font_slant_t slant = CAIRO_FONT_SLANT_NORMAL;
	cairo_font_weight_t bold = CAIRO_FONT_WEIGHT_NORMAL;
	strcpy(tts, "");
	cairo_font_slant_t use_slant = slant;
	cairo_font_weight_t use_bold = bold;
	int use_size = size;
	strcpy(font_face, font_name);
	int in_xx = xx;
	int in_yy = yy;
	int last_image_h = 0;

	int commands_done = 0;
	while(commands_done == 0)
	{
		if(strncmp(cp, "[color]", strlen("[color]")) == 0)
		{
			cp += strlen("[color]");
			my_cairo_set_source_rgba(cr, r, g, b, a);
		}
		else if(strncmp(cp, "[color=", strlen("[color=")) == 0)
		{
			cp += strlen("[color=");
			int number = return_color_by_name(cp);
			while((*cp != ']') && (*cp != '\0'))
			{
				cp++;
			}
			if(*cp == ']')
			{
				cp += strlen("]");
				my_cairo_set_source_rgba(cr, number);
			}
		}
		else if(strncmp(cp, "[face]", strlen("[face]")) == 0)
		{
			cp += strlen("[face]");
			cairo_select_font_face(cr, font_name, use_slant, use_bold);
			strcpy(font_face, font_name);
		}
		else if(strncmp(cp, "[face=", strlen("[face=")) == 0)
		{
			cp += strlen("[face=");
			char *cp2 = font_face;
			while((*cp != ']') && (*cp != '\0'))
			{
				*cp2++ = *cp++;
			}
			if(*cp == ']')
			{
				cp++;
				*cp2 = '\0';
				cairo_select_font_face(cr, font_face, use_slant, use_bold);
			}
		}
		else if(strncmp(cp, "[style]", strlen("[style]")) == 0)
		{
			cp += strlen("[style]");
			cairo_select_font_face(cr, font_face, slant, bold);
			use_slant = slant;
			use_bold = bold;
		}
		else if(strncmp(cp, "[style=", strlen("[style=")) == 0)
		{
			cp += strlen("[style=");
			if(strncmp(cp, "italic", strlen("italic")) == 0)
			{
				use_slant = CAIRO_FONT_SLANT_ITALIC;
			}
			if(strncmp(cp, "bold", strlen("bold")) == 0)
			{
				use_bold = CAIRO_FONT_WEIGHT_BOLD;
			}
			while((*cp != ']') && (*cp != '\0'))
			{
				cp++;
			}
			if(*cp == ']')
			{
				cp++;
				cairo_select_font_face(cr, font_face, use_slant, use_bold);
			}
		}
		else if(strncmp(cp, "[size]", strlen("[size]")) == 0)
		{
			cp += strlen("[size]");
			cairo_set_font_size(cr, size);
			use_size = size;
		}
		else if(strncmp(cp, "[size=", strlen("[size=")) == 0)
		{
			cp += strlen("[size=");
			int number = (int)atol(cp);
			while((*cp != ']') && (*cp != '\0'))
			{
				cp++;
			}
			if(*cp == ']')
			{
				cp += strlen("]");
				use_size = number;
				size = use_size;
				cairo_set_font_size(cr, use_size);
				if(yy < use_size) 
				{
					yy = use_size;
				}
			}
		}
		else if(strncmp(cp, "[audio]", strlen("[audio]")) == 0)
		{
			cp += strlen("[audio]");
		}
		else if(strncmp(cp, "[audio=", strlen("[audio=")) == 0)
		{
			cp += strlen("[audio=");
			char *cp2 = audio_filename;
			while((*cp != ']') && (*cp != '\0'))
			{
				*cp2++ = *cp++;
			}
			if(*cp == ']')
			{
				cp++;
				*cp2 = '\0';
				play_audio_file(in_win, audio_filename);
			}
		}
		else if(strncmp(cp, "[pipe]", strlen("[pipe]")) == 0)
		{
			cp += strlen("[pipe]");
			if(pipe_fp != NULL)
			{
				fprintf(pipe_fp, "%s\n", tts);
				fflush(pipe_fp);
				fclose(pipe_fp);
				pipe_fp = NULL;
			}
		}
		else if(strncmp(cp, "[pipe=", strlen("[pipe=")) == 0)
		{
			cp += strlen("[pipe=");
			char *cp2 = pipe_filename;
			while((*cp != ']') && (*cp != '\0'))
			{
				*cp2++ = *cp++;
			}
			if(*cp == ']')
			{
				cp++;
				*cp2 = '\0';
				if(pipe_fp == NULL)
				{
					int pipe_pid = popen2(pipe_filename, &pipe_in, &pipe_out);
					if(pipe_pid != -1)
					{
						pipe_fp = fdopen(pipe_in, "w");
					}
				}
			}
		}
		else if(strncmp(cp, "[image]", strlen("[image]")) == 0)
		{
			cp += strlen("[image]");
			xx = in_xx;
			yy += last_image_h;
		}
		else if(strncmp(cp, "[image=", strlen("[image=")) == 0)
		{
			cp += strlen("[image=");
			char *cp2 = image_filename;
			while((*cp != ']') && (*cp != '\0'))
			{
				*cp2++ = *cp++;
			}
			if(*cp == ']')
			{
				cp++;
				*cp2 = '\0';
				Mat my_mat;
				if(strncmp(image_filename, "http", strlen("http")) == 0)
				{
					my_mat = curlImg(image_filename);
				}
				else
				{
					my_mat = imread(image_filename);
				}
				if(!my_mat.empty())
				{
					cvtColor(my_mat, my_mat, COLOR_BGR2RGBA);
					if((my_mat.rows > 0) && (my_mat.cols > 0))
					{
						cairo_surface_t *surface = cairo_image_surface_create_for_data(my_mat.ptr(), CAIRO_FORMAT_ARGB32, my_mat.cols, my_mat.rows, my_mat.step);
						if(surface != NULL)
						{
							cairo_set_source_surface(cr, surface, xx, yy - size);
							cairo_paint(cr);
							cairo_surface_destroy(surface);
							my_cairo_set_source_rgba(cr, r, g, b, a);
							last_image_h = my_mat.rows;
						}
					}
				}
			}
		}
		else if(strncmp(cp, "[reset]", strlen("[reset]")) == 0)
		{
			cp += strlen("[reset]");
			cairo_save(cr);
			my_cairo_set_source_rgba(cr, cam->red, cam->green, cam->blue, cam->alpha);
			cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
			cairo_rectangle(cr, 0, 0, cam->width, cam->height);
			cairo_fill(cr);
			cairo_restore(cr);
			xx = in_xx;
			yy = in_yy;
		}
		else if(strncmp(cp, "\\n", strlen("\\n")) == 0)
		{
			cp += strlen("\\n");
			xx = in_xx;
			yy += size;
		}
		else if(strncmp(cp, "\\t", strlen("\\t")) == 0)
		{
			cp += strlen("\\t");
			while((xx & 100) != 0)
			{
				xx++;
			}
		}
		else
		{
			commands_done = 1;
		}
	}
	return(cp);
}

void	my_cairo_draw_text(MyWin *in_win, Camera *cam, cairo_t *cr, int in_xx, int in_yy, char *text, char *font_name, int style, int& size, int cur_pos, int r, int g, int b, int a, int out_r, int out_g, int out_b, int out_a, int& final_extent_w, int& final_extent_h, double scale_x = 1.0, double scale_y = 1.0)
{
int		interpret_output_path(MyWin *win, char *in, char *out, int *clock_type);
int		create_task(int (*funct)(int *), void *flag);
int		loop;
int		inner;
char	font_face[256];
char	audio_filename[4096];
char	pipe_filename[4096];
char	image_filename[4096];

	FILE *pipe_fp = NULL;
	int	pipe_in = -1;
	int	pipe_out = -1;
	char tts[32768];

	int xx = in_xx;
	int yy = in_yy;
	strcpy(tts, "");
	cairo_font_slant_t slant = CAIRO_FONT_SLANT_NORMAL;
	cairo_font_weight_t bold = CAIRO_FONT_WEIGHT_NORMAL;
	if((style & FONT_STYLE_ITALIC) == FONT_STYLE_ITALIC)
	{
		slant = CAIRO_FONT_SLANT_ITALIC;
	}
	if((style & FONT_STYLE_BOLD) == FONT_STYLE_BOLD)
	{
		bold = CAIRO_FONT_WEIGHT_BOLD;
	}
	cairo_font_slant_t use_slant = slant;
	cairo_font_weight_t use_bold = bold;
	int use_size = size;
	strcpy(font_face, font_name);
	my_cairo_set_source_rgba(cr, r, g, b, a);
	cairo_select_font_face(cr, font_face, slant, bold);
	cairo_set_font_size(cr, size);

	char out[32768];
	interpret_output_path(in_win, text, out, NULL);
	char cc[3];
	char *cp = out;

	char *str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890|/.,!@#$%^&*()-=+";
	cairo_text_extents_t extents;
	cairo_text_extents(cr, str, &extents);
	int baseline = extents.height * scale_y;
	if(size > baseline) baseline = size;
	yy += baseline;

	int save_x = xx;
	inner = 0;
	int last_image_h = 0;
	final_extent_w = 0;
	final_extent_h = 0;
	int max_xx = 0;
	int max_yy = 0;
	cairo_move_to(cr, xx, yy);
	while(*cp != '\0')
	{
		cp = text_string_commands(cp, in_win, cam, cr, xx, yy, font_name, size, r, g, b, a);
		if(*cp != '\0')
		{
			char cc[2];
			cc[0] = *cp;
			cc[1] = '\0';
			if(*cp == 10)
			{
				if(inner == cur_pos)
				{
					cairo_set_line_width(cr, 2.0);
					cairo_move_to(cr, xx, yy);
					cairo_line_to(cr, xx, yy - baseline);
					cairo_stroke(cr);
				}
				yy += baseline;
				xx = save_x;
				cairo_move_to(cr, xx, yy);
			}
			else
			{
				my_cairo_push_matrix(cr);
				cairo_scale(cr, scale_x, scale_y);
				if((style & FONT_STYLE_OUTLINE) == FONT_STYLE_OUTLINE)
				{
					my_cairo_set_source_rgba(cr, r, g, b, a);
					cairo_text_path(cr, cc);
					cairo_fill_preserve(cr);
					my_cairo_set_source_rgba(cr, out_r, out_g, out_b, out_a);
					cairo_set_line_width(cr, 2.56);
					cairo_stroke(cr);
				}
				else
				{
					if(inner == cur_pos)
					{
						cairo_set_line_width(cr, 2.0);
						cairo_line_to(cr, xx, yy - baseline);
						cairo_stroke(cr);
						cairo_move_to(cr, xx, yy);
					}
					cairo_show_text(cr, cc);
					cairo_stroke(cr);
				}
				cairo_text_extents_t extents;
				cairo_text_extents(cr, cc, &extents);
				xx += (extents.x_advance * scale_x);
				if(xx > max_xx)
				{
					final_extent_w = xx - in_xx;
					max_xx = xx;
				}
				if(yy > max_yy)
				{
					final_extent_h = yy - in_yy;
					max_yy = yy;
				}
				if(pipe_fp != NULL)
				{
					strcat(tts, cc);
				}
				my_cairo_pop_matrix(cr);
				cairo_move_to(cr, xx, yy);
			}
			inner++;
			cp++;
		}
	}
	if(pipe_fp != NULL)
	{
		fprintf(pipe_fp, "\n");
		fflush(pipe_fp);
		fclose(pipe_fp);
		pipe_fp = NULL;
	}
	if(inner == cur_pos)
	{
		cairo_set_line_width(cr, 2.0);
		cairo_move_to(cr, xx, yy);
		cairo_line_to(cr, xx, yy - baseline);
		cairo_stroke(cr);
	}
}

void	my_cairo_draw_text(cairo_t *cr, int in_xx, int in_yy, char *text, int sz)
{
int		loop;
int		inner;

	int xx = in_xx;
	int yy = in_yy;
	int save_x = xx;
	my_cairo_set_source_rgba(cr, 255, 255, 255, 255);
	cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
	cairo_set_font_size(cr, sz);

	char *cp = text;
	while(*cp != '\0')
	{
		if(*cp != '\0')
		{
			char cc[2];
			cc[0] = *cp;
			cc[1] = '\0';
			if(*cp == 10)
			{
				yy += sz;
				xx = save_x;
			}
			else
			{
				cairo_move_to(cr, xx, yy);
				cairo_show_text(cr, cc);
				cairo_stroke(cr);
				cairo_text_extents_t extents;
				cairo_text_extents(cr, cc, &extents);
				xx += extents.x_advance;
			}
			cp++;
		}
	}
}

void	test_blend(int xx, int yy, int ww, int hh, int width, int height, int stride, void *data_in, BLImageData *data_out)
{
	BLImage img;
	img.createFromData(width, height, BL_FORMAT_PRGB32, data_in, stride);
	BLContext ctx(img);

	ctx.setFillStyle(BLRgba32(255, 0, 0));
	ctx.fillRect(xx, yy, ww, hh);

	ctx.end();
	img.makeMutable(data_out);
}

int	force_to_grid2(int grid_sz, int use_x)
{
	int nx = use_x % grid_sz;
	if(nx != 0)
	{
		double nx = (double)use_x / (double)grid_sz;
		nx = round(nx);
		use_x = nx * grid_sz;
	}
	return(use_x);
}

int	force_to_grid(int grid_sz, int use_x)
{
	int nx = use_x % grid_sz;
	if(nx != 0)
	{
		double nx = (double)use_x / (double)grid_sz;
		nx = round(nx);
		use_x = nx * grid_sz;
	}
	return(use_x);
}

void	char_replace(char *in, char one, char two)
{
	char *cp = in;
	while(*cp != '\0')
	{
		if(*cp == one)
		{
			*cp = two;
		}
		cp++;
	}
}

void	change_alpha(Mat rgba, int direction)
{
	for(int y = 0; y < rgba.rows; ++y)
	{
		for(int x = 0; x < rgba.cols; ++x)
		{
			cv::Vec4b & pixel = rgba.at<cv::Vec4b>(y, x);
			int val = pixel[3];
			if(direction > 0)
			{
				if(val < 255)
				{
					pixel[3]++;
				}
			}
			else
			{
				if(val > 0)
				{
					pixel[3]--;
				}
			}
		}
	}
}

static int cmpstringp(const void *p1, const void *p2)
{
	return strcmp(*(char * const *)p1, *(char * const *)p2);
}

long int local_timestamp()
{
struct timeval tv;
	
	gettimeofday(&tv, NULL);
	long int ts = ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
	return(ts);
}

long int precise_time()
{
struct timeval tv;
	
	gettimeofday(&tv, NULL);
	long int ts = (tv.tv_sec * 1000000) + tv.tv_usec;
	return(ts);
}

long int filelength(int fd)
{
long int size = -1;
struct stat stat_buf;

	size = 0;
	if(fstat(fd, &stat_buf) == 0)
	{
		size = stat_buf.st_size;
	}
	return(size);
}

char	*read_whole_text_file(char *filename)
{
	char *rr = NULL;
	int fd = open(filename, O_RDONLY);
	if(fd != -1)
	{
		long int length = filelength(fd);
		char *buf = (char *)malloc(length + 1);
		if(buf != NULL)
		{
			read(fd, buf, length);
			buf[length] = '\0';
			rr = buf;
		}
		close(fd);
	}
	return(rr);
}

int	interpret_output_path(MyWin *win, char *in, char *out, int *clock_type)
{
char	*curl(char *url, char *user_name, char *password, int binary, int *sz);
char	buf[256];

	char *cp_in = in;
	char *cp_out = out;
	time_t now = time(0);
	struct tm *tm = localtime(&now);
	strcpy(out, "");
	if(clock_type != NULL)
	{
		*clock_type = 0;
	}
	while(*cp_in != '\0')
	{
		if(strncmp(cp_in, "%home", 5) == 0)
		{
			sprintf(buf, "%s", getenv("HOME"));
			strcat(cp_out, buf);
			cp_in += 5;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%frame", 6) == 0)
		{
			if(win != NULL)
			{
				sprintf(buf, "%06d", win->recorded_frames);
				strcat(cp_out, buf);
				cp_out += strlen(buf);
			}
			cp_in += 6;
		}
		else if(strncmp(cp_in, "%source", 7) == 0)
		{
			if(win != NULL)
			{
				Camera *cam = win->DisplayedCamera();
				if(cam != NULL)
				{
					char *str = cam->path;
					if(strlen(cam->alias) > 0)
					{
						str = cam->alias;
					}
					strcat(cp_out, str);
					cp_out += strlen(str);
				}
				cp_in += 7;
			}
		}
		else if(strncmp(cp_in, "%cwd", 5) == 0)
		{
			sprintf(buf, "%s", getenv("PWD"));
			strcat(cp_out, buf);
			cp_in += 4;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%tod", 4) == 0)
		{
			cp_in += 4;
			if(clock_type != NULL)
			{
				*clock_type |= CLOCK_TYPE_TOD;
			}
		}
		else if(strncmp(cp_in, "%elapsed", 8) == 0)
		{
			cp_in += 8;
			if(clock_type != NULL)
			{
				*clock_type |= CLOCK_TYPE_ELAPSED;
			}
		}
		else if(strncmp(cp_in, "%Y", 2) == 0)
		{
			sprintf(buf, "%d", 1900 + tm->tm_year);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%M", 2) == 0)
		{
			sprintf(buf, "%d", tm->tm_mon + 1);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%D", 2) == 0)
		{
			sprintf(buf, "%d", tm->tm_mday);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%h", 2) == 0)
		{
			sprintf(buf, "%02d", tm->tm_hour);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%m", 2) == 0)
		{
			sprintf(buf, "%02d", tm->tm_min);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%s", 2) == 0)
		{
			sprintf(buf, "%02d", tm->tm_sec);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%u", 2) == 0)
		{
			sprintf(buf, "%ld", precise_time());
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%U", 2) == 0)
		{
			sprintf(buf, "%ld", precise_time() / 1000);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%S", 2) == 0)
		{
			sprintf(buf, "%ld", time(0));
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%d", 2) == 0)
		{
			if(win != NULL)
			{
				Camera *cam = win->DisplayedCamera();
				if(cam != NULL)
				{
					int total_seconds = cam->running_time / 1000;
					int minutes = total_seconds / 60;
					int seconds = total_seconds % 60;
					sprintf(buf, "%03d:%02d", minutes, seconds);
					strcat(cp_out, buf);
					cp_in += 2;
					cp_out += strlen(buf);
				}
			}
		}
		else if(strncmp(cp_in, "[file=", strlen("[file=")) == 0)
		{
			char filename[4096];
			char buf[4096];
			cp_in += strlen("[curl=");
			char *cp2 = filename;
			while((*cp_in != ']') && (*cp_in != '\0'))
			{
				*cp2++ = *cp_in++;
			}
			if(*cp_in == ']')
			{
				cp_in++;
				*cp2 = '\0';
				FILE *fp = fopen(filename, "r");
				if(fp != NULL)
				{
					while(fgets(buf, 4096, fp))
					{
						strcat(cp_out, buf);
						cp_out += strlen(buf);
					}
					fclose(fp);
				}
			}
		}
		else if(strncmp(cp_in, "[curl=", strlen("[curl=")) == 0)
		{
			char curl_url[4096];
			char *use_url = NULL;
			char *login = NULL;
			char *password = NULL;
			char *json_filter = NULL;

			cp_in += strlen("[curl=");
			char *cp2 = curl_url;
			while((*cp_in != ']') && (*cp_in != '\0'))
			{
				*cp2++ = *cp_in++;
			}
			if(*cp_in == ']')
			{
				cp_in++;
				*cp2 = '\0';
			}
			use_url = curl_url;
			if(strncmp(curl_url, "http", strlen("http")) != 0)
			{
				login = curl_url;
				char *cp = login;
				while((*cp != ':') && (*cp != '\0'))
				{
					cp++;
				}
				if(*cp == ':')
				{
					*cp = '\0';
					cp++;
					password = cp;
					while((*cp != ':') && (*cp != '\0'))
					{
						cp++;
					}
					if(*cp == ':')
					{
						*cp = '\0';
						cp++;
						use_url = cp;
					}
				}
			}
			if(use_url != NULL)
			{
				if(strncmp(use_url, "json=", strlen("json=")) == 0)
				{
					char *cp = use_url + strlen("json=");
					json_filter = cp;
					while((*cp != ':') && (*cp != '\0'))
					{
						cp++;
					}
					if(*cp == ':')
					{
						*cp = '\0';
						cp++;
						use_url = cp;
					}
				}
				int sz = 0;
				char *result_str = curl(use_url, login, password, 0, &sz);
				if(result_str != NULL)
				{
					char buf[256];
					if(json_filter != NULL)
					{
						cJSON *json = cJSON_Parse(result_str);
						if(json == NULL)
						{
							const char *error_ptr = cJSON_GetErrorPtr();
							if(error_ptr != NULL)
							{
								fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
							}
						}
						else
						{
							cJSON *orig = json;
							char *use_json[64];
							int use_cnt = 0;
							char *cp = json_filter;
							use_json[use_cnt] = cp;
							use_cnt++;
							while(*cp != '\0')
							{
								if(*cp == '|')
								{
									*cp = '\0';
									cp++;
									use_json[use_cnt] = cp;
									use_cnt++;
								}
								cp++;
							}
							for(int loop = 0;loop < use_cnt;loop++)
							{
								cJSON *got = cJSON_GetObjectItemCaseSensitive(json, use_json[loop]);
								if(got != NULL)
								{
									json = got;
									if((cJSON_IsString(got)) && (got->valuestring != NULL))
									{
										result_str = got->valuestring;
									}
									else if(cJSON_IsNumber(got))
									{
										sprintf(buf, "%g", got->valuedouble);
										result_str = buf;
									}
								}
							}
							cJSON_Delete(orig);
						}
					}
					strcat(cp_out, result_str);
					cp_out += strlen(result_str);
				}
			}
		}
		else
		{
			*cp_out = *cp_in;
			cp_in++;
			cp_out++;
		}
		*cp_out = '\0';
	}
	int streaming = 0;
	if(strncasecmp(out, "ndi://", strlen("ndi://")) == 0)
	{
		streaming = STREAMING_NDI;
		char *cp = out + strlen("ndi://");
		if(strlen(cp) > 0)
		{
			strcpy(win->ndi_stream_name, cp);
		}
	}
	else if(strncasecmp(out, "ndi_rgbx://", strlen("ndi_rgbx://")) == 0)
	{
		streaming = STREAMING_NDI;
		char *cp = out + strlen("ndi_rgbx://");
		if(strlen(cp) > 0)
		{
			strcpy(win->ndi_stream_name, cp);
			win->ndi_send_video_format = NDI_SEND_VIDEO_FORMAT_RGBX;
		}
	}
	else if(strncasecmp(out, "ndi_bgrx://", strlen("ndi_bgrx://")) == 0)
	{
		streaming = STREAMING_NDI;
		char *cp = out + strlen("ndi_bgrx://");
		if(strlen(cp) > 0)
		{
			strcpy(win->ndi_stream_name, cp);
			win->ndi_send_video_format = NDI_SEND_VIDEO_FORMAT_BGRX;
		}
	}
	else if(strncasecmp(out, "ndi_i420://", strlen("ndi_i420://")) == 0)
	{
		streaming = STREAMING_NDI;
		char *cp = out + strlen("ndi_i420://");
		if(strlen(cp) > 0)
		{
			strcpy(win->ndi_stream_name, cp);
			win->ndi_send_video_format = NDI_SEND_VIDEO_FORMAT_I420;
		}
	}
	else if(strncasecmp(out, "ndi_uyva://", strlen("ndi_uyva://")) == 0)
	{
		streaming = STREAMING_NDI;
		char *cp = out + strlen("ndi_uyva://");
		if(strlen(cp) > 0)
		{
			strcpy(win->ndi_stream_name, cp);
			win->ndi_send_video_format = NDI_SEND_VIDEO_FORMAT_UYVA;
		}
	}
	else if(strncasecmp(out, "ndi_uyvy://", strlen("ndi_uyvy://")) == 0)
	{
		streaming = STREAMING_NDI;
		char *cp = out + strlen("ndi_uyvy://");
		if(strlen(cp) > 0)
		{
			strcpy(win->ndi_stream_name, cp);
			win->ndi_send_video_format = NDI_SEND_VIDEO_FORMAT_UYVY;
		}
	}
	else
	{
		char *cp = out;
		while(*cp != '\0')
		{
			if(strncasecmp(cp, "://", 3) == 0)
			{
				streaming = STREAMING_NET;
			}
			cp++;
		}
	}
	return(streaming);
}

void	swap_rgb(unsigned char *ptr, int sz)
{
int	 loop;

	for(loop = 0;loop < (sz / 3);loop++)
	{
		unsigned char *r = ptr;
		unsigned char *b = (ptr + 2);
		unsigned char t = *r;
		*r = *b;
		*b = t;
		ptr += 3;
	}
}

int	write_frame(int fd, void *ptr, int sz, long int ts)
{
	int nn = -1;
	nn = write(fd, &ts, sizeof(long int));
	if(nn == sizeof(long int))
	{
		nn = write(fd, ptr, sz);
	}
	return(nn);
}

int	write_frame(int fd, void *ptr, int w, int h, long int ts)
{
	int nn = -1;
	cv::Mat image(cv::Size(w, h), CV_8UC4, ptr);
	std::vector<uchar> buffer;
	imencode(".jpg", image, buffer);
	long int sz = buffer.size();
	nn = write(fd, &ts, sizeof(long int));
	nn = write(fd, &sz, sizeof(long int));
	nn = write(fd, buffer.data(), sz);
	return(nn);
}

int	read_frame(int fd, void *ptr, int sz, long int *ts)
{
	int nn = -1;
	nn = read(fd, ts, sizeof(long int));
	if(nn == sizeof(long int))
	{
		nn = read(fd, ptr, sz);
	}
	return(nn);
}

int	read_frame(int fd, void *ptr, int w, int h, long int *ts)
{
	int nn = -1;
	long int sz = 0;
	nn = read(fd, ts, sizeof(long int));
	nn = read(fd, &sz, sizeof(long int));
	if(nn == sizeof(long int))
	{
		nn = read(fd, ptr, sz);
		cv::Mat mat;
		mat = cv::imdecode(cv::Mat(1, sz, CV_8UC1, ptr), IMREAD_UNCHANGED);
		memcpy(ptr, mat.ptr(), w * h * 3);
	}
	return(nn);
}

void	dump_object(int fd, void *thing, int sz)
{
	long int nn = (long int)thing;
	write(fd, &sz, sizeof(int));
	write(fd, &nn, sizeof(long int));
	write(fd, thing, sz);
}

int	create_task(int (*funct)(int *), void *flag)
{
int	 	status;
pthread_t	mythread;
pthread_attr_t	attr;

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	if(pthread_create(&mythread, &attr, (void * (*)(void *))funct, flag))
	{
		fprintf(stderr, "Error: Cannot create a new thread.\n");
	}
	return((int)mythread);
}

void	copy_frame(unsigned char *dest, unsigned char *src, int sz)
{
	memcpy(dest, src, sz);
}

int	fifo_save_frame(int *flag)
{
int	loop;

	SaveFIFO *fifo = (SaveFIFO *)flag;
	if(fifo != NULL)
	{
		int last_ts = 0;
		while(fifo->done == 0)
		{
			if(fifo->top > 0)
			{
				long int fifo_start_ts = local_timestamp();
				int limit = fifo->top;
				for(loop = 0;loop < fifo->top;loop++)
				{
					pthread_mutex_lock(&fifo->mutex[loop]);
					if(fifo->frame[loop] != NULL)
					{
						if(fifo->use_ts > (last_ts + 29))
						{
							write_frame(fifo->fd, fifo->frame[loop], fifo->frame_sz, fifo->use_ts);
							last_ts = fifo->use_ts;
						}
						free(fifo->frame[loop]);
						fifo->frame[loop] = NULL;
					}
					pthread_mutex_unlock(&fifo->mutex[loop]);
				}
				fifo->top = 0;
			}
			else
			{
				usleep(10);
			}
		}
	}
	return(0);
}

void	test_plugin_camera_name(MyWin *win, char *in_name)
{
char	buf[4096];
char	use[8192];
int		loop;

	sprintf(buf, "camera_%s", in_name);
	for(loop = 0;loop < global_potential_camera_cnt;loop++)
	{
		if((global_potential_camera[loop] != NULL) && (global_potential_camera_handle[loop] != NULL))
		{
			if(strcmp(global_potential_camera[loop], buf) == 0)
			{ 
				void *handle = global_potential_camera_handle[loop];
				if(handle != NULL)
				{
					void *void_camera_plugin = (void *)dlsym(handle, buf);
					if(void_camera_plugin != NULL)
					{
						sprintf(use, "plugin://%s", buf);
						win->new_source_window->source->value(use);
					}
				}
			}
		}
	}
}

void	*resolve_plugin_camera_name(MyWin *win, char *in_name)
{
char	buf[4092];
char	use[4092];
int		loop;

	void *rr = NULL;
	if(strncmp(in_name, "camera_", strlen("camera_")) != 0)
	{
		sprintf(buf, "camera_%s", in_name);
	}
	else
	{
		sprintf(buf, "%s", in_name);
	}
	for(loop = 0;loop < global_potential_camera_cnt;loop++)
	{
		if((global_potential_camera[loop] != NULL) && (global_potential_camera_handle[loop] != NULL))
		{
			if(strcmp(global_potential_camera[loop], buf) == 0)
			{ 
				void *handle = global_potential_camera_handle[loop];
				if(handle != NULL)
				{
					void *void_camera_plugin = (void *)dlsym(handle, buf);
					if(void_camera_plugin != NULL)
					{
						rr = void_camera_plugin;
					}
				}
			}
		}
	}
	return(rr);
}

void	example_mask_it(Mat& mat)
{
	cv::Point corners[1][4];
	corners[0][0] = Point(10, 10);
	corners[0][1] = Point(600, 200);
	corners[0][2] = Point(800, 700);
	corners[0][3] = Point(20, 800);
	const Point* corner_list[1] = { corners[0] };

	int num_points = 4;
	int num_polygons = 1;
	int line_type = 8;
	cv::Mat mask(mat.rows, mat.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
	cv::fillPoly(mask, corner_list, &num_points, num_polygons, cv::Scalar(255, 255, 255, 255), line_type);

	cv::Mat result;
	cv::bitwise_and(mat, mask, mat);
}

void	matching_method(int match_method, Mat img, Mat temp, int *xx, int *yy)
{
Mat	result;

	/// Create the result matrix
	int result_cols =  img.cols - temp.cols + 1;
	int result_rows = img.rows - temp.rows + 1;

	result.create(result_rows, result_cols, CV_32FC1);

	/// Do the Matching and Normalize
	matchTemplate(img, temp, result, match_method);
	normalize(result, result, 0, 1, NORM_MINMAX, -1, Mat());

	/// Localizing the best match with minMaxLoc
	double minVal;
	double maxVal;
	Point minLoc;
	Point maxLoc;
	Point matchLoc;

	minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, Mat());

	/// For SQDIFF and SQDIFF_NORMED, the best matches are lower values. For all the other methods, the higher the better
	if((match_method == TM_SQDIFF) || (match_method == TM_SQDIFF_NORMED))
	{
		matchLoc = minLoc;
	}
	else
	{
		matchLoc = maxLoc;
	}
	*xx = matchLoc.x;
	*yy = matchLoc.y;
}

void	x11_mouse(int& xx, int& yy, int& mask)
{
Window		window_returned;
int		root_x, root_y;
int		win_x, win_y;
unsigned	int mask_return;

	int result = XQueryPointer(
		fl_display, 
		RootWindow(fl_display, fl_screen), 
		&window_returned, 
		&window_returned, 
		&root_x, 
		&root_y, 
		&win_x, 
		&win_y, 
		&mask_return);
	xx = root_x;
	yy = root_y;
	mask = mask_return;
}

XImage	*x11_create_shared_image(XShmSegmentInfo *shminfo, int in_ww, int in_hh)
{
	XImage *image = XShmCreateImage(fl_display, DefaultVisual(fl_display, 0), 24, ZPixmap, NULL, shminfo, in_ww, in_hh);
	shminfo->shmid = shmget(IPC_PRIVATE, image->bytes_per_line * image->height, IPC_CREAT | 0777);
	shminfo->shmaddr = image->data = (char *)shmat(shminfo->shmid, 0, 0);
	shminfo->readOnly = False;
	XShmAttach(fl_display, shminfo);

	return(image);
}

void	x11_destroy_shared_image(XImage *image, XShmSegmentInfo *shminfo)
{
	if(image != NULL)
	{
		XShmDetach(fl_display, shminfo);
		XDestroyImage(image);
		shmdt(shminfo->shmaddr);
		shmctl(shminfo->shmid, IPC_RMID, 0);
	}
}

unsigned char *grab_raw_image(Fl_Window *win, int xx, int yy, int& ww, int& hh, int *sz, int *in_depth)
{
static XShmSegmentInfo	 shminfo;
static XImage *image = NULL;
static int old_w = -1;
static int old_h = -1;

	int outlen = 0;
	unsigned char *r_data = NULL;
	int n_ww, n_hh;
	int start_x = 0;
	int start_y = 0;
	int start_w = Fl::w();
	int start_h = Fl::h();
	if(xx > -1)
	{
		start_x = xx;
	}
	if(yy > -1)
	{
		start_y = yy;
	}
	if(ww > -1)
	{
		start_w = ww;
	}
	if(hh > -1)
	{
		start_h = hh;
	}
	Window xwin = RootWindow(fl_display, fl_screen);
	if(win != NULL)
	{
		if(xx == -1) start_x = 0;
		if(yy == -1) start_y = 0;
		if(ww == -1) start_w = win->w();
		if(hh == -1) start_h = win->h();
		xwin = fl_xid(win);
	}
	double s = Fl::screen_scale(0);
	int Xs = Fl_Scalable_Graphics_Driver::floor(start_x, s);
	int Ys = Fl_Scalable_Graphics_Driver::floor(start_y, s);
	int ws = Fl_Scalable_Graphics_Driver::floor(start_x + start_w, s) - Xs;
	int hs = Fl_Scalable_Graphics_Driver::floor(start_y + start_h, s) - Ys;
	start_x = Xs;
	start_y = Ys;
	start_w = ws;
	start_h = hs;
	int true_w = Fl_Scalable_Graphics_Driver::floor(Fl::w(), s);
	int true_h = Fl_Scalable_Graphics_Driver::floor(Fl::h(), s);

	XSetWindowAttributes setwinattr;
	setwinattr.backing_store = Always;
	XChangeWindowAttributes(fl_display, xwin, CWBackingStore, &setwinattr);

	int use_x = 0;
	int use_y = 0;
	int my_depth = 4;

	if((image != NULL) && ((old_w != start_w) || (old_h != start_h)))
	{
		x11_destroy_shared_image(image, &shminfo);
		image = NULL;
	}
	if(image == NULL)
	{
		image = x11_create_shared_image(&shminfo, start_w, start_h);
		old_w = start_w;
		old_h = start_h;
	}
	if(image != NULL)
	{
		XWindowAttributes win_info;
		XGetWindowAttributes(fl_display, xwin, &win_info);
		Pixmap pixmap = None;
		if(((start_x + start_w) > true_w)
		|| ((start_y + start_h) > true_h)
		|| (start_x < 0)
		|| (start_y < 0))
		{
			XSetSubwindowMode(fl_display, DefaultGC(fl_display, fl_screen), IncludeInferiors);
			pixmap = XCreatePixmap(fl_display, xwin, start_w, start_h, win_info.depth);
			XCopyArea(fl_display, xwin, pixmap, DefaultGC(fl_display, fl_screen), use_x, use_y, start_w, start_h, 0, 0);
		}
		int nn = 0;
		unsigned char *use_data = NULL;
		if(pixmap == None)
		{
			nn = (int)XShmGetImage(fl_display, xwin, image, start_x, start_y, AllPlanes);
		}
		else
		{
			nn = (int)XShmGetImage(fl_display, pixmap, image, start_x, start_y, AllPlanes);
			XFreePixmap(fl_display, pixmap);
		}
		r_data = (unsigned char *)image->data;
		outlen = image->width * image->height * 4;
	}
	*sz = outlen;
	*in_depth = my_depth;
	ww = start_w;
	hh = start_h;
	return(r_data);
}

void	adjust_mouse_image(XFixesCursorImage *img, unsigned char *out)
{
unsigned char r, g, b, a;
unsigned short row, col, pos;

	unsigned char *cp = out;
	pos = 0;
	for(row = 0;row < img->height;row++)
	{
		for(col = 0;col < img->width;col++)
		{
			a = (unsigned char)((img->pixels[pos] >> 24) & 0xff);  
			r = (unsigned char)((img->pixels[pos] >> 16) & 0xff);  
			g = (unsigned char)((img->pixels[pos] >>  8) & 0xff);
			b = (unsigned char)((img->pixels[pos] >>  0) & 0xff);
		
			*cp++ = r;
			*cp++ = g;
			*cp++ = b;
			*cp++ = a;

			pos++;
		}
	}
}

unsigned char	*x11_grab_window_image(Camera *cam, Window win, int *ww, int *hh, int *dd)
{
XWindowAttributes attributes;
XColor colors;

	unsigned char *final_ptr = NULL;

	XGetWindowAttributes(fl_display, win, &attributes);
	int width = attributes.width;
	int height = attributes.height;
	int depth = attributes.depth / 8;

	XImage *image = NULL;
	XShmSegmentInfo	shminfo;
	if(cam == NULL)
	{
		image = x11_create_shared_image(&shminfo, width, height);
	}
	if(cam != NULL)
	{
		if(cam->shared_image == NULL)
		{
			cam->shared_image = x11_create_shared_image(&cam->shminfo, width, height);
		}
		image = cam->shared_image;
	}
	if(image != NULL)
	{
		XShmGetImage(fl_display, win, image, 0, 0, AllPlanes);
		unsigned char *use_data = (unsigned char *)image->data;

		int cv_flag = CV_8UC4;
		Mat frame(cv::Size(width, height), cv_flag, use_data);

		// COW NOTE - SET TO DEPTH OF 3, REMOVING ALPHA
		depth = 3;
		int color_flag = COLOR_BGRA2RGB;
		cvtColor(frame, frame, color_flag);
		unsigned char *r_data = (unsigned char *)frame.ptr();

		int outlen = width * height * depth;
		final_ptr = (unsigned char *)malloc(outlen);
		if(final_ptr != NULL)
		{
			*ww = width;
			*hh = height;
			*dd = depth;
			memcpy(final_ptr, r_data, outlen);
		}
		if(cam == NULL)
		{
			x11_destroy_shared_image(image, &shminfo);
		}
	}
	return(final_ptr);
}

void	read_svg_file(Mat& mat, char *filename, int width, int height)
{
	auto document = lunasvg::Document::loadFromFile(filename);
	if(document != nullptr)
	{
		auto bitmap = document->renderToBitmap(width, height);
		if(!bitmap.isNull())
		{
			bitmap.convertToRGBA();
			uint8_t *use_data = bitmap.data();
			if(use_data != NULL)
			{
				width = bitmap.width();
				height = bitmap.height();
				int cv_flag = CV_8UC4;
				Mat frame(cv::Size(width, height), cv_flag, use_data);
				frame.copyTo(mat);
			}
		}
	}
}

void	draw_transparency(Mat frame, Mat transp, int xPos, int yPos)
{
Mat mask;
vector<Mat> layers;

	Mat use;
	split(transp, layers); // seperate channels
	Mat rgb[3] = { layers[0], layers[1], layers[2] };
	mask = layers[3]; // png's alpha channel used as mask
	merge(rgb, 3, use);  // put together the RGB channels, now transp is not transparent
	int sx = xPos;
	if(sx < 0)
	{
		sx = 0;
	}
	int sy = yPos;
	if(sy < 0)
	{
		sy = 0;
	}
	int ex = xPos + transp.cols;
	if(ex >= frame.cols)
	{
		ex = (frame.cols - 1);
	}
	int ey = yPos + transp.rows;
	if(ey >= frame.rows)
	{
		ey = (frame.rows - 1);
	}
	int tw = (ex - sx);
	int th = (ey - sy);
	if((tw > 0) && (th > 0)
	&& (tw == use.cols) && (th == use.rows))
	{
		cvtColor(use, use, COLOR_RGB2RGBA);
		use.copyTo(frame.rowRange(sy, ey).colRange(sx, ex), mask);
	}
}

void	x11_get_mouse_image(Mat& use)
{
	XFixesCursorImage *cur = XFixesGetCursorImage(fl_display);
	cv::Mat local_mat(cur->height, cur->width, CV_8UC4, (unsigned char *)cur->pixels);
	adjust_mouse_image(cur, local_mat.ptr());
	use = local_mat;
	XFree(cur);
}

void	x11_add_mouse(Mat& dest, int mouse_x, int mouse_y)
{
	Mat mouse_mat;
	x11_get_mouse_image(mouse_mat);
	draw_transparency(dest, mouse_mat, mouse_x, mouse_y);
}

static char *x11_get_property(Display *disp, Window win, Atom xa_prop_type, char *prop_name, unsigned long *size)
{
Atom xa_prop_name;
Atom xa_ret_type;
int ret_format;
unsigned long ret_nitems;
unsigned long ret_bytes_after;
unsigned long tmp_size;
unsigned char *ret_prop;
char *ret;
	
	xa_prop_name = XInternAtom(disp, prop_name, False);
	
	// MAX_PROPERTY_VALUE_LEN / 4 explanation (XGetWindowProperty manpage):
	//
	// long_length = Specifies the length in 32-bit multiples of the
	//			   data to be retrieved.
	//
	if(XGetWindowProperty(disp, win, xa_prop_name, 0, MAX_PROPERTY_VALUE_LEN / 4, False, xa_prop_type, &xa_ret_type, &ret_format, &ret_nitems, &ret_bytes_after, &ret_prop) != Success)
	{
		return NULL;
	}
	if(xa_ret_type != xa_prop_type)
	{
		XFree(ret_prop);
		return NULL;
	}
	// null terminate the result to make string handling easier
	tmp_size = (ret_format / (32 / sizeof(long))) * ret_nitems;
	ret = (char *)malloc(tmp_size + 1);
	memcpy(ret, ret_prop, tmp_size);
	ret[tmp_size] = '\0';
	if(size)
	{
		*size = tmp_size;
	}
	XFree(ret_prop);
	return ret;
}

static char *x11_get_window_class(Display *disp, Window win)
{
char *class_utf8;
char *wm_class;
unsigned long size;

	wm_class = x11_get_property(disp, win, XA_STRING, "WM_CLASS", &size);
	if(wm_class)
	{
		char *p_0 = strchr(wm_class, '\0');
		if(wm_class + size - 1 > p_0)
		{
			*(p_0) = '.';
		}
		class_utf8 = strdup(wm_class);
	}
	else
	{
		class_utf8 = NULL;
	}
	free(wm_class);
	return class_utf8;
}

static Window *x11_get_client_list(Display *disp, unsigned long *size)
{
	Window *client_list;

	if((client_list = (Window *)x11_get_property(disp, DefaultRootWindow(disp), XA_WINDOW, "_NET_CLIENT_LIST", size)) == NULL)
	{
		if((client_list = (Window *)x11_get_property(disp, DefaultRootWindow(disp), XA_CARDINAL, "_WIN_CLIENT_LIST", size)) == NULL)
		{
			fputs("Cannot get client list properties. \n" "(_NET_CLIENT_LIST or _WIN_CLIENT_LIST)" "\n", stderr);
			return NULL;
		}
	}
	return client_list;
}

static char *x11_get_window_title(Display *disp, Window win)
{
char *title_utf8;
char *wm_name;
char *net_wm_name;

	wm_name = x11_get_property(disp, win, XA_STRING, "WM_NAME", NULL);
	net_wm_name = x11_get_property(disp, win, XInternAtom(disp, "UTF8_STRING", False), "_NET_WM_NAME", NULL);
	if(net_wm_name)
	{
		title_utf8 = (char *)strdup((char *)net_wm_name);
		free(net_wm_name);
	}
	else
	{
		if(wm_name)
		{
			title_utf8 = (char *)strdup((char *)wm_name);
		}
		else
		{
			title_utf8 = NULL;
		}
		free(wm_name);
	}
	return(title_utf8);
}

int	x11_iterate_windows2(Display *disp, char **window_list)
{
Window *client_list;
unsigned long client_list_size;
int i;
int max_client_machine_len = 0;
	
	if((client_list = x11_get_client_list(disp, &client_list_size)) == NULL)
	{
		return EXIT_FAILURE;
	}
	// find the longest client_machine name
	for(i = 0; i < client_list_size / sizeof(Window); i++)
	{
		char *client_machine;
		if((client_machine = x11_get_property(disp, client_list[i], XA_STRING, "WM_CLIENT_MACHINE", NULL)))
		{
			max_client_machine_len = strlen((char *)client_machine);	
		}
		free(client_machine);
	}
	// print the list
	int cnt = 0;
	for(i = 0; i < client_list_size / sizeof(Window); i++)
	{
		char *title_utf8 = x11_get_window_title(disp, client_list[i]);
		char *title_out = strdup(title_utf8);
		char *client_machine;
		char *class_out = x11_get_window_class(disp, client_list[i]);
		unsigned long *pid;
		unsigned long *desktop;
		int x, y, junkx, junky;
		unsigned int wwidth, wheight, bw, depth;
		Window junkroot;

		// desktop ID
		if((desktop = (unsigned long *)x11_get_property(disp, client_list[i], XA_CARDINAL, "_NET_WM_DESKTOP", NULL)) == NULL)
		{
			desktop = (unsigned long *)x11_get_property(disp, client_list[i], XA_CARDINAL, "_WIN_WORKSPACE", NULL);
		}
		// client machine
		client_machine = x11_get_property(disp, client_list[i], XA_STRING, "WM_CLIENT_MACHINE", NULL);
	
		// pid
		pid = (unsigned long *)x11_get_property(disp, client_list[i], XA_CARDINAL, "_NET_WM_PID", NULL);

		// geometry
		XGetGeometry(disp, client_list[i], &junkroot, &junkx, &junky, &wwidth, &wheight, &bw, &depth);
		XTranslateCoordinates(disp, client_list[i], junkroot, junkx, junky, &x, &y, &junkroot);
	
		// special desktop ID -1 means "all desktops", so we have to convert the desktop value to signed long
		// printf("0x%.8lx %2ld", client_list[i], desktop ? (signed long)*desktop : 0);
		// printf(" %*s %s\n", max_client_machine_len, client_machine ? client_machine : "N/A", title_out ? title_out : "N/A");
		// printf("%d %d %d %d\n", x, y, wwidth, wheight);

		char buf[4096];
		sprintf(buf, "%lu::%s", client_list[i], title_out ? title_out : "N/A");
		window_list[cnt] = strdup(buf);
		cnt++;

		free(title_utf8);
		free(title_out);
		free(desktop);
		free(client_machine);
		free(class_out);
		free(pid);
	}
	free(client_list);
	return(cnt);
}

void	x11_iterate_windows(Display *display, Window rootWindow, int depth)
{
Window parent;
Window *children;
Window *child;
unsigned int nNumChildren;
XTextProperty wmName;
XTextProperty wmCommand;

	int status = XGetWMName(display, rootWindow, &wmName);
	if(status && wmName.value && wmName.nitems)
	{
		int i;
		char **list;
		status = XmbTextPropertyToTextList(display, &wmName, &list, &i);
		if(status >= Success && i && *list)
		{
			if(depth == 1)
			{
				printf("%d NAME: [%s]\n", depth, (char *)*list);
			}
		}
	}
	status = XQueryTree(display, rootWindow, &rootWindow, &parent, &children, &nNumChildren);
	if(status == 0)
	{
		// Could not query window tree further, aborting
		return;
	}
	if(nNumChildren == 0)
	{
		// No more children found. Aborting
		return;
	}
	for(int i = 0; i < nNumChildren; i++)
	{
		x11_iterate_windows(display, children[i], depth + 1);
	}
	XFree((char*) children);
}

long int	x11_find_window_by_name(char *name)
{
int		loop;
char	*window_list[128];

	long int rr = 0;
	int cnt = x11_iterate_windows2(fl_display, window_list);
	if(cnt > 0)
	{
		for(loop = 0;loop < cnt;loop++)
		{
			unsigned long int window_id = (unsigned long int)atol(window_list[loop]);
			char *cp = window_list[loop];
			while((*cp != '\0') && (*cp != ':')) cp++;
			while((*cp != '\0') && (*cp == ':')) cp++;
			if(strcmp(cp, name) == 0)
			{
				rr = window_id;
			}
		}	
		for(loop = 0;loop < cnt;loop++)
		{
			free(window_list[loop]);
		}
	}
	return(rr);
}

static void map_busy_key(char *final)
{
int i;
unsigned char keymap[32];
unsigned char my_keymap[0xffff];
unsigned int state = 0;
int cap_lock = 0;
int num_lock = 0;

	strcpy(final, "");
	static unsigned int masktable[8] = {
		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
	};
	for(i = 0;i < 0xffff;i++)
	{
		my_keymap[i] = 0;
	}
	XkbGetIndicatorState (fl_display, XkbUseCoreKbd, &state);
	if((state & 1) == 1) cap_lock = 1;
	if((state & 2) == 2) num_lock = 1;

	XQueryKeymap(fl_display, (char *)keymap);
	int shifted = 0;
	int controlled = 0;
	int alted = 0;
	unsigned char cc = 0;
	for(i = 0; i < 256; i++) 
	{
		if(keymap[i >> 3] & masktable[i & 7]) 
		{
			KeySym ks = XkbKeycodeToKeysym(fl_display, (KeyCode)i, 0, 0);
			my_keymap[ks] = 1;
			char *cp = XKeysymToString(ks);
			if(cp != NULL)
			{
				if(strlen(cp) == 1)
				{
					cc = *cp;
				}
				else
				{
					if(((my_keymap[0xffe1] != 1) && (my_keymap[0xffe2] != 1))
					&& ((my_keymap[0xffe3] != 1) && (my_keymap[0xffe4] != 1))
					&& ((my_keymap[0xffe9] != 1) && (my_keymap[0xffea] != 1)))
					{
						strcpy(final, cp);
					}
					if(ks == 0x60) cc = '`';
					if(ks == 0x2d) cc = '-';
					if(ks == 0x3d) cc = '=';
					if(ks == 0x5b) cc = '[';
					if(ks == 0x5d) cc = ']';
					if(ks == 0x5c) cc = '\\';
					if(ks == 0x3b) cc = ';';
					if(ks == 0x27) cc = '\'';
					if(ks == 0x2c) cc = ',';
					if(ks == 0x2e) cc = '.';
					if(ks == 0x2f) cc = '/';
				}
			}
		}
	}
	// Timeouts provided for CAPS_LOCK and NUM_LOCK
	// so they won't toggle just because the user
	// lingers on the key.
	char *shift_str = "";
	char *ctrl_str = "";
	char *alt_str = "";
	if((my_keymap[0xffe1] == 1) || (my_keymap[0xffe2] == 1) || (cap_lock > 0))
	{
		shift_str = "SHIFT-";
		if((cc >= 'a') && (cc <= 'z'))
		{
			cc -= 32;
		}
		if((my_keymap[0xffe1] == 1) || (my_keymap[0xffe2] == 1))
		{
			if(cc == '`') cc = '~';
			else if(cc == '1') cc = '!';
			else if(cc == '2') cc = '@';
			else if(cc == '3') cc = '#';
			else if(cc == '4') cc = '$';
			else if(cc == '5') cc = '%';
			else if(cc == '6') cc = '^';
			else if(cc == '7') cc = '&';
			else if(cc == '8') cc = '*';
			else if(cc == '9') cc = '(';
			else if(cc == '0') cc = ')';
			else if(cc == '-') cc = '_';
			else if(cc == '=') cc = '+';
			else if(cc == '[') cc = '{';
			else if(cc == ']') cc = '}';
			else if(cc == '\\') cc = '|';
			else if(cc == ';') cc = ':';
			else if(cc == '\'') cc = '"';
			else if(cc == ',') cc = '<';
			else if(cc == '.') cc = '>';
			else if(cc == '/') cc = '?';
		}
	}
	if(num_lock > 0)
	{
		if(my_keymap[0xff95] == 1) cc = '7';
		if(my_keymap[0xff97] == 1) cc = '8';
		if(my_keymap[0xff9a] == 1) cc = '9';
		if(my_keymap[0xff96] == 1) cc = '4';
		if(my_keymap[0xff9d] == 1) cc = '5';
		if(my_keymap[0xff98] == 1) cc = '6';
		if(my_keymap[0xff9c] == 1) cc = '1';
		if(my_keymap[0xff99] == 1) cc = '2';
		if(my_keymap[0xff9b] == 1) cc = '3';
		if(my_keymap[0xff9e] == 1) cc = '0';
		if(my_keymap[0xff9f] == 1) cc = '.';
	}
	if((my_keymap[0xffe3] == 1) || (my_keymap[0xffe4] == 1))
	{
		ctrl_str = "CTRL-";
	}
	if((my_keymap[0xffe9] == 1) || (my_keymap[0xffea] == 1))
	{
		alt_str = "ALT-";
	}
	if(cc > 0)
	{
		sprintf(final, "%s%s%s%c", shift_str, ctrl_str, alt_str, cc);
	}
}

void	access_frame(unsigned char *frame, int x, int y, int ww, int hh, int dd, unsigned char *red, unsigned char *green, unsigned char *blue)
{
	int nn = (y * ww * dd) + (x * dd);
	if(frame != NULL)
	{
		unsigned char *ptr = frame + nn;
		if(dd == 3)
		{
			*red = *ptr;
			*green = *ptr + 1;
			*blue = *ptr + 2;
		}
		else
		{
			*red = *ptr;
		}
	}
}

void	fix_alpha(unsigned char *image, int ww, int hh)
{
int	x, y;

	unsigned char *p = image;
	for(x = 0;x < ww;x++)
	{
		for(y = 0;y < hh;y++)
		{
			unsigned char r = *p;
			unsigned char g = *(p + 1);
			unsigned char b = *(p + 2);
			unsigned char a = *(p + 3);
			int avg = (int)((int)r + (int)g + (int)b) / 3;
			if((r == 0) && (g == 0) && (b == 0))
			{
				*(p + 3) = 0;
			}
			p += 4;
		}
	}
}

char	*parse_triplet(char *cp, int *red, int *green, int *blue)
{
	*red = atoi(cp);
	while((*cp != '\0') && (*cp != ','))
	{
		cp++;
	}
	if(*cp == ',')
	{
		cp++;
		*green = atoi(cp);
		while((*cp != '\0') && (*cp != ','))
		{
			cp++;
		}
		if(*cp == ',')
		{
			cp++;
			*blue = atoi(cp);
		}
	}
	return(cp);
}

char	*parse_quadlet(char *cp, int *sx, int *sy, int *ex, int *ey)
{
	*sx = atoi(cp);
	while((*cp != '\0') && (*cp != ','))
	{
		cp++;
	}
	if(*cp == ',')
	{
		cp++;
		*sy = atoi(cp);
		while((*cp != '\0') && (*cp != ','))
		{
			cp++;
		}
		if(*cp == ',')
		{
			cp++;
			*ex = atoi(cp);
			while((*cp != '\0') && (*cp != ','))
			{
				cp++;
			}
			if(*cp == ',')
			{
				cp++;
				*ey = atoi(cp);
			}
		}
	}
	return(cp);
}

char	*parse_doublet(char *cp, int *red, int *green)
{
	*red = atoi(cp);
	while((*cp != '\0') && (*cp != ','))
	{
		cp++;
	}
	if(*cp == ',')
	{
		cp++;
		*green = atoi(cp);
	}
	return(cp);
}

void	draw_text(const char *str, int length, int sx, int sy)
{
char buf[2];
char local[4096];

	int xx = sx;
	int yy = sy;
	strncpy(local, str, 4096);
	char *cp = local;
	int done = 0;
	int extent_y = 0;
	while(done == 0)
	{
		buf[0] = *cp;
		buf[1] = '\0';
		if(*cp == '\0')
		{
			done = 1;
		}
		else if(*cp == '\\')
		{
			char *remember = cp;
			int met = 0;
			cp++;
			if(*cp == 'c')
			{
				cp++;
				if(*cp == '[')
				{
					cp++;
					int red = -1;
					int green = -1;
					int blue = -1;
					cp = parse_triplet(cp, &red, &green, &blue);
					while((*cp != '\0') && (*cp != ']'))
					{
						cp++;
					}
					if(*cp == ']')
					{
						if((red > -1) && (green > -1) && (blue > -1))
						{
							fl_color(fl_rgb_color(red, green, blue));
						}
						met = 1;
					}
				}
				else if((*cp >= '0') && (*cp <= '9'))
				{
					int color = atoi(cp);
					if((color > -1) && (color < 256))
					{
						while((*cp != '\0') && (*cp >= '0') && (*cp <= '9'))
						{
							cp++;
						}
						fl_color(color);
						met = 1;
						cp--;
					}
				}
			}
			else if(*cp == 'p')
			{
				cp++;
				if(*cp == '[')
				{
					cp++;
					int x_pos = -1;
					int y_pos = -1;
					cp = parse_doublet(cp, &x_pos, &y_pos);
					while((*cp != '\0') && (*cp != ']'))
					{
						cp++;
					}
					if(*cp == ']')
					{
						if((x_pos > -1) && (y_pos > -1))
						{
							xx = x_pos;
							yy = y_pos;
						}
						met = 1;
					}
				}
			}
			else if(*cp == 's')
			{
				cp++;
				if((*cp >= '0') && (*cp <= '9'))
				{
					int sz = atoi(cp);
					if((sz > -1) && (sz < 256))
					{
						while((*cp != '\0') && (*cp >= '0') && (*cp <= '9'))
						{
							cp++;
						}
						fl_font(fl_font(), sz);
						met = 1;
						cp--;
					}
				}
			}
			else if(*cp == 'f')
			{
				cp++;
				if((*cp >= '0') && (*cp <= '9'))
				{
					int face = atoi(cp);
					int limit = 256;
					if(global_window != NULL)
					{
						limit = global_window->number_of_fonts;
					}
					if((face > -1) && (face < limit))
					{
						while((*cp != '\0') && (*cp >= '0') && (*cp <= '9'))
						{
							cp++;
						}
						fl_font(face, fl_size());
						met = 1;
						cp--;
					}
				}
			}
			else if(*cp == 'i')
			{
				cp++;
				if(*cp == '[')
				{
					cp++;
					char filename[4096];
					strncpy(filename, cp, 4096);
					char *cp2 = filename;
					while((*cp2 != '\0') && (*cp2 != ']'))
					{
						cp2++;
						cp++;
					}
					if(*cp2 == ']')
					{
						*cp2 = '\0';
						Fl_Shared_Image *a = Fl_Shared_Image::get(filename);
						if(a != NULL)
						{
							buf[0] = 'g';
							int lx = 0;
							int ly = 0;
							fl_measure(buf, lx, ly);
							a->draw(xx, yy - ly, a->w(), a->h(), 0, 0);
							xx += a->w();
							if(a->h() > extent_y) extent_y = a->h();
							met = 1;
						}
					}
				}
			}
			else if((*cp == 'n') || (*cp == 'r'))
			{
				buf[0] = 'g';
				int lx = 0;
				int ly = 0;
				fl_measure(buf, lx, ly);
				if(ly > extent_y) extent_y = ly;
				yy += extent_y;
				xx = sx;
				met = 1;
			}
			else if(*cp == 't')
			{
				int ok = 0;
				buf[0] = 'M';
				int lx = 0;
				int ly = 0;
				fl_measure(buf, lx, ly);
				if(lx > 0)
				{
					for(int loop = 0;((ok == 0) && (loop < 4096));loop += (lx * 4))
					{
						if(loop > xx)
						{
							ok = loop;
							xx = loop;
						}
					}
				}
				met = 1;
			}
			if(met == 0)
			{
				int lx = 0;
				int ly = 0;
				fl_measure(buf, lx, ly);
				fl_draw(buf, 1, xx, yy);
				xx += lx;
				cp = remember;
			}
		}
		else if((*cp == 10) || (*cp == 13))
		{
			buf[0] = 'g';
			int lx = 0;
			int ly = 0;
			fl_measure(buf, lx, ly);
			if(ly > extent_y) extent_y = ly;
			yy += extent_y;
		}
		else
		{
			int lx = 0;
			int ly = 0;
			fl_measure(buf, lx, ly);
			fl_draw(buf, 1, xx, yy);
			if(ly > extent_y) extent_y = ly;
			xx += lx;
		}
		cp++;
	}
}

int	read_single_frame_file(int *flag)
{
	Camera *cam = (Camera *)flag;
	if(cam->single_frame_fd != -1)
	{
		while(cam->pipe_done == 0)
		{
			int fd = cam->single_frame_fd;
			int ready = 0;
			int cols = 0;
			int rows = 0;
			int depth = 0;
			lseek(fd, SEEK_SET, 0);
			read(fd, &ready, sizeof(int));
			if(ready == 1)
			{
				read(fd, &cols, sizeof(int));
				read(fd, &rows, sizeof(int));
				read(fd, &depth, sizeof(int));
				if((cols > 0) && (rows > 0) && (depth > 0))
				{
					int nn = cols * rows * depth;
					if(depth == 4)
					{
						cv::Mat local_mat(rows, cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
						if(read(fd, local_mat.ptr(), nn) == nn)
						{
							cam->mat = local_mat.clone();
						}
					}
					else if(depth == 3)
					{
						cv::Mat local_mat(rows, cols, CV_8UC3, cv::Scalar(0, 0, 0));
						if(read(fd, local_mat.ptr(), nn) == nn)
						{
							cvtColor(local_mat, local_mat, COLOR_RGB2RGBA);
							cam->mat = local_mat.clone();
						}
					}
				}
				lseek(fd, SEEK_SET, 0);
				ready = 0;
				write(fd, &ready, sizeof(int));
			}
			else
			{
				usleep(10000);
			}
		}
	}
	return(0);
}

int	thread_read_camera(int *flag)
{
	Camera *cam = (Camera *)flag;
	if(cam != NULL)
	{
		cam->CaptureLoop();
	}
	return(0);
}

int	play_audio_thread(int *flag)
{
int	loop;

	struct AudioInfo *audio_info = (AudioInfo *)flag;
	if(audio_info != NULL)
	{
		if(audio_info->wav != NULL)
		{
			int error = 0;
			if(audio_info->my_window != NULL)
			{
				if(audio_info->my_window->pulse_mixer != NULL)
				{
					PulseMixer *mixer = audio_info->my_window->pulse_mixer;
					int cnt = mixer->monitor_cnt;
					if(mixer->pa_monitor[cnt] != NULL)
					{
						if(audio_info->my_window->audio_direct_mix == 1)
						{
							if(audio_info->sample_rate == audio_info->my_window->audio_sample_rate)
							{
								mixer->MixSupplemental(cnt, audio_info->wav, audio_info->number_of_samples, audio_info->channels);
							}
						}
						if(mixer->pa_monitor[cnt]->stream != NULL)
						{
							mixer->pa_monitor[cnt]->stop = 0;
							for(loop = 0;loop < audio_info->number_of_samples * audio_info->channels;loop++)
							{
								SAMPLE nn = audio_info->wav[loop];
								SAMPLE val = (SAMPLE)((double)nn * mixer->my_window->audio_incidental_volume);
								audio_info->wav[loop] = val;
							}
							int adv_nn = 1024 * audio_info->channels;
							for(loop = 0;((loop < audio_info->number_of_samples * audio_info->channels) && (global_audio_sudden_stop == 0));loop += adv_nn)
							{
								int diff = (audio_info->number_of_samples * audio_info->channels) - loop;
								int amount = adv_nn;
								if(diff < adv_nn)
								{
									amount = diff;
								}
								if((mixer->pa_monitor[cnt]->stop == 0) && (amount > 0))
								{
									mixer->my_window->active_audio_playback = 1;
									int n = pa_simple_write(mixer->pa_monitor[cnt]->stream, &audio_info->wav[loop], amount * sizeof(SAMPLE), &error);
								}
								while((mixer->pa_monitor[cnt]->mini_pause == 1) && (mixer->pa_monitor[cnt]->stop == 0))
								{
									sleep(1);
								}
							}
						}
						mixer->monitor_cnt++;
						if(mixer->monitor_cnt >= 10)
						{
							mixer->monitor_cnt = 1;
						}
					}
					mixer->my_window->active_audio_playback = 0;
				}
			}
		}
		delete audio_info;
	}
	return(0);
}

int	read_pipe(int *flag)
{
char	buf[1024];

	Camera *cam = (Camera *)flag;
	while(cam->list_length < 1)
	{
		sleep(1);
	}
	while(cam->pipe_done == 0)
	{
		if(fgets(buf, 1024, cam->pipe_fp))
		{
			strip_lf(buf);
			cam->ScrollTextList(buf);
			cam->static_initialized = 0;
		}
		else
		{
			cam->pipe_done = -1;
		}
	}
	if(cam->pipe_done == 1)
	{
		kill(cam->pipe_pid, SIGTERM);
	}
	close(cam->pipe_in);
	fclose(cam->pipe_fp);
	return(0);
}

int	run_irc(int *flag)
{
int	cow_irc_run(irc_session_t *s, char *in_buffer);

	Camera *cam = (Camera *)flag;
	cam->irc_done = 0;
	cow_irc_run(cam->irc_session, cam->irc_buffer);
	return(0);
}

int	read_irc(int *flag)
{
	Camera *cam = (Camera *)flag;
	irc_ctx_t *ctx = (irc_ctx_t *)irc_get_ctx(cam->irc_session);
	while(cam->irc_done == 0)
	{
		while(ctx->flag == 0)
		{
			usleep(100000);
		}
		if(ctx->flag == 1)
		{
			cam->ScrollTextList(ctx->use_buffer);
			ctx->flag = 0;
		}
	}
	return(0);
}

int	osg_walk_tree(osg::Group *start, int limit, int total, osg::Node **list)
{
int	loop;

	std::string str = start->getName();
	if(str.c_str() != NULL)
	{
		if(total < (limit - 1))
		{
			list[total] = start;
			total++;
		}
	}
	int nn = start->getNumChildren();
	for(loop = 0;loop < nn;loop++)
	{
		osg::Node *nd = start->getChild(loop);
		osg::Group *grp = nd->asGroup();
		if(grp != NULL)
		{
			total = osg_walk_tree(grp, limit, total, list);
		}
	}
	return(total);
}

void	blend_two(Mat one, Mat two, int xx, int yy, double alpha)
{
int	row, col;

	if(alpha < 1.0)
	{
		double beta = (1.0 - alpha);
		for(row = 0;row < two.rows;row++)
		{
			for(col = 0;col < two.cols;col++)
			{
				unsigned char *color1 = one.ptr(row + yy, col + xx);
				unsigned char *color2 = two.ptr(row, col);

				double r1 = (double)color1[0] * beta;
				double g1 = (double)color1[1] * beta;
				double b1 = (double)color1[2] * beta;

				double r2 = (double)color2[0] * alpha;
				double g2 = (double)color2[1] * alpha;
				double b2 = (double)color2[2] * alpha;

				color2[0] = r1 + r2;
				color2[1] = g1 + g2;
				color2[2] = b1 + b2;
			}
		}
	}
}

void	cairo_draw_line(BLContext ctx, double x0, double y0, double x1, double y1)
{
	double x{x1 - x0}, y{y1 - y0};
	double max{ std::max(std::fabs(x), std::fabs(y)) };
	x /= max; y /= max;
	int cnt = 0;
	for(double n{0}; n < max; ++n)
	{
		int ww = 4;
		int hh = 10;
		x0 += x; y0 += y;
		if((cnt % 20) == 0)
		{
			if(abs(x) > abs(y))
			{
				ww = 10;
				hh = 4;
			}
			ctx.fillRect(x0, y0, ww, hh);
		}
		cnt++;
	}
}

void	edge_detect_with_blend(Mat& mat, double blend)
{
void				blend_two(Mat one, Mat two, int xx, int yy, double alpha);
std::vector<Mat>	channels;
Mat					contours;
Mat					gray_image;
Mat					hsv;
Mat					out;

	cvtColor(mat, hsv, COLOR_RGB2HSV);
	split(hsv, channels);
	gray_image = channels[0];

	Mat detected_edges;
	blur(mat, detected_edges, Size(3, 3));
	cv::Canny(detected_edges, contours, 35, 90);

	Mat rgb[4] = {contours, contours, contours, contours};
	merge(rgb, 4, out);

	blend_two(mat, out, 0, 0, blend);
	mat = out.clone();
}

void	edge_detect(Mat& mat, int blur_radius, int low, int high, double blend)
{
void				blend_two(Mat one, Mat two, int xx, int yy, double alpha);
std::vector<Mat>	channels;
Mat					contours;
Mat					gray_image;
Mat					hsv;
Mat					out;

	cvtColor(mat, hsv, COLOR_RGB2HSV);
	split(hsv, channels);
	gray_image = channels[0];

	Mat detected_edges;
	if(blur_radius < 1) blur_radius = 1;
	blur(mat, detected_edges, Size(blur_radius, blur_radius));
	cv::Canny(detected_edges, contours, low, high);

	Mat rgb[4] = {contours, contours, contours, contours};
	merge(rgb, 4, out);

	blend_two(mat, out, 0, 0, blend);
	mat = out.clone();
}

void	get_v4l_card_name(char *path, char *card_name)
{
struct v4l2_capability  capability;

	if((path != NULL) && (card_name != NULL))
	{
		strcpy(card_name, "");
		int fd = open(path, O_RDONLY);
		if(fd > -1)
		{
			memset(&capability, 0, sizeof(capability));
			int nn = ioctl(fd, VIDIOC_QUERYCAP, &capability);
			if(nn != -1)
			{
				if((capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) == V4L2_CAP_VIDEO_CAPTURE)
				{
					int done = 0;
					int i = 0;
					int go = 0;
					while(done == 0)
					{
						struct v4l2_fmtdesc fmtdesc;
						memset(&fmtdesc, 0, sizeof(fmtdesc));
						fmtdesc.index = i;
						fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
						if(ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc) != -1)
						{
							go = 1;
						}
						else
						{
							done = 1;
						}
						i++;
					}
					if(go == 1)
					{
						strcpy(card_name, (char *)capability.card);
					}
				}
			}
			close(fd);
		}
	}
}

int	get_v4l_formats(char *path, int *format, char **format_desc)
{
struct v4l2_capability  capability;

	int cnt = 0;
	if((path != NULL) && (format != NULL))
	{
		int fd = open(path, O_RDONLY);
		if(fd > -1)
		{
			memset(&capability, 0, sizeof(capability));
			int nn = ioctl(fd, VIDIOC_QUERYCAP, &capability);
			if(nn != -1)
			{
				if((capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) == V4L2_CAP_VIDEO_CAPTURE)
				{
					int done = 0;
					int i = 0;
					while(done == 0)
					{
						struct v4l2_fmtdesc fmtdesc;
						memset(&fmtdesc, 0, sizeof(fmtdesc));
						fmtdesc.index = i;
						fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
						if(ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc) != -1)
						{
							format[cnt] = fmtdesc.pixelformat;
							format_desc[cnt] = strdup((char *)fmtdesc.description);
							cnt++;
						}
						else
						{
							done = 1;
						}
						i++;
					}
				}
			}
			close(fd);
		}
	}
	return(cnt);
}

void	draw_arrow(int x1, int y1, int x2, int y2, int head_length, int head_width)
{
int	ax[3];
int	ay[3];

	double dx = (x1 - x2);
	double dy = (y1 - y2);
	double length = std::sqrt((dx * dx) + (dy * dy));
	if((head_length < 1) || (length < head_length)) return;

	// ux,uy is a unit vector parallel to the line.
	double ux = dx / length;
	double uy = dy / length;

	// vx,vy is a unit vector perpendicular to ux,uy
	double vx = -uy;
	double vy = ux;

	double half_width = 0.5 * head_width;
	ax[0] = round(x1 + (half_width * ux));
	ay[0] = round(y1 + (half_width * uy));
	ax[1] = round(x1 - (head_length * ux) + (half_width * vx));
	ay[1] = round(y1 - (head_length * uy) + (half_width * vy));
	ax[2] = round(x1 - (head_length * ux) - (half_width * vx));
	ay[2] = round(y1 - (head_length * uy) - (half_width * vy));
	fl_begin_polygon();
	fl_vertex(ax[0], ay[0]);
	fl_vertex(ax[1], ay[1]);
	fl_vertex(ax[2], ay[2]);
	fl_end_polygon();
}

void	my_cairo_draw_arrow(cairo_t *context, int x1, int y1, int x2, int y2, int head_length, int head_width)
{
int	ax[3];
int	ay[3];

	double dx = (x1 - x2);
	double dy = (y1 - y2);
	double length = std::sqrt((dx * dx) + (dy * dy));
	if((head_length < 1) || (length < head_length)) return;

	// ux,uy is a unit vector parallel to the line.
	double ux = dx / length;
	double uy = dy / length;

	// vx,vy is a unit vector perpendicular to ux,uy
	double vx = -uy;
	double vy = ux;

	double half_width = 0.5 * head_width;
	ax[0] = round(x1 + (half_width * ux));
	ay[0] = round(y1 + (half_width * uy));
	ax[1] = round(x1 - (head_length * ux) + (half_width * vx));
	ay[1] = round(y1 - (head_length * uy) + (half_width * vy));
	ax[2] = round(x1 - (head_length * ux) - (half_width * vx));
	ay[2] = round(y1 - (head_length * uy) - (half_width * vy));

	cairo_move_to(context, ax[0], ay[0]);
	cairo_line_to(context, ax[1], ay[1]);
	cairo_line_to(context, ax[2], ay[2]);
	cairo_fill(context);
}

void	draw_clock(Camera *cam, int in_hr, int in_min, int in_sec, int xx, int yy, int in_w, int in_h, int fr, int fg, int fb, int fa, int br, int bg, int bb, int ba)
{
int		i;
int		Inset;
int		Hours;
int		Minutes;
int		Seconds;
double	Radius;
double	xCenter;
double	yCenter;

	if(in_hr == -1) 
	{
		time_t now = time(0);
		struct tm *tm = localtime(&now);
		Hours = tm->tm_hour;
		Minutes = tm->tm_min;
		Seconds = tm->tm_sec;
	}
	else
	{
		Hours = in_hr;
		Minutes = in_min;
		Seconds = in_sec;
	}
	xCenter = (in_w / 2) + xx;
	yCenter = (in_h / 2) + yy;

	if(xCenter < yCenter)
	{
		Radius = (in_w / 2) - 5;
	}
	else
	{
		Radius = (in_h / 2) - 5;
	}
	double dfr = (1.0 / 255.0) * (double)fr;
	double dfg = (1.0 / 255.0) * (double)fg;
	double dfb = (1.0 / 255.0) * (double)fb;
	double dfa = (1.0 / 255.0) * (double)fa;
	double dbr = (1.0 / 255.0) * (double)br;
	double dbg = (1.0 / 255.0) * (double)bg;
	double dbb = (1.0 / 255.0) * (double)bb;
	double dba = (1.0 / 255.0) * (double)ba;

	cairo_set_line_width(cam->cairo_context, 2);
	cairo_arc(cam->cairo_context, xCenter, yCenter, Radius, 0, 2 * M_PI);
	cairo_set_source_rgba(cam->cairo_context, dbb, dbg, dbr, dba);
	cairo_fill_preserve(cam->cairo_context);
	cairo_set_source_rgba(cam->cairo_context, dfb, dfg, dfr, dfa);
	cairo_stroke(cam->cairo_context);

	for(i = 0;i < 12;i++)
	{
		if((i % 3) == 0)
		{
			Inset = 0.2 * Radius;
		}
		else
		{
			Inset = 0.1 * Radius;
		}
		cairo_move_to(cam->cairo_context, xCenter + (Radius - Inset) * cos(i * M_PI / 6), yCenter + (Radius - Inset) * sin(i * M_PI / 6));
		cairo_line_to(cam->cairo_context, xCenter + Radius * cos(i * M_PI / 6), yCenter + Radius * sin(i * M_PI / 6));
		cairo_stroke(cam->cairo_context);
	}
	cairo_save(cam->cairo_context);
	cairo_set_line_width(cam->cairo_context, 3);
	cairo_move_to(cam->cairo_context, xCenter, yCenter);
	cairo_line_to(cam->cairo_context, xCenter + Radius * 0.75 * sin(M_PI / 6 * Hours + M_PI / 360 * Minutes), yCenter + Radius / 2 * -cos(M_PI / 6 * Hours + M_PI / 360 * Minutes));
	cairo_stroke(cam->cairo_context);

	cairo_set_line_width(cam->cairo_context, 2);
	cairo_move_to (cam->cairo_context, xCenter, yCenter);
	cairo_line_to (cam->cairo_context, xCenter + Radius * 0.85 * sin(M_PI / 30 * Minutes), yCenter + Radius * 0.7 * -cos(M_PI / 30 * Minutes));
	cairo_stroke (cam->cairo_context);

	cairo_save(cam->cairo_context);
	cairo_set_line_width(cam->cairo_context, 1);
	cairo_move_to (cam->cairo_context, xCenter, yCenter);
	cairo_line_to (cam->cairo_context, xCenter + Radius * 0.98 * sin(M_PI / 30 * Seconds), yCenter + Radius * 0.75 * -cos(M_PI / 30 * Seconds));
	cairo_stroke (cam->cairo_context);

	cairo_restore(cam->cairo_context);
}

unsigned char *grab_raw_desktop_image()
{
unsigned char	*fl_read_image(unsigned char *, int, int, int, int, int = 0);

	unsigned char *r_data = NULL;
	int start_x = 0;
	int start_y = 0;
	int start_w = Fl::w();
	int start_h = Fl::h();
	Window xwin = RootWindow(fl_display, fl_screen);

	int use_x = 0;
	int use_y = 0;
	int my_depth = 4;

	fl_window = xwin;
	unsigned char *b = fl_read_image((unsigned char *)NULL, use_x, use_y, start_w, start_h, 0);
	r_data = b;
	return(r_data);
}

void	convert_fourcc(int fourcc, char &c1, char &c2, char &c3, char &c4)
{
	c1 = fourcc & 255;
	c2 = (fourcc >> 8) & 255;
	c3 = (fourcc >> 16) & 255;
	c4 = (fourcc >> 24) & 255;
}

int	get_title_bar_height(Fl_Window *win)
{
Atom			t;
int				f;
unsigned long	n, b;
unsigned char	*data = 0;
XEvent			e;
long			*extents;

	Atom a = XInternAtom(fl_display, "_NET_FRAME_EXTENTS", True);
	while(XGetWindowProperty(fl_display, fl_xid(win), a, 0, 4, False, AnyPropertyType, &t, &f, &n, &b, &data) != Success || n != 4 || b != 0)
	{
		XNextEvent(fl_display, &e);
	}
	extents = (long *)data;
	int hh = (int)extents[2];
	return(hh);
}

void	invert_mat(Mat one)
{
int	row, col;

	for(row = 0;row < one.rows;row++)
	{
		for(col = 0;col < one.cols;col++)
		{
			unsigned char *color1 = one.ptr(row, col);

			unsigned char r1 = (double)color1[0];
			unsigned char g1 = (double)color1[1];
			unsigned char b1 = (double)color1[2];

			color1[0] = 255 - r1;
			color1[1] = 255 - g1;
			color1[2] = 255 - b1;
		}
	}
}

void	chromakey2(Mat& src, Mat& img, Mat& result, double a1, double a2)
{
	Size S = Size((int)src.cols, (int)src.rows);

	src.convertTo(src, CV_32FC3, 1.0 / 255);
	img.convertTo(img, CV_32FC3, 1.0 / 255);

	Mat res_front, res_back, res;
	vector<Mat> channels, img_channels;

	Mat alpha = Mat::zeros(S, CV_32F);
	split(src, channels);
	split(img, img_channels);

	alpha = Scalar::all(1.0) - a1 * (channels[1] - a2 * channels[0]);
 
	threshold(alpha, alpha, 1, 1, THRESH_TRUNC);
	threshold(-1 * alpha, alpha, 0, 0, THRESH_TRUNC);
	alpha = -1 * alpha;

	for(int i = 0;i < 3; ++i) 
	{
		multiply(alpha, channels[i], channels[i]);
		multiply(Scalar::all(1.0) - alpha, img_channels[i], img_channels[i]);  
	}
	merge(channels, res_front);
	merge(img_channels, res_back);

	res = res_front + res_back;
	res.convertTo(res, CV_8UC4, 255);

	result = res.clone();
}

void	chromakey(Mat& src, Mat& result, int use_color, double a1, double a2)
{
	Size S = Size((int)src.cols, (int)src.rows);

	src.convertTo(src, CV_32FC4, 1.0 / 255);

	Mat res;
	vector<Mat> channels, img_channels;

	Mat alpha = Mat::zeros(S, CV_32F);
	split(src, channels);

	if(use_color == CHROMA_ON_GREEN)
	{
		alpha = Scalar::all(1.0) - a1 * (channels[1] - a2 * channels[0]);
	}
	else if(use_color == CHROMA_ON_BLUE)
	{
		alpha = Scalar::all(1.0) - a1 * (channels[2] - a2 * channels[0]);
	}
	threshold(alpha, alpha, 1, 1, THRESH_TRUNC);
	threshold(-1 * alpha, alpha, 0, 0, THRESH_TRUNC);
	alpha = -1 * alpha;

	for(int i = 0;i < 3; ++i) 
	{
		multiply(alpha, channels[i], channels[i]);
	}
	Mat rgb[4] = {channels[0], channels[1], channels[2], alpha};
	merge(rgb, 4, res);

	res.convertTo(res, CV_8UC4, 255);

	result = res.clone();
}

// SECTION *********************************** RESIZEFRAME *******************************************

ResizeFrame::ResizeFrame(MyWin *win, int xx, int yy, int ww, int hh) : DragGroup(xx, yy, ww, hh)
{
	my_window = win;
	color(YELLOW);
	box(FL_NO_BOX);
	use = NULL;
	mode = 0;
	potential_mode = 0;
	ignore_release = 0;
	drag_start_x = -1;
	drag_start_y = -1;
	dx = xx;
	dy = yy;
	dw = ww;
	dh = hh;
	original_w = ww;
	original_h = hh;
	proportion = 0.0;
	operation = FRAME_OPERATION_PROPORTIONAL_RESIZE;
	end();
}

ResizeFrame::~ResizeFrame()
{
}

void	ResizeFrame::show()
{
	if(my_window->split == 0)
	{
		DragGroup::show();
	}
}

void	ResizeFrame::draw()
{
	DragGroup::draw();
	fl_color(color());
	char *mode_str = NULL;
	if(operation == FRAME_OPERATION_PROPORTIONAL_RESIZE)
	{
		mode_str = "Proportional Resize";
	}
	else if(operation == FRAME_OPERATION_FREE_RESIZE)
	{
		mode_str = "Resize";
	}
	else if(operation == FRAME_OPERATION_CROP)
	{
		mode_str = "Crop";
	}
	else if(operation == FRAME_OPERATION_ROTATE)
	{
		mode_str = "Rotate";
	}
	else if(operation == FRAME_OPERATION_DELETE)
	{
		mode_str = "Delete";
	}
	if(mode_str != NULL)
	{
		fl_rectf(x() + 25, y() + 12, 90, 14);
		fl_color(BLACK);
		fl_font(FL_HELVETICA, 8);
		fl_draw(mode_str, x() + 25, y() + 12, 90, 14, FL_ALIGN_CENTER);
		fl_color(color());
		if(operation == FRAME_OPERATION_DELETE)
		{
			fl_rect(x() + 10, y() + 13, 10, 10);
			fl_font(FL_HELVETICA, 6);
			fl_draw("X", x() + 11, y() + 14, 10, 10, FL_ALIGN_CENTER);
		}
	}
	fl_rect(x() + 6, y() + 6, w() - 12, h() - 12);

	if(operation != FRAME_OPERATION_DELETE)
	{
		if(potential_mode == DRAG_MODE_LEFT_TOP)
		{
			fl_color(RED);
		}
		fl_rectf(x(), y(), 10, 4);
		fl_rectf(x(), y(), 4, 10);
		fl_color(YELLOW);

		if(potential_mode == DRAG_MODE_RIGHT_TOP)
		{
			fl_color(RED);
		}
		fl_rectf(x() + w() - 10, y(), 10, 4);
		fl_rectf(x() + w() - 4, y(), 4, 10);
		fl_color(YELLOW);

		if(potential_mode == DRAG_MODE_LEFT_BOTTOM)
		{
			fl_color(RED);
		}
		fl_rectf(x(), y() + h() - 10, 4, 10);
		fl_rectf(x(), y() + h() - 4, 10, 4);
		fl_color(YELLOW);

		if(potential_mode == DRAG_MODE_RIGHT_BOTTOM)
		{
			fl_color(RED);
		}
		fl_rectf(x() + w() - 10, y() + h() - 4, 10, 4);
		fl_rectf(x() + w() - 4, y() + h() - 10, 4, 10);
		fl_color(YELLOW);

		if(potential_mode == DRAG_MODE_TOP)
		{
			fl_color(RED);
		}
		fl_rectf(x() + (w() / 2) - 5, y(), 10, 4);
		fl_color(YELLOW);

		if(potential_mode == DRAG_MODE_BOTTOM)
		{
			fl_color(RED);
		}
		fl_rectf(x() + (w() / 2) - 5, y() + h() - 4, 10, 4);
		fl_color(YELLOW);

		if(potential_mode == DRAG_MODE_LEFT)
		{
			fl_color(RED);
		}
		fl_rectf(x(), y() + (h() / 2) - 5, 4, 10);
		fl_color(YELLOW);

		if(potential_mode == DRAG_MODE_RIGHT)
		{
			fl_color(RED);
		}
		fl_rectf(x() + w() - 4, y() + (h() / 2) - 5, 4, 10);
	}
}

void	ResizeFrame::resize(double xx, double yy, double ww, double hh)
{
	dx = xx;
	dy = yy;
	dw = ww;
	dh = hh;
	DragGroup::resize(dx, dy, dw, dh);
}

int		ResizeFrame::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		if(Fl::event_button() == FL_LEFT_MOUSE)
		{
			int xx = Fl::event_x();
			int yy = Fl::event_y();

			if((xx > x() + 10) && (yy > y() + 13)
			&& (xx < x() + 20) && (yy < y() + 23)
			&& (operation == FRAME_OPERATION_DELETE))
			{
				if(use != NULL)
				{
					if(object_type == FRAME_OBJECT_TYPE_IMAGE_WINDOW)
					{
						ImageWindow *im = (ImageWindow *)use;
						use = NULL;
						im->Delete();
					}
					else if(object_type == FRAME_OBJECT_TYPE_IMMEDIATE)
					{
						Immediate *im = (Immediate *)use;
						use = NULL;
						Camera *cam = my_window->DisplayedCamera();
						my_window->immediate_drawing_window->ClearSelectedWidget();
						cam->RemoveImmediate(im);
						Fl::delete_widget(im);
					}
					hide();
					flag = 1;
				}
			}
			else if((xx > x() + 25) && (yy > y() + 12)
			&& (xx < x() + 115) && (yy < y() + 26))
			{
				operation++;
				if(operation > FRAME_OPERATION_DELETE)
				{
					operation = FRAME_OPERATION_PROPORTIONAL_RESIZE;
				}
				flag = 1;
				ignore_release = 1;
			}
			else if(((xx > x()) && (xx < x() + 20))
			&& ((yy > y()) && (yy < y() + 20)))
			{
				if(operation != FRAME_OPERATION_DELETE)
				{
					mode = DRAG_MODE_LEFT_TOP;
					drag_start_x = xx;
					drag_start_y = yy;
					flag = 1;
				}
			}
			else if(((xx > x()) && (xx < x() + 20))
			&& ((yy < y() + h()) && (yy > y() + h() - 20)))
			{
				if(operation != FRAME_OPERATION_DELETE)
				{
					mode = DRAG_MODE_LEFT_BOTTOM;
					drag_start_x = xx;
					drag_start_y = yy;
					flag = 1;
				}
			}
			else if(((xx < x() + w()) && (xx > x() + w() - 20))
			&& ((yy < y() + h()) && (yy > y() + h() - 20)))
			{
				if(operation != FRAME_OPERATION_DELETE)
				{
					mode = DRAG_MODE_RIGHT_BOTTOM;
					drag_start_x = xx;
					drag_start_y = yy;
					flag = 1;
				}
			}
			else if(((xx < x() + w()) && (xx > x() + w() - 20))
			&& ((yy > y()) && (yy < y() + 20)))
			{
				if(operation != FRAME_OPERATION_DELETE)
				{
					mode = DRAG_MODE_RIGHT_TOP;
					drag_start_x = xx;
					drag_start_y = yy;
					flag = 1;
				}
			}
			else if(((xx > x() + (w() / 2) - 5) && (xx < x() + (w() / 2) + 5))
			&& ((yy > y()) && (yy < y() + 16)))
			{
				if(operation != FRAME_OPERATION_DELETE)
				{
					mode = DRAG_MODE_TOP;
					drag_start_x = xx;
					drag_start_y = yy;
					flag = 1;
				}
			}
			else if(((xx > x() + (w() / 2) - 5) && (xx < x() + (w() / 2) + 5))
			&& ((yy > y() + h() - 16) && (yy < y() + h())))
			{
				if(operation != FRAME_OPERATION_DELETE)
				{
					mode = DRAG_MODE_BOTTOM;
					drag_start_x = xx;
					drag_start_y = yy;
					flag = 1;
				}
			}
			else if(((yy > y() + (h() / 2) - 5) && (yy < y() + (h() / 2) + 5))
			&& ((xx > x()) && (xx < x() + 16)))
			{
				if(operation != FRAME_OPERATION_DELETE)
				{
					mode = DRAG_MODE_LEFT;
					drag_start_x = xx;
					drag_start_y = yy;
					flag = 1;
				}
			}
			else if(((yy > y() + (h() / 2) - 5) && (yy < y() + (h() / 2) + 5))
			&& ((xx > x() + w() - 16) && (xx < x() + w())))
			{
				if(operation != FRAME_OPERATION_DELETE)
				{
					mode = DRAG_MODE_RIGHT;
					drag_start_x = xx;
					drag_start_y = yy;
					flag = 1;
				}
			}
		}
	}
	else if(event == FL_DRAG)
	{
		if(Fl::event_button() == FL_LEFT_MOUSE)
		{
			if(use != NULL)
			{
				if((operation != FRAME_OPERATION_DELETE)
				&& (operation != FRAME_OPERATION_ROTATE))
				{
					if(mode == DRAG_MODE_LEFT_TOP)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						int dx = drag_start_x - xx;
						int dy = drag_start_y - yy;
						if((w() + dx > 20) && (h() + dy > 20))
						{
							resize(x() - dx, y() - dy, w() + dx, h() + dy);
							AdjustImmediateLinePosition(dx, dy);
							drag_start_x = xx;
							drag_start_y = yy;
						}
						flag = 1;
					}
					else if(mode == DRAG_MODE_LEFT_BOTTOM)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						int dx = drag_start_x - xx;
						int dy = drag_start_y - yy;
						if((w() + dx > 20) && (h() - dy > 20))
						{
							resize(x() - dx, y(), w() + dx, h() - dy);
							AdjustImmediateLinePosition(dx, 0);
							drag_start_x = xx;
							drag_start_y = yy;
						}
						flag = 1;
					}
					else if(mode == DRAG_MODE_RIGHT_TOP)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						int dx = drag_start_x - xx;
						int dy = drag_start_y - yy;
						if((w() - dx > 20) && (h() + dy > 20))
						{
							resize(x(), y() - dy, w() - dx, h() + dy);
							AdjustImmediateLinePosition(0, dy);
							drag_start_x = xx;
							drag_start_y = yy;
						}
						flag = 1;
					}
					else if(mode == DRAG_MODE_RIGHT_BOTTOM)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						int dx = drag_start_x - xx;
						int dy = drag_start_y - yy;
						if((w() - dx > 20) && (h() - dy > 20))
						{
							resize(x(), y(), w() - dx, h() - dy);
							drag_start_x = xx;
							drag_start_y = yy;
						}
						flag = 1;
					}
					else if(mode == DRAG_MODE_TOP)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						int dx = drag_start_x - xx;
						int dy = drag_start_y - yy;
						if(h() + dy > 20)
						{
							resize(x(), y() - dy, w(), h() + dy);
							AdjustImmediateLinePosition(0, dy);
							drag_start_x = xx;
							drag_start_y = yy;
						}
						flag = 1;
					}
					else if(mode == DRAG_MODE_BOTTOM)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						int dx = drag_start_x - xx;
						int dy = drag_start_y - yy;
						if(h() - dy > 20)
						{
							resize(x(), y(), w(), h() - dy);
							drag_start_x = xx;
							drag_start_y = yy;
						}
						flag = 1;
					}
					else if(mode == DRAG_MODE_LEFT)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						int dx = drag_start_x - xx;
						int dy = drag_start_y - yy;
						if(w() + dx > 20)
						{
							resize(x() - dx, y(), w() + dx, h());
							AdjustImmediateLinePosition(dx, 0);
							drag_start_x = xx;
							drag_start_y = yy;
						}
						flag = 1;
					}
					else if(mode == DRAG_MODE_RIGHT)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						int dx = drag_start_x - xx;
						int dy = drag_start_y - yy;
						if(w() - dx > 20)
						{
							resize(x(), y(), w() - dx, h());
							drag_start_x = xx;
							drag_start_y = yy;
						}
						flag = 1;
					}
					if(mode > 0)
					{
						if(operation == FRAME_OPERATION_FREE_RESIZE)
						{
							use->resize(x() + 6, y() + 6, w() - 12, h() - 12);
						}
						else if(operation == FRAME_OPERATION_PROPORTIONAL_RESIZE)
						{
							double ddh = proportion * (double)w();
							resize(x(), y(), w(), ddh);
							use->resize(x() + 6, y() + 6, w() - 12, h() - 12);
						}
						else if(operation == FRAME_OPERATION_CROP)
						{
						}
					}
				}
				else if(operation == FRAME_OPERATION_ROTATE)
				{
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					int dy = drag_start_y - yy;
					if(xx > x() + (w() / 2))
					{
						if(object_type == FRAME_OBJECT_TYPE_IMMEDIATE)
						{
							Immediate *im = (Immediate *)use;
							if(dy > 0)
							{
								im->angle -= M_PI / 100.0;
								drag_start_y = yy;
								im->redraw();
							}
							else if(dy < 0)
							{
								im->angle += M_PI / 100.0;
								drag_start_y = yy;
								im->redraw();
							}
						}
						else
						{
							ImageWindow *iw = (ImageWindow *)use;
							if(dy > 0)
							{
								iw->angle -= M_PI / 100.0;
								drag_start_y = yy;
								iw->redraw();
							}
							else if(dy < 0)
							{
								iw->angle += M_PI / 100.0;
								drag_start_y = yy;
								iw->redraw();
							}
						}
					}
					else
					{
						if(object_type == FRAME_OBJECT_TYPE_IMMEDIATE)
						{
							Immediate *im = (Immediate *)use;
							if(dy < 0)
							{
								im->angle -= M_PI / 100.0;
								drag_start_y = yy;
								im->redraw();
							}
							else if(dy > 0)
							{
								im->angle += M_PI / 100.0;
								drag_start_y = yy;
								im->redraw();
							}
						}
						else
						{
							ImageWindow *iw = (ImageWindow *)use;
							if(dy < 0)
							{
								iw->angle -= M_PI / 100.0;
								drag_start_y = yy;
								iw->redraw();
							}
							else if(dy > 0)
							{
								iw->angle += M_PI / 100.0;
								drag_start_y = yy;
								iw->redraw();
							}
						}
					}
					flag = 1;
				}
			}
		}
	}
	else if(event == FL_RELEASE)
	{
		if((mode > 0) && (ignore_release == 0))
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				if(operation == FRAME_OPERATION_PROPORTIONAL_RESIZE)
				{
					double ddh = proportion * (double)w();
					resize(x(), y(), w(), ddh);
					use->size(w() - 12, h() - 12);
				}
				else if(operation == FRAME_OPERATION_CROP)
				{
					if(object_type == FRAME_OBJECT_TYPE_IMMEDIATE)
					{
						Immediate *im = (Immediate *)use;
						int xx = x() - im->x();
						int yy = y() - im->y();
						int ww = w();
						int hh = h();
						im->crop_x = xx;
						im->crop_y = yy;
						im->crop_w = ww;
						im->crop_h = hh;
					}
					else
					{
						ImageWindow *im = (ImageWindow *)use;
						int xx = x() - im->x();
						if(xx < 0) xx = 0;
						int yy = y() - im->y();
						if(yy < 0) yy = 0;
						int ww = w();
						if(ww > im->w() - 1) ww = im->w() - 1;
						int hh = h();
						if(hh > im->h() - 1) hh = im->h() - 1;
						im->crop_x = xx;
						im->crop_y = yy;
						im->crop_w = ww;
						im->crop_h = hh;
					}
				}
				mode = 0;
				drag_start_x = -1;
				drag_start_y = -1;
				if(object_type == FRAME_OBJECT_TYPE_IMMEDIATE)
				{
					AdjustForImmediateLine();
				}
				flag = 1;
			}
		}
		ignore_release = 0;
	}
	else if(event == FL_LEAVE)
	{
		if(!Fl::event_inside(this))
		{
			fl_cursor(FL_CURSOR_DEFAULT);
		}
		use = NULL;
		hide();
		flag = 1;
	}
	else if(event == FL_MOUSEWHEEL)
	{
		if(use != NULL)
		{
			if(operation == FRAME_OPERATION_ROTATE)
			{
				if(object_type == FRAME_OBJECT_TYPE_IMMEDIATE)
				{
					Immediate *im = (Immediate *)use;
					int nn = Fl::event_dy();
					if(nn < 0)
					{
						im->angle -= M_PI / 1000.0;
						im->redraw();
					}
					else if(nn > 0)
					{
						im->angle += M_PI / 1000.0;
						im->redraw();
					}
				}
				else
				{
					ImageWindow *iw = (ImageWindow *)use;
					int nn = Fl::event_dy();
					if(nn < 0)
					{
						iw->angle -= M_PI / 1000.0;
						iw->redraw();
					}
					else if(nn > 0)
					{
						iw->angle += M_PI / 1000.0;
						iw->redraw();
					}
				}
			}
			else
			{
				int nn = Fl::event_dy();
				if(nn > 0)
				{
					resize(x(), y(), dw * 1.01, dh * 1.01);
					use->size(w() - 12, h() - 12);
				}
				else if(nn < 0)
				{
					resize(x(), y(), dw * 0.99, dh * 0.99);
					use->size(w() - 12, h() - 12);
				}
			}
			flag = 1;
		}
	}
	else if(event == FL_MOVE)
	{
		if(Fl::event_inside(this))
		{
			int xx = Fl::event_x();
			int yy = Fl::event_y();
			if((xx > x() + 10) && (yy > y() + 13)
			&& (xx < x() + 10 + 10) && (yy < y() + 13 + 10)
			&& (operation == FRAME_OPERATION_DELETE))
			{
				fl_cursor(FL_CURSOR_DEFAULT);
			}
			else if((xx > x() + 25) && (yy > y() + 12)
			&& (xx < x() + 25 + 90) && (yy < y() + 12 + 14))
			{
				fl_cursor(FL_CURSOR_DEFAULT);
			}
			else if(operation == FRAME_OPERATION_ROTATE)
			{
				potential_mode = 0;
				fl_cursor(FL_CURSOR_NS);
			}
			else if(((xx > x()) && (xx < x() + 20))
			&& ((yy > y()) && (yy < y() + 20)))
			{
				potential_mode = DRAG_MODE_LEFT_TOP;
				fl_cursor(FL_CURSOR_CROSS);
			}
			else if(((xx > x()) && (xx < x() + 20))
			&& ((yy < y() + h()) && (yy > y() + h() - 20)))
			{
				potential_mode = DRAG_MODE_LEFT_BOTTOM;
				fl_cursor(FL_CURSOR_CROSS);
			}
			else if(((xx < x() + w()) && (xx > x() + w() - 20))
			&& ((yy < y() + h()) && (yy > y() + h() - 20)))
			{
				potential_mode = DRAG_MODE_RIGHT_BOTTOM;
				fl_cursor(FL_CURSOR_CROSS);
			}
			else if(((xx < x() + w()) && (xx > x() + w() - 20))
			&& ((yy > y()) && (yy < y() + 20)))
			{
				potential_mode = DRAG_MODE_RIGHT_TOP;
				fl_cursor(FL_CURSOR_CROSS);
			}
			else if(((xx > x() + (w() / 2) - 5) && (xx < x() + (w() / 2) + 5))
			&& ((yy > y()) && (yy < y() + 16)))
			{
				potential_mode = DRAG_MODE_TOP;
				fl_cursor(FL_CURSOR_NS);
			}
			else if(((xx > x() + (w() / 2) - 5) && (xx < x() + (w() / 2) + 5))
			&& ((yy > y() + h() - 16) && (yy < y() + h())))
			{
				potential_mode = DRAG_MODE_BOTTOM;
				fl_cursor(FL_CURSOR_NS);
			}
			else if(((yy > y() + (h() / 2) - 5) && (yy < y() + (h() / 2) + 5))
			&& ((xx > x()) && (xx < x() + 16)))
			{
				potential_mode = DRAG_MODE_LEFT;
				fl_cursor(FL_CURSOR_WE);
			}
			else if(((yy > y() + (h() / 2) - 5) && (yy < y() + (h() / 2) + 5))
			&& ((xx > x() + w() - 16) && (xx < x() + w())))
			{
				potential_mode = DRAG_MODE_RIGHT;
				fl_cursor(FL_CURSOR_WE);
			}
			else
			{
				potential_mode = 0;
				fl_cursor(FL_CURSOR_MOVE);
			}
			if(operation == FRAME_OPERATION_DELETE)
			{
				potential_mode = 0;
				fl_cursor(FL_CURSOR_DEFAULT);
			}
			flag = 1;
		}
		else
		{
			fl_cursor(FL_CURSOR_DEFAULT);
		}
	}
	if(flag == 0)
	{
		int old_x = x();
		int old_y = y();
		flag = DragGroup::handle(event);
		if(use != NULL)
		{
			if((event != FL_MOVE) && (ignore_release == 0))
			{
				if(Fl::event_button() == FL_LEFT_MOUSE)
				{
					if((x() != old_x) || (y() != old_y))
					{
						if((operation != FRAME_OPERATION_CROP)
						&& (operation != FRAME_OPERATION_DELETE))
						{
							use->resize(x() + 6, y() + 6, w() - 12, h() - 12);
						}
						else
						{
							use->resize(x() + 6, y() + 6, use->w(), use->h());
						}
					}
				}
			}
		}
	}
	return(flag);
}

int		ResizeFrame::AdjustForImmediateLine()
{
	int rr = 0;
	Immediate *im = (Immediate *)use;
	if(im != NULL)
	{
		if(operation != FRAME_OPERATION_CROP)
		{
			if((im->immediate_type == DRAWING_MODE_LINE)
			|| (im->immediate_type == DRAWING_MODE_POLYGON)
			|| (im->immediate_type == DRAWING_MODE_POLYGON_PASSTHRU)
			|| (im->immediate_type == DRAWING_MODE_FREEHAND)
			|| (im->immediate_type == DRAWING_MODE_LOOP))
			{
				if(im->line != NULL)
				{
					double ux = im->line->extent_x1;
					double uy = im->line->extent_y1;
					double uw = im->line->extent_x2 - im->line->extent_x1;
					double uh = im->line->extent_y2 - im->line->extent_y1;
					resize(ux - 6, uy - 6, uw + 12, uh + 12);
					rr = 1;
				}
			}
		}
	}
	return(rr);
}

int		ResizeFrame::AdjustImmediateLinePosition(int dx, int dy)
{
	int rr = 0;
	Immediate *im = (Immediate *)use;
	if(im != NULL)
	{
		if(operation != FRAME_OPERATION_CROP)
		{
			if((im->immediate_type == DRAWING_MODE_LINE)
			|| (im->immediate_type == DRAWING_MODE_POLYGON)
			|| (im->immediate_type == DRAWING_MODE_POLYGON_PASSTHRU)
			|| (im->immediate_type == DRAWING_MODE_FREEHAND)
			|| (im->immediate_type == DRAWING_MODE_LOOP))
			{
				if(im->line != NULL)
				{
					if((im->line->xx != NULL) && (im->line->yy != NULL))
					{
						im->line->xx[0] -= dx;
						im->line->yy[0] -= dy;
						rr = 1;
					}
				}
			}
		}
	}
	return(rr);
}

void	ResizeFrame::Use(int in_type, Fl_Widget *in_use)
{
	use = in_use;
	object_type = in_type;
	double ux = use->x() - 6;
	double uy = use->y() - 6;
	double uw = use->w() + 12;
	double uh = use->h() + 12;
	if(operation == FRAME_OPERATION_CROP)
	{
		if(object_type == FRAME_OBJECT_TYPE_IMMEDIATE)
		{
			Immediate *im = (Immediate *)use;
			if(im != NULL)
			{
				if((im->crop_w > 0) && (im->crop_h > 0))
				{
					ux += im->crop_x;
					uy += im->crop_y;
					uw = im->crop_w;
					uh = im->crop_h;
				}
			}
		}
		else
		{
			ImageWindow *iw = (ImageWindow *)use;
			if(iw != NULL)
			{
				if((iw->crop_w > 0) && (iw->crop_h > 0))
				{
					ux += iw->crop_x;
					uy += iw->crop_y;
					uw = iw->crop_w;
					uh = iw->crop_h;
				}
			}
		}
	}
	int adjusted = 0;
	if(object_type == FRAME_OBJECT_TYPE_IMMEDIATE)
	{
		adjusted = AdjustForImmediateLine();
	}
	if(adjusted == 0)
	{
		resize(ux, uy, uw, uh);
	}
	original_w = w();
	original_h = h();
	proportion = (double)use->h() / (double)use->w();
}


// SECTION *********************************** MY SCROLL *******************************************

MyScroll::MyScroll(int in_item_width, int in_row_height, int xx, int yy, int ww, int hh) : Fl_Scroll(xx, yy, ww, hh)
{
int	loop;

	layout = MY_SCROLL_LAYOUT_LIST;
	selection = NULL;
	item_cnt = 0;
	row_height = in_row_height;
	item_width = in_item_width;
	for(loop = 0;loop < 32768;loop++)
	{
		item[loop] = NULL;
	}
}

MyScroll::~MyScroll()
{
}

int	MyScroll::handle(int event)
{
	int flag = 0;
	int next_row_key = 0;
	int prev_row_key = 0;
	int next_item_key = FL_Down;
	int prev_item_key = FL_Up;
	if(layout == MY_SCROLL_LAYOUT_GRID)
	{
		next_row_key = FL_Down;
		prev_row_key = FL_Up;
		next_item_key = FL_Right;
		prev_item_key = FL_Left;
	}
	if((event == FL_FOCUS) || (event == FL_UNFOCUS))
	{
		flag = 1;
	}
	else if(event == FL_PUSH)
	{
		if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
		{
			flag = 1;
		}
	}
	else if(event == FL_KEYUP)
	{
		flag = 1;
	}
	else if(event == FL_SHORTCUT)
	{
		flag = 1;
	}
	else if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(layout == MY_SCROLL_LAYOUT_LIST)
		{
			if(key == FL_Right) key = FL_Down;
			if(key == FL_Left) key = FL_Up;
		}
		if(key == next_item_key)
		{
			SelectNext();
			ScrollToSelection();
			flag = 1;
		}
		else if(key == prev_item_key)
		{
			SelectPrev();
			ScrollToSelection();
			flag = 1;
		}
		else if(key == next_row_key)
		{
			SelectNextRow();
			ScrollToSelection();
			flag = 1;
		}
		else if(key == prev_row_key)
		{
			SelectPrevRow();
			ScrollToSelection();
			flag = 1;
		}
		else if(key == FL_Page_Down)
		{
			int yy = yposition() + h();
			if(yy > (item_cnt * row_height) - h())
			{
				yy = (item_cnt * row_height) - h();
			}
			scroll_to(0, yy);
			SelectFirstVisible();
			flag = 1;
		}
		else if(key == FL_Page_Up)
		{
			int yy = yposition() - h();
			if(yy < 0)
			{
				yy = 0;
			}
			scroll_to(0, yy);
			SelectFirstVisible();
			flag = 1;
		}
		else if(key == FL_Home)
		{
			scroll_to(0, 0);
			SelectFirstVisible();
			flag = 1;
		}
		else if(key == FL_End)
		{
			int yy = (item_cnt * row_height) - h();
			scroll_to(0, yy);
			SelectFirstVisible();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Scroll::handle(event);
	}
	return(flag);
}

void	MyScroll::Add(Fl_Widget *wid)
{
	if(item_cnt < 32768)
	{
		item[item_cnt] = wid;
		item_cnt++;
		Fl_Scroll::add(wid);
	}
}

void	MyScroll::add(Fl_Widget *wid)
{
	Fl_Scroll::add(wid);
}

void	MyScroll::clear()
{
int	loop;

	for(loop = 0;loop < 32768;loop++)
	{
		item[loop] = NULL;
	}
	item_cnt = 0;
	Fl_Scroll::clear();
}

void	MyScroll::ScrollToSelection()
{
	if(selection != NULL)
	{
		int yy = (selection->y() + selection->h()) - y();
		while(yy > h())
		{
			scroll_to(0, yposition() + 1);
			yy = (selection->y() + selection->h()) - y();
			redraw();
		}
		yy = selection->y() - y();
		while((yy < 0) && (yposition() > 0))
		{
			scroll_to(0, yposition() - 1);
			yy = selection->y() - y();
			redraw();
		}
	}
}

void	MyScroll::SelectNext()
{
int	loop;

	int flag = 0;
	for(loop = 0;((loop < item_cnt) && (flag == 0));loop++)
	{
		if(item[loop] == selection)
		{
			if(loop < (item_cnt - 1))
			{
				DisplayAsSelected(item[loop + 1]);
				flag = 1;
			}
		}
	}
}

void	MyScroll::SelectPrev()
{
int	loop;

	int flag = 0;
	for(loop = 0;((loop < item_cnt) && (flag == 0));loop++)
	{
		if(item[loop] == selection)
		{
			if(loop > 0)
			{
				DisplayAsSelected(item[loop - 1]);
				flag = 1;
			}
		}
	}
}

void	MyScroll::SelectNextRow()
{
int	loop;

	int flag = 0;
	for(loop = 0;((loop < item_cnt) && (flag == 0));loop++)
	{
		if(item[loop] == selection)
		{
			if(loop < (item_cnt - 1))
			{
				int items_per_row = (w() / item_width) - 1;
				int nn = loop + items_per_row;
				if(nn < (item_cnt - 1))
				{
					DisplayAsSelected(item[nn]);
					flag = 1;
				}
			}
		}
	}
}

void	MyScroll::SelectPrevRow()
{
int	loop;

	int flag = 0;
	for(loop = 0;((loop < item_cnt) && (flag == 0));loop++)
	{
		if(item[loop] == selection)
		{
			if(loop > 0)
			{
				int items_per_row = (w() / item_width) - 1;
				int nn = loop - items_per_row;
				if(nn >= 0)
				{
					DisplayAsSelected(item[nn]);
					flag = 1;
				}
			}
		}
	}
}

void	MyScroll::SelectFirstVisible()
{
int	loop;

	int flag = 0;
	for(loop = 0;((loop < item_cnt) && (flag == 0));loop++)
	{
		int yy = item[loop]->y() - y();
		if(yy >= 0)
		{
			DisplayAsSelected(item[loop]);
			flag = 1;
		}
	}
}

void	MyScroll::DisplayAsSelected(Fl_Widget *select)
{
	if(selection != NULL)
	{
		selection->labelcolor(LIGHT_GRAY);
		selection->color(DARK_GRAY);
		selection->redraw();
	}
	selection = select;
	selection->color(LIGHT_GRAY);
	selection->labelcolor(DARK_GRAY);
	selection->redraw();
	window()->redraw();
}

// SECTION *********************************** FILE SELECTOR *******************************************

FileInfo::FileInfo(char *in_name)
{
struct stat statbuf;
char		filetype[4096];

	filename = strdup(in_name);

	stat(filename, &statbuf);
	size = statbuf.st_size;
	is_dir = 0;
	if((statbuf.st_mode & S_IFDIR) == S_IFDIR)
	{
		is_dir = 1;
	}
	timestamp = statbuf.st_mtim.tv_sec;

	strcpy(filetype, "");
	magic(filename, filetype);
	description = strdup(filetype);
}

FileInfo::~FileInfo()
{
	if(filename != NULL)
	{
		free(filename);
	}
	if(description != NULL)
	{
		free(description);
	}
}

void	file_selector_select_cb(Fl_Widget *w, void *v)
{
char	cwd[4096];

	MyButton *b = (MyButton *)w;
	FileSelector *fs = (FileSelector *)v;
	char *filename = (char *)b->label();
	if(fs->scroll->selection != NULL)
	{
		if(IsDirectory((char *)fs->scroll->selection->label()))
		{
			fs->scroll->selection->labelcolor(WHITE);
		}
		else
		{
			fs->scroll->selection->labelcolor(fl_darker(WHITE));
		}
		fs->scroll->selection->color(DARK_GRAY);
		fs->scroll->selection->redraw();
		fs->redraw();
	}
	if(filename != NULL)
	{
		getcwd(cwd, 4096);
		fs->path->value(cwd);
		fs->path->redraw();
		fs->accept->show();
		sprintf(fs->current_selection, "%s/%s", cwd, filename);
		if(b == fs->scroll->selection)
		{
			if(IsDirectory(filename))
			{
				fs->scroll->selection = NULL;
				fs->Update(filename);
				fs->redraw();
				if(fs->select_dir == 0)
				{
					fs->accept->hide();
				}
			}
			else
			{
				fs->hide();
			}
		}
		else
		{
			b->color(WHITE);
			b->labelcolor(DARK_GRAY);
			b->redraw();
			fs->scroll->selection = b;
			if(IsDirectory(filename))
			{
				if(fs->select_dir == 0)
				{
					fs->accept->hide();
				}
			}
		}
	}
}

void	file_selector_accept_cb(Fl_Widget *w, void *v)
{
char	cwd[4096];

	FileSelector *fs = (FileSelector *)v;
	if(fs->scroll->selection != NULL)
	{
		int use_this = 0;
		char *filename = "";
		if(fs->new_file == 1)
		{
			char *str = (char *)fs->path->value();
			if(access(str, F_OK) != 0)
			{
				if(!IsDirectory(str))
				{
					use_this = 1;
					filename = str;
					sprintf(fs->current_selection, "%s", str);
					fs->use_result = 1;
				}
			}
		}
		if(use_this == 0)
		{
			getcwd(cwd, 4096);
			char *fn = (char *)fs->scroll->selection->label();
			sprintf(fs->current_selection, "%s/%s", cwd, fn);
			fs->use_result = 1;
			filename = fs->current_selection;
		}
		int go_ahead = 1;
		if(IsDirectory(filename))
		{
			go_ahead = 0;
			if(fs->select_dir != 0)
			{
				go_ahead = 1;
			}
		}
		if(go_ahead == 1)
		{
			fs->hide();
		}
	}
}

void	file_selector_cancel_cb(Fl_Widget *w, void *v)
{
	FileSelector *fs = (FileSelector *)v;
	strcpy(fs->current_selection, "");
	fs->hide();
}

void	file_selector_path_cb(Fl_Widget *w, void *v)
{
char	out[4096];

	FileSelector *fs = (FileSelector *)v;
	char *str = (char *)fs->path->value();
	fl_filename_expand(out, 4096, str);
	if(fs->new_file == 1)
	{
		fs->accept->hide();
		if(access(str, F_OK) != 0)
		{
			char *use = strdup(str);
			if(use != NULL)
			{
				char *dir_name = dirname(use);
				if(dir_name != NULL)
				{
					if(access(dir_name, W_OK) == 0)
					{
						strcpy(fs->current_selection, str);
						fs->accept->show();
					}
				}
				free(use);
			}
		}
		else
		{
			fs->Update(out);
		}
	}
	else
	{
		fs->Update(out);
	}
}

void	file_selector_sort_cb(Fl_Widget *w, void *v)
{
	FileSelector *fs = (FileSelector *)v;
	if(w == fs->sort_name)
	{
		if(fs->sort_style == SORT_NAME_ASCENDING)
		{
			fs->sort_style = SORT_NAME_DESCENDING;
		}
		else
		{
			fs->sort_style = SORT_NAME_ASCENDING;
		}
	}
	else if(w == fs->sort_size)
	{
		if(fs->sort_style == SORT_SIZE_ASCENDING)
		{
			fs->sort_style = SORT_SIZE_DESCENDING;
		}
		else
		{
			fs->sort_style = SORT_SIZE_ASCENDING;
		}
	}
	else if(w == fs->sort_type)
	{
		if(fs->sort_style == SORT_TYPE_ASCENDING)
		{
			fs->sort_style = SORT_TYPE_DESCENDING;
		}
		else
		{
			fs->sort_style = SORT_TYPE_ASCENDING;
		}
	}
	else if(w == fs->sort_timestamp)
	{
		if(fs->sort_style == SORT_TIMESTAMP_ASCENDING)
		{
			fs->sort_style = SORT_TIMESTAMP_DESCENDING;
		}
		else
		{
			fs->sort_style = SORT_TIMESTAMP_ASCENDING;
		}
	}
	fs->UpdateSort();
	char *str = (char *)fs->path->value();
	fs->Update(str);
}

void	file_selector_preview_cb(Fl_Widget *w, void *v)
{
	FileSelector *fs = (FileSelector *)v;
	MyButton *b = (MyButton *)w;
	if(fs->previewing == 0)
	{
		fs->previewing = 1;
		b->copy_label("Disable Preview");
	}
	else
	{
		fs->previewing = 0;
		b->copy_label("Enable Preview");
	}
	fs->redraw();
}

void	file_selector_view_type_cb(Fl_Widget *w, void *v)
{
	FileSelector *fs = (FileSelector *)v;
	MyButton *b = (MyButton *)w;
	if(fs->view_style == FILE_SELECTOR_VIEW_STYLE_DETAILS)
	{
		fs->view_style = FILE_SELECTOR_VIEW_STYLE_ICONS;
		fs->Update(".");
		b->copy_label("Enable List View");
	}
	else
	{
		fs->view_style = FILE_SELECTOR_VIEW_STYLE_DETAILS;
		fs->Update(".");
		b->copy_label("Enable Grid View");
	}
	fs->redraw();
}

void	file_selector_navigate_cb(Fl_Widget *w, void *v)
{
char out[4096];

	FileSelector *fs = (FileSelector *)v;
	if(w == fs->desktop)
	{
		fl_filename_expand(out, 4096, "~/Desktop");
		fs->scroll->selection = NULL;
		fs->Update(out);
	}
	else if(w == fs->documents)
	{
		fl_filename_expand(out, 4096, "~/Documents");
		fs->scroll->selection = NULL;
		fs->Update(out);
	}
	else if(w == fs->downloads)
	{
		fl_filename_expand(out, 4096, "~/Downloads");
		fs->scroll->selection = NULL;
		fs->Update(out);
	}
	else if(w == fs->home)
	{
		fl_filename_expand(out, 4096, "~");
		fs->scroll->selection = NULL;
		fs->Update(out);
	}
	else if(w == fs->music)
	{
		fl_filename_expand(out, 4096, "~/Music");
		fs->scroll->selection = NULL;
		fs->Update(out);
	}
	else if(w == fs->pictures)
	{
		fl_filename_expand(out, 4096, "~/Pictures");
		fs->scroll->selection = NULL;
		fs->Update(out);
	}
	else if(w == fs->root)
	{
		fs->scroll->selection = NULL;
		fs->Update("/");
	}
	else if(w == fs->videos)
	{
		fl_filename_expand(out, 4096, "~/Videos");
		fs->scroll->selection = NULL;
		fs->Update(out);
	}
	else if(w == fs->initial)
	{
		fs->scroll->selection = NULL;
		fs->Update(fs->initial_directory);
	}
	else if(w == fs->up)
	{
		fl_filename_expand(out, 4096, "..");
		fs->scroll->selection = NULL;
		fs->Update(out);
	}
	else if(w == fs->refresh)
	{
		fl_filename_expand(out, 4096, ".");
		fs->scroll->selection = NULL;
		fs->Update(out);
	}
}

FileSelector::FileSelector(char *lbl, char *in_filter, char *in_result_string, int in_select_dir, int in_new_file) : Dialog(1000, 550, lbl)
{
int		loop;
char	cwd[4096];

	getcwd(cwd, 4096);
	strcpy(initial_directory, cwd);
	strcpy(current_path, "");
	current_selection = in_result_string;
	strcpy(current_selection, "");
	view_style = global_window->file_selector_layout;
	use_result = 0;
	file_list_cnt = 0;
	select_dir = in_select_dir;
	new_file = in_new_file;
	filter = in_filter;
	strcpy(hot_filter, "");
	sort_style = SORT_NAME_ASCENDING;
	previewing = 1;
	global_window->use_mousewheel = 0;
	if(filter == NULL)
	{
		filter = "*";
	}
	color(fl_darker(DARK_GRAY));
	getcwd(cwd, 4096);
	for(loop = 0;loop < 32768;loop++)
	{
		file_list[loop] = NULL;
	}
	path = new MyInput(195, 28, w() - 200, 20, "Path");
	path->box(FL_FLAT_BOX);
	path->color(DARK_GRAY);
	path->cursor_color(WHITE);
	path->labelcolor(WHITE);
	path->labelsize(12);
	path->textcolor(WHITE);
	path->textsize(11);
	if(new_file == 1)
	{
		path->copy_tooltip("Enter a path here to create a new file");
	}
	else
	{
		path->copy_tooltip("Enter a path here to navigate to that path");
	}
	path->value(cwd);
	path->callback(file_selector_path_cb, this);
	if(global_window->file_selector_exclude_directories == 1)
	{
		path->deactivate();
	}
	int xp = 195;
	sort_name = new MyButton(xp, 50, 300, 7, "@#-28>");
	sort_name->box(FL_FLAT_BOX);
	sort_name->color(DARK_GRAY);
	sort_name->labelcolor(YELLOW);
	sort_name->labelsize(12);
	sort_name->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	sort_name->copy_tooltip("Sort by filename");
	sort_name->callback(file_selector_sort_cb, this);
	xp += 300;

	sort_size = new MyButton(xp, 50, 110, 7, "@#-28>");
	sort_size->box(FL_FLAT_BOX);
	sort_size->color(DARK_GRAY);
	sort_size->labelcolor(YELLOW);
	sort_size->labelsize(12);
	sort_size->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	sort_size->copy_tooltip("Sort by file size");
	sort_size->callback(file_selector_sort_cb, this);
	xp += 110;

	sort_type = new MyButton(xp, 50, 200, 7, "@#-28>");
	sort_type->box(FL_FLAT_BOX);
	sort_type->color(DARK_GRAY);
	sort_type->labelcolor(YELLOW);
	sort_type->labelsize(12);
	sort_type->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	sort_type->copy_tooltip("Sort by file size");
	sort_type->callback(file_selector_sort_cb, this);
	xp += 200;

	sort_timestamp = new MyButton(xp, 50, 190, 7, "@#-28>");
	sort_timestamp->box(FL_FLAT_BOX);
	sort_timestamp->color(DARK_GRAY);
	sort_timestamp->labelcolor(YELLOW);
	sort_timestamp->labelsize(12);
	sort_timestamp->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	sort_timestamp->copy_tooltip("Sort by file size");
	sort_timestamp->callback(file_selector_sort_cb, this);

	scroll = new MyScroll(84, 20, 195, 58, w() - 200, h() - 112);
	scroll->color(DARK_GRAY);
	scroll->end();

	int yp = 48;
	if(global_window->file_selector_exclude_directories == 0)
	{
		desktop = new MyButton(10, yp, 120, 20, "Desktop");
		desktop->box(FL_FLAT_BOX);
		desktop->color(fl_darker(DARK_GRAY));
		desktop->labelcolor(YELLOW);
		desktop->labelsize(12);
		desktop->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		desktop->callback(file_selector_navigate_cb, this);
		desktop->copy_tooltip("Your desktop directory");
		yp += 22;
		documents = new MyButton(10, yp, 120, 20, "Documents");
		documents->box(FL_FLAT_BOX);
		documents->color(fl_darker(DARK_GRAY));
		documents->labelcolor(YELLOW);
		documents->labelsize(12);
		documents->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		documents->callback(file_selector_navigate_cb, this);
		documents->copy_tooltip("Your documents directory");
		yp += 22;
		downloads = new MyButton(10, yp, 120, 20, "Downloads");
		downloads->box(FL_FLAT_BOX);
		downloads->color(fl_darker(DARK_GRAY));
		downloads->labelcolor(YELLOW);
		downloads->labelsize(12);
		downloads->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		downloads->callback(file_selector_navigate_cb, this);
		downloads->copy_tooltip("Your downloads directory");
		yp += 22;
		home = new MyButton(10, yp, 120, 20, "Home");
		home->box(FL_FLAT_BOX);
		home->color(fl_darker(DARK_GRAY));
		home->labelcolor(YELLOW);
		home->labelsize(12);
		home->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		home->callback(file_selector_navigate_cb, this);
		home->copy_tooltip("Your home directory");
		yp += 22;
		music = new MyButton(10, yp, 120, 20, "Music");
		music->box(FL_FLAT_BOX);
		music->color(fl_darker(DARK_GRAY));
		music->labelcolor(YELLOW);
		music->labelsize(12);
		music->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		music->callback(file_selector_navigate_cb, this);
		music->copy_tooltip("Your music directory");
		yp += 22;
		pictures = new MyButton(10, yp, 120, 20, "Pictures");
		pictures->box(FL_FLAT_BOX);
		pictures->color(fl_darker(DARK_GRAY));
		pictures->labelcolor(YELLOW);
		pictures->labelsize(12);
		pictures->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		pictures->callback(file_selector_navigate_cb, this);
		pictures->copy_tooltip("Your pictures directory");
		yp += 22;
		root = new MyButton(10, yp, 120, 20, "Root");
		root->box(FL_FLAT_BOX);
		root->color(fl_darker(DARK_GRAY));
		root->labelcolor(YELLOW);
		root->labelsize(12);
		root->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		root->callback(file_selector_navigate_cb, this);
		root->copy_tooltip("Your the root directory of your system");
		yp += 22;
		videos = new MyButton(10, yp, 120, 20, "Videos");
		videos->box(FL_FLAT_BOX);
		videos->color(fl_darker(DARK_GRAY));
		videos->labelcolor(YELLOW);
		videos->labelsize(12);
		videos->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		videos->callback(file_selector_navigate_cb, this);
		videos->copy_tooltip("Your videos directory");
		yp += 32;

		initial = new MyButton(10, yp, 120, 20, "Initial");
		initial->box(FL_FLAT_BOX);
		initial->color(fl_darker(DARK_GRAY));
		initial->labelcolor(YELLOW);
		initial->labelsize(12);
		initial->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		initial->callback(file_selector_navigate_cb, this);
		initial->copy_tooltip("Return to the initial directory");
		yp += 22;
		up = new MyButton(10, yp, 120, 20, "Up");
		up->box(FL_FLAT_BOX);
		up->color(fl_darker(DARK_GRAY));
		up->labelcolor(YELLOW);
		up->labelsize(12);
		up->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		up->callback(file_selector_navigate_cb, this);
		up->copy_tooltip("Go back up the directory tree");
		yp += 22;
	}
	refresh = new MyButton(10, yp, 120, 20, "Refresh");
	refresh->box(FL_FLAT_BOX);
	refresh->color(fl_darker(DARK_GRAY));
	refresh->labelcolor(YELLOW);
	refresh->labelsize(12);
	refresh->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
	refresh->callback(file_selector_navigate_cb, this);
	refresh->copy_tooltip("Refresh the current directory");
	yp += 22;
	view_type = new MyButton(10, yp, 120, 20, "Enable Grid View");
	view_type->box(FL_FLAT_BOX);
	view_type->color(fl_darker(DARK_GRAY));
	view_type->labelcolor(YELLOW);
	view_type->labelsize(12);
	view_type->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
	view_type->callback(file_selector_view_type_cb, this);
	view_type->copy_tooltip("View the files as a grid");

	preview = new MyButton(10, h() - 200, 180, 20, "Disable Preview");
	preview->box(FL_FLAT_BOX);
	preview->color(fl_darker(DARK_GRAY));
	preview->labelcolor(YELLOW);
	preview->labelsize(12);
	preview->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
	preview->callback(file_selector_preview_cb, this);
	preview->copy_tooltip("Preview the selected file");

	accept = new MyButton(w() - 160, h() - 38, 60, 20, "Accept");
	accept->box(FL_FLAT_BOX);
	accept->color(DARK_GRAY);
	accept->labelcolor(WHITE);
	accept->labelsize(12);
	accept->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	accept->callback(file_selector_accept_cb, this);
	accept->copy_tooltip("Accept the selected file");
	accept->hide();

	cancel = new MyButton(w() - 80, h() - 38, 60, 20, "Cancel");
	cancel->box(FL_FLAT_BOX);
	cancel->color(DARK_GRAY);
	cancel->labelcolor(WHITE);
	cancel->labelsize(12);
	cancel->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	cancel->copy_tooltip("Cancel and close the dialog");
	cancel->callback(file_selector_cancel_cb, this);
	end();
}

FileSelector::~FileSelector()
{
int	loop;

	for(loop = 0;loop < file_list_cnt;loop++)
	{
		if(file_list[loop] != NULL)
		{
			delete file_list[loop];
		}
	}
	global_window->use_mousewheel = 1;
	global_window->file_selector_layout = view_style;
}

void	FileSelector::draw()
{
	Dialog::draw();
	if(previewing == 1)
	{
		Preview();
	}
}

int	FileSelector::handle(int event)
{
	int flag = 0;
	if(Fl::event_inside(scroll))
	{
		flag = scroll->handle(event);
		if(event == FL_KEYBOARD)
		{
			int key = Fl::event_key();
			if((key > ' ') && (key < '~'))
			{
				char cc[2];
				cc[0] = key;
				cc[1] = '\0';
				strcat(hot_filter, cc);
				Update(".");
				flag = 1;
			}
			else if(key == FL_Delete)
			{
				strcpy(hot_filter, "");
				Update(".");
				flag = 1;
			}
			else if(key == FL_BackSpace)
			{
				if(strlen(hot_filter) > 0)
				{
					char *cp = hot_filter + (strlen(hot_filter) - 1);
					*cp = '\0';
				}
				Update(".");
				flag = 1;
			}
			else if(key == FL_Escape)
			{
				strcpy(current_selection, "");
			}
			else if((key == FL_Enter) || (key == ' '))
			{
				if(IsDirectory(current_selection))
				{
					if(scroll->selection != NULL)
					{
						file_selector_select_cb(scroll->selection, this);
					}
				}
				else
				{
					file_selector_accept_cb(NULL, this);
				}
				flag = 1;
			}
		}
	}
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	preview_svg(char *filename, Mat& mat, int sz)
{
	read_svg_file(mat, filename, Fl::w(), Fl::h());
	if(mat.rows > 0)
	{
		double dx = (double)sz / (double)mat.rows;
		if(mat.cols > mat.rows)
		{
			dx = (double)sz / (double)mat.cols;
		}
		int ww = (int)((double)mat.cols * dx);
		int hh = (int)((double)mat.rows * dx);
		cv::resize(mat, mat, cv::Size(ww, hh));
	}
}

void	preview_image(char *filename, Mat& mat, int sz)
{
	mat = imread(filename, IMREAD_UNCHANGED);
	if(mat.cols > 0)
	{
		if(mat.channels() == 3)
		{
			cvtColor(mat, mat, COLOR_BGR2RGBA);
		}
		else
		{
			cvtColor(mat, mat, COLOR_BGRA2RGBA);
		}
		double dx = (double)sz / (double)mat.rows;
		if(mat.cols > mat.rows)
		{
			dx = (double)sz / (double)mat.cols;
		}
		int ww = (int)((double)mat.cols * dx);
		int hh = (int)((double)mat.rows * dx);
		cv::resize(mat, mat, cv::Size(ww, hh));
	}
}

void	preview_video(char *filename, Mat& mat, int sz)
{
	cv::VideoCapture cap(filename);
	if(cap.isOpened())
	{
		cap.read(mat);
		cap.release();
		if(mat.cols > 0)
		{
			if(mat.channels() == 3)
			{
				cvtColor(mat, mat, COLOR_BGR2RGB);
			}
			else
			{
				cvtColor(mat, mat, COLOR_BGRA2RGBA);
			}
			double dx = (double)sz / (double)mat.rows;
			if(mat.cols > mat.rows)
			{
				dx = (double)sz / (double)mat.cols;
			}
			int ww = (int)((double)mat.cols * dx);
			int hh = (int)((double)mat.rows * dx);
			cv::resize(mat, mat, cv::Size(ww, hh));
		}
	}
}

void	preview_html(char *filename, Mat& mat, int sz)
{
	if(global_html == 1)
	{
		HTML_Win *(*make_html)(char *, char *, int, char *, char *, char *, int, int);
		make_html = (HTML_Win *(*)(char *, char *, int, char *, char *, char *, int, int))void_MakeHTMLWindow_cef;
		if(make_html != NULL)
		{
			char *content = read_whole_text_file(filename);
			if(content != NULL)
			{
				HTML_Win *html = make_html(NULL, content, global_window->html_background, NULL, NULL, NULL, 1024, 1024);
				if(html != NULL)
				{
					int cnt = 0;
					while((html->raw == NULL) && (cnt < 1000))
					{
						void (*get_image)(HTML_Win *);
						get_image = (void (*)(HTML_Win *))void_get_image_cef;
						get_image(html);
						usleep(10000);
						cnt++;
					}
					if(html->raw != NULL)
					{
						Mat src = Mat(1024, 1024, CV_8UC4, html->raw);
						mat = src.clone();
						int width = mat.cols;
						int height = mat.rows;
						cvtColor(mat, mat, COLOR_BGRA2RGBA);
						double dx = (double)sz / (double)mat.rows;
						if(mat.cols > mat.rows)
						{
							dx = (double)sz / (double)mat.cols;
						}
						int ww = (int)((double)mat.cols * dx);
						int hh = (int)((double)mat.rows * dx);
						cv::resize(mat, mat, cv::Size(ww, hh));
					}
					if(void_delete_html_cef != NULL)
					{
						void (*delete_html)(HTML_Win *);
						delete_html = (void (*)(HTML_Win *))void_delete_html_cef;
						delete_html(html);
					}
				}
				free(content);
			}
		}
	}
}

void	preview_osg(char *filename, Mat& mat, int sz)
{
	if(global_osg_enabled == 1)
	{
		MyViewer *(*osg_open_osg)(int, char **, int, int);
		osg_open_osg = (MyViewer *(*)(int, char **, int, int))void_OSG_open_osg;
		if(osg_open_osg != NULL)
		{
			char *file[1];
			file[0] = filename;
			MyViewer *osg_viewer = osg_open_osg(1, file, 1024, 1024);
			if(osg_viewer != NULL)
			{
				osg_viewer->frame();
				unsigned char *im = (unsigned char *)osg_viewer->image->getDataPointer();
				int cnt = 0;
				while(cnt < 100)
				{
					usleep(1000);
					osg_viewer->frame();
					im = (unsigned char *)osg_viewer->image->getDataPointer();
					cnt++;
				}
				Mat src(osg_viewer->image->t(), osg_viewer->image->s(), CV_8UC4, (void *)im);
				mat = src.clone();
				int width = mat.cols;
				int height = mat.rows;
				cvtColor(mat, mat, COLOR_BGRA2RGBA);
				double dx = (double)sz / (double)mat.rows;
				if(mat.cols > mat.rows)
				{
					dx = (double)sz / (double)mat.cols;
				}
				int ww = (int)((double)mat.cols * dx);
				int hh = (int)((double)mat.rows * dx);
				cv::resize(mat, mat, cv::Size(ww, hh));
				delete osg_viewer;
			}
		}
	}
}

void	preview_text(char *filename, Mat& mat, int sz)
{
	FILE *fp = fopen(filename, "r");
	if(fp != NULL)
	{
		cv::Mat local_mat(1024, 1024, CV_8UC4, cv::Scalar(0, 0, 0, 0));
		cairo_surface_t *cairo_surface = cairo_image_surface_create_for_data(local_mat.ptr(), CAIRO_FORMAT_ARGB32, local_mat.cols, local_mat.rows, local_mat.step);
		if(cairo_surface != NULL)
		{
			char buf[265];
			int xx = 20;
			int yy = 0;
			cairo_t *cairo_context = cairo_create(cairo_surface);
			cairo_set_antialias(cairo_context, CAIRO_ANTIALIAS_BEST);
			while((fgets(buf, 256, fp)) && (yy < 1024))
			{
				my_cairo_draw_text(cairo_context, 0, 64 + yy, buf, 64);
				yy += 64;
			}
			mat = local_mat.clone();
			cv::resize(mat, mat, cv::Size(sz, sz));
			cairo_destroy(cairo_context);
			cairo_surface_destroy(cairo_surface);
		}
		fclose(fp);
	}
}

void	preview_directory(char *filename, Mat& mat, int sz)
{
	mat = global_folder_mat.clone();
	if(mat.cols > 0)
	{
		if(mat.channels() == 3)
		{
			cvtColor(mat, mat, COLOR_BGR2RGBA);
		}
		else
		{
			cvtColor(mat, mat, COLOR_BGRA2RGBA);
		}
		double dx = (double)sz / (double)mat.rows;
		if(mat.cols > mat.rows)
		{
			dx = (double)sz / (double)mat.cols;
		}
		int ww = (int)((double)mat.cols * dx);
		int hh = (int)((double)mat.rows * dx);
		cv::resize(mat, mat, cv::Size(ww, hh));
	}
}

void	FileSelector::Preview()
{
char	filetype[4096];
char	cwd[4096];

	if(scroll->selection != NULL)
	{
		getcwd(cwd, 4096);
		char *filename = (char *)scroll->selection->label();
		sprintf(current_selection, "%s/%s", cwd, filename);
		strcpy(filetype, "");
		magic(current_selection, filetype);
		global_audio_sudden_stop = 1;
		int detect_osg = 0;
		if(global_osg_enabled == 1)
		{
			if(strncmp(filetype, "text/plain", strlen("text/plain")) == 0)
			{
				char *cp = current_selection;
				while(*cp != '\0')
				{
					if(strncmp(cp, ".osg", strlen(".osg")) == 0)
					{
						detect_osg = 1;
					}
					cp++;
				}
			}
		}
		if(strncmp(filetype, "image/", strlen("image/")) == 0)
		{
			if(strncmp(filetype, "image/svg", strlen("image/svg")) == 0)
			{
				Mat mat;
				preview_svg(current_selection, mat, 160);
				if((mat.rows > 0) && (mat.cols > 0))
				{
					int xx = ((160 / 2) - (mat.cols / 2)) + 20;
					fl_draw_image(mat.ptr(), xx, h() - 180, mat.cols, mat.rows, mat.channels());
				}
			}
			else
			{
				Mat mat;
				preview_image(current_selection, mat, 160);
				if((mat.rows > 0) && (mat.cols > 0))
				{
					int xx = ((160 / 2) - (mat.cols / 2)) + 20;
					fl_draw_image(mat.ptr(), xx, h() - 180, mat.cols, mat.rows, mat.channels());
				}
			}
		}
		else if(strncmp(filetype, "inode/", strlen("inode/")) == 0)
		{
			Mat mat;
			preview_directory(current_selection, mat, 160);
			if((mat.rows > 0) && (mat.cols > 0))
			{
				int xx = ((160 / 2) - (mat.cols / 2)) + 20;
				fl_draw_image(mat.ptr(), xx, h() - 180, mat.cols, mat.rows, mat.channels());
			}
		}
		else if(strncmp(filetype, "video/", strlen("video/")) == 0)
		{
			Mat mat;
			preview_video(current_selection, mat, 160);
			if((mat.rows > 0) && (mat.cols > 0))
			{
				int xx = ((160 / 2) - (mat.cols / 2)) + 20;
				fl_draw_image(mat.ptr(), xx, h() - 180, mat.cols, mat.rows, mat.channels());
			}
		}
		else if(strncmp(filetype, "text/html", strlen("text/html")) == 0)
		{
			if(global_html == 1)
			{
				Mat mat;
				preview_html(current_selection, mat, 160);
				if((mat.rows > 0) && (mat.cols > 0))
				{
					int xx = ((160 / 2) - (mat.cols / 2)) + 20;
					fl_draw_image(mat.ptr(), xx, h() - 180, mat.cols, mat.rows, mat.channels());
				}
			}
		}
		else if((strncmp(filetype, "text/plain", strlen("text/plain")) == 0) && (detect_osg == 1))
		{
			if(global_osg_enabled == 1)
			{
				Mat mat;
				preview_osg(current_selection, mat, 160);
				if((mat.rows > 0) && (mat.cols > 0))
				{
					int xx = ((160 / 2) - (mat.cols / 2)) + 20;
					fl_draw_image(mat.ptr(), xx, h() - 180, mat.cols, mat.rows, mat.channels());
				}
			}
		}
		else if(strncmp(filetype, "audio/", strlen("audio/")) == 0)
		{
			global_audio_sudden_stop = 0;
			play_audio_file(global_window, current_selection);
		}
		else if((strncmp(filetype, "application/json", strlen("application/json")) == 0)
		|| (strncmp(filetype, "text/", strlen("text/")) == 0))
		{
			Mat mat;
			preview_text(current_selection, mat, 160);
			if((mat.rows > 0) && (mat.cols > 0))
			{
				int xx = ((160 / 2) - (mat.cols / 2)) + 20;
				fl_draw_image(mat.ptr(), xx, h() - 180, mat.cols, mat.rows, mat.channels());
			}
		}
	}
}

void	*get_file_thumbnail(Mat& mat, char *filename, int sz)
{
char	filetype[4096];
char	current_selection[8192];
char	cwd[4096];

	void *rr = NULL;
	getcwd(cwd, 4096);
	sprintf(current_selection, "%s/%s", cwd, filename);
	strcpy(filetype, "");
	magic(current_selection, filetype);
	global_audio_sudden_stop = 1;
	int detect_osg = 0;
	if(global_osg_enabled == 1)
	{
		if(strncmp(filetype, "text/plain", strlen("text/plain")) == 0)
		{
			char *cp = current_selection;
			while(*cp != '\0')
			{
				if(strncmp(cp, ".osg", strlen(".osg")) == 0)
				{
					detect_osg = 1;
				}
				cp++;
			}
		}
	}
	if(strncmp(filetype, "image/", strlen("image/")) == 0)
	{
		if(strncmp(filetype, "image/svg", strlen("image/svg")) == 0)
		{
			preview_svg(current_selection, mat, sz);
			if((mat.rows > 0) && (mat.cols > 0))
			{
				rr = mat.ptr();
			}
		}
		else
		{
			preview_image(current_selection, mat, sz);
			if((mat.rows > 0) && (mat.cols > 0))
			{
				rr = mat.ptr();
			}
		}
	}
	else if(strncmp(filetype, "inode/", strlen("inode/")) == 0)
	{
		preview_directory(current_selection, mat, sz);
		if((mat.rows > 0) && (mat.cols > 0))
		{
			rr = mat.ptr();
		}
	}
	else if(strncmp(filetype, "video/", strlen("video/")) == 0)
	{
		preview_video(current_selection, mat, sz);
		if((mat.rows > 0) && (mat.cols > 0))
		{
			rr = mat.ptr();
		}
	}
	else if(strncmp(filetype, "text/html", strlen("text/html")) == 0)
	{
		if(global_html == 1)
		{
			preview_html(current_selection, mat, sz);
			if((mat.rows > 0) && (mat.cols > 0))
			{
				rr = mat.ptr();
			}
		}
	}
	else if((strncmp(filetype, "text/plain", strlen("text/plain")) == 0) && (detect_osg == 1))
	{
		if(global_osg_enabled == 1)
		{
			preview_osg(current_selection, mat, sz);
			if((mat.rows > 0) && (mat.cols > 0))
			{
				rr = mat.ptr();
			}
		}
	}
	else if((strncmp(filetype, "application/json", strlen("application/json")) == 0)
	|| (strncmp(filetype, "text/", strlen("text/")) == 0))
	{
		preview_text(current_selection, mat, sz);
		if((mat.rows > 0) && (mat.cols > 0))
		{
			rr = mat.ptr();
		}
	}
	return(rr);
}

void	FileSelector::UpdateSort()
{
	sort_name->copy_label("");
	sort_size->copy_label("");
	sort_type->copy_label("");
	sort_timestamp->copy_label("");
	if(sort_style == SORT_NAME_ASCENDING)
	{
		sort_name->copy_label("@#-28>");
	}
	else if(sort_style == SORT_NAME_DESCENDING)
	{
		sort_name->copy_label("@#-22>");
	}
	else if(sort_style == SORT_SIZE_ASCENDING)
	{
		sort_size->copy_label("@#-28>");
	}
	else if(sort_style == SORT_SIZE_DESCENDING)
	{
		sort_size->copy_label("@#-22>");
	}
	else if(sort_style == SORT_TYPE_ASCENDING)
	{
		sort_type->copy_label("@#-28>");
	}
	else if(sort_style == SORT_TYPE_DESCENDING)
	{
		sort_type->copy_label("@#-22>");
	}
	else if(sort_style == SORT_TIMESTAMP_ASCENDING)
	{
		sort_timestamp->copy_label("@#-28>");
	}
	else if(sort_style == SORT_TIMESTAMP_DESCENDING)
	{
		sort_timestamp->copy_label("@#-22>");
	}
	sort_name->redraw();
	sort_size->redraw();
	sort_type->redraw();
	sort_timestamp->redraw();
}

int	sort_by_filename_ascending(const void *a, const void *b)
{
	FileInfo *aa = *(FileInfo **)a;
	FileInfo *bb = *(FileInfo **)b;
	int nn = strcmp(aa->filename, bb->filename);
	return(nn);
}

int	sort_by_filename_descending(const void *a, const void *b)
{
	FileInfo *aa = *(FileInfo **)a;
	FileInfo *bb = *(FileInfo **)b;
	int nn = strcmp(bb->filename, aa->filename);
	return(nn);
}

int	sort_by_size_ascending(const void *a, const void *b)
{
struct stat statbuf;

	FileInfo *aa = *(FileInfo **)a;
	FileInfo *bb = *(FileInfo **)b;

	off_t sz_a = aa->size;
	off_t sz_b = bb->size;

	int rr = 0;
	if(sz_a > sz_b) rr = 1;
	else if(sz_b > sz_a) rr = -1;
	return(rr);
}

int	sort_by_size_descending(const void *a, const void *b)
{
struct stat statbuf;

	FileInfo *aa = *(FileInfo **)a;
	FileInfo *bb = *(FileInfo **)b;

	off_t sz_a = aa->size;
	off_t sz_b = bb->size;

	int rr = 0;
	if(sz_a > sz_b) rr = -1;
	else if(sz_b > sz_a) rr = 1;
	return(rr);
}

int	sort_by_type_ascending(const void *a, const void *b)
{
	FileInfo *aa = *(FileInfo **)a;
	FileInfo *bb = *(FileInfo **)b;

	int nn = strcmp(aa->description, bb->description);
	return(nn);
}

int	sort_by_type_descending(const void *a, const void *b)
{
	FileInfo *aa = *(FileInfo **)a;
	FileInfo *bb = *(FileInfo **)b;

	int nn = strcmp(bb->description, aa->description);
	return(nn);
}

int	sort_by_timestamp_ascending(const void *a, const void *b)
{
struct stat statbuf;

	FileInfo *aa = *(FileInfo **)a;
	FileInfo *bb = *(FileInfo **)b;

	time_t ts_a = aa->size;
	time_t ts_b = bb->size;

	int rr = 0;
	if(ts_a > ts_b) rr = 1;
	else if(ts_b > ts_a) rr = -1;
	return(rr);
}

int	sort_by_timestamp_descending(const void *a, const void *b)
{
struct stat statbuf;

	FileInfo *aa = *(FileInfo **)a;
	FileInfo *bb = *(FileInfo **)b;

	time_t ts_a = aa->size;
	time_t ts_b = bb->size;

	int rr = 0;
	if(ts_a > ts_b) rr = -1;
	else if(ts_b > ts_a) rr = 1;
	return(rr);
}

void	FileSelector::SortFilenames()
{
	if(sort_style == SORT_NAME_ASCENDING)
	{
		qsort(file_list, file_list_cnt, sizeof(FileInfo *), sort_by_filename_ascending);
	}
	else if(sort_style == SORT_NAME_DESCENDING)
	{
		qsort(file_list, file_list_cnt, sizeof(FileInfo *), sort_by_filename_descending);
	}
	else if(sort_style == SORT_SIZE_ASCENDING)
	{
		qsort(file_list, file_list_cnt, sizeof(FileInfo *), sort_by_size_ascending);
	}
	else if(sort_style == SORT_SIZE_DESCENDING)
	{
		qsort(file_list, file_list_cnt, sizeof(FileInfo *), sort_by_size_descending);
	}
	else if(sort_style == SORT_TYPE_ASCENDING)
	{
		qsort(file_list, file_list_cnt, sizeof(FileInfo *), sort_by_type_ascending);
	}
	else if(sort_style == SORT_TYPE_DESCENDING)
	{
		qsort(file_list, file_list_cnt, sizeof(FileInfo *), sort_by_type_descending);
	}
	else if(sort_style == SORT_TIMESTAMP_ASCENDING)
	{
		qsort(file_list, file_list_cnt, sizeof(FileInfo *), sort_by_timestamp_ascending);
	}
	else if(sort_style == SORT_TIMESTAMP_DESCENDING)
	{
		qsort(file_list, file_list_cnt, sizeof(FileInfo *), sort_by_timestamp_descending);
	}
}

void	FileSelector::Update(char *in_path)
{
int				loop;
char			cwd[4096];
struct dirent	**namelist;
char			use_filter[4096];
	
	if(in_path != NULL)
	{
		scroll->selection = NULL;
		UpdateSort();
		strcpy(current_path, in_path);
		fl_chdir(current_path);
		getcwd(cwd, 4096);
		path->value(cwd);
		path->redraw();
		accept->hide();
		scroll->clear();
		for(loop = 0;loop < file_list_cnt;loop++)
		{
			if(file_list[loop] != NULL)
			{
				delete file_list[loop];
				file_list[loop] = NULL;
			}
		}
		int n = scandir(".", &namelist, NULL, alphasort);
		sprintf(use_filter, "%s%s", hot_filter, filter);
		if(n > 0)
		{
			file_list_cnt = 0;
			for(loop = 0;loop < n;loop++)
			{
				if((!fl_filename_isdir(namelist[loop]->d_name)) || (global_window->file_selector_exclude_directories == 0))
				{
					if((fl_filename_isdir(namelist[loop]->d_name)) || (fl_filename_match(namelist[loop]->d_name, use_filter)))
					{
						if(file_list_cnt < 32768)
						{
							file_list[file_list_cnt] = new FileInfo(namelist[loop]->d_name);
							file_list_cnt++;
						}
					}
				}
				free(namelist[loop]);
			}
			free(namelist);
			SortFilenames();
			if(view_style == FILE_SELECTOR_VIEW_STYLE_DETAILS)
			{
				scroll->layout = MY_SCROLL_LAYOUT_LIST;
				scroll->item_width = 0;
				scroll->row_height = 20;
				int yy = 0;
				struct stat statbuf;
				for(loop = 0;loop < file_list_cnt;loop++)
				{
					Fl_Color back = DARK_GRAY;
					Fl_Color fore = WHITE;
					if(file_list[loop]->is_dir == 1)
					{
						fore = GRAY;
					}
					int use_color = fl_darker(WHITE);
					MyButton *path_button = new MyButton(scroll->x(), scroll->y() + yy, 300, scroll->row_height, file_list[loop]->filename);
					path_button->box(FL_FLAT_BOX);
					path_button->color(back);
					path_button->labelcolor(fore);
					path_button->labelsize(12);
					path_button->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
					path_button->copy_tooltip("Select a file. Click twice to select or descend into a directory");
					path_button->shortcut(' ');
					if(scroll->selection == NULL)
					{
						path_button->color(fore);
						path_button->labelcolor(back);
						scroll->selection = path_button;
					}
					path_button->callback(file_selector_select_cb, this);
					scroll->Add(path_button);

					char buf[8192];
					sprintf(buf, "%ld", file_list[loop]->size);
					MyBox *my_box = new MyBox(scroll->x() + 300, scroll->y() + yy, 100, scroll->row_height, buf);
					my_box->box(FL_FLAT_BOX);
					my_box->color(back);
					my_box->labelcolor(fore);
					my_box->labelsize(12);
					my_box->align(FL_ALIGN_INSIDE | FL_ALIGN_RIGHT);
					my_box->copy_tooltip("Size of the file");
					scroll->add(my_box);

					Fl_Box *spacer = new Fl_Box(scroll->x() + 400, scroll->y() + yy, 10, scroll->row_height);
					spacer->box(FL_FLAT_BOX);
					spacer->color(back);
					scroll->add(spacer);

					sprintf(buf, "%s", file_list[loop]->description);
					Fl_Output *box = new Fl_Output(scroll->x() + 410, scroll->y() + yy, 200, scroll->row_height);
					box->box(FL_FLAT_BOX);
					box->color(back);
					box->textcolor(fore);
					box->textsize(12);
					box->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
					box->value(buf);
					box->copy_tooltip("Type of the file");
					scroll->add(box);

					spacer = new Fl_Box(scroll->x() + 610, scroll->y() + yy, 10, scroll->row_height);
					spacer->box(FL_FLAT_BOX);
					spacer->color(back);
					scroll->add(spacer);

					struct tm *my_tm = localtime(&file_list[loop]->timestamp);
					sprintf(buf, "%04d/%02d/%02d %02d:%02d:%02d", my_tm->tm_year + 1900, my_tm->tm_mon + 1, my_tm->tm_mday, 
						my_tm->tm_hour, my_tm->tm_min, my_tm->tm_sec);
					box = new Fl_Output(scroll->x() + 620, scroll->y() + yy, scroll->w() - 630, scroll->row_height);
					box->box(FL_FLAT_BOX);
					box->color(back);
					box->textcolor(fore);
					box->textsize(12);
					box->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
					box->value(buf);
					box->copy_tooltip("Type of the file");
					scroll->add(box);

					yy += scroll->row_height;
				}
			}
			if(view_style == FILE_SELECTOR_VIEW_STYLE_ICONS)
			{
				int yy = 0;
				int xx = 0;
				scroll->layout = MY_SCROLL_LAYOUT_GRID;
				scroll->row_height = 90;
				scroll->item_width = 84;
				struct stat statbuf;
				for(loop = 0;loop < file_list_cnt;loop++)
				{
					Fl_Color back = DARK_GRAY;
					Fl_Color fore = WHITE;
					if(file_list[loop]->is_dir == 1)
					{
						fore = GRAY;
					}
					int use_color = fl_darker(WHITE);
					MyFileImageButton *path_button = new MyFileImageButton(scroll->x() + xx, scroll->y() + yy, 84, scroll->row_height, file_list[loop]->filename);
					path_button->box(FL_FRAME_BOX);
					path_button->color(back);
					path_button->labelcolor(fore);
					path_button->labelsize(9);
					path_button->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT | FL_ALIGN_BOTTOM | FL_ALIGN_WRAP);
					path_button->copy_tooltip("Select a file. Click twice to select or descend into a directory");
					path_button->shortcut(' ');
					if(scroll->selection == NULL)
					{
						path_button->color(fore);
						path_button->labelcolor(back);
						scroll->selection = path_button;
					}
					path_button->callback(file_selector_select_cb, this);
					scroll->Add(path_button);
					xx += 90;
					if((xx + 84) > scroll->w())
					{
						xx = 0;
						yy += 100;
					}
				}
			}
			scroll->redraw();
			scroll->take_focus();
		}
	}
}


// SECTION *********************************** MY BUTTON *******************************************

void	create_path_to_widget(Fl_Widget *button, char *path)
{
	char *orig = (char *)button->label();
	if(orig == NULL)
	{
		orig = "(null)";
	}
	strcpy(path, orig);
	Fl_Widget *last = button;
	while(last != NULL)
	{
		Fl_Widget *win = last->parent();
		if(win != NULL)
		{
			strcat(path, "|");
			char *str = (char *)win->label();
			if(str != NULL)
			{
				strcat(path, str);
			}
			else
			{
				strcat(path, "(null)");
			}
		}
		last = win;
	}
}

int	scan_paths_for_shortcut(char *path)
{
char	buf[256];

	int rr = 0;
	FILE *fp = fopen("shortcuts.txt", "r");
	if(fp != NULL)
	{
		while(fgets(buf, 256, fp))
		{
			strip_lf(buf);
			if(strncmp(buf, path, strlen(path)) == 0)
			{
				char *cp = buf + strlen(path);
				while((*cp != '\t') && (*cp != '\0'))
				{
					cp++;
				}
				if(*cp == '\t')
				{
					cp++;
					rr = atoi(cp);
				}
			}
		}
		fclose(fp);
	}
	return(rr);
}

char	*scan_paths_for_label(char *path)
{
char	buf[256];

	char *rr = NULL;
	FILE *fp = fopen("relabel.txt", "r");
	if(fp != NULL)
	{
		while(fgets(buf, 256, fp))
		{
			strip_lf(buf);
			if(strncmp(buf, path, strlen(path)) == 0)
			{
				char *cp = buf + strlen(path);
				while((*cp != '\t') && (*cp != '\0'))
				{
					cp++;
				}
				if(*cp == '\t')
				{
					cp++;
					rr = strdup(cp);
				}
			}
		}
		fclose(fp);
	}
	return(rr);
}

ShortcutWindow::ShortcutWindow(Fl_Button *b, int xx, int yy, int ww, int hh) : Fl_Window(xx, yy, ww, hh)
{
	end();

	global_window->SetErrorMessage("Waiting on a keystroke.", 100000);
	button = b;
	box(FL_NO_BOX);
	set_modal();
	take_focus();
	Fl::focus(this);
}

ShortcutWindow::~ShortcutWindow()
{
}

int	ShortcutWindow::handle(int event)
{
char	path[4096];

	int flag = 0;
	if(event == FL_FOCUS)
	{
		flag = 1;
	}
	else if(event == FL_UNFOCUS)
	{
		flag = 1;
	}
	else if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if((key != FL_Shift_L)
		&& (key != FL_Shift_R)
		&& (key != FL_Control_L)
		&& (key != FL_Control_R)
		&& (key != FL_Alt_L)
		&& (key != FL_Alt_R)
		&& (key != FL_Escape))
		{
			FILE *fp = fopen("shortcuts.txt", "a");
			if(fp != NULL)
			{
				int state = Fl::event_state();
				if((state & FL_ALT) == FL_ALT)
				{
					key += FL_ALT;
				}
				if((state & FL_SHIFT) == FL_SHIFT)
				{
					key += FL_SHIFT;
				}
				if((state & FL_CTRL) == FL_CTRL)
				{
					key += FL_CTRL;
				}
				global_window->SetErrorMessage("Waiting on a keystroke - Satisfied.");
				button->shortcut(key);
				flag = 1;
				hide();
				Fl::delete_widget(this);
				strcpy(path, "");
				create_path_to_widget(button, path);
				if(strlen(path) > 0)
				{
					fprintf(fp, "%s\t%d\n", path, key);
				}
				else
				{
					global_window->SetErrorMessage("Waiting on a keystroke - Failed.");
				}
				fclose(fp);
			}
			else
			{
				global_window->SetErrorMessage("Waiting on a keystroke - Failed.");
			}
		}
		else if(key == FL_Escape)
		{
			hide();
			Fl::delete_widget(this);
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	relabel_label_cb(Fl_Widget *w, void *v)
{
char	path[256];

	RelabelWindow *win = (RelabelWindow *)v;
	if(win->button != NULL)
	{
		char *str = (char *)win->input->value();
		if(str != NULL)
		{
			strcpy(path, "");
			create_path_to_widget(win->button, path);
			FILE *fp = fopen("relabel.txt", "a");
			if(fp != NULL)
			{
				fprintf(fp, "%s\t%s\n", path, str);
				fclose(fp);
			}
			win->button->copy_label(str);
		}
	}
	win->hide();
	Fl::delete_widget(win);
}

RelabelWindow::RelabelWindow(MyWin *in_win, Fl_Button *b, int xx, int yy, int ww, int hh) : Dialog(xx, yy, ww, hh, "Relabel")
{
	button = b;
	input = new Fl_Input(70, 30, 250, 20, "New Label");
	input->textsize(11);
	input->labelsize(11);
	input->textcolor(BLACK);
	input->color(LIGHT_GRAY);
	input->labelcolor(LIGHT_GRAY);
	input->box(FL_FRAME_BOX);
	input->set_visible_focus();
	input->when(FL_WHEN_ENTER_KEY);
	input->callback(relabel_label_cb, this);
	end();
	set_modal();
	input->take_focus();
	Fl::focus(input);
}

RelabelWindow::~RelabelWindow()
{
}

void	my_button_popup_cb(Fl_Widget *w, void *v)
{
	Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
	Fl_Button *button = (Fl_Button *)v;
	char *str = (char *)browser->text(browser->value());
	if(str != NULL)
	{
		if(strcmp(str, "Assign Shortcut") == 0)
		{
			browser->window()->hide();
			ShortcutWindow *sc = new ShortcutWindow(button, 0, 0, 10, 10);
			sc->show();
		}
		else if(strcmp(str, "Relabel") == 0)
		{
			browser->window()->hide();
			int xx = button->x();
			int yy = button->y();
			RelabelWindow *sc = new RelabelWindow(global_window, button, xx, yy, 340, 40);
			sc->show();
		}
	}
}

MyButton::MyButton(int xx, int yy, int ww, int hh, char *lbl) : Fl_Button(xx, yy, ww, hh, lbl)
{
	strcpy(path, "");
}

MyButton::~MyButton()
{
}

int	MyButton::handle(int event)
{
	int flag = 0;
	if(event == FL_SHOW)
	{
		if(strlen(path) < 1)
		{
			create_path_to_widget(this, path);
			if(strlen(path) > 0)
			{
				int nn = scan_paths_for_shortcut(path);
				if(nn != 0)
				{
					shortcut(nn);
				}
				char *new_label = scan_paths_for_label(path);
				if(new_label != NULL)
				{
					copy_label(new_label);
					free(new_label);
				}
			}
		}
	}
	else if(event == FL_PUSH)
	{
		if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
		{
			popup = new PopupMenu(x(), y(), 160, 300);
			popup->browser->callback(my_button_popup_cb, this);
			popup->browser->add("Assign Shortcut", this);
			popup->browser->add("Relabel", this);

			popup->Fit();
			popup->resize(Fl::event_x_root(), Fl::event_y_root(), popup->w(), popup->h());
			popup->set_modal();
			Fl_Group *grp = Fl_Group::current();
			Fl_Group::current(0);
			popup->show();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Button::handle(event);
	}
	return(flag);
}

MyToggleButton::MyToggleButton(int xx, int yy, int ww, int hh, char *lbl) : Fl_Toggle_Button(xx, yy, ww, hh, lbl)
{
	strcpy(path, "");
}

MyToggleButton::~MyToggleButton()
{
}

int	MyToggleButton::handle(int event)
{
	int flag = 0;
	if(event == FL_SHOW)
	{
		if(strlen(path) < 1)
		{
			create_path_to_widget(this, path);
			if(strlen(path) > 0)
			{
				int nn = scan_paths_for_shortcut(path);
				if(nn != 0)
				{
					shortcut(nn);
				}
			}
		}
	}
	else if(event == FL_PUSH)
	{
		if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
		{
			popup = new PopupMenu(x(), y(), 160, 300);
			popup->browser->callback(my_button_popup_cb, this);
			popup->browser->add("Assign Shortcut", this);

			popup->Fit();
			popup->resize(Fl::event_x_root(), Fl::event_y_root(), popup->w(), popup->h());
			popup->set_modal();
			Fl_Group *grp = Fl_Group::current();
			Fl_Group::current(0);
			popup->show();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Toggle_Button::handle(event);
	}
	return(flag);
}

MyLightButton::MyLightButton(int xx, int yy, int ww, int hh, char *lbl) : Fl_Light_Button(xx, yy, ww, hh, lbl)
{
	strcpy(path, "");
}

MyLightButton::~MyLightButton()
{
}

int	MyLightButton::handle(int event)
{
	int flag = 0;
	if(event == FL_SHOW)
	{
		if(strlen(path) < 1)
		{
			create_path_to_widget(this, path);
			if(strlen(path) > 0)
			{
				int nn = scan_paths_for_shortcut(path);
				if(nn != 0)
				{
					shortcut(nn);
				}
			}
		}
	}
	else if(event == FL_PUSH)
	{
		if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
		{
			popup = new PopupMenu(x(), y(), 160, 300);
			popup->browser->callback(my_button_popup_cb, this);
			popup->browser->add("Assign Shortcut", this);

			popup->Fit();
			popup->resize(Fl::event_x_root(), Fl::event_y_root(), popup->w(), popup->h());
			popup->set_modal();
			Fl_Group *grp = Fl_Group::current();
			Fl_Group::current(0);
			popup->show();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Light_Button::handle(event);
	}
	return(flag);
}

MyRepeatButton::MyRepeatButton(int xx, int yy, int ww, int hh, char *lbl) : Fl_Repeat_Button(xx, yy, ww, hh, lbl)
{
	strcpy(path, "");
}

MyRepeatButton::~MyRepeatButton()
{
}

int	MyRepeatButton::handle(int event)
{
	int flag = 0;
	if(event == FL_SHOW)
	{
		if(strlen(path) < 1)
		{
			create_path_to_widget(this, path);
			if(strlen(path) > 0)
			{
				int nn = scan_paths_for_shortcut(path);
				if(nn != 0)
				{
					shortcut(nn);
				}
			}
		}
	}
	else if(event == FL_PUSH)
	{
		if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
		{
			popup = new PopupMenu(x(), y(), 160, 300);
			popup->browser->callback(my_button_popup_cb, this);
			popup->browser->add("Assign Shortcut", this);

			popup->Fit();
			popup->resize(Fl::event_x_root(), Fl::event_y_root(), popup->w(), popup->h());
			popup->set_modal();
			Fl_Group *grp = Fl_Group::current();
			Fl_Group::current(0);
			popup->show();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Repeat_Button::handle(event);
	}
	return(flag);
}

MyFileImageButton::MyFileImageButton(int xx, int yy, int ww, int hh, char *lbl) : Fl_Button(xx, yy, ww, hh, lbl)
{
}

MyFileImageButton::~MyFileImageButton()
{
}

void	MyFileImageButton::draw()
{
	fl_push_clip(x(), y(), w(), h());
	Fl_Button::draw();
	if(mat.empty())
	{
		char *filename = (char *)label();
		get_file_thumbnail(mat, filename, w() - 4);
	}
	if(!mat.empty())
	{
		fl_draw_image(mat.ptr(), x() + 2, y() + 2, mat.cols, mat.rows - 10, mat.channels());
	}
	fl_pop_clip();
}

MyImageButton::MyImageButton(Mat& in_mat, int xx, int yy, int ww, int hh, char *lbl) : Fl_Button(xx, yy, ww, hh, lbl)
{
	mat = in_mat.clone();
}

MyImageButton::~MyImageButton()
{
}

void	MyImageButton::draw()
{
	fl_push_clip(x(), y(), w(), h());
	Fl_Button::draw();
	if(!mat.empty())
	{
		fl_draw_image(mat.ptr(), x(), y(), mat.cols, mat.rows, mat.channels());
		fl_color(WHITE);
		fl_draw(label(), x() + 10, y() + (h() - 20), w(), 20, FL_ALIGN_LEFT);
	}
	fl_pop_clip();
}

// SECTION *********************************** SELECT BUTTON *******************************************

void	select_button_prev_cb(Fl_Widget *w, void *v)
{
	SelectButton *b = (SelectButton *)v;
	b->Prev();
	b->do_callback(NULL, b->user_data());
}

void	select_button_next_cb(Fl_Widget *w, void *v)
{
	SelectButton *b = (SelectButton *)v;
	b->Next();
	b->do_callback(NULL, b->user_data());
}

SelectButton::SelectButton(int xx, int yy, int ww, int hh, char *lbl) : Fl_Group(xx, yy, ww, hh, lbl)
{
int	loop;

	total = 0;
	current = 0;
	for(loop = 0;loop < 128;loop++)
	{
		list[loop] = NULL;
	}
	prev = new MyButton(xx, yy + 4, 8, 8, "@<");
	prev->box(box());
	prev->color(BLACK);
	prev->labelcolor(LIGHT_GRAY);
	prev->labelsize(8);
	prev->callback(select_button_prev_cb, this);

	value_box = new Fl_Box(xx + 8, yy, ww - 16, 18);
	value_box->box(box());
	value_box->color(BLACK);
	value_box->labelcolor(WHITE);
	value_box->labelsize(11);
	value_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	next = new MyButton(ww - 8, yy + 4, 8, 8, "@>");
	next->box(box());
	next->color(BLACK);
	next->labelcolor(LIGHT_GRAY);
	next->labelsize(8);
	next->callback(select_button_next_cb, this);
	end();
}

SelectButton::~SelectButton()
{
int	loop;

	for(loop = 0;loop < total;loop++)
	{
		if(list[loop] != NULL)
		{
			free(list[loop]);
		}
	}
}

void	SelectButton::Add(char *str)
{
	if(total < 128)
	{
		list[total] = strdup(str);
		if(total == 0)
		{
			value_box->copy_label(list[total]);
		}
		total++;
	}
}

void	SelectButton::SetCurrent(int nn)
{
	if(nn < 0) nn = total - 1;
	if(nn >= total) nn = 0;
	if((nn > -1) && (nn < total))
	{
		if(list[nn] != NULL)
		{
			value_box->copy_label(list[nn]);
			current = nn;
		}
		value_box->redraw();
	}
}

void	SelectButton::Next()
{
	SetCurrent(current + 1);
}

void	SelectButton::Prev()
{
	SetCurrent(current - 1);
}

// SECTION *********************************** DRAG WINDOW *******************************************

DragWindow::DragWindow(int ww, int hh) : Fl_Double_Window(ww, hh)
{
	last_x = 0;
	last_y = 0;
	border(0);
	set_non_modal();
	box(FL_FRAME_BOX);
	color(BLACK);
}

DragWindow::DragWindow(int ww, int hh, char *lbl) : Fl_Double_Window(ww, hh, lbl)
{
	last_x = 0;
	last_y = 0;
	border(0);
	box(FL_FRAME_BOX);
	color(BLACK);
}

DragWindow::DragWindow(int xx, int yy, int ww, int hh) : Fl_Double_Window(xx, yy, ww, hh)
{
	last_x = 0;
	last_y = 0;
	border(0);
	box(FL_FRAME_BOX);
	color(BLACK);
}

DragWindow::DragWindow(int xx, int yy, int ww, int hh, char *lbl) : Fl_Double_Window(xx, yy, ww, hh, lbl)
{
	last_x = 0;
	last_y = 0;
	border(0);
	box(FL_FRAME_BOX);
	color(BLACK);
}

DragWindow::~DragWindow()
{
}

int	DragWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		last_x = Fl::event_x_root();
		last_y = Fl::event_y_root();
	}
	else if(event == FL_DRAG)
	{
		int xx = Fl::event_x_root();
		int yy = Fl::event_y_root();
		int dx = last_x - xx;
		int dy = last_y - yy;
		resize(x() - dx, y() - dy, w(), h());
		last_x = xx;
		last_y = yy;
		flag = 1;
	}
	else if(event == FL_FOCUS)
	{
		flag = 1;
	}
	else if(event == FL_UNFOCUS)
	{
		flag = 1;
	}
	else if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == FL_Escape)
		{
			hide();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
		if(flag == 0)
		{
			if(event == FL_PUSH)
			{
				flag = 1;
			}
		}
	}
	return(flag);
}

void	dialog_common(Dialog *dialog, char *lbl)
{
	dialog->title_box = new Fl_Box(2, 2, dialog->w() - 4, 18);
	dialog->title_box->box(FL_FLAT_BOX);
	dialog->title_box->color(BLACK);
	dialog->title_box->labelcolor(WHITE);
	dialog->title_box->labelsize(11);
	dialog->title_box->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	dialog->title_box->copy_label(lbl);

	dialog->close = new MyButton(dialog->w() - 60, 2, 60, 18, "Close");
	dialog->close->box(FL_NO_BOX);
	dialog->close->color(BLACK);
	dialog->close->labelcolor(YELLOW);
	dialog->close->labelsize(9);
	dialog->close->callback(hide_window_cb, dialog);
	if(dialog->w() < 160)
	{
		dialog->close->hide();
	}
	dialog->expanded = 1;
	dialog->old_w = dialog->w();
	dialog->old_h = dialog->h();
}

Dialog::Dialog(int ww, int hh, char *lbl) : DragWindow(ww, hh + 20)
{
	dialog_common(this, lbl);
}

Dialog::Dialog(int xx, int yy, int ww, int hh, char *lbl) : DragWindow(xx, yy, ww, hh + 20)
{
	dialog_common(this, lbl);
}

Dialog::~Dialog()
{
}

void	Dialog::resize(int xx, int yy, int ww, int hh)
{
	title_box->resize(title_box->x(), title_box->y(), ww - 4, title_box->h());
	DragWindow::resize(xx, yy, ww, hh);
	if(w() >= 160)
	{
		close->show();
	}
	else
	{
		close->hide();
	}
	close->resize(w() - 60, close->y(), close->w(), close->h());
	close->redraw();
}

void	Dialog::draw()
{
	DragWindow::draw();
}

int	Dialog::handle(int event)
{
	int flag = 0;
	if(event == FL_MOUSEWHEEL)
	{
		if(Fl::event_inside(title_box))
		{
			int direction = Fl::event_dy();
			if(direction > 0)
			{
				if(expanded == 1)
				{
					old_w = w();
					old_h = h();
					expanded = 0;
					resize(x(), y(), w(), title_box->h() + 2);
					title_box->box(FL_FRAME_BOX);
					box(FL_FLAT_BOX);
					redraw();
				}
				else
				{
					resize(x(), 0, w(), h());
				}
				flag = 1;
			}
			else
			{
				if(expanded == 0)
				{
					expanded = 1;
					resize(x(), y(), w(), old_h);
					title_box->box(FL_FLAT_BOX);
					box(FL_FRAME_BOX);
					redraw();
				}
				else
				{
					old_w = w();
					old_h = h();
					expanded = 0;
					resize(x(), Fl::h() - title_box->h() + 2, w(), title_box->h() + 2);
					title_box->box(FL_FRAME_BOX);
					box(FL_FLAT_BOX);
					redraw();
				}
				flag = 1;
			}
		}
	}
	if(flag == 0)
	{
		flag = DragWindow::handle(event);
	}
	return(flag);
}

// SECTION *********************************** DRAG GROUP *******************************************

DragGroup::DragGroup(int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	last_x = 0;
	last_y = 0;
	box(FL_FRAME_BOX);
	color(BLACK);
}

DragGroup::DragGroup(int xx, int yy, int ww, int hh, char *lbl) : Fl_Group(xx, yy, ww, hh, lbl)
{
	last_x = 0;
	last_y = 0;
	box(FL_FRAME_BOX);
	color(BLACK);
}

DragGroup::~DragGroup()
{
}

int	DragGroup::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		last_x = Fl::event_x_root();
		last_y = Fl::event_y_root();
	}
	else if(event == FL_DRAG)
	{
		int xx = Fl::event_x_root();
		int yy = Fl::event_y_root();
		int dx = last_x - xx;
		int dy = last_y - yy;
		resize(x() - dx, y() - dy, w(), h());
		last_x = xx;
		last_y = yy;
		flag = 1;
	}
	else if(event == FL_FOCUS)
	{
		flag = 1;
	}
	else if(event == FL_UNFOCUS)
	{
		flag = 1;
	}
	else if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == FL_Escape)
		{
			hide();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Group::handle(event);
		if(flag == 0)
		{
			if(event == FL_PUSH)
			{
				flag = 1;
			}
		}
	}
	return(flag);
}

// SECTION *********************************** POPUP MENU *******************************************

PopupMenu::PopupMenu(int xx, int yy, int ww, int hh) : Fl_Window(xx, yy, ww, hh)
{
	box(FL_FRAME_BOX);
	color(BLACK);
	border(0);
	
	browser = new Fl_Hold_Browser(4, 4, ww, hh);
	browser->box(FL_FLAT_BOX);
	browser->color(BLACK);
	browser->textsize(9);
	browser->textcolor(WHITE);
	browser->has_scrollbar(0);
	end();
}

PopupMenu::~PopupMenu()
{
}

int	PopupMenu::handle(int event)
{
	int flag = 0;
	if(event == FL_ENTER)
	{
		flag = 1;
	}
	else if(event == FL_LEAVE)
	{
		hide();
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	PopupMenu::Resize(int xx, int yy, int ww, int hh)
{
	Fl_Window::resize(xx, yy, ww, hh);
	browser->resize(0, 0, ww, hh);
}

void	PopupMenu::Fit()
{
	int nn = browser->size();
	fl_font(FL_HELVETICA, 9);
	int ww = 0;
	int hh = 0;
	fl_measure("Hello", ww, hh);
	int sz = nn * hh;
	browser->resize(4, 4, browser->w(), sz);
	resize(x(), y(), w() + 8, sz + 8);
}

// SECTION *********************************** DRAG BOX AND ARRANGE GROUP *******************************************

DragBox::DragBox(MyGroup **in_parent_list, int in_parent_cnt, int xx, int yy, int ww, int hh, char *lbl) : Fl_Box(xx, yy, ww, hh, lbl)
{
	parent_list = in_parent_list;
	parent_cnt = in_parent_cnt;
	last_x = 0;
	last_y = 0;
	old_parent = NULL;
	index = -1;
}

DragBox::~DragBox()
{
}

int	DragBox::handle(int event)
{
int	loop;

	int flag = 0;
	if(event == FL_PUSH)
	{
		last_x = Fl::event_x_root();
		last_y = Fl::event_y_root();
	}
	else if(event == FL_DRAG)
	{
		if(parent() != window())
		{
			if(window() != NULL)
			{
				old_parent = (MyGroup *)parent();
				window()->add(this);
			}
		}
		int xx = Fl::event_x_root();
		int yy = Fl::event_y_root();
		int dx = last_x - xx;
		int dy = last_y - yy;
		resize(x() - dx, y() - dy, w(), h());
		redraw();
		if(window() != NULL)
		{
			window()->redraw();
		}
		last_x = xx;
		last_y = yy;
		flag = 1;
	}
	else if(event == FL_RELEASE)
	{
		int added = 0;
		for(loop = 0;loop < parent_cnt;loop++)
		{
			if(Fl::event_inside(parent_list[loop]))
			{
				ArrangeGroup *ag = (ArrangeGroup *)parent_list[loop];
				ag->add(this);
				added = 1;
			}
		}
		if(added == 0)
		{
			if(old_parent != NULL)
			{
				ArrangeGroup *ag = (ArrangeGroup *)old_parent;
				ag->add(this);
				ag->redraw();
			}
		}
		window()->redraw();
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Box::handle(event);
		if(flag == 0)
		{
			if(event == FL_PUSH)
			{
				flag = 1;
			}
		}
	}
	return(flag);
}

ArrangeGroup::ArrangeGroup(Fl_Scroll *in_scroll, int in_item_h, int xx, int yy, int ww, int hh, char *lbl) : MyGroup(xx, yy, ww, hh, lbl)
{
	scroll = in_scroll;
	item_h = in_item_h;
	limit = 32768;
}

void	ArrangeGroup::add(Fl_Widget *in_wid)
{
int	loop;

	DragBox *wid = (DragBox *)in_wid;
	if(scroll == NULL)
	{
		MyGroup::add(wid);
		int accum = 0;
		for(loop = 0;loop < children();loop++)
		{
			Fl_Widget *chld = child(loop);
			if(chld != NULL)
			{
				int y_pos = y() + accum;
				chld->resize(x(), y_pos, chld->w(), chld->h());
				chld->redraw();
				accum += item_h;
			}
		}
	}
	else
	{
		int y_pos = round((double)(wid->y() - y()) / (double)item_h);
		if(y_pos < 0) y_pos = 0;
		if(y_pos >= limit) y_pos = limit - 1;
		wid->index = y_pos;
		y_pos *= item_h;
		wid->resize(x(), y_pos + y(), wid->w(), wid->h());
		MyGroup::add(wid);
	}
	redraw();
	window()->redraw();
}

// SECTION *********************************** IMMEDIATE DRAWING WINDOW *******************************************

void	immediate_drawing_mode_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *id = (ImmediateDrawingWindow *)v;
	MyWin *win = id->my_window;
	Camera *cam = win->DisplayedCamera();

	id->general->labelcolor(YELLOW);
	id->text->labelcolor(YELLOW);
	id->line->labelcolor(YELLOW);
	id->rectangle->labelcolor(YELLOW);
	id->ellipse->labelcolor(YELLOW);
	id->image_im->labelcolor(YELLOW);
	id->polygon->labelcolor(YELLOW);
	id->loop->labelcolor(YELLOW);
	id->freehand->labelcolor(YELLOW);
	id->pixelate->labelcolor(YELLOW);
	id->passthru_rectangle->labelcolor(YELLOW);
	id->passthru_ellipse->labelcolor(YELLOW);
	id->passthru_polygon->labelcolor(YELLOW);
	id->delete_im->labelcolor(YELLOW);
	id->hide_im->labelcolor(YELLOW);
	id->hide_all->labelcolor(YELLOW);
	id->show_all->labelcolor(YELLOW);

	if(w == id->general)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_GENERAL)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->general->labelcolor(CYAN);
			id->mode = DRAWING_MODE_GENERAL;
			id->ClearSelectedWidget();
			id->GeneralSetup();
		}
	}
	else if(w == id->text)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_TEXT)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->text->labelcolor(CYAN);
			id->mode = DRAWING_MODE_TEXT;
			id->ClearSelectedWidget();
			id->TextSetup();
		}
	}
	else if(w == id->line)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_LINE)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->line->labelcolor(CYAN);
			id->mode = DRAWING_MODE_LINE;
			id->ClearSelectedWidget();
			id->LineSetup();
		}
	}
	else if(w == id->polygon)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_POLYGON)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->polygon->labelcolor(CYAN);
			id->mode = DRAWING_MODE_POLYGON;
			id->ClearSelectedWidget();
			id->LineSetup();
		}
	}
	else if(w == id->passthru_polygon)
	{
		win->im_drawing_mode = 1;
		id->passthru_polygon->labelcolor(CYAN);
		id->mode = DRAWING_MODE_POLYGON_PASSTHRU;
		id->CloseAll();
		id->ClearSelectedWidget();
		id->resize(id->x(), id->y(), 120, id->orig_h);
	}
	else if(w == id->loop)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_LOOP)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->loop->labelcolor(CYAN);
			id->mode = DRAWING_MODE_LOOP;
			id->ClearSelectedWidget();
			id->LineSetup();
		}
	}
	else if(w == id->rectangle)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_RECTANGLE)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->rectangle->labelcolor(CYAN);
			id->mode = DRAWING_MODE_RECTANGLE;
			id->ClearSelectedWidget();
			id->RectangleSetup();
		}
	}
	else if(w == id->pixelate)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_PIXELATE)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->pixelate->labelcolor(CYAN);
			id->mode = DRAWING_MODE_PIXELATE;
			id->ClearSelectedWidget();
			id->PixelateSetup();
		}
	}
	else if(w == id->image_im)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_IMAGE)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->image_im->labelcolor(CYAN);
			id->mode = DRAWING_MODE_IMAGE;
			id->ClearSelectedWidget();
			id->ImageSetup();
		}
	}
	else if(w == id->ellipse)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_ELLIPSE)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->ellipse->labelcolor(CYAN);
			id->mode = DRAWING_MODE_ELLIPSE;
			id->ClearSelectedWidget();
			id->RectangleSetup();
		}
	}
	else if(w == id->freehand)
	{
		id->CloseAll();
		if(id->mode == DRAWING_MODE_FREEHAND)
		{
			id->mode = DRAWING_MODE_NONE;
		}
		else
		{
			win->im_drawing_mode = 1;
			id->freehand->labelcolor(CYAN);
			id->mode = DRAWING_MODE_FREEHAND;
			id->ClearSelectedWidget();
			id->FreehandSetup();
		}
	}
	else if(w == id->passthru_rectangle)
	{
		win->im_drawing_mode = 1;
		id->passthru_rectangle->labelcolor(CYAN);
		id->mode = DRAWING_MODE_RECTANGLE_PASSTHRU;
		id->CloseAll();
		id->ClearSelectedWidget();
		id->resize(id->x(), id->y(), 120, id->orig_h);
	}
	else if(w == id->passthru_ellipse)
	{
		win->im_drawing_mode = 1;
		id->passthru_ellipse->labelcolor(CYAN);
		id->mode = DRAWING_MODE_ELLIPSE_PASSTHRU;
		id->CloseAll();
		id->ClearSelectedWidget();
		id->resize(id->x(), id->y(), 120, id->orig_h);
	}
	else if(w == id->delete_im)
	{
		win->im_drawing_mode = 1;
		id->delete_im->labelcolor(CYAN);
		id->CloseAll();
		id->mode = DRAWING_MODE_DELETE;
		id->ClearSelectedWidget();
		id->resize(id->x(), id->y(), 120, id->orig_h);
	}
	else if(w == id->hide_im)
	{
		win->im_drawing_mode = 1;
		id->hide_im->labelcolor(CYAN);
		id->CloseAll();
		id->mode = DRAWING_MODE_HIDE;
		id->ClearSelectedWidget();
		id->resize(id->x(), id->y(), 120, id->orig_h);
	}
	else if(w == id->hide_all)
	{
		win->im_drawing_mode = 1;
		id->CloseAll();
		id->mode = DRAWING_MODE_HIDE_ALL;
		id->ClearSelectedWidget();
		id->resize(id->x(), id->y(), 120, id->orig_h);
		Camera *cam = id->my_window->DisplayedCamera();
		if(cam->immediate_list != NULL)
		{
			int loop;
			for(loop = 0;loop < cam->immediate_cnt;loop++)
			{
				if(cam->immediate_list[loop] != NULL)
				{
					cam->immediate_list[loop]->Hide();
				}
			}
		}
	}
	else if(w == id->show_all)
	{
		win->im_drawing_mode = 1;
		id->CloseAll();
		id->mode = DRAWING_MODE_SHOW_ALL;
		id->ClearSelectedWidget();
		id->resize(id->x(), id->y(), 120, id->orig_h);
		Camera *cam = id->my_window->DisplayedCamera();
		if(cam->immediate_list != NULL)
		{
			int loop;
			for(loop = 0;loop < cam->immediate_cnt;loop++)
			{
				if(cam->immediate_list[loop] != NULL)
				{
					cam->immediate_list[loop]->Show();
				}
			}
		}
	}
	id->redraw();
}

void	drawing_font_selection_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hold_Browser *hold = (Fl_Hold_Browser *)w;
	char *str = (char *)hold->text(hold->value());
	if(str != NULL)
	{
		char *font_name = str;
		if(strlen(str) > 7)
		{
			font_name = str + 7;
		}
		idw->font_num = (int)(long int)hold->data(hold->value());
		strcpy(idw->selected_font, font_name);
		idw->font_output->copy_label(font_name);
		idw->font_output->labelfont(idw->font_num);
		idw->font_sample->labelfont(idw->font_num);
		idw->font_sample->redraw();
		if(idw->selected_widget != NULL)
		{
			if(idw->selected_widget->text != NULL)
			{
				idw->selected_widget->text->textfont(idw->font_num);
				strncpy(idw->selected_widget->text->font_name, font_name, 128);
				idw->selected_widget->redraw();
			}
		}
	}
}

void	drawing_font_color_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	int use = 255;
	if(slider == idw->font_red_slider)
	{
		if(idw->using_background_color == 2)
		{
			idw->outline_color_red = (int)slider->value();
			use = idw->outline_color_red;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_red = (int)slider->value();
			use = idw->back_color_red;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_red = (int)slider->value();
			use = idw->font_color_red;
		}
		sprintf(buf, "%3d", use);
		idw->font_red_output->value(buf);
	}
	else if(slider == idw->font_green_slider)
	{
		if(idw->using_background_color == 2)
		{
			idw->outline_color_green = (int)slider->value();
			use = idw->outline_color_green;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_green = (int)slider->value();
			use = idw->back_color_green;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_green = (int)slider->value();
			use = idw->font_color_green;
		}
		sprintf(buf, "%3d", use);
		idw->font_green_output->value(buf);
	}
	else if(slider == idw->font_blue_slider)
	{
		if(idw->using_background_color == 2)
		{
			idw->outline_color_blue = (int)slider->value();
			use = idw->outline_color_blue;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_blue = (int)slider->value();
			use = idw->back_color_blue;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_blue = (int)slider->value();
			use = idw->font_color_blue;
		}
		sprintf(buf, "%3d", use);
		idw->font_blue_output->value(buf);
	}
	else if(slider == idw->font_alpha_slider)
	{
		if(idw->using_background_color == 2)
		{
			idw->outline_color_alpha = (int)slider->value();
			use = idw->outline_color_alpha;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_alpha = (int)slider->value();
			use = idw->back_color_alpha;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_alpha = (int)slider->value();
			use = idw->font_color_alpha;
		}
		sprintf(buf, "%3d", use);
		idw->font_alpha_output->value(buf);
	}
	else if(slider == NULL)
	{
		int use = 0;
		if(idw->using_background_color == 2)
		{
			idw->outline_color_red = (int)idw->font_red_slider->value();
			use = idw->outline_color_red;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_red = (int)idw->font_red_slider->value();
			use = idw->back_color_red;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_red = (int)idw->font_red_slider->value();
			use = idw->font_color_red;
		}
		sprintf(buf, "%3d", use);
		idw->font_red_output->value(buf);

		if(idw->using_background_color == 2)
		{
			idw->outline_color_green = (int)idw->font_green_slider->value();
			use = idw->outline_color_green;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_green = (int)idw->font_green_slider->value();
			use = idw->back_color_green;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_green = (int)idw->font_green_slider->value();
			use = idw->font_color_green;
		}
		sprintf(buf, "%3d", use);
		idw->font_green_output->value(buf);

		if(idw->using_background_color == 2)
		{
			idw->outline_color_blue = (int)idw->font_blue_slider->value();
			use = idw->outline_color_blue;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_blue = (int)idw->font_blue_slider->value();
			use = idw->back_color_blue;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_blue = (int)idw->font_blue_slider->value();
			use = idw->font_color_blue;
		}
		sprintf(buf, "%3d", use);
		idw->font_blue_output->value(buf);

		if(idw->using_background_color == 2)
		{
			idw->outline_color_alpha = (int)idw->font_alpha_slider->value();
			use = idw->outline_color_alpha;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_alpha = (int)idw->font_alpha_slider->value();
			use = idw->back_color_alpha;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_alpha = (int)idw->font_alpha_slider->value();
			use = idw->font_color_alpha;
		}
		sprintf(buf, "%3d", use);
		idw->font_alpha_output->value(buf);
	}
	if(idw->using_background_color == 2)
	{
		idw->font_sample->color(fl_rgb_color(idw->outline_color_red, idw->outline_color_green, idw->outline_color_blue));
		idw->font_sample->redraw();
	}
	else if(idw->using_background_color == 1)
	{
		idw->font_sample->color(fl_rgb_color(idw->back_color_red, idw->back_color_green, idw->back_color_blue));
		idw->font_sample->redraw();
		if(idw->selected_widget != NULL)
		{
			if(idw->selected_widget->text != NULL)
			{
				idw->selected_widget->text->color(fl_rgb_color(idw->back_color_red, idw->back_color_green, idw->back_color_blue));
				idw->selected_widget->text->background_red = idw->back_color_red;
				idw->selected_widget->text->background_green = idw->back_color_green;
				idw->selected_widget->text->background_blue = idw->back_color_blue;
				idw->selected_widget->text->background_alpha = idw->back_color_alpha;
				idw->selected_widget->redraw();
			}
		}
	}
	else
	{
		idw->font_sample->labelcolor(fl_rgb_color(idw->font_color_red, idw->font_color_green, idw->font_color_blue));
		idw->font_sample->redraw();
		if(idw->selected_widget != NULL)
		{
			if(idw->selected_widget->text != NULL)
			{
				idw->selected_widget->text->textcolor(fl_rgb_color(idw->font_color_red, idw->font_color_green, idw->font_color_blue));
				idw->selected_widget->text->red = idw->font_color_red;
				idw->selected_widget->text->green = idw->font_color_green;
				idw->selected_widget->text->blue = idw->font_color_blue;
				idw->selected_widget->text->font_alpha = idw->font_color_alpha;
				idw->selected_widget->redraw();
			}
		}
	}
}

void	drawing_line_color_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	if(slider == idw->line_red_slider)
	{
		idw->line_color_red = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_red);
		idw->line_red_output->value(buf);
	}
	else if(slider == idw->line_green_slider)
	{
		idw->line_color_green = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_green);
		idw->line_green_output->value(buf);
	}
	else if(slider == idw->line_blue_slider)
	{
		idw->line_color_blue = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_blue);
		idw->line_blue_output->value(buf);
	}
	else if(slider == idw->line_alpha_slider)
	{
		idw->line_color_alpha = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_alpha);
		idw->line_alpha_output->value(buf);
	}
	else
	{
		idw->line_color_red = (int)idw->line_red_slider->value();
		sprintf(buf, "%3d", idw->line_color_red);
		idw->line_red_output->value(buf);

		idw->line_color_green = (int)idw->line_green_slider->value();
		sprintf(buf, "%3d", idw->line_color_green);
		idw->line_green_output->value(buf);

		idw->line_color_blue = (int)idw->line_blue_slider->value();
		sprintf(buf, "%3d", idw->line_color_blue);
		idw->line_blue_output->value(buf);

		idw->line_color_alpha = (int)idw->line_alpha_slider->value();
		sprintf(buf, "%3d", idw->line_color_alpha);
		idw->line_alpha_output->value(buf);
	}
	idw->line_sample->labelcolor(fl_rgb_color(idw->line_color_red, idw->line_color_green, idw->line_color_blue));
	idw->line_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->line != NULL)
		{
			idw->selected_widget->line->red = idw->line_color_red;
			idw->selected_widget->line->green = idw->line_color_green;
			idw->selected_widget->line->blue = idw->line_color_blue;
			idw->selected_widget->line->alpha = idw->line_color_alpha;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_rectangle_color_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	if(slider == idw->rectangle_red_slider)
	{
		idw->rectangle_color_red = (int)slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_red);
		idw->rectangle_red_output->value(buf);
	}
	else if(slider == idw->rectangle_green_slider)
	{
		idw->rectangle_color_green = (int)slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_green);
		idw->rectangle_green_output->value(buf);
	}
	else if(slider == idw->rectangle_blue_slider)
	{
		idw->rectangle_color_blue = (int)slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_blue);
		idw->rectangle_blue_output->value(buf);
	}
	else if(slider == idw->rectangle_alpha_slider)
	{
		idw->rectangle_color_alpha = (int)slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_alpha);
		idw->rectangle_alpha_output->value(buf);
	}
	else
	{
		idw->rectangle_color_red = (int)idw->rectangle_red_slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_red);
		idw->rectangle_red_output->value(buf);

		idw->rectangle_color_green = (int)idw->rectangle_green_slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_green);
		idw->rectangle_green_output->value(buf);

		idw->rectangle_color_blue = (int)idw->rectangle_blue_slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_blue);
		idw->rectangle_blue_output->value(buf);

		idw->rectangle_color_alpha = (int)idw->rectangle_alpha_slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_alpha);
		idw->rectangle_alpha_output->value(buf);
	}
	idw->rectangle_sample->labelcolor(fl_rgb_color(idw->rectangle_color_red, idw->rectangle_color_green, idw->rectangle_color_blue));
	idw->rectangle_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if((idw->selected_widget->rectangle != NULL) && (idw->mode == DRAWING_MODE_RECTANGLE))
		{
			idw->selected_widget->rectangle->red = idw->rectangle_color_red;
			idw->selected_widget->rectangle->green = idw->rectangle_color_green;
			idw->selected_widget->rectangle->blue = idw->rectangle_color_blue;
			idw->selected_widget->rectangle->alpha = idw->rectangle_color_alpha;
			idw->selected_widget->redraw();
		}
		else if((idw->selected_widget->ellipse != NULL) && (idw->mode == DRAWING_MODE_ELLIPSE))
		{
			idw->selected_widget->ellipse->red = idw->rectangle_color_red;
			idw->selected_widget->ellipse->green = idw->rectangle_color_green;
			idw->selected_widget->ellipse->blue = idw->rectangle_color_blue;
			idw->selected_widget->ellipse->alpha = idw->rectangle_color_alpha;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_freehand_color_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	if(slider == idw->freehand_red_slider)
	{
		idw->line_color_red = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_red);
		idw->freehand_red_output->value(buf);
	}
	else if(slider == idw->freehand_green_slider)
	{
		idw->line_color_green = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_green);
		idw->freehand_green_output->value(buf);
	}
	else if(slider == idw->freehand_blue_slider)
	{
		idw->line_color_blue = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_blue);
		idw->freehand_blue_output->value(buf);
	}
	else
	{
		idw->line_color_red = (int)idw->freehand_red_slider->value();
		sprintf(buf, "%3d", idw->line_color_red);
		idw->freehand_red_output->value(buf);

		idw->line_color_green = (int)idw->freehand_green_slider->value();
		sprintf(buf, "%3d", idw->line_color_green);
		idw->freehand_green_output->value(buf);

		idw->line_color_blue = (int)idw->freehand_blue_slider->value();
		sprintf(buf, "%3d", idw->line_color_blue);
		idw->freehand_blue_output->value(buf);
	}
	idw->freehand_sample->labelcolor(fl_rgb_color(idw->line_color_red, idw->line_color_green, idw->line_color_blue));
	idw->freehand_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->freehand != NULL)
		{
			idw->selected_widget->freehand->red = idw->line_color_red;
			idw->selected_widget->freehand->green = idw->line_color_green;
			idw->selected_widget->freehand->blue = idw->line_color_blue;
			idw->selected_widget->freehand->alpha = idw->line_color_alpha;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_font_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->font_size = (int)slider->value();
	idw->font_sample->labelsize(idw->font_size);
	sprintf(buf, "%3d", idw->font_size);
	idw->font_size_output->value(buf);
	idw->font_size_output->redraw();
	idw->font_sample->redraw();
	idw->text_group->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->text != NULL)
		{
			idw->selected_widget->text->textsize(idw->font_size);
			idw->selected_widget->text->use_size = idw->font_size;
			idw->selected_widget->text->redraw();
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_line_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->line_size = (int)slider->value();
	idw->line_sample->labelsize(idw->line_size);
	idw->line_sample->redraw();
	sprintf(buf, "%3d", idw->line_size);
	idw->line_size_output->value(buf);
	idw->line_size_output->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->line != NULL)
		{
			idw->selected_widget->line->width = idw->line_size;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_rectangle_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->rectangle_size = (int)slider->value();
	idw->rectangle_sample->labelsize(idw->rectangle_size);
	idw->rectangle_sample->redraw();
	sprintf(buf, "%3d", idw->rectangle_size);
	idw->rectangle_size_output->value(buf);
	idw->rectangle_size_output->redraw();
	if(idw->selected_widget != NULL)
	{
		if((idw->selected_widget->rectangle != NULL) && (idw->mode == DRAWING_MODE_RECTANGLE))
		{
			idw->selected_widget->rectangle->width = idw->rectangle_size;
			idw->selected_widget->rectangle->redraw();
			idw->selected_widget->redraw();
		}
		else if((idw->selected_widget->ellipse != NULL) && (idw->mode == DRAWING_MODE_ELLIPSE))
		{
			idw->selected_widget->ellipse->width = idw->rectangle_size;
			idw->selected_widget->ellipse->redraw();
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_freehand_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->line_size = (int)slider->value();
	idw->freehand_sample->labelsize(idw->line_size);
	idw->freehand_sample->redraw();
	sprintf(buf, "%3d", idw->line_size);
	idw->freehand_size_output->value(buf);
	idw->freehand_size_output->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->freehand != NULL)
		{
			idw->selected_widget->freehand->width = idw->line_size;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_pixelate_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->pixelate_size = (int)slider->value();
	sprintf(buf, "%3d", idw->pixelate_size);
	idw->pixelate_size_output->value(buf);
	idw->pixelate_size_output->redraw();

	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->pixelate != NULL)
		{
			idw->selected_widget->pixelate->use_size = idw->pixelate_size;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_pixelate_mode_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int shape = 0;
	if(idw->pixelate_pixelate_button->value()) shape = PIXELATE_MODE_PIXELATE;
	if(idw->pixelate_blur_button->value()) shape = PIXELATE_MODE_BLUR;
	idw->line_style = shape;
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->pixelate != NULL)
		{
			idw->selected_widget->pixelate->style = idw->line_style;
			idw->selected_widget->redraw();
		}
	}
}

LineSample::LineSample(ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh) : Fl_Box(xx, yy, ww, hh)
{
	idw = in_idw;
	line_style = 0;
}

LineSample::~LineSample()
{
}

void	LineSample::draw()
{
	fl_color(color());
	fl_rectf(x(), y(), w(), h());
	fl_push_clip(x() + 1, y() + 1, w() - 2, h() - 2);
	fl_color(labelcolor());
	int width = labelsize();

	int use_style  = line_style & ~(MY_CAP_ARROW | MY_TYPE_CURVES);
	fl_line_style(use_style, width, NULL);

	fl_begin_line();
	fl_vertex(x() + 12, y() + 4);
	fl_vertex(x() + 60, y() + 40);
	fl_vertex(x() + 19, y() + 70);
	fl_vertex(x() + 80, y() + 90);
	fl_end_line();
	fl_pop_clip();
	fl_line_style(FL_SOLID, 1, NULL);
}

FreehandSample::FreehandSample(ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh) : Fl_Box(xx, yy, ww, hh)
{
	idw = in_idw;
	line_style = FREEHAND_SHAPE_SQUARE;
	key = '/';
}

FreehandSample::~FreehandSample()
{
}

void	FreehandSample::draw()
{
char	buf[2];

	fl_color(color());
	fl_rectf(x(), y(), w(), h());
	fl_push_clip(x() + 1, y() + 1, w() - 2, h() - 2);
	fl_color(labelcolor());
	int width = labelsize();
	int cx = x() + (w() / 2);
	int cy = y() + (h() / 2);
	if(line_style == FREEHAND_SHAPE_SQUARE)
	{
		fl_rectf(cx - (width / 2), cy - (width / 2), width, width);
	}
	else if(line_style == FREEHAND_SHAPE_CIRCLE)
	{
		fl_begin_polygon();
		fl_arc(cx, cy, (width / 2) + 1, 0.0, 359.9);
		fl_end_polygon();
	}
	else if(line_style == FREEHAND_SHAPE_STAMP)
	{
		if((freehand_mat.cols > 0) && (freehand_mat.rows > 0))
		{
			Mat local_mat;
			cv::resize(freehand_mat, local_mat, cv::Size(width, width));
			fl_draw_image(local_mat.ptr(), cx - (width / 2), cy - (width / 2), local_mat.cols, local_mat.rows, local_mat.channels());
		}
	}
	else if(line_style == FREEHAND_SHAPE_KEY)
	{
		buf[0] = key;
		buf[1] = '\0';
		fl_font(labelfont(), labelsize());
		fl_draw(buf, x(), y(), w(), h(), align());
	}
	fl_pop_clip();
}

RectangleSample::RectangleSample(ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh) : Fl_Box(xx, yy, ww, hh)
{
	idw = in_idw;
	line_style = 0;
}

RectangleSample::~RectangleSample()
{
}

void	RectangleSample::draw()
{
	fl_color(color());
	fl_rectf(x(), y(), w(), h());
	fl_push_clip(x() + 1, y() + 1, w() - 2, h() - 2);
	fl_color(labelcolor());
	int width = labelsize();
	fl_line_style(line_style, width, NULL);
	if(idw->mode == DRAWING_MODE_RECTANGLE)
	{
		if(idw->rectangle_filled == 0)
		{
			fl_rect(x() + 10, y() + 10, w() - 20, h() - 20);
		}
		else
		{
			fl_rectf(x() + 10, y() + 10, w() - 20, h() - 20);
		}
	}
	else if(idw->mode == DRAWING_MODE_ELLIPSE)
	{
		if(idw->rectangle_filled == 0)
		{
			fl_arc(x() + 10, y() + 10, w() - 20, h() - 20, 0, 359.99);
		}
		else
		{
			double nx = (double)(x() + (w() / 2));
			double ny = (double)(y() + (h() / 2));
			fl_begin_polygon();
			fl_arc(nx, ny, (double)((w() / 2) - 10), 0, 359.99);
			fl_end_polygon();
		}
	}
	else if(idw->mode == DRAWING_MODE_IMAGE)
	{
		if((idw->image_mat.cols > 0) && (idw->image_mat.rows > 0))
		{
			Mat local_mat;
			double scale = 1.0;
			int newWidth = w();
			int newHeight = h();
			if(idw->image_mat.cols > idw->image_mat.rows)
			{
				newWidth = w();
				newHeight = idw->image_mat.rows * newWidth / idw->image_mat.cols; 
			}
			else
			{
				newHeight = h();
				newWidth = idw->image_mat.cols * newHeight / idw->image_mat.rows; 
			}
			cv::resize(idw->image_mat, local_mat, cv::Size(newWidth, newHeight));
			fl_color(color());
			fl_rectf(x(), y(), w(), h());
			Fl_RGB_Image image(local_mat.ptr(), newWidth, newHeight, local_mat.channels());
			image.draw(x(), y(), newWidth, newHeight);
		}
	}
	fl_pop_clip();
	fl_line_style(FL_SOLID, 1, NULL);
}

FontSample::FontSample(ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh, char *lbl) : Fl_Box(xx, yy, ww, hh, lbl)
{
	idw = in_idw;
}

FontSample::~FontSample()
{
}

void	FontSample::draw()
{
	fl_color(color());
	fl_rectf(x(), y(), w(), h());
	fl_push_clip(x() + 1, y() + 1, w() - 2, h() - 2);
	fl_color(labelcolor());
	fl_font(labelfont(), labelsize());
	fl_draw(label(), x(), y(), w(), h(), align());
	fl_pop_clip();
}

void	line_style_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int style = 0;
	if(idw->line_style_solid_button->value()) style |= FL_SOLID;
	if(idw->line_style_dash_button->value()) style |= FL_DASH;
	if(idw->line_style_dot_button->value()) style |= FL_DOT;
	if(idw->line_style_flat_button->value()) style |= FL_CAP_FLAT;
	if(idw->line_style_round_button->value()) style |= FL_CAP_ROUND;
	if(idw->line_style_square_button->value()) style |= FL_CAP_SQUARE;
	if(idw->line_style_arrow_button->value()) style |= MY_CAP_ARROW;
	if(idw->line_style_join_miter_button->value()) style |= FL_JOIN_MITER;
	if(idw->line_style_join_round_button->value()) style |= FL_JOIN_ROUND;
	if(idw->line_style_join_bevel_button->value()) style |= FL_JOIN_BEVEL;
	if(idw->line_type_segments_button->value()) style &= ~MY_TYPE_CURVES;
	if(idw->line_type_curves_button->value()) style |= MY_TYPE_CURVES;
	idw->erase = idw->line_style_erase_button->value();
	idw->line_style = style;
	idw->line_sample->line_style = style;
	idw->line_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->line != NULL)
		{
			idw->selected_widget->line->style = idw->line_style;
			idw->selected_widget->redraw();
		}
	}
}

void	rectangle_style_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int style = 0;
	if(idw->rectangle_style_solid_button->value()) style |= FL_SOLID;
	if(idw->rectangle_style_dash_button->value()) style |= FL_DASH;
	if(idw->rectangle_style_dot_button->value()) style |= FL_DOT;
	if(idw->rectangle_style_join_miter_button->value()) style |= FL_JOIN_MITER;
	if(idw->rectangle_style_join_round_button->value()) style |= FL_JOIN_ROUND;
	if(idw->rectangle_style_join_bevel_button->value()) style |= FL_JOIN_BEVEL;
	idw->rectangle_filled = idw->rectangle_filled_button->value();
	idw->rectangle_square = idw->rectangle_square_button->value();
	idw->rectangle_erase = idw->rectangle_erase_button->value();
	idw->rectangle_style = style;
	idw->rectangle_sample->line_style = style;
	idw->rectangle_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if((idw->selected_widget->rectangle != NULL) && (idw->mode == DRAWING_MODE_RECTANGLE))
		{
			idw->selected_widget->rectangle->style = idw->rectangle_style;
			idw->selected_widget->rectangle->filled = idw->rectangle_filled;
			idw->selected_widget->rectangle->square = idw->rectangle_square;
			idw->selected_widget->rectangle->erase = idw->rectangle_erase;
			idw->selected_widget->redraw();
		}
		else if((idw->selected_widget->ellipse != NULL) && (idw->mode == DRAWING_MODE_ELLIPSE))
		{
			idw->selected_widget->ellipse->style = idw->rectangle_style;
			idw->selected_widget->ellipse->filled = idw->rectangle_filled;
			idw->selected_widget->ellipse->square = idw->rectangle_square;
			idw->selected_widget->ellipse->erase = idw->rectangle_erase;
			idw->selected_widget->redraw();
		}
	}
}

void	freehand_shape_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int shape = 0;
	if(idw->freehand_shape_square_button->value()) shape = FREEHAND_SHAPE_SQUARE;
	if(idw->freehand_shape_circle_button->value()) shape = FREEHAND_SHAPE_CIRCLE;
	if(idw->freehand_shape_erase_square_button->value()) shape = FREEHAND_SHAPE_ERASE_SQUARE;
	if(idw->freehand_shape_erase_circle_button->value()) shape = FREEHAND_SHAPE_ERASE_CIRCLE;
	if(idw->freehand_shape_stamp_button->value()) shape = FREEHAND_SHAPE_STAMP;
	if(idw->freehand_shape_key_button->value()) shape = FREEHAND_SHAPE_KEY;
	idw->line_style = shape;
	idw->freehand_sample->line_style = shape;
	idw->freehand_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->freehand != NULL)
		{
			idw->selected_widget->freehand->style = idw->line_style;
			idw->selected_widget->redraw();
		}
	}
}

void	freehand_shape_file_cb(Fl_Widget *w, void *v)
{
char	filename[4096];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int nn = my_file_chooser("Select an image file", "*.{png,jpg,jpeg,webp,tiff,tif,bmp}", "./", filename);
	if(nn > 0)
	{
		Mat local_mat = imread(filename, IMREAD_UNCHANGED);
		if(local_mat.channels() == 3)
		{
			cvtColor(local_mat, local_mat, COLOR_BGR2RGB);
		}
		else
		{
			cvtColor(local_mat, local_mat, COLOR_BGRA2RGBA);
		}
		idw->freehand_mat = local_mat;
		idw->freehand_sample->redraw();
		strcpy(idw->freehand_filename, filename);
	}
}

void	image_paste_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(idw->image_paste_button->value())
	{
		Fl::paste(*idw, 1, Fl::clipboard_image);
		idw->from_paste = 1;
	}
	else
	{
		idw->from_paste = 0;
	}
}

void	image_file_cb(Fl_Widget *w, void *v)
{
char	filename[4096];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int nn = 0;
	if(w == idw->image_file_button)
	{
		strcpy(filename, "");
		nn = my_file_chooser("Select an image file", "*.{png,jpg,jpeg,webp,tiff,tif,bmp}", "./", filename);
	}
	else
	{
		char *str = (char *)idw->image_file_path->value();
		if(str != NULL)
		{
			strcpy(filename, str);
			nn = 1;
		}
	}
	if(nn > 0)
	{
		Mat local_mat = imread(filename, IMREAD_UNCHANGED);
		if((local_mat.rows > 0) && (local_mat.cols > 0))
		{
			if(local_mat.channels() == 3)
			{
				cvtColor(local_mat, local_mat, COLOR_BGR2RGB);
			}
			else
			{
				cvtColor(local_mat, local_mat, COLOR_BGRA2RGBA);
			}
			idw->image_file_path->value(filename);
			idw->image_mat = local_mat;
			idw->image_sample->redraw();
			idw->redraw();
		}
	}
}

void	drawing_grid_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->grid_size = (int)slider->value();
	sprintf(buf, "%3d", idw->grid_size);
	idw->grid_size_output->value(buf);
	idw->grid_size_output->redraw();
}

void	text_color_selection_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(w == idw->text_foreground_color_button)
	{
		idw->using_background_color = 0;
	}
	else if(w == idw->text_background_color_button)
	{
		idw->using_background_color = 1;
	}
	else if(w == idw->text_outline_color_button)
	{
		idw->using_background_color = 2;
	}
}

void	drawing_text_box_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Choice *choice = (Fl_Choice *)w;
	char *str = (char *)choice->text();
	if(str != NULL)
	{
		Fl_Boxtype box_type = FL_NO_BOX;
		if(strcmp(str, "No Box") == 0)
		{
			box_type = FL_NO_BOX;
		}
		if(strcmp(str, "Flat Box") == 0)
		{
			box_type = FL_FLAT_BOX;
		}
		if(strcmp(str, "Frame") == 0)
		{
			box_type = FL_FRAME;
		}
		if(strcmp(str, "Framed Box") == 0)
		{
			box_type = FL_FRAME_BOX;
		}
		idw->text_box_type = box_type;
		idw->font_sample->box(box_type);
		idw->font_sample->redraw();
		if(idw->selected_widget != NULL)
		{
			if(idw->selected_widget->text != NULL)
			{
				idw->selected_widget->text->box(box_type);
				idw->selected_widget->redraw();
			}
		}
	}
}

void	layer_select_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Camera *cam = idw->my_window->DisplayedCamera();
	if(cam != NULL)
	{
		cam->edit_layer = 0;
		for(loop = 0;loop < 8;loop++)
		{
			if(idw->layer_select_button[loop]->value())
			{
				cam->edit_layer = loop;
			}
		}
	}
}

void	layer_visible_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Camera *cam = idw->my_window->DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < 8;loop++)
		{
			cam->layer_state[loop] = 0;
			if(idw->layer_visible_button[loop]->value())
			{
				cam->layer_state[loop] = 1;
			}
		}
	}
}

void	layer_up_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int use_layer = -1;
	for(loop = 0;loop < 8;loop++)
	{
		if(w == idw->layer_up_button[loop])
		{
			use_layer = loop;
		}
	}
	if((use_layer > -1) && (use_layer < 8))
	{
		Camera *cam = idw->my_window->DisplayedCamera();
		if(cam != NULL)
		{
			cam->RaiseALayer(use_layer);
		}
	}
	idw->redraw();
}

void	layer_down_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int use_layer = -1;
	for(loop = 0;loop < 8;loop++)
	{
		if(w == idw->layer_down_button[loop])
		{
			use_layer = loop;
		}
	}
	if((use_layer > -1) && (use_layer < 8))
	{
		Camera *cam = idw->my_window->DisplayedCamera();
		if(cam != NULL)
		{
			cam->LowerALayer(use_layer);
		}
	}
	idw->redraw();
}

void	general_paste_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(idw->my_window != NULL)
	{
		MyWin *win = idw->my_window;
		win->PasteImmediate();
	}
}

void	clear_copy_buffer_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(idw->my_window != NULL)
	{
		MyWin *win = idw->my_window;
		win->ClearImmediate();
	}
}

void	general_save_button_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(idw->my_window != NULL)
	{
		MyWin *win = idw->my_window;
		Camera *cam = idw->my_window->DisplayedCamera();
		if(cam != NULL)
		{
			if(access("./ImmediateDrawingFiles", 0) != 0)
			{
				mkdir("./ImmediateDrawingFiles", 0755);
			}
			chdir("./ImmediateDrawingFiles");
			char filename[4096];
			int r = my_file_chooser("Select an immediate file", "*.json", "./ImmediateDrawingFiles", filename, 0, 1);
			if(r > 0)
			{
				if(strlen(filename) > 0)
				{
					cam->SaveImmediate(filename);
				}
			}
			chdir("..");
		}
	}
}

void	general_load_button_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(idw->my_window != NULL)
	{
		MyWin *win = idw->my_window;
		Camera *cam = idw->my_window->DisplayedCamera();
		if(cam != NULL)
		{
			char filename[4096];
			strcpy(filename, "");
			int nn = my_file_chooser("Select an immediate drawing file", "*.json", "./ImmediateDrawingFiles", filename);
			if(nn > 0)
			{
				if(strlen(filename) > 0)
				{
					cam->LoadImmediate(filename);
				}
			}
		}
	}
}

LayerLabelButton::LayerLabelButton(MyWin *in_win, int in_layer, int xx, int yy, int ww, int hh, char *lbl) : MyToggleButton(xx, yy, ww, hh, lbl)
{
	my_window = in_win;
	layer = in_layer;
}

LayerLabelButton::~LayerLabelButton()
{
}

void	LayerLabelButton::draw()
{
int		loop;
char	buf[256];

	MyToggleButton::draw();
	if(value())
	{
		fl_color(WHITE);
	}
	else
	{
		fl_color(color());
	}
	fl_rectf(x(), y(), w(), h());
	fl_font(labelfont(), labelsize());
	if(value())
	{
		fl_color(BLACK);
	}
	else
	{
		fl_color(labelcolor());
	}
	int cnt = 0;
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < cam->immediate_cnt;loop++)
		{
			if(cam->immediate_list[loop] != NULL)
			{
				if(cam->immediate_list[loop]->layer == layer)
				{
					cnt++;
				}
			}
		}
		for(loop = 0;loop < cam->image_window_cnt;loop++)
		{
			if(cam->image_window[loop] != NULL)
			{
				if(cam->image_window[loop]->layer == layer)
				{
					cnt++;
				}
			}
		}
	}
	sprintf(buf, "Layer #%d (%d)", layer, cnt);
	fl_draw(buf, x(), y(), w(), h(), FL_ALIGN_CENTER);
}

void	text_edit_window_cb(Fl_Widget *w, void *v)
{
char	buf[256];

	TextEditWindow *win = (TextEditWindow *)v;
	sprintf(buf, "%3d", (int)win->font_size_slider->value());
	win->font_size_output->value(buf);

	int nn = win->font_browser->value();
	char *font_str = (char *)win->font_browser->text(nn);
printf("FONT STR: [%s]\n", font_str);
	if(font_str != NULL)
	{
		if(strlen(font_str) > 7)
		{
			font_str += 7;
		}
		win->font_output->copy_label(font_str);
		win->font_output->labelfont(nn - 1);
	}
	if(win->my_misc != NULL)
	{
		MiscCopy *misc = win->my_misc;
		if(misc->quick_text != NULL)
		{
			QuickText *qt = misc->quick_text;
			qt->textsize((int)win->font_size_slider->value());
			if(font_str != NULL)
			{
				strcpy(qt->use_font, font_str);
			}
			else
			{
				strcpy(qt->use_font, "sans");
			}
			int rr = win->local_red;
			int gg = win->local_green;
			int bb = win->local_blue;
			int aa = win->local_alpha;
			qt->textcolor(fl_rgb_color(rr, gg, bb));
			qt->alpha = aa;

			qt->italic = win->text_italic_button->value();
			qt->bold = win->text_bold_button->value();
			qt->outline = win->text_outline_button->value();
			qt->value(win->text_initial_text->value());
			qt->redraw();
		}
	}
	win->redraw();
}

TextEditWindow::TextEditWindow(MyWin *in_win, Camera *in_cam, MiscCopy *in_misc) : Dialog(400, 540, "Edit Text")
{
int	loop;

	my_window = in_win;
	my_camera = in_cam;
	my_misc = in_misc;

	int yp = 38;
	strcpy(selected_font, "");

	font_output = new Fl_Box(60, yp, 300, 20);
	font_output->color(BLACK);
	font_output->box(FL_FRAME_BOX);
	font_output->labelcolor(WHITE);
	font_output->labelsize(9);
	font_output->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	yp += 24;
	
	font_browser = new Fl_Hold_Browser(60, yp, 300, 200);
	font_browser->color(BLACK);
	font_browser->box(FL_FLAT_BOX);
	font_browser->textcolor(WHITE);
	font_browser->textsize(9);
	font_browser->selection_color(YELLOW);
	font_browser->scrollbar.color(BLACK);
	font_browser->callback(text_edit_window_cb, this);
	yp += 204;
	int nn = my_window->number_of_fonts;
	for(loop = 0;loop < nn;loop++)
	{
		int attr = 0;
		char *str = (char *)Fl::get_font_name(loop, &attr);
		if(attr == 0)
		{
			char buf[256];
			sprintf(buf, "@F%05d%s", loop, str);
			font_browser->add(buf, (void *)(long int)loop);
		}
	}
	if(strlen(selected_font) < 1)
	{
		font_browser->value(1);
		char *str = (char *)font_browser->text(font_browser->value());
		if(str != NULL)
		{
			strcpy(selected_font, str);
			font_output->copy_label(str);
			font_output->redraw();
		}
	}
	font_size_slider = new Fl_Hor_Slider(60, yp, 100, 10, "Size");
	font_size_slider->color(BLACK);
	font_size_slider->box(FL_FRAME_BOX);
	font_size_slider->align(FL_ALIGN_LEFT);
	font_size_slider->labelcolor(WHITE);
	font_size_slider->labelsize(9);
	font_size_slider->value(32.0);
	font_size_slider->range(3.0, 255.0);
	font_size_slider->callback(text_edit_window_cb, this);

	font_size_output = new Fl_Output(165, yp, 25, 10);
	font_size_output->color(BLACK);
	font_size_output->box(FL_FLAT_BOX);
	font_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
	font_size_output->textfont(FL_COURIER);
	font_size_output->textcolor(WHITE);
	font_size_output->textsize(9);
	font_size_output->value(" 32");
	yp += 16;

	local_red = 255;
	local_blue = 255;
	local_green = 255;
	local_alpha = 255;
	color_panel = new ColorPanel(in_win, &local_red, &local_green, &local_blue, &local_alpha, 4, yp, 390, 142);
	color_panel->Callback(text_edit_window_cb, this);
	yp += 150;
	int xp = 60;

	text_italic_button = new MyLightButton(xp, yp, 60, 20, "Italic");
	text_italic_button->labelsize(9);
	text_italic_button->labelcolor(WHITE);
	text_italic_button->color(DARK_GRAY);
	text_italic_button->box(FL_FLAT_BOX);
	text_italic_button->clear_visible_focus();
	text_italic_button->callback(text_edit_window_cb, this);
	xp += 60;

	text_bold_button = new MyLightButton(xp, yp, 60, 20, "Bold");
	text_bold_button->labelsize(9);
	text_bold_button->labelcolor(WHITE);
	text_bold_button->color(DARK_GRAY);
	text_bold_button->box(FL_FLAT_BOX);
	text_bold_button->clear_visible_focus();
	text_bold_button->callback(text_edit_window_cb, this);
	xp += 60;

	text_outline_button = new MyLightButton(xp, yp, 60, 20, "Outline");
	text_outline_button->labelsize(9);
	text_outline_button->labelcolor(WHITE);
	text_outline_button->color(DARK_GRAY);
	text_outline_button->box(FL_FLAT_BOX);
	text_outline_button->clear_visible_focus();
	text_outline_button->callback(text_edit_window_cb, this);
	yp += 48;

	xp = 60;
	text_initial_text = new Fl_Multiline_Input(xp, yp, 300, 60, "Initial Text");
	text_initial_text->labelsize(9);
	text_initial_text->textsize(9);
	text_initial_text->labelcolor(WHITE);
	text_initial_text->textcolor(WHITE);
	text_initial_text->cursor_color(WHITE);
	text_initial_text->color(BLACK);
	text_initial_text->box(FL_FRAME_BOX);
	text_initial_text->align(FL_ALIGN_CENTER | FL_ALIGN_TOP);
	if(my_misc->quick_text != NULL)
	{
		text_initial_text->value(my_misc->quick_text->value());
	}
	text_initial_text->callback(text_edit_window_cb, this);
	text_initial_text->when(FL_WHEN_CHANGED);
}

TextEditWindow::~TextEditWindow()
{
}

void	hide_immediate_window_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *win = (ImmediateDrawingWindow *)v;
	if(win->my_window != NULL)
	{
		if(win->my_window->anim_timeline != NULL)
		{
			win->my_window->anim_timeline->hide();
		}
	}
	win->ClearSelectedWidget();
	win->hide();
}

void	immediate_choose_color(Fl_Hor_Slider *red, Fl_Hor_Slider *green, Fl_Hor_Slider *blue, Fl_Hor_Slider *alpha)
{
	int rr = red->value();
	int gg = green->value();
	int bb = blue->value();
	int aa = 255;
	if(alpha != NULL)
	{
		aa = alpha->value();
	}
	my_color_chooser("Fill Color", rr, gg, bb, aa);
	red->value(rr);
	green->value(gg);
	blue->value(bb);
	if(alpha != NULL)
	{
		alpha->value(aa);
	}
}

void	immediate_palette_for_font_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	immediate_choose_color(idw->font_red_slider, idw->font_green_slider, idw->font_blue_slider, idw->font_alpha_slider);
	drawing_font_color_cb(NULL, idw);
}

void	immediate_palette_for_line_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	immediate_choose_color(idw->line_red_slider, idw->line_green_slider, idw->line_blue_slider, idw->line_alpha_slider);
	drawing_line_color_cb(NULL, idw);
}

void	immediate_palette_for_rectangle_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	immediate_choose_color(idw->rectangle_red_slider, idw->rectangle_green_slider, idw->rectangle_blue_slider, idw->rectangle_alpha_slider);
	drawing_rectangle_color_cb(NULL, idw);
}

void	immediate_palette_for_freehand_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	immediate_choose_color(idw->freehand_red_slider, idw->freehand_green_slider, idw->freehand_blue_slider, NULL);
	drawing_freehand_color_cb(NULL, idw);
}


ImmediateDrawingWindow::ImmediateDrawingWindow(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : Dialog(xx, yy, ww, hh, lbl)
{
char	buf[256];
int		ii;

	my_window = in_win;
	resize(x(), y(), w(), h());
	orig_w = w();
	orig_h = h();

	selected_widget = NULL;
	last_x = 0;
	last_y = 0;
	font_num = 0;
	strcpy(selected_font, "");
	strcpy(freehand_filename, "");
	font_size = 72;
	font_color_red = 255;
	font_color_green = 255;
	font_color_blue = 255;
	font_color_alpha = 255;
	back_color_red = 0;
	back_color_green = 0;
	back_color_blue = 0;
	back_color_alpha = 255;
	outline_color_red = 0;
	outline_color_green = 0;
	outline_color_blue = 0;
	outline_color_alpha = 255;
	using_background_color = 0;
	line_style = 0;
	line_size = 1;
	line_color_red = 255;
	line_color_green = 255;
	line_color_blue = 255;
	line_color_alpha = 255;
	rectangle_style = 0;
	rectangle_size = 1;
	rectangle_color_red = 255;
	rectangle_color_green = 255;
	rectangle_color_blue = 255;
	rectangle_color_alpha = 255;
	rectangle_filled = 0;
	rectangle_square = 0;
	freehand_key = '/';
	text_box_type = FL_NO_BOX;
	grid_size = 1;
	pixelate_size = 10;
	erase = 0;
	from_paste = 0;

	int yp = 40;
	general = new MyButton(10, yp, 100, 20, "General");
	general->labelsize(9);
	general->labelcolor(YELLOW);
	general->color(DARK_GRAY);
	general->box(FL_FLAT_BOX);
	general->clear_visible_focus();
	general->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	text = new MyButton(10, yp, 100, 20, "Text");
	text->labelsize(9);
	text->labelcolor(YELLOW);
	text->color(DARK_GRAY);
	text->box(FL_FLAT_BOX);
	text->clear_visible_focus();
	text->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	line = new MyButton(10, yp, 100, 20, "Line");
	line->labelsize(9);
	line->labelcolor(YELLOW);
	line->color(DARK_GRAY);
	line->box(FL_FLAT_BOX);
	line->clear_visible_focus();
	line->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	rectangle = new MyButton(10, yp, 100, 20, "Rectangle");
	rectangle->labelsize(9);
	rectangle->labelcolor(YELLOW);
	rectangle->color(DARK_GRAY);
	rectangle->box(FL_FLAT_BOX);
	rectangle->clear_visible_focus();
	rectangle->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	ellipse = new MyButton(10, yp, 100, 20, "Ellipse");
	ellipse->labelsize(9);
	ellipse->labelcolor(YELLOW);
	ellipse->color(DARK_GRAY);
	ellipse->box(FL_FLAT_BOX);
	ellipse->clear_visible_focus();
	ellipse->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	image_im = new MyButton(10, yp, 100, 20, "Image");
	image_im->labelsize(9);
	image_im->labelcolor(YELLOW);
	image_im->color(DARK_GRAY);
	image_im->box(FL_FLAT_BOX);
	image_im->clear_visible_focus();
	image_im->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	polygon = new MyButton(10, yp, 100, 20, "Polygon");
	polygon->labelsize(9);
	polygon->labelcolor(YELLOW);
	polygon->color(DARK_GRAY);
	polygon->box(FL_FLAT_BOX);
	polygon->clear_visible_focus();
	polygon->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	loop = new MyButton(10, yp, 100, 20, "Loop");
	loop->labelsize(9);
	loop->labelcolor(YELLOW);
	loop->color(DARK_GRAY);
	loop->box(FL_FLAT_BOX);
	loop->clear_visible_focus();
	loop->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	freehand = new MyButton(10, yp, 100, 20, "Freehand");
	freehand->labelsize(9);
	freehand->labelcolor(YELLOW);
	freehand->color(DARK_GRAY);
	freehand->box(FL_FLAT_BOX);
	freehand->clear_visible_focus();
	freehand->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	pixelate = new MyButton(10, yp, 100, 20, "Pixelate/Blur");
	pixelate->labelsize(9);
	pixelate->labelcolor(YELLOW);
	pixelate->color(DARK_GRAY);
	pixelate->box(FL_FLAT_BOX);
	pixelate->clear_visible_focus();
	pixelate->callback(immediate_drawing_mode_cb, this);
	yp += 32;
	passthru_rectangle = new MyButton(10, yp, 100, 20, "Passthru Rect");
	passthru_rectangle->labelsize(9);
	passthru_rectangle->labelcolor(YELLOW);
	passthru_rectangle->color(DARK_GRAY);
	passthru_rectangle->box(FL_FLAT_BOX);
	passthru_rectangle->clear_visible_focus();
	passthru_rectangle->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	passthru_ellipse = new MyButton(10, yp, 100, 20, "Passthru Ellipse");
	passthru_ellipse->labelsize(9);
	passthru_ellipse->labelcolor(YELLOW);
	passthru_ellipse->color(DARK_GRAY);
	passthru_ellipse->box(FL_FLAT_BOX);
	passthru_ellipse->clear_visible_focus();
	passthru_ellipse->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	passthru_polygon = new MyButton(10, yp, 100, 20, "Passthru Poly");
	passthru_polygon->labelsize(9);
	passthru_polygon->labelcolor(YELLOW);
	passthru_polygon->color(DARK_GRAY);
	passthru_polygon->box(FL_FLAT_BOX);
	passthru_polygon->clear_visible_focus();
	passthru_polygon->callback(immediate_drawing_mode_cb, this);
	yp += 32;
	delete_im = new MyButton(10, yp, 100, 20, "Delete");
	delete_im->labelsize(9);
	delete_im->labelcolor(YELLOW);
	delete_im->color(DARK_GRAY);
	delete_im->box(FL_FLAT_BOX);
	delete_im->clear_visible_focus();
	delete_im->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	hide_im = new MyButton(10, yp, 100, 20, "Hide");
	hide_im->labelsize(9);
	hide_im->labelcolor(YELLOW);
	hide_im->color(DARK_GRAY);
	hide_im->box(FL_FLAT_BOX);
	hide_im->clear_visible_focus();
	hide_im->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	hide_all = new MyButton(10, yp, 100, 20, "Hide All");
	hide_all->labelsize(9);
	hide_all->labelcolor(YELLOW);
	hide_all->color(DARK_GRAY);
	hide_all->box(FL_FLAT_BOX);
	hide_all->clear_visible_focus();
	hide_all->callback(immediate_drawing_mode_cb, this);
	yp += 22;
	show_all = new MyButton(10, yp, 100, 20, "Show All");
	show_all->labelsize(9);
	show_all->labelcolor(YELLOW);
	show_all->color(DARK_GRAY);
	show_all->box(FL_FLAT_BOX);
	show_all->clear_visible_focus();
	show_all->callback(immediate_drawing_mode_cb, this);
	yp += 29;

	MyButton *done = new MyButton(10, yp, 100, 20, "Done");
	done->labelsize(11);
	done->labelcolor(YELLOW);
	done->color(BLACK);
	done->box(FL_FLAT_BOX);
	done->clear_visible_focus();
	done->callback(hide_immediate_window_cb, this);
	yp += 22;

	general_group = new MyGroup(120, 20, 1920, 1080);
	general_group->box(FL_NO_BOX);
	general_group->color(DARK_GRAY);
		yp = 38;
		grid_size_slider = new Fl_Hor_Slider(180, yp, 100, 10, "Grid Size");
		grid_size_slider->color(BLACK);
		grid_size_slider->box(FL_FRAME_BOX);
		grid_size_slider->align(FL_ALIGN_LEFT);
		grid_size_slider->labelcolor(WHITE);
		grid_size_slider->labelsize(9);
		grid_size_slider->value(1.0);
		grid_size_slider->range(1.0, 100.0);
		grid_size_slider->callback(drawing_grid_size_cb, this);

		grid_size_output = new Fl_Output(280, yp, 25, 10);
		grid_size_output->color(BLACK);
		grid_size_output->box(FL_FLAT_BOX);
		grid_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		grid_size_output->textfont(FL_COURIER);
		grid_size_output->textcolor(WHITE);
		grid_size_output->textsize(9);
		grid_size_output->value("  1");
		yp += 22;
		int save_yp = yp;
		MyGroup *layer_select_group = new MyGroup(180, yp, 100, (20) * 8);
		for(ii = 0;ii < 8;ii++)
		{
			sprintf(buf, "Layer %d", ii);
			layer_select_button[ii] = new LayerLabelButton(my_window, ii, 180, yp, 100, 20, strdup(buf));
			layer_select_button[ii]->labelsize(9);
			layer_select_button[ii]->labelcolor(WHITE);
			layer_select_button[ii]->color(DARK_GRAY);
			layer_select_button[ii]->box(FL_FLAT_BOX);
			layer_select_button[ii]->clear_visible_focus();
			layer_select_button[ii]->type(FL_RADIO_BUTTON);
			layer_select_button[ii]->callback(layer_select_cb, this);
			if(ii == 0)
			{
				layer_select_button[ii]->value(1);
			}
			yp += 21;
		}
		layer_select_group->end();
		yp = save_yp;
		for(ii = 0;ii < 8;ii++)
		{
			layer_visible_button[ii] = new MyToggleButton(160, yp + 4, 12, 12, " ");
			layer_visible_button[ii]->labelsize(9);
			layer_visible_button[ii]->labelcolor(WHITE);
			layer_visible_button[ii]->color(DARK_GRAY);
			layer_visible_button[ii]->box(FL_FRAME_BOX);
			layer_visible_button[ii]->clear_visible_focus();
			layer_visible_button[ii]->value(1);
			layer_visible_button[ii]->callback(layer_visible_cb, this);

			layer_down_button[ii] = new MyButton(280, yp + 4, 12, 12, "@8->");
			layer_down_button[ii]->labelsize(9);
			layer_down_button[ii]->labelcolor(WHITE);
			layer_down_button[ii]->color(DARK_GRAY);
			layer_down_button[ii]->box(FL_FLAT_BOX);
			layer_down_button[ii]->clear_visible_focus();
			layer_down_button[ii]->callback(layer_down_cb, this);
			if(ii == 0)
			{
				layer_down_button[ii]->hide();
			}
			layer_up_button[ii] = new MyButton(294, yp + 4, 12, 12, "@2->");
			layer_up_button[ii]->labelsize(9);
			layer_up_button[ii]->labelcolor(WHITE);
			layer_up_button[ii]->color(DARK_GRAY);
			layer_up_button[ii]->box(FL_FLAT_BOX);
			layer_up_button[ii]->clear_visible_focus();
			layer_up_button[ii]->callback(layer_up_cb, this);
			if(ii == 7)
			{
				layer_up_button[ii]->hide();
			}
			yp += 21;
		}
		int xp = 140;
		yp += 5;
		paste_button = new MyButton(xp, yp, 60, 18, "Paste");
		paste_button->labelsize(11);
		paste_button->labelcolor(WHITE);
		paste_button->color(DARK_GRAY);
		paste_button->box(FL_FLAT_BOX);
		paste_button->clear_visible_focus();
		paste_button->hide();
		paste_button->callback(general_paste_button_cb, this);
		xp += 70;
		clear_copy_buffer_button = new MyButton(xp, yp, 120, 18, "Clear Copy Buffer");
		clear_copy_buffer_button->labelsize(11);
		clear_copy_buffer_button->labelcolor(WHITE);
		clear_copy_buffer_button->color(DARK_GRAY);
		clear_copy_buffer_button->box(FL_FLAT_BOX);
		clear_copy_buffer_button->clear_visible_focus();
		clear_copy_buffer_button->hide();
		clear_copy_buffer_button->callback(clear_copy_buffer_button_cb, this);
		xp = 140;
		yp += 20;
		save_button = new MyButton(xp, yp, 60, 18, "Save");
		save_button->labelsize(11);
		save_button->labelcolor(WHITE);
		save_button->color(DARK_GRAY);
		save_button->box(FL_FLAT_BOX);
		save_button->clear_visible_focus();
		save_button->callback(general_save_button_cb, this);
		xp = 140;
		yp += 20;
		load_button = new MyButton(xp, yp, 60, 18, "Load");
		load_button->labelsize(11);
		load_button->labelcolor(WHITE);
		load_button->color(DARK_GRAY);
		load_button->box(FL_FLAT_BOX);
		load_button->clear_visible_focus();
		load_button->callback(general_load_button_cb, this);
	general_group->end();
	general_group->hide();
	text_group = new MyGroup(120, 20, 1920, 1080);
	text_group->box(FL_NO_BOX);
	text_group->color(DARK_GRAY);
		yp = 38;
		font_output = new Fl_Box(120, yp, 300, 20);
		font_output->color(BLACK);
		font_output->box(FL_FRAME_BOX);
		font_output->labelcolor(WHITE);
		font_output->labelsize(9);
		font_output->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		yp += 24;
	
		font_browser = new Fl_Hold_Browser(120, yp, 300, 170);
		font_browser->color(BLACK);
		font_browser->box(FL_FLAT_BOX);
		font_browser->textcolor(WHITE);
		font_browser->textsize(9);
		font_browser->selection_color(YELLOW);
		font_browser->scrollbar.color(BLACK);
		font_browser->callback(drawing_font_selection_cb, this);
		yp += 174;
	
		font_sample = new FontSample(this, 120, yp, 100, 100, "Ab");
		font_sample->color(DARK_GRAY);
		font_sample->box(FL_FRAME_BOX);
		font_sample->labelcolor(WHITE);
		font_sample->labelsize(72);
		font_sample->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

		font_size_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Size");
		font_size_slider->color(BLACK);
		font_size_slider->box(FL_FRAME_BOX);
		font_size_slider->align(FL_ALIGN_LEFT);
		font_size_slider->labelcolor(WHITE);
		font_size_slider->labelsize(9);
		font_size_slider->value(72.0);
		font_size_slider->range(3.0, 255.0);
		font_size_slider->callback(drawing_font_size_cb, this);

		font_size_output = new Fl_Output(365, yp, 25, 10);
		font_size_output->color(BLACK);
		font_size_output->box(FL_FLAT_BOX);
		font_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_size_output->textfont(FL_COURIER);
		font_size_output->textcolor(WHITE);
		font_size_output->textsize(9);
		font_size_output->value(" 72");
		yp += 16;
	
		font_red_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Red");
		font_red_slider->color(BLACK);
		font_red_slider->box(FL_FRAME_BOX);
		font_red_slider->align(FL_ALIGN_LEFT);
		font_red_slider->labelcolor(WHITE);
		font_red_slider->labelsize(9);
		font_red_slider->value(255.0);
		font_red_slider->range(0.0, 255.0);
		font_red_slider->callback(drawing_font_color_cb, this);

		font_red_output = new Fl_Output(365, yp, 25, 10);
		font_red_output->color(BLACK);
		font_red_output->box(FL_FLAT_BOX);
		font_red_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_red_output->textfont(FL_COURIER);
		font_red_output->textcolor(WHITE);
		font_red_output->textsize(9);
		font_red_output->value("255");
		yp += 12;
	
		font_green_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Green");
		font_green_slider->color(BLACK);
		font_green_slider->box(FL_FRAME_BOX);
		font_green_slider->align(FL_ALIGN_LEFT);
		font_green_slider->labelcolor(WHITE);
		font_green_slider->labelsize(9);
		font_green_slider->value(255.0);
		font_green_slider->range(0.0, 255.0);
		font_green_slider->callback(drawing_font_color_cb, this);

		font_green_output = new Fl_Output(365, yp, 25, 10);
		font_green_output->color(BLACK);
		font_green_output->box(FL_FLAT_BOX);
		font_green_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_green_output->textfont(FL_COURIER);
		font_green_output->textcolor(WHITE);
		font_green_output->textsize(9);
		font_green_output->value("255");
		yp += 12;
	
		font_blue_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Blue");
		font_blue_slider->color(BLACK);
		font_blue_slider->box(FL_FRAME_BOX);
		font_blue_slider->align(FL_ALIGN_LEFT);
		font_blue_slider->labelcolor(WHITE);
		font_blue_slider->labelsize(9);
		font_blue_slider->value(255.0);
		font_blue_slider->range(0.0, 255.0);
		font_blue_slider->callback(drawing_font_color_cb, this);

		font_blue_output = new Fl_Output(365, yp, 25, 10);
		font_blue_output->color(BLACK);
		font_blue_output->box(FL_FLAT_BOX);
		font_blue_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_blue_output->textfont(FL_COURIER);
		font_blue_output->textcolor(WHITE);
		font_blue_output->textsize(9);
		font_blue_output->value("255");
		yp += 12;

		font_alpha_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Alpha");
		font_alpha_slider->color(BLACK);
		font_alpha_slider->box(FL_FRAME_BOX);
		font_alpha_slider->align(FL_ALIGN_LEFT);
		font_alpha_slider->labelcolor(WHITE);
		font_alpha_slider->labelsize(9);
		font_alpha_slider->value(255.0);
		font_alpha_slider->range(0.0, 255.0);
		font_alpha_slider->callback(drawing_font_color_cb, this);

		font_alpha_output = new Fl_Output(365, yp, 25, 10);
		font_alpha_output->color(BLACK);
		font_alpha_output->box(FL_FLAT_BOX);
		font_alpha_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_alpha_output->textfont(FL_COURIER);
		font_alpha_output->textcolor(WHITE);
		font_alpha_output->textsize(9);
		font_alpha_output->value("255");
		yp += 12;

		font_palette_button = new MyButton(260, yp, 70, 18, "Palette");
		font_palette_button->labelsize(7);
		font_palette_button->labelcolor(YELLOW);
		font_palette_button->color(BLACK);
		font_palette_button->box(FL_FLAT_BOX);
		font_palette_button->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		font_palette_button->clear_visible_focus();
		font_palette_button->callback(immediate_palette_for_font_cb, this);
		yp += 22;

		xp = 240;
		MyGroup *drawing_text_color_selection_group = new MyGroup(xp, yp, 186, 18);
			text_foreground_color_button = new MyToggleButton(xp, yp, 40, 20, "Fore");
			text_foreground_color_button->labelsize(9);
			text_foreground_color_button->labelcolor(WHITE);
			text_foreground_color_button->color(DARK_GRAY);
			text_foreground_color_button->box(FL_FLAT_BOX);
			text_foreground_color_button->clear_visible_focus();
			text_foreground_color_button->type(FL_RADIO_BUTTON);
			text_foreground_color_button->value(1);
			text_foreground_color_button->callback(text_color_selection_cb, this);
			xp += 42;

			text_background_color_button = new MyToggleButton(xp, yp, 40, 18, "Back");
			text_background_color_button->labelsize(9);
			text_background_color_button->labelcolor(WHITE);
			text_background_color_button->color(DARK_GRAY);
			text_background_color_button->box(FL_FLAT_BOX);
			text_background_color_button->clear_visible_focus();
			text_background_color_button->type(FL_RADIO_BUTTON);
			text_background_color_button->callback(text_color_selection_cb, this);
			xp += 42;

			text_outline_color_button = new MyToggleButton(xp, yp, 40, 18, "Outline");
			text_outline_color_button->labelsize(9);
			text_outline_color_button->labelcolor(WHITE);
			text_outline_color_button->color(DARK_GRAY);
			text_outline_color_button->box(FL_FLAT_BOX);
			text_outline_color_button->clear_visible_focus();
			text_outline_color_button->type(FL_RADIO_BUTTON);
			text_outline_color_button->callback(text_color_selection_cb, this);
			xp += 42;
		drawing_text_color_selection_group->end();
		yp += 24;
		xp = 260;

		drawing_text_box = new Fl_Choice(xp, yp, 100, 16, "Box");
		drawing_text_box->labelsize(9);
		drawing_text_box->labelcolor(WHITE);
		drawing_text_box->textsize(9);
		drawing_text_box->color(DARK_GRAY);
		drawing_text_box->box(FL_FLAT_BOX);
		drawing_text_box->value(1);
		drawing_text_box->callback(drawing_text_box_cb, this);
		drawing_text_box->add("No Box");
		drawing_text_box->add("Flat Box");
		drawing_text_box->add("Frame");
		drawing_text_box->add("Framed Box");
		yp += 18;

		xp = 230;
		text_italic_button = new MyLightButton(xp, yp, 60, 20, "Italic");
		text_italic_button->labelsize(9);
		text_italic_button->labelcolor(WHITE);
		text_italic_button->color(DARK_GRAY);
		text_italic_button->box(FL_FLAT_BOX);
		text_italic_button->clear_visible_focus();
		xp += 60;

		text_bold_button = new MyLightButton(xp, yp, 60, 20, "Bold");
		text_bold_button->labelsize(9);
		text_bold_button->labelcolor(WHITE);
		text_bold_button->color(DARK_GRAY);
		text_bold_button->box(FL_FLAT_BOX);
		text_bold_button->clear_visible_focus();
		xp += 60;

		text_outline_button = new MyLightButton(xp, yp, 60, 20, "Outline");
		text_outline_button->labelsize(9);
		text_outline_button->labelcolor(WHITE);
		text_outline_button->color(DARK_GRAY);
		text_outline_button->box(FL_FLAT_BOX);
		text_outline_button->clear_visible_focus();
		yp += 28;

		xp = 140;
		text_initial_text = new Fl_Multiline_Input(xp, yp, 250, 60, "Initial Text");
		text_initial_text->labelsize(9);
		text_initial_text->textsize(9);
		text_initial_text->labelcolor(WHITE);
		text_initial_text->textcolor(WHITE);
		text_initial_text->cursor_color(WHITE);
		text_initial_text->color(BLACK);
		text_initial_text->box(FL_FRAME_BOX);
		text_initial_text->align(FL_ALIGN_TOP_LEFT);

	text_group->end();
	text_group->hide();
	line_group = new MyGroup(120, 20, 1920, 1080);
	line_group->box(FL_NO_BOX);
	line_group->color(DARK_GRAY);
		yp = 38;
		line_sample = new LineSample(this, 120, yp, 100, 100);
		line_sample->color(DARK_GRAY);
		line_sample->box(FL_FRAME_BOX);
		line_sample->labelcolor(WHITE);
		line_sample->labelsize(1);

		line_size_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Size");
		line_size_slider->color(BLACK);
		line_size_slider->box(FL_FRAME_BOX);
		line_size_slider->align(FL_ALIGN_LEFT);
		line_size_slider->labelcolor(WHITE);
		line_size_slider->labelsize(9);
		line_size_slider->value(1.0);
		line_size_slider->range(1.0, 30.0);
		line_size_slider->callback(drawing_line_size_cb, this);

		line_size_output = new Fl_Output(365, yp, 25, 10);
		line_size_output->color(BLACK);
		line_size_output->box(FL_FLAT_BOX);
		line_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_size_output->textfont(FL_COURIER);
		line_size_output->textcolor(WHITE);
		line_size_output->textsize(9);
		line_size_output->value("  1");
		yp += 16;
	
		line_red_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Red");
		line_red_slider->color(BLACK);
		line_red_slider->box(FL_FRAME_BOX);
		line_red_slider->align(FL_ALIGN_LEFT);
		line_red_slider->labelcolor(WHITE);
		line_red_slider->labelsize(9);
		line_red_slider->value(255.0);
		line_red_slider->range(0.0, 255.0);
		line_red_slider->callback(drawing_line_color_cb, this);

		line_red_output = new Fl_Output(365, yp, 25, 10);
		line_red_output->color(BLACK);
		line_red_output->box(FL_FLAT_BOX);
		line_red_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_red_output->textfont(FL_COURIER);
		line_red_output->textcolor(WHITE);
		line_red_output->textsize(9);
		line_red_output->value("255");
		yp += 12;
	
		line_green_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Green");
		line_green_slider->color(BLACK);
		line_green_slider->box(FL_FRAME_BOX);
		line_green_slider->align(FL_ALIGN_LEFT);
		line_green_slider->labelcolor(WHITE);
		line_green_slider->labelsize(9);
		line_green_slider->value(255.0);
		line_green_slider->range(0.0, 255.0);
		line_green_slider->callback(drawing_line_color_cb, this);

		line_green_output = new Fl_Output(365, yp, 25, 10);
		line_green_output->color(BLACK);
		line_green_output->box(FL_FLAT_BOX);
		line_green_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_green_output->textfont(FL_COURIER);
		line_green_output->textcolor(WHITE);
		line_green_output->textsize(9);
		line_green_output->value("255");
		yp += 12;
	
		line_blue_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Blue");
		line_blue_slider->color(BLACK);
		line_blue_slider->box(FL_FRAME_BOX);
		line_blue_slider->align(FL_ALIGN_LEFT);
		line_blue_slider->labelcolor(WHITE);
		line_blue_slider->labelsize(9);
		line_blue_slider->value(255.0);
		line_blue_slider->range(0.0, 255.0);
		line_blue_slider->callback(drawing_line_color_cb, this);

		line_blue_output = new Fl_Output(365, yp, 25, 10);
		line_blue_output->color(BLACK);
		line_blue_output->box(FL_FLAT_BOX);
		line_blue_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_blue_output->textfont(FL_COURIER);
		line_blue_output->textcolor(WHITE);
		line_blue_output->textsize(9);
		line_blue_output->value("255");
		yp += 12;

		line_alpha_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Alpha");
		line_alpha_slider->color(BLACK);
		line_alpha_slider->box(FL_FRAME_BOX);
		line_alpha_slider->align(FL_ALIGN_LEFT);
		line_alpha_slider->labelcolor(WHITE);
		line_alpha_slider->labelsize(9);
		line_alpha_slider->value(255.0);
		line_alpha_slider->range(0.0, 255.0);
		line_alpha_slider->callback(drawing_line_color_cb, this);

		line_alpha_output = new Fl_Output(365, yp, 25, 10);
		line_alpha_output->color(BLACK);
		line_alpha_output->box(FL_FLAT_BOX);
		line_alpha_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_alpha_output->textfont(FL_COURIER);
		line_alpha_output->textcolor(WHITE);
		line_alpha_output->textsize(9);
		line_alpha_output->value("255");
		yp += 12;

		line_palette_button = new MyButton(260, yp, 70, 18, "Palette");
		line_palette_button->labelsize(7);
		line_palette_button->labelcolor(YELLOW);
		line_palette_button->color(BLACK);
		line_palette_button->box(FL_FLAT_BOX);
		line_palette_button->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		line_palette_button->clear_visible_focus();
		line_palette_button->callback(immediate_palette_for_line_cb, this);
		yp += 22;

		int start_yp = yp;
		MyGroup *line_style_group = new MyGroup(220, yp, 60, 60);
			line_style_solid_button = new MyToggleButton(220, yp, 60, 16, "Solid");
			line_style_solid_button->labelsize(9);
			line_style_solid_button->labelcolor(WHITE);
			line_style_solid_button->color(DARK_GRAY);
			line_style_solid_button->box(FL_FLAT_BOX);
			line_style_solid_button->clear_visible_focus();
			line_style_solid_button->type(FL_RADIO_BUTTON);
			line_style_solid_button->value(1);
			line_style_solid_button->callback(line_style_cb, this);
			yp += 18;

			line_style_dash_button = new MyToggleButton(220, yp, 60, 16, "Dash");
			line_style_dash_button->labelsize(9);
			line_style_dash_button->labelcolor(WHITE);
			line_style_dash_button->color(DARK_GRAY);
			line_style_dash_button->box(FL_FLAT_BOX);
			line_style_dash_button->clear_visible_focus();
			line_style_dash_button->type(FL_RADIO_BUTTON);
			line_style_dash_button->callback(line_style_cb, this);
			yp += 18;

			line_style_dot_button = new MyToggleButton(220, yp, 60, 16, "Dot");
			line_style_dot_button->labelsize(9);
			line_style_dot_button->labelcolor(WHITE);
			line_style_dot_button->color(DARK_GRAY);
			line_style_dot_button->box(FL_FLAT_BOX);
			line_style_dot_button->clear_visible_focus();
			line_style_dot_button->type(FL_RADIO_BUTTON);
			line_style_dot_button->callback(line_style_cb, this);
			yp += 24;

		line_style_group->end();
		line_style_erase_button = new MyToggleButton(290, yp, 60, 16, "Erase");
		line_style_erase_button->labelsize(9);
		line_style_erase_button->labelcolor(WHITE);
		line_style_erase_button->color(DARK_GRAY);
		line_style_erase_button->box(FL_FLAT_BOX);
		line_style_erase_button->clear_visible_focus();
		line_style_erase_button->callback(line_style_cb, this);
		line_style_erase_button->hide();
		MyGroup *line_type_group = new MyGroup(220, yp, 60, 40);
			line_type_segments_button = new MyToggleButton(220, yp, 60, 16, "Segments");
			line_type_segments_button->labelsize(9);
			line_type_segments_button->labelcolor(WHITE);
			line_type_segments_button->color(DARK_GRAY);
			line_type_segments_button->box(FL_FLAT_BOX);
			line_type_segments_button->clear_visible_focus();
			line_type_segments_button->value(1);
			line_type_segments_button->type(FL_RADIO_BUTTON);
			line_type_segments_button->callback(line_style_cb, this);
			yp += 18;
			line_type_curves_button = new MyToggleButton(220, yp, 60, 16, "Curves");
			line_type_curves_button->labelsize(9);
			line_type_curves_button->labelcolor(WHITE);
			line_type_curves_button->color(DARK_GRAY);
			line_type_curves_button->box(FL_FLAT_BOX);
			line_type_curves_button->clear_visible_focus();
			line_type_curves_button->type(FL_RADIO_BUTTON);
			line_type_curves_button->callback(line_style_cb, this);
		line_type_group->end();
		yp = start_yp;
		MyGroup *line_cap_group = new MyGroup(290, yp, 60, 80);
			line_style_flat_button = new MyToggleButton(290, yp, 60, 16, "Flat");
			line_style_flat_button->labelsize(9);
			line_style_flat_button->labelcolor(WHITE);
			line_style_flat_button->color(DARK_GRAY);
			line_style_flat_button->box(FL_FLAT_BOX);
			line_style_flat_button->clear_visible_focus();
			line_style_flat_button->type(FL_RADIO_BUTTON);
			line_style_flat_button->value(1);
			line_style_flat_button->callback(line_style_cb, this);
			yp += 18;
			line_style_round_button = new MyToggleButton(290, yp, 60, 16, "Round");
			line_style_round_button->labelsize(9);
			line_style_round_button->labelcolor(WHITE);
			line_style_round_button->color(DARK_GRAY);
			line_style_round_button->box(FL_FLAT_BOX);
			line_style_round_button->clear_visible_focus();
			line_style_round_button->type(FL_RADIO_BUTTON);
			line_style_round_button->callback(line_style_cb, this);
			yp += 18;
			line_style_square_button = new MyToggleButton(290, yp, 60, 16, "Square");
			line_style_square_button->labelsize(9);
			line_style_square_button->labelcolor(WHITE);
			line_style_square_button->color(DARK_GRAY);
			line_style_square_button->box(FL_FLAT_BOX);
			line_style_square_button->clear_visible_focus();
			line_style_square_button->type(FL_RADIO_BUTTON);
			line_style_square_button->callback(line_style_cb, this);
			yp += 18;
			line_style_arrow_button = new MyToggleButton(290, yp, 60, 16, "Arrow");
			line_style_arrow_button->labelsize(9);
			line_style_arrow_button->labelcolor(WHITE);
			line_style_arrow_button->color(DARK_GRAY);
			line_style_arrow_button->box(FL_FLAT_BOX);
			line_style_arrow_button->clear_visible_focus();
			line_style_arrow_button->type(FL_RADIO_BUTTON);
			line_style_arrow_button->callback(line_style_cb, this);
			line_style_arrow_button->hide();
		line_cap_group->end();
		yp = start_yp;
		MyGroup *line_join_group = new MyGroup(360, yp, 60, 60);
			line_style_join_miter_button = new MyToggleButton(360, yp, 60, 16, "Join Miter");
			line_style_join_miter_button->labelsize(9);
			line_style_join_miter_button->labelcolor(WHITE);
			line_style_join_miter_button->color(DARK_GRAY);
			line_style_join_miter_button->box(FL_FLAT_BOX);
			line_style_join_miter_button->clear_visible_focus();
			line_style_join_miter_button->type(FL_RADIO_BUTTON);
			line_style_join_miter_button->value(1);
			line_style_join_miter_button->callback(line_style_cb, this);
			yp += 18;
			line_style_join_round_button = new MyToggleButton(360, yp, 60, 16, "Join Round");
			line_style_join_round_button->labelsize(9);
			line_style_join_round_button->labelcolor(WHITE);
			line_style_join_round_button->color(DARK_GRAY);
			line_style_join_round_button->box(FL_FLAT_BOX);
			line_style_join_round_button->clear_visible_focus();
			line_style_join_round_button->type(FL_RADIO_BUTTON);
			line_style_join_round_button->callback(line_style_cb, this);
			yp += 18;
			line_style_join_bevel_button = new MyToggleButton(360, yp, 60, 16, "Join Bevel");
			line_style_join_bevel_button->labelsize(9);
			line_style_join_bevel_button->labelcolor(WHITE);
			line_style_join_bevel_button->color(DARK_GRAY);
			line_style_join_bevel_button->box(FL_FLAT_BOX);
			line_style_join_bevel_button->clear_visible_focus();
			line_style_join_bevel_button->type(FL_RADIO_BUTTON);
			line_style_join_bevel_button->callback(line_style_cb, this);
			yp += 18;
		line_join_group->end();
	line_group->end();
	line_group->hide();
	rectangle_group = new MyGroup(120, 20, 1920, 1080);
	rectangle_group->box(FL_NO_BOX);
	rectangle_group->color(DARK_GRAY);
		yp = 38;
		rectangle_sample = new RectangleSample(this, 120, yp, 100, 100);
		rectangle_sample->color(DARK_GRAY);
		rectangle_sample->box(FL_FRAME_BOX);
		rectangle_sample->labelcolor(WHITE);
		rectangle_sample->labelsize(1);

		rectangle_size_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Size");
		rectangle_size_slider->color(BLACK);
		rectangle_size_slider->box(FL_FRAME_BOX);
		rectangle_size_slider->align(FL_ALIGN_LEFT);
		rectangle_size_slider->labelcolor(WHITE);
		rectangle_size_slider->labelsize(9);
		rectangle_size_slider->value(1.0);
		rectangle_size_slider->range(1.0, 30.0);
		rectangle_size_slider->callback(drawing_rectangle_size_cb, this);

		rectangle_size_output = new Fl_Output(365, yp, 25, 10);
		rectangle_size_output->color(BLACK);
		rectangle_size_output->box(FL_FLAT_BOX);
		rectangle_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_size_output->textfont(FL_COURIER);
		rectangle_size_output->textcolor(WHITE);
		rectangle_size_output->textsize(9);
		rectangle_size_output->value("  1");
		yp += 16;
	
		rectangle_red_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Red");
		rectangle_red_slider->color(BLACK);
		rectangle_red_slider->box(FL_FRAME_BOX);
		rectangle_red_slider->align(FL_ALIGN_LEFT);
		rectangle_red_slider->labelcolor(WHITE);
		rectangle_red_slider->labelsize(9);
		rectangle_red_slider->value(255.0);
		rectangle_red_slider->range(0.0, 255.0);
		rectangle_red_slider->callback(drawing_rectangle_color_cb, this);

		rectangle_red_output = new Fl_Output(365, yp, 25, 10);
		rectangle_red_output->color(BLACK);
		rectangle_red_output->box(FL_FLAT_BOX);
		rectangle_red_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_red_output->textfont(FL_COURIER);
		rectangle_red_output->textcolor(WHITE);
		rectangle_red_output->textsize(9);
		rectangle_red_output->value("255");
		yp += 12;
	
		rectangle_green_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Green");
		rectangle_green_slider->color(BLACK);
		rectangle_green_slider->box(FL_FRAME_BOX);
		rectangle_green_slider->align(FL_ALIGN_LEFT);
		rectangle_green_slider->labelcolor(WHITE);
		rectangle_green_slider->labelsize(9);
		rectangle_green_slider->value(250.0);
		rectangle_green_slider->range(0.0, 255.0);
		rectangle_green_slider->callback(drawing_rectangle_color_cb, this);

		rectangle_green_output = new Fl_Output(365, yp, 25, 10);
		rectangle_green_output->color(BLACK);
		rectangle_green_output->box(FL_FLAT_BOX);
		rectangle_green_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_green_output->textfont(FL_COURIER);
		rectangle_green_output->textcolor(WHITE);
		rectangle_green_output->textsize(9);
		rectangle_green_output->value("255");
		yp += 12;
	
		rectangle_blue_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Blue");
		rectangle_blue_slider->color(BLACK);
		rectangle_blue_slider->box(FL_FRAME_BOX);
		rectangle_blue_slider->align(FL_ALIGN_LEFT);
		rectangle_blue_slider->labelcolor(WHITE);
		rectangle_blue_slider->labelsize(9);
		rectangle_blue_slider->value(255.0);
		rectangle_blue_slider->range(0.0, 255.0);
		rectangle_blue_slider->callback(drawing_rectangle_color_cb, this);

		rectangle_blue_output = new Fl_Output(365, yp, 25, 10);
		rectangle_blue_output->color(BLACK);
		rectangle_blue_output->box(FL_FLAT_BOX);
		rectangle_blue_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_blue_output->textfont(FL_COURIER);
		rectangle_blue_output->textcolor(WHITE);
		rectangle_blue_output->textsize(9);
		rectangle_blue_output->value("255");
		yp += 12;

		rectangle_alpha_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Alpha");
		rectangle_alpha_slider->color(BLACK);
		rectangle_alpha_slider->box(FL_FRAME_BOX);
		rectangle_alpha_slider->align(FL_ALIGN_LEFT);
		rectangle_alpha_slider->labelcolor(WHITE);
		rectangle_alpha_slider->labelsize(9);
		rectangle_alpha_slider->value(255.0);
		rectangle_alpha_slider->range(0.0, 255.0);
		rectangle_alpha_slider->callback(drawing_rectangle_color_cb, this);

		rectangle_alpha_output = new Fl_Output(365, yp, 25, 10);
		rectangle_alpha_output->color(BLACK);
		rectangle_alpha_output->box(FL_FLAT_BOX);
		rectangle_alpha_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_alpha_output->textfont(FL_COURIER);
		rectangle_alpha_output->textcolor(WHITE);
		rectangle_alpha_output->textsize(9);
		rectangle_alpha_output->value("255");
		yp += 12;

		rectangle_palette_button = new MyButton(260, yp, 70, 18, "Palette");
		rectangle_palette_button->labelsize(7);
		rectangle_palette_button->labelcolor(YELLOW);
		rectangle_palette_button->color(BLACK);
		rectangle_palette_button->box(FL_FLAT_BOX);
		rectangle_palette_button->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		rectangle_palette_button->clear_visible_focus();
		rectangle_palette_button->callback(immediate_palette_for_rectangle_cb, this);
		yp += 22;

		start_yp = yp;
		MyGroup *rectangle_style_group = new MyGroup(250, yp, 60, 60);
			rectangle_style_solid_button = new MyToggleButton(250, yp, 60, 16, "Solid");
			rectangle_style_solid_button->labelsize(9);
			rectangle_style_solid_button->labelcolor(WHITE);
			rectangle_style_solid_button->color(DARK_GRAY);
			rectangle_style_solid_button->box(FL_FLAT_BOX);
			rectangle_style_solid_button->clear_visible_focus();
			rectangle_style_solid_button->type(FL_RADIO_BUTTON);
			rectangle_style_solid_button->value(1);
			rectangle_style_solid_button->callback(rectangle_style_cb, this);
			yp += 18;

			rectangle_style_dash_button = new MyToggleButton(250, yp, 60, 16, "Dash");
			rectangle_style_dash_button->labelsize(9);
			rectangle_style_dash_button->labelcolor(WHITE);
			rectangle_style_dash_button->color(DARK_GRAY);
			rectangle_style_dash_button->box(FL_FLAT_BOX);
			rectangle_style_dash_button->clear_visible_focus();
			rectangle_style_dash_button->type(FL_RADIO_BUTTON);
			rectangle_style_dash_button->callback(rectangle_style_cb, this);
			yp += 18;

			rectangle_style_dot_button = new MyToggleButton(250, yp, 60, 16, "Dot");
			rectangle_style_dot_button->labelsize(9);
			rectangle_style_dot_button->labelcolor(WHITE);
			rectangle_style_dot_button->color(DARK_GRAY);
			rectangle_style_dot_button->box(FL_FLAT_BOX);
			rectangle_style_dot_button->clear_visible_focus();
			rectangle_style_dot_button->type(FL_RADIO_BUTTON);
			rectangle_style_dot_button->callback(rectangle_style_cb, this);
		rectangle_style_group->end();
		yp = start_yp;
		MyGroup *rectangle_join_group = new MyGroup(320, yp, 60, 60);
			rectangle_style_join_miter_button = new MyToggleButton(320, yp, 60, 16, "Join Miter");
			rectangle_style_join_miter_button->labelsize(9);
			rectangle_style_join_miter_button->labelcolor(WHITE);
			rectangle_style_join_miter_button->color(DARK_GRAY);
			rectangle_style_join_miter_button->box(FL_FLAT_BOX);
			rectangle_style_join_miter_button->clear_visible_focus();
			rectangle_style_join_miter_button->type(FL_RADIO_BUTTON);
			rectangle_style_join_miter_button->value(1);
			rectangle_style_join_miter_button->callback(rectangle_style_cb, this);
			yp += 18;
			rectangle_style_join_round_button = new MyToggleButton(320, yp, 60, 16, "Join Round");
			rectangle_style_join_round_button->labelsize(9);
			rectangle_style_join_round_button->labelcolor(WHITE);
			rectangle_style_join_round_button->color(DARK_GRAY);
			rectangle_style_join_round_button->box(FL_FLAT_BOX);
			rectangle_style_join_round_button->clear_visible_focus();
			rectangle_style_join_round_button->type(FL_RADIO_BUTTON);
			rectangle_style_join_round_button->callback(rectangle_style_cb, this);
			yp += 18;
			rectangle_style_join_bevel_button = new MyToggleButton(320, yp, 60, 16, "Join Bevel");
			rectangle_style_join_bevel_button->labelsize(9);
			rectangle_style_join_bevel_button->labelcolor(WHITE);
			rectangle_style_join_bevel_button->color(DARK_GRAY);
			rectangle_style_join_bevel_button->box(FL_FLAT_BOX);
			rectangle_style_join_bevel_button->clear_visible_focus();
			rectangle_style_join_bevel_button->type(FL_RADIO_BUTTON);
			rectangle_style_join_bevel_button->callback(rectangle_style_cb, this);
			yp += 22;
		rectangle_join_group->end();
		rectangle_filled_button = new MyToggleButton(250, yp, 60, 16, "Filled");
		rectangle_filled_button->labelsize(9);
		rectangle_filled_button->labelcolor(WHITE);
		rectangle_filled_button->color(DARK_GRAY);
		rectangle_filled_button->box(FL_FLAT_BOX);
		rectangle_filled_button->clear_visible_focus();
		rectangle_filled_button->value(0);
		rectangle_filled_button->callback(rectangle_style_cb, this);
		yp += 22;

		rectangle_square_button = new MyToggleButton(250, yp, 60, 16, "Squared");
		rectangle_square_button->labelsize(9);
		rectangle_square_button->labelcolor(WHITE);
		rectangle_square_button->color(DARK_GRAY);
		rectangle_square_button->box(FL_FLAT_BOX);
		rectangle_square_button->clear_visible_focus();
		rectangle_square_button->value(0);
		rectangle_square_button->callback(rectangle_style_cb, this);
		yp += 22;

		rectangle_erase_button = new MyToggleButton(250, yp, 60, 16, "Erase");
		rectangle_erase_button->labelsize(9);
		rectangle_erase_button->labelcolor(WHITE);
		rectangle_erase_button->color(DARK_GRAY);
		rectangle_erase_button->box(FL_FLAT_BOX);
		rectangle_erase_button->clear_visible_focus();
		rectangle_erase_button->value(0);
		rectangle_erase_button->callback(rectangle_style_cb, this);
	rectangle_group->end();
	rectangle_group->hide();

	freehand_group = new MyGroup(120, 20, 1920, 1080);
	freehand_group->box(FL_NO_BOX);
	freehand_group->color(DARK_GRAY);
		yp = 38;
		freehand_sample = new FreehandSample(this, 120, yp, 100, 100);
		freehand_sample->color(DARK_GRAY);
		freehand_sample->box(FL_FRAME_BOX);
		freehand_sample->labelcolor(WHITE);
		freehand_sample->labelsize(1);
		freehand_sample->freehand_mat = freehand_mat;

		freehand_size_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Size");
		freehand_size_slider->color(BLACK);
		freehand_size_slider->box(FL_FRAME_BOX);
		freehand_size_slider->align(FL_ALIGN_LEFT);
		freehand_size_slider->labelcolor(WHITE);
		freehand_size_slider->labelsize(9);
		freehand_size_slider->value(1.0);
		freehand_size_slider->range(1.0, 90.0);
		freehand_size_slider->callback(drawing_freehand_size_cb, this);

		freehand_size_output = new Fl_Output(365, yp, 25, 10);
		freehand_size_output->color(BLACK);
		freehand_size_output->box(FL_FLAT_BOX);
		freehand_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		freehand_size_output->textfont(FL_COURIER);
		freehand_size_output->textcolor(WHITE);
		freehand_size_output->textsize(9);
		freehand_size_output->value("  1");
		yp += 16;
	
		freehand_red_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Red");
		freehand_red_slider->color(BLACK);
		freehand_red_slider->box(FL_FRAME_BOX);
		freehand_red_slider->align(FL_ALIGN_LEFT);
		freehand_red_slider->labelcolor(WHITE);
		freehand_red_slider->labelsize(9);
		freehand_red_slider->value(255.0);
		freehand_red_slider->range(0.0, 255.0);
		freehand_red_slider->callback(drawing_freehand_color_cb, this);

		freehand_red_output = new Fl_Output(365, yp, 25, 10);
		freehand_red_output->color(BLACK);
		freehand_red_output->box(FL_FLAT_BOX);
		freehand_red_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		freehand_red_output->textfont(FL_COURIER);
		freehand_red_output->textcolor(WHITE);
		freehand_red_output->textsize(9);
		freehand_red_output->value("255");
		yp += 12;
	
		freehand_green_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Green");
		freehand_green_slider->color(BLACK);
		freehand_green_slider->box(FL_FRAME_BOX);
		freehand_green_slider->align(FL_ALIGN_LEFT);
		freehand_green_slider->labelcolor(WHITE);
		freehand_green_slider->labelsize(9);
		freehand_green_slider->value(255.0);
		freehand_green_slider->range(0.0, 255.0);
		freehand_green_slider->callback(drawing_freehand_color_cb, this);

		freehand_green_output = new Fl_Output(365, yp, 25, 10);
		freehand_green_output->color(BLACK);
		freehand_green_output->box(FL_FLAT_BOX);
		freehand_green_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		freehand_green_output->textfont(FL_COURIER);
		freehand_green_output->textcolor(WHITE);
		freehand_green_output->textsize(9);
		freehand_green_output->value("255");
		yp += 12;
	
		freehand_blue_slider = new Fl_Hor_Slider(260, yp, 100, 10, "Blue");
		freehand_blue_slider->color(BLACK);
		freehand_blue_slider->box(FL_FRAME_BOX);
		freehand_blue_slider->align(FL_ALIGN_LEFT);
		freehand_blue_slider->labelcolor(WHITE);
		freehand_blue_slider->labelsize(9);
		freehand_blue_slider->value(255.0);
		freehand_blue_slider->range(0.0, 255.0);
		freehand_blue_slider->callback(drawing_freehand_color_cb, this);

		freehand_blue_output = new Fl_Output(365, yp, 25, 10);
		freehand_blue_output->color(BLACK);
		freehand_blue_output->box(FL_FLAT_BOX);
		freehand_blue_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		freehand_blue_output->textfont(FL_COURIER);
		freehand_blue_output->textcolor(WHITE);
		freehand_blue_output->textsize(9);
		freehand_blue_output->value("255");
		yp += 12;

		freehand_palette_button = new MyButton(260, yp, 70, 18, "Palette");
		freehand_palette_button->labelsize(7);
		freehand_palette_button->labelcolor(YELLOW);
		freehand_palette_button->color(BLACK);
		freehand_palette_button->box(FL_FLAT_BOX);
		freehand_palette_button->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		freehand_palette_button->clear_visible_focus();
		freehand_palette_button->callback(immediate_palette_for_freehand_cb, this);
		yp += 22;

		start_yp = yp;
		MyGroup *freehand_shape_group = new MyGroup(250, yp, 120, 120);
			freehand_shape_square_button = new MyToggleButton(250, yp, 80, 16, "Square");
			freehand_shape_square_button->labelsize(9);
			freehand_shape_square_button->labelcolor(WHITE);
			freehand_shape_square_button->color(DARK_GRAY);
			freehand_shape_square_button->box(FL_FLAT_BOX);
			freehand_shape_square_button->clear_visible_focus();
			freehand_shape_square_button->type(FL_RADIO_BUTTON);
			freehand_shape_square_button->value(1);
			freehand_shape_square_button->callback(freehand_shape_cb, this);
			yp += 18;
			freehand_shape_circle_button = new MyToggleButton(250, yp, 80, 16, "Circle");
			freehand_shape_circle_button->labelsize(9);
			freehand_shape_circle_button->labelcolor(WHITE);
			freehand_shape_circle_button->color(DARK_GRAY);
			freehand_shape_circle_button->box(FL_FLAT_BOX);
			freehand_shape_circle_button->clear_visible_focus();
			freehand_shape_circle_button->type(FL_RADIO_BUTTON);
			freehand_shape_circle_button->value(0);
			freehand_shape_circle_button->callback(freehand_shape_cb, this);
			yp += 18;
			freehand_shape_erase_square_button = new MyToggleButton(250, yp, 80, 16, "Erase Square");
			freehand_shape_erase_square_button->labelsize(9);
			freehand_shape_erase_square_button->labelcolor(WHITE);
			freehand_shape_erase_square_button->color(DARK_GRAY);
			freehand_shape_erase_square_button->box(FL_FLAT_BOX);
			freehand_shape_erase_square_button->clear_visible_focus();
			freehand_shape_erase_square_button->type(FL_RADIO_BUTTON);
			freehand_shape_erase_square_button->value(0);
			freehand_shape_erase_square_button->callback(freehand_shape_cb, this);
			yp += 18;
			freehand_shape_erase_circle_button = new MyToggleButton(250, yp, 80, 16, "Erase Circle");
			freehand_shape_erase_circle_button->labelsize(9);
			freehand_shape_erase_circle_button->labelcolor(WHITE);
			freehand_shape_erase_circle_button->color(DARK_GRAY);
			freehand_shape_erase_circle_button->box(FL_FLAT_BOX);
			freehand_shape_erase_circle_button->clear_visible_focus();
			freehand_shape_erase_circle_button->type(FL_RADIO_BUTTON);
			freehand_shape_erase_circle_button->value(0);
			freehand_shape_erase_circle_button->callback(freehand_shape_cb, this);
			yp += 18;
			freehand_shape_stamp_button = new MyToggleButton(250, yp, 80, 16, "Stamp");
			freehand_shape_stamp_button->labelsize(9);
			freehand_shape_stamp_button->labelcolor(WHITE);
			freehand_shape_stamp_button->color(DARK_GRAY);
			freehand_shape_stamp_button->box(FL_FLAT_BOX);
			freehand_shape_stamp_button->clear_visible_focus();
			freehand_shape_stamp_button->type(FL_RADIO_BUTTON);
			freehand_shape_stamp_button->value(0);
			freehand_shape_stamp_button->callback(freehand_shape_cb, this);

			freehand_shape_stamp_file_button = new MyButton(330, yp, 16, 16, "@fileopen");
			freehand_shape_stamp_file_button->labelsize(9);
			freehand_shape_stamp_file_button->labelcolor(WHITE);
			freehand_shape_stamp_file_button->color(DARK_GRAY);
			freehand_shape_stamp_file_button->box(FL_FLAT_BOX);
			freehand_shape_stamp_file_button->clear_visible_focus();
			freehand_shape_stamp_file_button->callback(freehand_shape_file_cb, this);
			yp += 18;
			freehand_shape_key_button = new MyToggleButton(250, yp, 80, 16, "Key");
			freehand_shape_key_button->labelsize(9);
			freehand_shape_key_button->labelcolor(WHITE);
			freehand_shape_key_button->color(DARK_GRAY);
			freehand_shape_key_button->box(FL_FLAT_BOX);
			freehand_shape_key_button->clear_visible_focus();
			freehand_shape_key_button->type(FL_RADIO_BUTTON);
			freehand_shape_key_button->value(0);
			freehand_shape_key_button->callback(freehand_shape_cb, this);
			yp += 18;
		freehand_shape_group->end();

	freehand_group->end();
	freehand_group->hide();
	image_group = new MyGroup(120, 20, 1920, 1080);
	image_group->box(FL_NO_BOX);
	image_group->color(DARK_GRAY);
		yp = 38;
		image_sample = new RectangleSample(this, 120, yp, 320, 180);
		image_sample->color(LIGHT_GRAY);
		image_sample->box(FL_FRAME_BOX);
		image_sample->labelcolor(WHITE);
		image_sample->labelsize(1);
		yp += 190;

		image_file_button = new MyToggleButton(120, yp, 16, 16, "@fileopen");
		image_file_button->labelsize(9);
		image_file_button->labelcolor(WHITE);
		image_file_button->color(DARK_GRAY);
		image_file_button->box(FL_FLAT_BOX);
		image_file_button->clear_visible_focus();
		image_file_button->callback(image_file_cb, this);

		image_file_path = new Fl_Input(138, yp, 300, 18);
		image_file_path->textsize(11);
		image_file_path->textcolor(BLACK);
		image_file_path->color(LIGHT_GRAY);
		image_file_path->box(FL_FLAT_BOX);
		image_file_path->set_visible_focus();
		image_file_path->when(FL_WHEN_ENTER_KEY);
		image_file_path->callback(image_file_cb, this);
		yp += 22;

		image_paste_button = new MyToggleButton(120, yp, 60, 18, "Paste");
		image_paste_button->labelsize(9);
		image_paste_button->labelcolor(WHITE);
		image_paste_button->color(DARK_GRAY);
		image_paste_button->box(FL_FLAT_BOX);
		image_paste_button->clear_visible_focus();
		image_paste_button->callback(image_paste_cb, this);

	image_group->end();
	image_group->hide();
	pixelate_group = new MyGroup(120, 20, 1920, 1080);
	pixelate_group->box(FL_NO_BOX);
	pixelate_group->color(DARK_GRAY);
		yp = 38;
		pixelate_size_slider = new Fl_Hor_Slider(160, yp, 100, 10, "Size");
		pixelate_size_slider->color(BLACK);
		pixelate_size_slider->box(FL_FRAME_BOX);
		pixelate_size_slider->align(FL_ALIGN_LEFT);
		pixelate_size_slider->labelcolor(WHITE);
		pixelate_size_slider->labelsize(9);
		pixelate_size_slider->value(10.0);
		pixelate_size_slider->range(2.0, 255.0);
		pixelate_size_slider->callback(drawing_pixelate_size_cb, this);

		pixelate_size_output = new Fl_Output(265, yp, 25, 10);
		pixelate_size_output->color(BLACK);
		pixelate_size_output->box(FL_FLAT_BOX);
		pixelate_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		pixelate_size_output->textfont(FL_COURIER);
		pixelate_size_output->textcolor(WHITE);
		pixelate_size_output->textsize(9);
		pixelate_size_output->value(" 10");

		yp += 32;
		pixelate_pixelate_button = new MyToggleButton(150, yp, 60, 16, "Pixelate");
		pixelate_pixelate_button->labelsize(9);
		pixelate_pixelate_button->labelcolor(WHITE);
		pixelate_pixelate_button->color(DARK_GRAY);
		pixelate_pixelate_button->box(FL_FLAT_BOX);
		pixelate_pixelate_button->clear_visible_focus();
		pixelate_pixelate_button->type(FL_RADIO_BUTTON);
		pixelate_pixelate_button->value(1);
		pixelate_pixelate_button->callback(drawing_pixelate_mode_cb, this);
		
		pixelate_blur_button = new MyToggleButton(220, yp, 60, 16, "Blur");
		pixelate_blur_button->labelsize(9);
		pixelate_blur_button->labelcolor(WHITE);
		pixelate_blur_button->color(DARK_GRAY);
		pixelate_blur_button->box(FL_FLAT_BOX);
		pixelate_blur_button->clear_visible_focus();
		pixelate_blur_button->type(FL_RADIO_BUTTON);
		pixelate_blur_button->value(0);
		pixelate_blur_button->callback(drawing_pixelate_mode_cb, this);
		yp += 18;
	pixelate_group->end();
	pixelate_group->hide();
	end();
}

ImmediateDrawingWindow::~ImmediateDrawingWindow()
{
}

void	ImmediateDrawingWindow::ClearSelectedWidget()
{
	if(selected_widget != NULL)
	{
		selected_widget->actively_drawing = 0;
		selected_widget = NULL;
	}
}

void	ImmediateDrawingWindow::hide()
{
	my_window->im_drawing_mode = 0;
	if(my_window->anim_timeline != NULL)
	{
		my_window->anim_timeline->hide();
	}
	Fl_Window::hide();
}

void	ImmediateDrawingWindow::Color(int in_color)
{
int	loop;

	color(in_color);
	for(loop = 0;loop < children();loop++)
	{
		if(child(loop) != NULL)
		{
			child(loop)->color(in_color);
		}
	}
}

void	ImmediateDrawingWindow::CloseAll()
{
	general_group->hide();
	text_group->hide();
	line_group->hide();
	freehand_group->hide();
	rectangle_group->hide();
	image_group->hide();
	pixelate_group->hide();

	resize(x(), y(), orig_w, orig_h);
}

int	ImmediateDrawingWindow::handle(int event)
{
	int flag = 0;
	if((event == FL_FOCUS) || (event == FL_UNFOCUS))
	{
		flag = 1;
	}
	else if(event == FL_KEYBOARD)
	{
		if(mode == DRAWING_MODE_FREEHAND)
		{
			char *str = (char *)Fl::event_text();
			if(str != NULL)
			{
				char key = str[0];
				if((key > 32) && (key < 127))
				{
					freehand_key = key;
					freehand_sample->key = key;
					freehand_sample->redraw();
					flag = 1;
				}
			}
		}
	}
	else if(event == FL_SHOW)
	{
		if(my_window != NULL)
		{
			if(my_window->immediate_cnt > 0)
			{
				paste_button->show();
				clear_copy_buffer_button->show();
			}
			else
			{
				paste_button->hide();
				clear_copy_buffer_button->hide();
			}
		}
	}
	else if(event == FL_PASTE)
	{
		int	rr = mat_from_copy_buffer(image_mat);
		if(rr == 1)
		{
			redraw();
		}
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	font_selection_cb(Fl_Widget *w, void *v)
{
}

void	ImmediateDrawingWindow::GeneralSetup()
{
int	loop;

	general_group->show();
	resize(x(), y(), 352, orig_h);
}

void	ImmediateDrawingWindow::TextSetup()
{
int	loop;

	font_browser->clear();
	int yp = 0;
	int nn = my_window->number_of_fonts;
	for(loop = 0;loop < nn;loop++)
	{
		int attr = 0;
		char *str = (char *)Fl::get_font_name(loop, &attr);
		if(attr == 0)
		{
			char buf[256];
			sprintf(buf, "@F%05d%s", loop, str);
			font_browser->add(buf, (void *)(long int)loop);
		}
	}
	if(strlen(selected_font) < 1)
	{
		font_browser->value(1);
		char *str = (char *)font_browser->text(font_browser->value());
		if(str != NULL)
		{
			strcpy(selected_font, str);
			font_output->copy_label(str);
			font_output->redraw();
		}
	}
	text_group->show();
	resize(x(), y(), 430, orig_h);
}

void	ImmediateDrawingWindow::LineSetup()
{
	line_group->show();
	if(mode == DRAWING_MODE_LINE)
	{
		line_style_arrow_button->show();
		line_style_erase_button->hide();
	}
	else
	{
		line_style_arrow_button->hide();
		line_style_erase_button->show();
	}
	resize(x(), y(), 430, orig_h);
}

void	ImmediateDrawingWindow::RectangleSetup()
{
	rectangle_group->show();
	resize(x(), y(), 430, orig_h);
}

void	ImmediateDrawingWindow::PixelateSetup()
{
	pixelate_group->show();
	resize(x(), y(), 320, orig_h);
}

void	ImmediateDrawingWindow::ImageSetup()
{
	image_group->show();
	resize(x(), y(), 460, orig_h);
}

void	ImmediateDrawingWindow::FreehandSetup()
{
	freehand_group->show();
	resize(x(), y(), 430, orig_h);
}

// SECTION *********************************** COLOR WINDOW *******************************************

void	save_global_palette_as_JSON()
{
int	loop;

	FILE *fp = fopen("color_palette.json", "w");
	if(fp != NULL)
	{
		fprintf(fp, "{\n");
		fprintf(fp, "\t\"palette\": [\n");
		for(loop = 0;loop < 32;loop++)
		{
			fprintf(fp, "\t\t{\n");
			fprintf(fp, "\t\t\t\"red\": %d,\n", global_palette_red[loop]);
			fprintf(fp, "\t\t\t\"green\": %d,\n", global_palette_green[loop]);
			fprintf(fp, "\t\t\t\"blue\": %d,\n", global_palette_blue[loop]);
			fprintf(fp, "\t\t\t\"alpha\": %d\n", global_palette_alpha[loop]);
			if(loop == 32 - 1)
			{
				fprintf(fp, "\t\t}\n");
			}
			else
			{
				fprintf(fp, "\t\t},\n");
			}
		}
		fprintf(fp, "\t]\n");
		fprintf(fp, "}\n");
		fclose(fp);
	}
}

void	load_global_palette_as_JSON()
{
	char *buf = ReadWholeFile("color_palette.json");
	if(buf != NULL)
	{
		cJSON *json = cJSON_Parse(buf);
		if(json == NULL)
		{
			const char *error_ptr = cJSON_GetErrorPtr();
			if(error_ptr != NULL)
			{
				fprintf(stderr, "Error: JSON Error before: %s reading %s\n", error_ptr, "color_palette.json");
			}
		}
		else
		{
			cJSON *palette = NULL;
			cJSON *palettes = json_parse_array(json, "palette");
			int cnt = 0;
			if(palettes != NULL)
			{
				int cnt = 0;
				cJSON_ArrayForEach(palette, palettes)
				{
					if(cnt < 32)
					{
						json_parse_int(palette, "red", global_palette_red[cnt]);
						json_parse_int(palette, "green", global_palette_green[cnt]);
						json_parse_int(palette, "blue", global_palette_blue[cnt]);
						json_parse_int(palette, "alpha", global_palette_alpha[cnt]);
						cnt++;
					}
				}
			}
			cJSON_Delete(json);
		}
		free(buf);
	}
	else
	{
		fprintf(stderr, "Error: Cannot read JSON file: %s\n", "color_palette.json");
	}
}

void	color_dialog_cb(Fl_Widget *w, void *v)
{
int	loop;

	ColorPanel *cd = (ColorPanel *)v;
	int rr = cd->red->value();
	int gg = cd->green->value();
	int bb = cd->blue->value();
	int aa = cd->alpha->value();

	*cd->client_red = rr;
	*cd->client_green = gg;
	*cd->client_blue = bb;
	*cd->client_alpha = aa;
	cd->sample->color(fl_rgb_color(rr, gg, bb));
	for(loop = 0;loop < 32;loop++)
	{
		if(cd->palette_set_button[loop]->value())
		{
			global_palette_red[loop] = cd->red->value();
			global_palette_green[loop] = cd->green->value();
			global_palette_blue[loop] = cd->blue->value();
			global_palette_alpha[loop] = cd->alpha->value();
			int rr = global_palette_red[loop];
			int gg = global_palette_green[loop];
			int bb = global_palette_blue[loop];
			cd->palette_button[loop]->color(fl_rgb_color(rr, gg, bb));
			cd->palette_button[loop]->redraw();
		}
	}
	cd->redraw();
	if(cd->custom_callback == 1)
	{
		cd->do_callback();
	}
}

void	color_dialog_select_palette(Fl_Widget *w, void *v)
{
int	loop;

	ColorPanel *cd = (ColorPanel *)v;
	for(loop = 0;loop < 32;loop++)
	{
		if(w == cd->palette_button[loop])
		{
			int rr = global_palette_red[loop];
			int gg = global_palette_green[loop];
			int bb = global_palette_blue[loop];
			int aa = global_palette_alpha[loop];

			cd->red->value(rr);
			cd->green->value(gg);
			cd->blue->value(bb);
			cd->alpha->value(aa);

			*cd->client_red = rr;
			*cd->client_green = gg;
			*cd->client_blue = bb;
			*cd->client_alpha = aa;

			cd->sample->color(fl_rgb_color(rr, gg, bb));
			cd->sample->redraw();
		}
	}
	cd->redraw();
	if(cd->custom_callback == 1)
	{
		cd->do_callback();
	}
}

void	color_dialog_set_palette(Fl_Widget *w, void *v)
{
int	loop;

	ColorPanel *cd = (ColorPanel *)v;
	for(loop = 0;loop < 32;loop++)
	{
		if(w == cd->palette_set_button[loop])
		{
			global_palette_red[loop] = cd->red->value();
			global_palette_green[loop] = cd->green->value();
			global_palette_blue[loop] = cd->blue->value();
			global_palette_alpha[loop] = cd->alpha->value();
			int rr = global_palette_red[loop];
			int gg = global_palette_green[loop];
			int bb = global_palette_blue[loop];
			cd->palette_button[loop]->color(fl_rgb_color(rr, gg, bb));
			cd->palette_button[loop]->redraw();
		}
	}
}

ColorPanel::ColorPanel(MyWin *in_win, int *in_red, int *in_green, int *in_blue, int *in_alpha, int xx, int yy, int ww, int hh) : Fl_Window(xx, yy, ww, hh)
{
int	inner, outer;

	box(FL_FLAT_BOX);
	color(BLACK);

	custom_callback = 0;
	client_red = in_red;
	client_green = in_green;
	client_blue = in_blue;
	client_alpha = in_alpha;

	int y_pos = 0;
	red = new ColorSlider(40, y_pos, w() - 100, 20, 128, "Red");
	red->callback(color_dialog_cb, this);
	y_pos += 22;
	green = new ColorSlider(40, y_pos, w() - 100, 20, 128, "Green");
	green->callback(color_dialog_cb, this);
	y_pos += 22;
	blue = new ColorSlider(40, y_pos, w() - 100, 20, 128, "Blue");
	blue->callback(color_dialog_cb, this);
	y_pos += 22;
	alpha = new ColorSlider(40, y_pos, w() - 100, 20, 255, "Alpha");
	alpha->callback(color_dialog_cb, this);
	y_pos += 28;

	int cnt = 0;
	int ux = 40;
	int uy = y_pos;
	for(outer = 0;outer < 2;outer++)
	{
		for(inner = 0;inner < 16;inner++)
		{
			int rr = global_palette_red[cnt];
			int gg = global_palette_green[cnt];
			int bb = global_palette_blue[cnt];
			palette_button[cnt] = new MyButton(ux, uy, 18, 18, "");
			palette_button[cnt]->box(FL_FLAT_BOX);
			palette_button[cnt]->color(fl_rgb_color(rr, gg, bb));
			palette_button[cnt]->copy_tooltip("Select a palette color");
			palette_button[cnt]->callback(color_dialog_select_palette, this);

			palette_set_button[cnt] = new MyToggleButton(ux, uy + 18, 18, 8);
			palette_set_button[cnt]->box(FL_FRAME_BOX);
			palette_set_button[cnt]->color(BLACK);
			palette_set_button[cnt]->down_color(YELLOW);
			palette_set_button[cnt]->copy_tooltip("Set a palette entry");
			palette_set_button[cnt]->callback(color_dialog_set_palette, this);
			ux += 19;
			cnt++;
		}
		ux = 40;
		uy += 28;
	}
	red->value(*client_red);
	green->value(*client_green);
	blue->value(*client_blue);
	alpha->value(*client_alpha);

	sample = new Fl_Box(w() - 55, 0, 50, 50);
	sample->box(FL_FRAME_BOX);
	sample->color(fl_rgb_color(*client_red, *client_green, *client_blue));
	end();
};

ColorPanel::~ColorPanel()
{
}

void	ColorPanel::Callback(Fl_Callback *cb, void *v)
{
	custom_callback = 1;
	Fl_Window::callback(cb, v);
}

ColorDialog::ColorDialog(MyWin *in_win, int ww, int hh, int& use_r, int& use_g, int& use_b, int& use_a, char *title) : Dialog(360, 300, ww, hh, "Color Dialog")
{
int	outer, inner;

	my_window = in_win;
	set_non_modal();

	last_x = 0;
	last_y = 0;

	client_red = &use_r;
	client_green = &use_g;
	client_blue = &use_b;
	client_alpha = &use_a;
	color_panel = new ColorPanel(in_win, client_red, client_green, client_blue, client_alpha, 2, 35, w() - 4, h() - 37);
}

ColorDialog::~ColorDialog()
{
	hide();
}

void	ColorDialog::draw()
{
	Fl_Window::draw();
}

int	ColorDialog::handle(int event)
{
	int flag = 0;
	if(event == FL_FOCUS)
	{
		flag = 1;
	}
	else if(event == FL_UNFOCUS)
	{
		flag = 1;
	}
	else if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == FL_Escape)
		{
			hide();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	ColorDialog::hide()
{
	save_global_palette_as_JSON();
	Dialog::hide();
}

// SECTION *********************************** FAKE WINDOW *******************************************

FakeWindow::FakeWindow(MyWin *in_win, char *raw) : Fl_Double_Window(0, 0, Fl::w(), Fl::h())
{
	my_window = in_win;
	border(0);
	fullscreen();
	set_modal();
	raw_data = raw;
	start_x = -1;
	start_y = -1;
	end_x = -1;
	end_y = -1;
	final_sx = -1;
	final_sy = -1;
	final_ww = -1;
	final_hh = -1;
	dragging = 0;
	end();
	show();
}

FakeWindow::~FakeWindow()
{
}

void	FakeWindow::draw()
{
	Fl_Window::draw();
	if(raw_data != NULL)
	{
		fl_draw_image((unsigned char *)raw_data, 0, 0, w(), h(), 3);
		if((start_x > -1)
		&& (start_y > -1)
		&& (end_x > -1)
		&& (end_y > -1))
		{
			int sx = 0;
			int sy = 0;
			int ww = Fl::w();
			int hh = Fl::h();
			if(start_x < end_x)
			{
				ww = end_x - start_x;
				sx = start_x;
			}
			else
			{
				ww = start_x - end_x;
				sx = end_x;
			}
			if(start_y < end_y)
			{
				hh = end_y - start_y;
				sy = start_y;
			}
			else
			{
				hh = start_y - end_y;
				sy = end_y;
			}
			fl_color(YELLOW);
			fl_rect(sx, sy, ww, hh);
			final_sx = sx;
			final_sy = sy;
			final_ww = ww;
			final_hh = hh;
		}
	}
}

int	FakeWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		if(Fl::event_button() == 1)
		{
			start_x = Fl::event_x();
			start_y = Fl::event_y();
			end_x = start_x;
			end_y = start_y;
			redraw();
			dragging = 1;
		}
		else if(Fl::event_button() == 3)
		{
			if((final_sx > -1)
			&& (final_sy > -1)
			&& (final_ww > -1)
			&& (final_hh > -1))
			{
				char buf[4096];
				char buf2[4096];
				sprintf(buf, "desktop://%d,%d,%d,%d", final_sx, final_sy, final_ww, final_hh);
				sprintf(buf2, "Desktop (%d,%d,%d,%d)", final_sx, final_sy, final_ww, final_hh);
				if(my_window->new_source_window != NULL)
				{
					my_window->new_source_window->source->value(buf);
					Fl_Input *alias_in = (Fl_Input *)my_window->new_source_window->alias;
					char *alias = (char *)alias_in->value();
					if(alias != NULL)
					{
						if(strlen(alias) > 0)
						{
							strcpy(buf2, alias);
						}
					}
				}
				my_window->show();
				my_window->new_source_window->show();
				my_window->set_non_modal();
				hide();
			}
			dragging = 0;
		}
		flag = 1;
	}
	else if((event == FL_DRAG) || (event == FL_DRAG))
	{
		if(dragging == 1)
		{
			end_x = Fl::event_x();
			end_y = Fl::event_y();
			redraw();
			flag = 1;
		}
	}
	else if(event == FL_RELEASE)
	{
		end_x = Fl::event_x();
		end_y = Fl::event_y();
		dragging = 0;
		redraw();
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

// SECTION *********************************** CAMERA *******************************************

unsigned char	*local_capture_cap(int *width, int *height)
{
	unsigned char *(*capture_cap)(int *, int *);
	capture_cap = (unsigned char *(*)(int *, int *))void_capture_capture;
	int pseudo_width = 0;
	int pseudo_height = 0;
	unsigned char *ptr = capture_cap(&pseudo_width, &pseudo_height);
	*width = pseudo_width;
	*height = pseudo_height;
	return(ptr);
}

Camera::Camera(MyWin *in_win, int in_id, char *source, int num, double forced_fps, int in_requested_w, int in_requested_h, int rr, int gg, int bb, int aa, int t_rr, int t_gg, int t_bb, int t_aa, int use_chroma)
{
int		loop;

	hot = 0;
	hot_delay = 10000;

	my_window = in_win;
	type = CAMERA_TYPE_CAMERA;
	id = in_id;
	power = 1;
	failed = 0;
	triggers_requested = 0;
	trigger_override = 0;
	result_trigger = 0;
	detect_time = 0;
	requested_x = -1;
	requested_y = -1;
	requested_w = in_requested_w;
	requested_h = in_requested_h;
	strcpy(path, "");
	strcpy(original_path, "");
	strcpy(alias, "");
	record = 0;
	recording = 0;
	last = 0;
	record_trigger = 0;
	schedule_start = 0;
	schedule_stop = 0;
	schedule_day = 0;
	darkness_trigger = 0.5;
	darkness_score = 0.0;
	motion_score = 0;
	ever_opened = 0;
	capture_scaling = 1.0;
	zoom = 1.0;
	priority = 0;
	cap = NULL;
	width = 0;
	height = 0;
	orig_width = 0;
	orig_height = 0;
	last_grab_time = 0;
	grab_interval = 0;
	last_capture_time = 0;
	capture_interval = 0.0;
	newly_captured = 0;
	font_sz = 32;
	grab_window_id = 0;
	static_initialized = 0;
	save_fifo = NULL;
	stopped = 1;
	forced_aspect_x = 1.0;
	forced_aspect_y = 1.0;
	hot_fps = my_window->minimum_fps;
	fd = -1;
	total_frames = 0;
	true_total_frames = 0;
	since_frames = 0;
	since_time = 0;
	elapsed = 0;
	old_elapsed = -1;
	frame_cnt = 0;
	fps = forced_fps;
	capturing = 0;
	current_fps = 30.0;
	old_fps = 0;
	fps_cnt = 0;
	focus_using_samples = 0;
	keep_focusing = 0;
	focus_frame_ready = 0;
	cap_fourcc = 0;
	cap_total_frames = 0;
	cap_format = 0;
	ccx = 0;
	ccy = 0;
	cx = 0;
	cy = 0;
	last_cx = cx;
	last_cy = cy;
	shared_image = NULL;
	accel = 100;
	pip_idx = -1;
	keep_pip = 0;
	red = rr;
	green = gg;
	blue = bb;
	alpha = aa;
	text_red = t_rr;
	text_green = t_gg;
	text_blue = t_bb;
	text_alpha = t_aa;
	html = NULL;
	capture_effects = 1;
	standalone_display = NULL;
	strcpy(snapshot_filename_format, "photo_%U.png");
	snapshot_initial_delay = 0;
	snapshot_repeat_delay = 0;
	snapshot_trigger_condition = SNAPSHOT_TRIGGER_BUTTON;
	snapshot_scale = 1.0;
	snapshot = 0;
	start_timer = 0;
	stop_timer = 0;
	initial_timer = 0;
	military_clock = 0;
	timer_format = 1;
	analog = 0;
	analog_size = -1;
	slideshow_fp = NULL;
	slideshow_list_cnt = 0;
	slideshow_current = 0;
	for(loop = 0;loop < 1024;loop++)
	{
		slideshow_list[loop] = NULL;
	}
	strcpy(alert_monitor_file, "");
	alert_trigger_mode = 0;
	alert_display_mode = ALERT_DISPLAY_MODE_ALL;
	alert_duration = 0;
	alert_did_exist = 0;
	alert_end_time = 0;
	alert_permanent_trigger = 0;
	strcpy(alert_old_buffer, "");
	strcpy(alert_audio_file, "");

	irc_session = NULL;
	irc_done = 0;

	anim_preview = 0;

	ptz_lock_interface = -1;
	ptz_lock_camera = -1;
	v4l_pending_command = 0;

	immediate_list = NULL;
	immediate_cnt = 0;
	for(loop = 0;loop < 8;loop++)
	{
		layer_state[loop] = 1;
	}
	edit_layer = 0;
	split_source_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		split_source[loop] = NULL;
	}
	ndi_recv = NULL;
	ndi_capture = 0;
	ndi_ptz = 0;
	prefer_ndi = 0;
	prefer_v4l = 0;

	strcpy(pseudo_camera_name, "PSEUDO CAMERA");
	plugin_camera = NULL;
	freeze_video = 0;
	mute_video = 0;
	alternate_interval = 5.0;
	alternate_index = 0;
	alternate_time = 0;
	for(loop = 0;loop < 128;loop++)
	{
		color_it_r[loop] = 0;
		color_it_g[loop] = 0;
		color_it_b[loop] = 0;
		color_it_tolerance_r[loop] = 24;
		color_it_tolerance_g[loop] = 24;
		color_it_tolerance_b[loop] = 24;
		color_it_replace_r[loop] = 0;
		color_it_replace_g[loop] = 0;
		color_it_replace_b[loop] = 0;
		color_it_replace_a[loop] = 0;
	}
	color_it_cnt = 0;

	crop_start_x = 0;
	crop_start_y = 0;
	use_crop_start = 0;
	last_start_x = 0;
	last_start_y = 0;

	edge_blend = 0.5;
	paused_accumulation_ts = 0;
	paused_start_ts = 0;
	start_ts = local_timestamp();
	local_ts = local_timestamp();
	running_time = 0;
	starting_time = 0;

	flip_horizontal = 0;
	flip_vertical = 0;
	brightness = 0.5;
	saturation = 1.0;
	hue = 1.0;
	intensity = 1.0;
	red_intensity = 1.0;
	green_intensity = 1.0;
	blue_intensity = 1.0;
	alpha_intensity = 1.0;
	contrast = 0.5;
	motion_threshold = 100;
	recognition_threshold = 0.5;
	recognize_interval = 10;
	extra_url = NULL;
	extra_css = NULL;
	extra_js_once = NULL;
	extra_js_always = NULL;

	v4l_capable = 0;

	zoom_box_display = 0;
	zoom_box_x = -1;
	zoom_box_y = -1;
	zoom_box_w = -1;
	zoom_box_h = -1;
	resuming = 0;
	strcpy(format_code, "");
	grab_portion_x = -1;
	grab_portion_y = -1;
	grab_portion_w = -1;
	grab_portion_h = -1;
	source_camera = NULL;
	cairo_surface = NULL;
	cairo_context = NULL;
	single_frame_fd = -1;
	chroma_color = CHROMA_ON_GREEN;

	for(loop = 0;loop < 128;loop++)
	{
		filter_plugin[loop] = NULL;
		filter_plugin_name[loop] = NULL;
		filter_name[loop] = NULL;
		filter_dialog[loop] = NULL;
	}
	filter_plugin_cnt = 0;
	filter_cnt = 0;

	osg_viewer = NULL;
	instrument_window = NULL;
	for(loop = 0;loop < 128;loop++)
	{
		matrix_state[loop] = NULL;
	}
	matrix_state_cnt = 0;

	av_window = NULL;

	list_length = -1;
	list_position = 0;
	pipe_done = 0;
	for(loop = 0;loop < 128;loop++)
	{
		strcpy(text_list[loop], "");
	}
	display_width = my_window->display_width;
	display_height = my_window->display_height;
	int mw_w = my_window->w();
	int mw_h = my_window->h();
	
	bound_mic_cnt = -1;
	for(loop = 0;loop < 128;loop++)
	{
		bound_mic[loop] = NULL;
	}
	if(my_window->auto_scale == 1)
	{
		if(Fl::h() > 0)
		{
			double use_scale = 1080.0 / (double)Fl::h();
			mw_w = my_window->w() * use_scale;
			mw_h = my_window->h() * use_scale;
		}
	}
	image_sx = (mw_w / 2) - (display_width / 2);
	image_sy = (mw_h / 2) - (display_height / 2);

	once = 0;
	detected_object_cnt = 0;
	detected_object_countdown = 0;
	for(loop = 0;loop < 10;loop++)
	{
		detected_object[loop].x = -1;
		detected_object[loop].y = -1;
		detected_object[loop].w = -1;
		detected_object[loop].h = -1;
		detected_object[loop].idx = -1;
		detected_object[loop].confidence = 0.0;
	}
	for(loop = 0;loop < 1024;loop++)
	{
		object_index[loop] = 0;
	}
	trigger_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		trigger[loop] = -1;
	}
	for(loop = 0;loop < 32;loop++)
	{
		pip[loop] = NULL;
	}
	for(loop = 0;loop < 128;loop++)
	{
		image_window[loop] = NULL;
	}
	image_window_cnt = 0;
	int progress_thumb = 0;

	pipe_pid = -1;
	pipe_in = -1;
	pipe_out = -1;
	pipe_fp = NULL;

	piping_text = 0;
	if(source != NULL)
	{
		if(strncmp(source, "camera://", strlen("camera://")) == 0)
		{
			source += strlen("camera://");
		}
		if(strncmp(source, "image://", strlen("image://")) == 0)
		{
			source += strlen("image://");
		}
	}
	int live_camera = 0;
	VideoCapture *n_cap = CreateCameraCapture(source, num);
	if(n_cap != NULL)
	{
		if(n_cap->isOpened())
		{
			live_camera = 1;
		}
	}
	if(live_camera == 1)
	{
		SetSystemAlias();
		int starting_width = (int)n_cap->get(CAP_PROP_FRAME_WIDTH);
		int starting_height = (int)n_cap->get(CAP_PROP_FRAME_HEIGHT);
		if(strlen(format_code) > 0)
		{
			n_cap->set(CAP_PROP_FOURCC, VideoWriter::fourcc(format_code[0], format_code[1], format_code[2], format_code[3]));
		}
		if((starting_width != requested_w) || (starting_height != requested_h))
		{
			n_cap->set(CAP_PROP_FRAME_WIDTH, requested_w);
			n_cap->set(CAP_PROP_FRAME_HEIGHT, requested_h);
			sleep(1);
		}
		int n_width = (int)n_cap->get(CAP_PROP_FRAME_WIDTH);
		int n_height = (int)n_cap->get(CAP_PROP_FRAME_HEIGHT);
		n_cap->set(CAP_PROP_BUFFERSIZE, 10);
		n_cap->set(CAP_PROP_FPS, 60);

		cap_fourcc = n_cap->get(cv::CAP_PROP_FOURCC);
		char c1, c2, c3, c4;
		convert_fourcc(cap_fourcc, c1, c2, c3, c4);
		cap_total_frames = 0;
		cap_total_frames = n_cap->get(cv::CAP_PROP_FRAME_COUNT);
		cap_format = n_cap->get(cv::CAP_PROP_FORMAT);
		int frame_rate = n_cap->get(cv::CAP_PROP_FPS);
		int frame_pos = n_cap->get(cv::CAP_PROP_POS_FRAMES);
		Mat test_only = imread(path);
		if(cap_total_frames < 2)
		{
			if((cap_fourcc == 0) || ((test_only.rows > 0) && (test_only.cols > 0)))
			{
				type = CAMERA_TYPE_IMAGE;
			}
		}
		n_width = (int)n_cap->get(CAP_PROP_FRAME_WIDTH);
		n_height = (int)n_cap->get(CAP_PROP_FRAME_HEIGHT);
		cap = n_cap;
		width = n_width;
		height = n_height;
		if((n_width != requested_w) || (n_height != requested_h))
		{
			fprintf(stderr, "Warning: received dimensions differ from requested dimensions. (%d x %d) vs. (%d x %d).\nImage will be scaled in software.\n",
				n_width, n_height,
				requested_w, requested_h);
			width = requested_w;
			height = requested_h;
		}
		progress_thumb = 1;
	}
	else if(source != NULL)
	{
		type = CAMERA_TYPE_TEXT;
		width = requested_w;
		height = requested_h;
		if(strncasecmp(source, "blank://", strlen("blank://")) == 0)
		{
			red = 0;
			green = 0;
			blue = 0;
			alpha = 0;
			char *cp = source + strlen("blank://");
			if(strlen(cp) > 0)
			{
				parse_quadlet(cp, &red, &green, &blue, &alpha);
			}
			cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(red, green, blue, alpha));
			mat = local_mat;
			reserve_mat = local_mat.clone();

			width = requested_w;
			height = requested_h;
			type = CAMERA_TYPE_BLANK;
		}
		else if(strncasecmp(source, "dynamic://", strlen("dynamic://")) == 0)
		{
			type = CAMERA_TYPE_DYNAMIC_TEXT;
		}
		else if(strncasecmp(source, "slideshow://", strlen("slideshow://")) == 0)
		{
			char *filename = source + strlen("slideshow://");
			if(IsDirectory(filename))
			{
				struct dirent **namelist;
				int n = scandir(filename, &namelist, NULL, alphasort);
				for(int i = 0; i < n; i++) 
				{
					if(slideshow_list_cnt < 1024)
					{
						slideshow_list[slideshow_list_cnt] = strdup(namelist[i]->d_name);
						slideshow_list_cnt++;
					}
					free(namelist[i]);
				}
				free(namelist);
			}
			else
			{
				slideshow_fp = fopen(filename, "r");
			}
			Fl::add_timeout(0.1, slideshow_cb, this);
			type = CAMERA_TYPE_SLIDESHOW;
		}
		else if(strncasecmp(source, "alert://", strlen("alert://")) == 0)
		{
			char *cp = source + strlen("alert://");
			strcpy(alert_monitor_file, cp);
			cp = alert_monitor_file;
			while((*cp != ':') && (*cp != '\0')) cp++;
			if(*cp == ':')
			{
				*cp = '\0';
				cp++;
				alert_trigger_mode = atoi(cp);
				while((*cp != ':') && (*cp != '\0')) cp++;
				if(*cp == ':')
				{
					*cp = '\0';
					cp++;
					alert_display_mode = atoi(cp);
					while((*cp != ':') && (*cp != '\0')) cp++;
					if(*cp == ':')
					{
						*cp = '\0';
						cp++;
						alert_duration = atoi(cp);
						while((*cp != ':') && (*cp != '\0')) cp++;
						if(*cp == ':')
						{
							*cp = '\0';
							cp++;
							alert_opaque = atoi(cp);
							while((*cp != ':') && (*cp != '\0')) cp++;
							if(*cp == ':')
							{
								cp++;
								if(strlen(cp) > 0)
								{
									strcpy(alert_audio_file, cp);
								}
							}
						}
					}
				}
			}
			type = CAMERA_TYPE_ALERT;
		}
		else if(strncasecmp(source, "pipe://", strlen("pipe://")) == 0)
		{
			char *cp = source + strlen("pipe://");
			pipe_pid = popen2(cp, &pipe_in, &pipe_out);
			if(pipe_pid != -1)
			{
				piping_text = 1;
				type = CAMERA_TYPE_PIPED;
				pipe_fp = fdopen(pipe_out, "r");
				if(pipe_fp != NULL)
				{
					create_task((int (*)(int *))read_pipe, (void *)this);
				}
				else
				{
					my_window->SetErrorMessage("No Pipe Created");
				}
			}
			else
			{
				my_window->SetErrorMessage("No Pipe Created");
			}
		}
		else if(strncasecmp(source, "irc://", strlen("irc://")) == 0)
		{
			char *cp = source + strlen("irc://");
			char *server = cp;
			while((*cp != 10) && (*cp != '\0')) cp++;
			if(*cp == 10)
			{
				*cp = '\0';
				cp++;
				int port = atoi(cp);
				while((*cp != 10) && (*cp != '\0')) cp++;
				if(*cp == 10)
				{
					*cp = '\0';
					cp++;
					char *user = cp;
					while((*cp != 10) && (*cp != '\0')) cp++;
					if(*cp == 10)
					{
						*cp = '\0';
						cp++;
						char *password = cp;
						while((*cp != 10) && (*cp != '\0')) cp++;
						if(*cp == 10)
						{
							*cp = '\0';
							cp++;
							char *channel = cp;
							irc_session = cow_irc_connect(server, port, user, password, channel);
							if(irc_session != NULL)
							{
								piping_text = 1;
								type = CAMERA_TYPE_TEXT;
								create_task((int (*)(int *))run_irc, (void *)this);
								create_task((int (*)(int *))read_irc, (void *)this);
							}
						}
					}
				}
			}
		}
		else if(strncasecmp(source, "ndi://", strlen("ndi://")) == 0)
		{
			char *cp = source + strlen("ndi://");
			if(strlen(cp) > 0)
			{
				type = CAMERA_TYPE_CAMERA;
				ndi_recv = NULL;
				ndi_recv = FindNDI(cp, 0);
				if(ndi_recv != NULL)
				{
					ndi_capture = 1;
				}
			}
			progress_thumb = 1;
		}
		else if(strncasecmp(source, "ndi_uyvy://", strlen("ndi_uyvy://")) == 0)
		{
			char *cp = source + strlen("ndi_uyvy://");
			if(strlen(cp) > 0)
			{
				type = CAMERA_TYPE_CAMERA;
				ndi_recv = NULL;
				ndi_recv = FindNDI(cp, 1);
				if(ndi_recv != NULL)
				{
					ndi_capture = 1;
				}
			}
			progress_thumb = 1;
		}
		else if(strncasecmp(source, "ndi_p216://", strlen("ndi_p216://")) == 0)
		{
			char *cp = source + strlen("ndi_p216://");
			if(strlen(cp) > 0)
			{
				type = CAMERA_TYPE_CAMERA;
				ndi_recv = NULL;
				ndi_recv = FindNDI(cp, 2);
				if(ndi_recv != NULL)
				{
					ndi_capture = 1;
				}
			}
			progress_thumb = 1;
		}
		else if(strncasecmp(source, "ndi_bgrx://", strlen("ndi_bgrx://")) == 0)
		{
			char *cp = source + strlen("ndi_bgrx://");
			if(strlen(cp) > 0)
			{
				type = CAMERA_TYPE_CAMERA;
				ndi_recv = NULL;
				ndi_recv = FindNDI(cp, 3);
				if(ndi_recv != NULL)
				{
					ndi_capture = 1;
				}
			}
			progress_thumb = 1;
		}
		else if(strncasecmp(source, "ndi_rgbx://", strlen("ndi_rgbx://")) == 0)
		{
			char *cp = source + strlen("ndi_rgbx://");
			if(strlen(cp) > 0)
			{
				type = CAMERA_TYPE_CAMERA;
				ndi_recv = NULL;
				ndi_recv = FindNDI(cp, 4);
				if(ndi_recv != NULL)
				{
					ndi_capture = 1;
				}
			}
			progress_thumb = 1;
		}
		else if(strncasecmp(source, "sff://", strlen("sff://")) == 0)
		{
			char *cp = source + strlen("sff://");
			single_frame_fd = open(cp, O_RDWR);
			if(single_frame_fd != -1)
			{
				type = CAMERA_TYPE_SINGLE_FRAME_FILE;
				create_task((int (*)(int *))read_single_frame_file, (void *)this);
			}
			else
			{
				my_window->SetErrorMessage("No SFF Found");
			}
		}
		else if(strncasecmp(source, "osg://", strlen("osg://")) == 0)
		{
			if(global_osg_enabled == 1)
			{
				char *cp = source + strlen("osg://");
				char *file[1];
				file[0] = cp;

				MyViewer *(*osg_open_osg)(int, char **, int, int);
				osg_open_osg = (MyViewer *(*)(int, char **, int, int))void_OSG_open_osg;
				if(osg_open_osg != NULL)
				{
					osg_viewer = osg_open_osg(1, file, requested_w, requested_h);
					if(osg_viewer != NULL)
					{
						type = CAMERA_TYPE_OSG;
					}
					else
					{
						my_window->SetErrorMessage("OSG Viewer not created");
					}
				}
				else
				{
					my_window->SetErrorMessage("OSG Viewer not created");
				}
			}
			else
			{
				my_window->SetErrorMessage("OSG is not enabled");
			}
		}
		else if(strncasecmp(source, "desktop://", strlen("desktop://")) == 0)
		{
			char *cp = source + strlen("desktop://");
			if(strlen(cp) > 0)
			{
				int sx = 0;
				int sy = 0;
				int sw = Fl::w();
				int sh = Fl::h();
				parse_quadlet(cp, &sx, &sy, &sw, &sh);
				grab_portion_x = sx;
				grab_portion_y = sy;
				grab_portion_w = sw;
				grab_portion_h = sh;
			}
			in_win->GrabDesktop();
			width = in_win->desktop_mat.cols;
			height = in_win->desktop_mat.rows;
			type = CAMERA_TYPE_DESKTOP;
		}
		else if(strncasecmp(source, "this://", strlen("this://")) == 0)
		{
		}
		else if(strncasecmp(source, "window://", strlen("window://")) == 0)
		{
			char *cp = source + strlen("window://");
			if(strlen(cp) > 0)
			{
				grab_window_id = (unsigned long int)atol(cp);
				GrabWindow();
				width = mat.cols;
				height = mat.rows;
				type = CAMERA_TYPE_WINDOW;
			}
			else
			{
				my_window->SetErrorMessage("Window ID Missing");
			}
		}
		else if(strncasecmp(source, "pseudo://", strlen("pseudo://")) == 0)
		{
			if(void_pseudo_camera != NULL)
			{
				int use_id = 0;
				char *cp = source + strlen("pseudo://");
				if(strlen(cp) > 0)
				{
					strcpy(pseudo_camera_name, cp);
				}
				void *(*pseudo_camera)(char *, int *, int *, int *);
				pseudo_camera = (void *(*)(char *, int *, int *, int *))void_pseudo_camera;
				int pseudo_width = 0;
				int pseudo_height = 0;
				int pseudo_depth = 0;
				void *ptr = pseudo_camera(pseudo_camera_name, &pseudo_width, &pseudo_height, &pseudo_depth);
				if(ptr != NULL)
				{
					free(ptr);
					width = pseudo_width;
					height = pseudo_height;
					type = CAMERA_TYPE_PSEUDO;
				}
				else
				{
					my_window->SetErrorMessage("No Pseudo Camera Created");
				}
			}
		}
		else if(strncasecmp(source, "plugin://", strlen("plugin://")) == 0)
		{
			int use_id = 0;
			char *cp = source + strlen("plugin://");
			if(strlen(cp) > 0)
			{
				void *rr = resolve_plugin_camera_name(my_window, cp);
				if(rr != NULL)
				{
					plugin_camera = rr;
					void *(*pseudo_camera)(char *, int *, int *, int *);
					pseudo_camera = (void *(*)(char *, int *, int *, int *))plugin_camera;
					int pseudo_width = 0;
					int pseudo_height = 0;
					int pseudo_depth = 0;
					void *ptr = pseudo_camera(pseudo_camera_name, &pseudo_width, &pseudo_height, &pseudo_depth);
					if(ptr != NULL)
					{
						free(ptr);
						width = pseudo_width;
						height = pseudo_height;
						type = CAMERA_TYPE_PLUGIN;
					}
					else
					{
						my_window->SetErrorMessage("No Plugin Camera Created");
					}
				}
				else
				{
					my_window->SetErrorMessage("No Plugin Camera Found");
				}
			}
		}
		else if(strncasecmp(source, "timer://", strlen("timer://")) == 0)
		{
			char *cp = source + strlen("timer://");
			if(strlen(cp) > 0)
			{
				start_timer = atol(cp);
				while(*cp != '\0')
				{
					if(*cp == ',')
					{
						cp++;
						stop_timer = atol(cp);
					}
					if(*cp == ':')
					{
						cp++;
						timer_format = atoi(cp);
					}
					cp++;
				}
				initial_timer = time(0);
				type = CAMERA_TYPE_TIMER;
			}
			else
			{
				my_window->SetErrorMessage("No Timer Parameters");
			}
		}
		else if(strncasecmp(source, "clock://", strlen("clock://")) == 0)
		{
			char *cp = source + strlen("clock://");
			if(strlen(cp) > 0)
			{
				military_clock = atoi(cp);
				while(*cp != '\0')
				{
					if(*cp == ':')
					{
						cp++;
						timer_format = atoi(cp);
						while(*cp != '\0')
						{
							if(*cp == ':')
							{
								cp++;
								analog = atoi(cp);
								while(*cp != '\0')
								{
									if(*cp == ':')
									{
										cp++;
										analog_size = atoi(cp);
									}
									cp++;
								}
							}
							cp++;
						}
					}
					cp++;
				}
				type = CAMERA_TYPE_CLOCK;
			}
			else
			{
				my_window->SetErrorMessage("No Clock Parameters");
			}
		}
		else if(strncasecmp(source, "av://", strlen("av://")) == 0)
		{
			char *cp = source + strlen("av://");
			if(strlen(cp) > 0)
			{
				av_window = new VLC_Window(cp, width, height);
				type = CAMERA_TYPE_AV;
				Fl::add_timeout(1.0, vlc_window_start_cb, av_window);
			}
			else
			{
				my_window->SetErrorMessage("No AV Parameters");
			}
		}
		else if(strncasecmp(source, "vector://", strlen("vector://")) == 0)
		{
			char *cp = source + strlen("vector://");
			if(strlen(cp) > 0)
			{
				type = CAMERA_TYPE_VECTOR;
			}
			else
			{
				my_window->SetErrorMessage("No Vector File Parameters");
			}
		}
		else if(strncasecmp(source, "html://", strlen("html://")) == 0)
		{
			if(global_html == 1)
			{
				char *cp = source + strlen("html://");
				if((strlen(cp) > 0) && (strlen(cp) < 32768))
				{
					extra_url = NULL;
					extra_css = NULL;
					extra_js_once = NULL;
					extra_js_always = NULL;

					char url[32768];
					char css[32768];
					char js_once[32768];
					char js_always[32768];
					find_url_css_js(cp, url, css, js_once, js_always);
					if(strlen(url) > 0) extra_url = strdup(url);
					if(strlen(css) > 0) extra_css = strdup(css);
					if(strlen(js_once) > 0) extra_js_once = strdup(js_once);
					if(strlen(js_always) > 0) extra_js_always = strdup(js_always);
					HTML_Win *(*make_html)(char *, char *, int, char *, char *, char *, int, int);
					make_html = (HTML_Win *(*)(char *, char *, int, char *, char *, char *, int, int))void_MakeHTMLWindow_cef;
					if(make_html != NULL)
					{
						html = make_html(extra_url, NULL, my_window->html_background, extra_css, extra_js_once, extra_js_always, width, height);
						while(html->raw == NULL)
						{
							Fl::check();
						}
						type = CAMERA_TYPE_HTML;
					}
				}
				else
				{
					my_window->SetErrorMessage("No HTML Parameters");
				}
			}
			else
			{
				my_window->SetErrorMessage("HTML Rendering disabled");
			}
		}
		else if((strncasecmp(source, "http://", strlen("http://")) == 0)
		|| (strncasecmp(source, "https://", strlen("https://")) == 0))
		{
			if(global_html == 1)
			{
				if((strlen(source) > 0) && (strlen(source) < 32768))
				{
					extra_url = NULL;
					extra_css = NULL;
					extra_js_once = NULL;
					extra_js_always = NULL;
					char url[32768];
					char css[32768];
					char js_once[32768];
					char js_always[32768];
					find_url_css_js(source, url, css, js_once, js_always);
					if(strlen(url) > 0) extra_url = strdup(url);
					if(strlen(css) > 0) extra_css = strdup(css);
					if(strlen(js_once) > 0) extra_js_once = strdup(js_once);
					if(strlen(js_always) > 0) extra_js_always = strdup(js_always);
					HTML_Win *(*make_html)(char *, char *, int, char *, char *, char *, int, int);
					make_html = (HTML_Win *(*)(char *, char *, int, char *, char *, char *, int, int))void_MakeHTMLWindow_cef;
					if(make_html != NULL)
					{
						make_html = (HTML_Win *(*)(char *, char *, int, char *, char *, char *, int, int))void_MakeHTMLWindow_cef;
						html = make_html(extra_url, NULL, my_window->html_background, extra_css, extra_js_once, extra_js_always, width, height);
						while(html->raw == NULL)
						{
							Fl::check();
						}
						type = CAMERA_TYPE_HTML;
					}
				}
			}
			else
			{
				my_window->SetErrorMessage("HTML Rendering disabled");
			}
		}
		else if(strncasecmp(source, "html source://", strlen("html source://")) == 0)
		{
			if(global_html == 1)
			{
				char *cp = source + strlen("html source://");
				if(strlen(cp) > 0)
				{
					HTML_Win *(*make_html)(char *, char *, int, char *, char *, char *, int, int);
					make_html = (HTML_Win *(*)(char *, char *, int, char *, char *, char *, int, int))void_MakeHTMLWindow_cef;
					if(make_html != NULL)
					{
						html = make_html(NULL, cp, my_window->html_background, NULL, NULL, NULL, width, height);
						while(html->raw == NULL)
						{
							Fl::check();
						}
						type = CAMERA_TYPE_HTML;
					}
				}
				else
				{
					my_window->SetErrorMessage("No HTML");
				}
			}
			else
			{
				my_window->SetErrorMessage("HTML Rendering disabled");
			}
		}
		else if(strncasecmp(source, "sourced://", strlen("sourced://")) == 0)
		{
			source_camera = NULL;
			char *cp = source + strlen("sourced://");
			if(strlen(cp) > 0)
			{
				double factor = 1.0;
				if(*cp == '(')
				{
					cp++;
					factor = atof(cp);
					while((*cp != ')') && (*cp != '\0')) cp++;
					while(*cp == ')') cp++;
				}
				int match = -1;
				for(loop = 0;((loop < my_window->source_cnt) && (match == -1));loop++)
				{
					Camera *compare_cam = my_window->camera[loop];
					if(strcmp(cp, compare_cam->alias) == 0)
					{
						match = loop;
					}
					if(match == -1)
					{
						if(strcmp(cp, compare_cam->path) == 0)
						{
							match = loop;
						}
					}
				}
				if(match > -1)
				{
					Camera *test_camera = my_window->camera[match];
					if((test_camera->type != CAMERA_TYPE_ALL)
					&& (test_camera->type != CAMERA_TYPE_ALTERNATING)
					&& (test_camera->type != CAMERA_TYPE_SOURCED)
					&& (test_camera->type != CAMERA_TYPE_EDGE_DETECT)
					&& (test_camera->type != CAMERA_TYPE_SPLIT)
					&& (test_camera->type != CAMERA_TYPE_CHROMAKEY))
					{
						source_camera = test_camera;
						requested_w = source_camera->width * factor;
						requested_h = source_camera->height * factor;
						type = CAMERA_TYPE_SOURCED;
					}
					else
					{
						my_window->SetErrorMessage("No Acceptable Source Found");
					}
				}
				else
				{
					my_window->SetErrorMessage("No Source Found");
				}
			}
			else
			{
				my_window->SetErrorMessage("No Source");
			}
		}
		else if(strncasecmp(source, "edge://", strlen("edge://")) == 0)
		{
			source_camera = NULL;
			char *cp = source + strlen("edge://");
			if(strlen(cp) > 0)
			{
				double factor = 1.0;
				if(*cp == '(')
				{
					cp++;
					factor = atof(cp);
					while((*cp != ')') && (*cp != '\0')) cp++;
					while(*cp == ')') cp++;
				}
				int match = -1;
				for(loop = 0;((loop < my_window->source_cnt) && (match == -1));loop++)
				{
					Camera *compare_cam = my_window->camera[loop];
					if(strcmp(cp, compare_cam->alias) == 0)
					{
						match = loop;
					}
					if(match == -1)
					{
						if(strcmp(cp, compare_cam->path) == 0)
						{
							match = loop;
						}
					}
				}
				if(match > -1)
				{
					Camera *test_camera = my_window->camera[match];
					if((test_camera->type != CAMERA_TYPE_ALL)
					&& (test_camera->type != CAMERA_TYPE_ALTERNATING)
					&& (test_camera->type != CAMERA_TYPE_SOURCED)
					&& (test_camera->type != CAMERA_TYPE_EDGE_DETECT)
					&& (test_camera->type != CAMERA_TYPE_SPLIT)
					&& (test_camera->type != CAMERA_TYPE_CHROMAKEY))
					{
						source_camera = test_camera;
						requested_w = source_camera->width * factor;
						requested_h = source_camera->height * factor;
						type = CAMERA_TYPE_EDGE_DETECT;
					}
					else
					{
						my_window->SetErrorMessage("No Acceptable Source Found");
					}
				}
				else
				{
					my_window->SetErrorMessage("No Source Found");
				}
			}
			else
			{
				my_window->SetErrorMessage("No Edge Source");
			}
		}
		else if(strncasecmp(source, "chroma://", strlen("chroma://")) == 0)
		{
			source_camera = NULL;
			char *cp = source + strlen("chroma://");
			if(strlen(cp) > 0)
			{
				double factor = 1.0;
				if(*cp == '(')
				{
					cp++;
					factor = atof(cp);
					while((*cp != ')') && (*cp != '\0')) cp++;
					while(*cp == ')') cp++;
				}
				int match = -1;
				for(loop = 0;((loop < my_window->source_cnt) && (match == -1));loop++)
				{
					Camera *compare_cam = my_window->camera[loop];
					if(strcmp(cp, compare_cam->alias) == 0)
					{
						match = loop;
					}
					if(match == -1)
					{
						if(strcmp(cp, compare_cam->path) == 0)
						{
							match = loop;
						}
					}
				}
				if(match > -1)
				{
					Camera *test_camera = my_window->camera[match];
					if((test_camera->type != CAMERA_TYPE_ALL)
					&& (test_camera->type != CAMERA_TYPE_ALTERNATING)
					&& (test_camera->type != CAMERA_TYPE_SOURCED)
					&& (test_camera->type != CAMERA_TYPE_EDGE_DETECT)
					&& (test_camera->type != CAMERA_TYPE_SPLIT)
					&& (test_camera->type != CAMERA_TYPE_CHROMAKEY))
					{
						source_camera = test_camera;
						requested_w = source_camera->width * factor;
						requested_h = source_camera->height * factor;
						chroma_color = use_chroma;
						type = CAMERA_TYPE_CHROMAKEY;
					}
					else
					{
						my_window->SetErrorMessage("No Acceptable Source Found");
					}
				}
				else
				{
					my_window->SetErrorMessage("No Source Found");
				}
			}
			else
			{
				my_window->SetErrorMessage("No Chroma Source");
			}
		}
		else if(strncasecmp(source, "alternating://", strlen("alternating://")) == 0)
		{
			alternate_interval = 5;
			char *cp = source + strlen("alternating://");
			if(strlen(cp) > 0)
			{
				alternate_interval = atof(cp);
			}
			alternate_index = 0;
			alternate_time = precise_time();
			type = CAMERA_TYPE_ALTERNATING;
		}
		else if(strncasecmp(source, "all://", strlen("all://")) == 0)
		{
			type = CAMERA_TYPE_ALL;
		}
		else if(strncasecmp(source, "split://", strlen("split://")) == 0)
		{
			split_cols = 2;
			split_rows = 2;
			split_source_cnt = 0;
			char *cp = source + strlen("split://");
			if(strlen(cp) > 0)
			{
				split_cols = atoi(cp);
				while((*cp != '\0') && (*cp != ',')) cp++;
				if(*cp == ',')
				{
					cp++;
					split_rows = atoi(cp);
					int cnt = split_cols * split_rows;
					while((*cp != '\0') && (*cp != ';')) cp++;
					if(*cp == ';')
					{
						cp++;
						char *start = cp;
						for(loop = 0;loop < cnt;loop++)
						{
							while((*cp != '\0') && (*cp != ',')) cp++;
							if(*cp == ',')
							{
								*cp = '\0';
								cp++;
							}
							split_source[split_source_cnt] = strdup(start);
							split_source_cnt++;
							start = cp;
						}
					}
				}
			}
			alternate_index = 0;
			alternate_time = precise_time();
			type = CAMERA_TYPE_SPLIT;
		}
		cap = n_cap;
	}
	net = my_window->net;
	for(loop = 0;loop < my_window->recognize_class_cnt;loop++)
	{
		if(my_window->recognize_class_name[loop] != NULL)
		{
			if((strcasecmp("bird", my_window->recognize_class_name[loop]) == 0)
			|| (strcasecmp("squirrel", my_window->recognize_class_name[loop]) == 0)
			|| (strcasecmp("animal", my_window->recognize_class_name[loop]) == 0))
			{
				object_index[loop] = 1;
			}
		}
	}
	if(!mat.empty())
	{
		if(mat.channels() == 3)
		{
			cvtColor(mat, mat, COLOR_RGB2RGBA);
		}
		cairo_surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
		if(cairo_surface != NULL)
		{
			cairo_context = cairo_create(cairo_surface);
			cairo_set_antialias(cairo_context, CAIRO_ANTIALIAS_BEST);
		}
	}
	if(progress_thumb == 1)
	{
		if(start_win != NULL)
		{
			char buf[8192];
			if(strlen(alias) > 0)
			{
				sprintf(buf, "Open camera:\n%s", alias);
			}
			else
			{
				sprintf(buf, "Open camera:\n%s", source);
			}
			if(mat.empty())
			{
				if(cap != NULL)
				{
					if(cap->isOpened())
					{
						cap->grab();
						last_grab_time = precise_time();
					}
				}
				Capture(1);
			}
			if(!mat.empty())
			{
				if(start_win->image_mat_cnt < 128)
				{
					Mat local_mat;
					mat.copyTo(local_mat);
					cv::resize(local_mat, local_mat, cv::Size(160, 90));
					start_win->image_mat[start_win->image_mat_cnt] = local_mat.clone();
					start_win->image_mat_cnt++;
					start_win->redraw();
					if(start_win->intro_pipe_fp != NULL)
					{
						Mat send_mat;
						int nn = fileno(start_win->intro_pipe_fp);
						int sz = local_mat.total() * local_mat.elemSize();
						fprintf(start_win->intro_pipe_fp, "image: %d\n", sz);
						fflush(start_win->intro_pipe_fp);
						unsigned char *cp = local_mat.ptr();
						for(int inner = 0;inner < sz;inner++)
						{
							fprintf(start_win->intro_pipe_fp, "%u\n", *cp);
							cp++;
						}
						fflush(start_win->intro_pipe_fp);
					}
				}
			}
			start_win->Update(buf);
		}
	}
}

Camera::~Camera()
{
int	outer;
int	loop;

	power = 0;
	hot = 0;
	int cnt = 0;
	Fl::remove_timeout(slideshow_cb, this);
	if(instrument_window != NULL)
	{
		instrument_window->hide();
		Fl::delete_widget(instrument_window);
		instrument_window = NULL;
	}
	if(slideshow_list_cnt > 0)
	{
		for(loop = 0;loop < slideshow_list_cnt;loop++)
		{
			if(slideshow_list[loop] != NULL)
			{
				free(slideshow_list[loop]);
				slideshow_list[loop] = NULL;
			}
		}
		slideshow_list_cnt = 0;
	}
	if(slideshow_fp != NULL)
	{
		fclose(slideshow_fp);
		slideshow_fp = NULL;
	}
	if(my_window->recording_camera == this)
	{
		my_window->recording_camera = NULL;
	}
	if(type == CAMERA_TYPE_CAMERA)
	{
		if(cap != NULL)
		{
			if((cap->isOpened()) || (ndi_capture == 1))
			{
				while((hot != -1) && (cnt < 100))
				{
					usleep(100000);
					cnt++;
				}
			}
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(bound_mic[loop] != NULL)
		{
			free(bound_mic[loop]);
			bound_mic[loop] = NULL;
		}
	}
	bound_mic_cnt = -1;
	pipe_done = 1;
	for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
	{
		if(my_window->ptz_window[loop] != NULL)
		{
			if(my_window->ptz_window[loop]->bound_camera == this)
			{
				my_window->ptz_window[loop]->bound_camera = NULL;
			}
		}
	}
	if(standalone_display != NULL)
	{
		standalone_display->hide();
		standalone_display = NULL;
	}
	if(single_frame_fd != -1)
	{
		close(single_frame_fd);
	}
	if(immediate_list != NULL)
	{
		for(loop = 0;loop < immediate_cnt;loop++)
		{
			if(immediate_list[loop] != NULL)
			{
				Fl::delete_widget(immediate_list[loop]);
				immediate_list[loop] = NULL;
			}
		}
		immediate_cnt = 0;
		free(immediate_list);
		immediate_list = NULL;
	}
	if(cairo_context != NULL)
	{
		cairo_destroy(cairo_context);
	}
	if(cairo_surface != NULL)
	{
		cairo_surface_destroy(cairo_surface);
	}
	if(shared_image != NULL)
	{
		x11_destroy_shared_image(shared_image, &shminfo);
	}
	if(av_window != NULL)
	{
		av_window->Pause();
		av_window->Stop();
		delete av_window;
		av_window = NULL;
	}
	for(loop = 0;loop < 32;loop++)
	{
		if(pip[loop] != NULL)
		{
			delete pip[loop];
			pip[loop] = NULL;
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(filter_plugin[loop] != NULL)
		{
			filter_plugin[loop] = NULL;
		}
		if(filter_plugin_name[loop] != NULL)
		{
			free(filter_plugin_name[loop]);
			filter_plugin_name[loop] = NULL;
		}
		if(filter_name[loop] != NULL)
		{
			free(filter_name[loop]);
			filter_name[loop] = NULL;
		}
		if(filter_dialog[loop] != NULL)
		{
			filter_dialog[loop]->hide();
			Fl::delete_widget(filter_dialog[loop]);
			filter_dialog[loop] = NULL;
		}
	}
	if(my_window->single_stream == 1)
	{
		for(outer = 0;outer < my_window->source_cnt;outer++)
		{
			if(my_window->camera[outer] != NULL)
			{
				Camera *cam = my_window->camera[outer];
				if(cam != this)
				{
					save_fifo = NULL;
					fd = -1;
				}
			}
		}
	}
	if(save_fifo != NULL)
	{
		while(save_fifo->top > 0)
		{
			usleep(10000);
		}
		delete save_fifo;
	}
	if(fd > -1)
	{
		close(fd);
	}
	if(cap != NULL)
	{
		if(cap->isOpened())
		{
			cap->release();
			delete cap;
			cap = NULL;
		}
	}
	if(html != NULL)
	{
		if(void_delete_html_cef != NULL)
		{
			void (*delete_html)(HTML_Win *);
			delete_html = (void (*)(HTML_Win *))void_delete_html_cef;
			delete_html(html);
		}
	}
	if(ndi_recv != NULL)
	{
		if(NDILib != NULL)
		{
			NDILib->NDIlib_recv_destroy(ndi_recv);
			ndi_recv = NULL;
		}
	}
	for(loop = 0;loop < split_source_cnt;loop++)
	{
		if(split_source[loop] != NULL)
		{
			free(split_source[loop]);
		}
	}
	if(extra_url != NULL)
	{
		free(extra_url);
		extra_url = NULL;
	}
	if(extra_css != NULL)
	{
		free(extra_css);
		extra_css = NULL;
	}
	if(extra_js_once != NULL)
	{
		free(extra_js_once);
		extra_js_once = NULL;
	}
	if(extra_js_always != NULL)
	{
		free(extra_js_always);
		extra_js_always = NULL;
	}
}

Immediate	*Camera::EventInImmediate()
{
int	loop;

	Immediate *rr = NULL;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(Fl::event_inside(immediate_list[loop]))
			{
				rr = immediate_list[loop];
			}
		}
	}
	if(rr == NULL)
	{
		if(my_window->resize_frame != NULL)
		{
			if(my_window->resize_frame->visible())
			{
				if(Fl::event_inside(my_window->resize_frame))
				{
					for(loop = 0;loop < immediate_cnt;loop++)
					{
						if(immediate_list[loop] != NULL)
						{
							if(immediate_list[loop] == my_window->resize_frame->use)
							{
								rr = immediate_list[loop];
							}
						}
					}
				}
			}
		}
	}
	return(rr);
}

void	Camera::ActivateBoundMics()
{
int	loop;
int	inner;

	if(bound_mic_cnt > -1)
	{
		my_window->audio_bind_to_camera_button->copy_label("Unbind Camera");
		my_window->audio_bind_to_camera_button->copy_tooltip("Remove audio source binding from displayed camera.");
		for(loop = 0;loop < my_window->audio_thumbnail_cnt;loop++)
		{
			if(my_window->audio_thumbnail[loop] != NULL)
			{
				PulseAudioButton *pab = my_window->audio_thumbnail[loop];
				pab->Stop();
			}
		}
		if(bound_mic_cnt > 0)
		{
			for(loop = 0;loop < my_window->audio_thumbnail_cnt;loop++)
			{
				if(my_window->audio_thumbnail[loop] != NULL)
				{
					PulseAudioButton *pab = my_window->audio_thumbnail[loop];
					if(pab->microphone != NULL)
					{
						for(inner = 0;inner < bound_mic_cnt;inner++)
						{
							if(bound_mic[inner] != NULL)
							{
								if(strcmp(bound_mic[inner], pab->microphone->name) == 0)
								{
									pab->Start();
								}
							}
						}
					}
				}
			}
		}
	}
	else
	{
		my_window->audio_bind_to_camera_button->copy_label("Bind to Camera");
		my_window->audio_bind_to_camera_button->copy_tooltip("Bind currently selected audio sources to displayed camera.");
	}
}

void	Camera::BindMics()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(bound_mic[loop] != NULL)
		{
			free(bound_mic[loop]);
			bound_mic[loop] = NULL;
		}
	}
	bound_mic_cnt = 0;
	int cnt = 0;
	for(loop = 0;loop < my_window->audio_thumbnail_cnt;loop++)
	{
		if(my_window->audio_thumbnail[loop] != NULL)
		{
			PulseAudioButton *pab = my_window->audio_thumbnail[loop];
			if(pab->microphone != NULL)
			{
				if(pab->microphone->stop == 0)
				{
					bound_mic[cnt] = strdup(pab->microphone->name);
					cnt++;
				}
			}
		}
	}
	bound_mic_cnt = cnt;
}

void	Camera::UnBindMics()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(bound_mic[loop] != NULL)
		{
			free(bound_mic[loop]);
			bound_mic[loop] = NULL;
		}
	}
	bound_mic_cnt = -1;
}

void	Camera::SaveAsJSON(FILE *fp)
{
int	loop;
int	inner;

	fprintf(fp, "{\n");
	fprintf(fp, "\t\"path\": \"%s\",\n", path);
	fprintf(fp, "\t\"original path\": \"%s\",\n", original_path);
	fprintf(fp, "\t\"alias\": \"%s\",\n", alias);
	fprintf(fp, "\t\"triggers requested\": %d,\n", triggers_requested);
	fprintf(fp, "\t\"requested x\": %d,\n", requested_x);
	fprintf(fp, "\t\"requested y\": %d,\n", requested_y);
	fprintf(fp, "\t\"requested w\": %d,\n", requested_w);
	fprintf(fp, "\t\"requested h\": %d,\n", requested_h);
	fprintf(fp, "\t\"darkness trigger\": %f,\n", darkness_trigger);
	fprintf(fp, "\t\"grab interval\": %d,\n", grab_interval);
	fprintf(fp, "\t\"capture interval\": %f,\n", capture_interval);
	fprintf(fp, "\t\"cap fourcc\": %d,\n", cap_fourcc);
	fprintf(fp, "\t\"cap format\": %d,\n", cap_format);
	fprintf(fp, "\t\"font sz\": %d,\n", font_sz);
	fprintf(fp, "\t\"zoom\": %f,\n", zoom);
	fprintf(fp, "\t\"width\": %d,\n", width);
	fprintf(fp, "\t\"height\": %d,\n", height);
	fprintf(fp, "\t\"orig width\": %d,\n", orig_width);
	fprintf(fp, "\t\"orig height\": %d,\n", orig_height);
	fprintf(fp, "\t\"capture effects\": %d,\n", capture_effects);
	fprintf(fp, "\t\"font name\": \"%s\",\n", font_name);
	fprintf(fp, "\t\"capture scaling\": %f,\n", capture_scaling);
	fprintf(fp, "\t\"fps\": %f,\n", fps);
	fprintf(fp, "\t\"timer format\": %d,\n", timer_format);
	fprintf(fp, "\t\"military clock\": %d,\n", military_clock);
	fprintf(fp, "\t\"format code\": \"%s\",\n", format_code);
	if(extra_url != NULL)
	{
		fprintf(fp, "\t\"extra url\": \"%s\",\n", extra_url);
	}
	else
	{
		fprintf(fp, "\t\"extra url\": \"%s\",\n", "");
	}
	if(extra_css != NULL)
	{
		fprintf(fp, "\t\"extra css\": \"%s\",\n", extra_css);
	}
	else
	{
		fprintf(fp, "\t\"extra css\": \"%s\",\n", "");
	}
	if(extra_js_once != NULL)
	{
		fprintf(fp, "\t\"extra js once\": \"%s\",\n", extra_js_once);
	}
	else
	{
		fprintf(fp, "\t\"extra js once\": \"%s\",\n", "");
	}
	if(extra_js_always != NULL)
	{
		fprintf(fp, "\t\"extra js always\": \"%s\",\n", extra_js_always);
	}
	else
	{
		fprintf(fp, "\t\"extra js always\": \"%s\",\n", "");
	}
	fprintf(fp, "\t\"ndi capture\": %d,\n", ndi_capture);
	fprintf(fp, "\t\"immediate cnt\": %d,\n", immediate_cnt);
	if(immediate_cnt > 0)
	{
		fprintf(fp, "\t\"Immediate\": [\n");
		for(loop = 0;loop < immediate_cnt;loop++)
		{
			if(immediate_list[loop] != NULL)
			{
				Immediate *im = immediate_list[loop];
				fprintf(fp, "\t\t{\n");
				im->SaveAsJSON(fp);
				if(loop == immediate_cnt - 1)
				{
					fprintf(fp, "\t\t}\n");
				}
				else
				{
					fprintf(fp, "\t\t},\n");
				}
			}
		}
		fprintf(fp, "\t],\n");
	}
	fprintf(fp, "\t\"pseudo camera name\": \"%s\",\n", pseudo_camera_name);
	fprintf(fp, "\t\"color it cnt\": %d,\n", color_it_cnt);
	if(color_it_cnt > 0)
	{
		int nn = color_it_cnt - 1;
		fprintf(fp, "\t\"color it r\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_r[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"color it g\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_g[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"color it b\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_b[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"color it tolerance r\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_tolerance_r[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"color it tolerance g\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_tolerance_g[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"color it tolerance b\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_tolerance_b[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"color it replace r\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_replace_r[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"color it replace g\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_replace_g[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"color it replace b\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_replace_b[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"color it replace a\": [");
		for(loop = 0;loop < color_it_cnt;loop++)
		{
			fprintf(fp, "%d", color_it_replace_a[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"chroma color\": %d,\n", chroma_color);
	fprintf(fp, "\t\"matrix state cnt\": %d,\n", matrix_state_cnt);
	if(matrix_state_cnt > 0)
	{
		fprintf(fp, "\t\"Matrix State\": [\n");
		for(loop = 0;loop < matrix_state_cnt;loop++)
		{
			if(matrix_state[loop] != NULL)
			{
				fprintf(fp, "\t\t{\n");
				fprintf(fp, "\t\t\t\"name\": \"%s\",\n", matrix_state[loop]->name);
				fprintf(fp, "\t\t\t\"type\": %d,\n", matrix_state[loop]->type);
				fprintf(fp, "\t\t\t\"command\": %d,\n", matrix_state[loop]->command);
				fprintf(fp, "\t\t\t\"frames\": %d,\n", matrix_state[loop]->frames);
				fprintf(fp, "\t\t\t\"start x\": %f,\n", matrix_state[loop]->start_x);
				fprintf(fp, "\t\t\t\"start y\": %f,\n", matrix_state[loop]->start_y);
				fprintf(fp, "\t\t\t\"start z\": %f,\n", matrix_state[loop]->start_z);
				fprintf(fp, "\t\t\t\"end x\": %f,\n", matrix_state[loop]->end_x);
				fprintf(fp, "\t\t\t\"end y\": %f,\n", matrix_state[loop]->end_y);
				fprintf(fp, "\t\t\t\"end z\": %f\n", matrix_state[loop]->end_z);
				if(loop == matrix_state_cnt - 1)
				{
					fprintf(fp, "\t\t}\n");
				}
				else
				{
					fprintf(fp, "\t\t},\n");
				}
			}
		}
		fprintf(fp, "\t],\n");
	}
	fprintf(fp, "\t\"crop start x\": %d,\n", crop_start_x);
	fprintf(fp, "\t\"crop start y\": %d,\n", crop_start_y);
	fprintf(fp, "\t\"use crop start\": %d,\n", use_crop_start);
	fprintf(fp, "\t\"flip horizontal\": %d,\n", flip_horizontal);
	fprintf(fp, "\t\"flip vertical\": %d,\n", flip_vertical);
	fprintf(fp, "\t\"brightness\": %f,\n", brightness);
	fprintf(fp, "\t\"saturation\": %f,\n", saturation);
	fprintf(fp, "\t\"hue\": %f,\n", hue);
	fprintf(fp, "\t\"intensity\": %f,\n", intensity);
	fprintf(fp, "\t\"contrast\": %f,\n", contrast);
	fprintf(fp, "\t\"red intensity\": %f,\n", red_intensity);
	fprintf(fp, "\t\"green intensity\": %f,\n", green_intensity);
	fprintf(fp, "\t\"blue intensity\": %f,\n", blue_intensity);
	fprintf(fp, "\t\"alpha intensity\": %f,\n", alpha_intensity);
	fprintf(fp, "\t\"motion threshold\": %d,\n", motion_threshold);
	fprintf(fp, "\t\"recognition threshold\": %f,\n", recognition_threshold);
	fprintf(fp, "\t\"recognize interval\": %d,\n", recognize_interval);
	fprintf(fp, "\t\"forced aspect x\": %f,\n", forced_aspect_x);
	fprintf(fp, "\t\"forced aspect y\": %f,\n", forced_aspect_y);
	fprintf(fp, "\t\"zoom box display\": %d,\n", zoom_box_display);
	fprintf(fp, "\t\"zoom box x\": %d,\n", zoom_box_x);
	fprintf(fp, "\t\"zoom box y\": %d,\n", zoom_box_y);
	fprintf(fp, "\t\"zoom box w\": %d,\n", zoom_box_w);
	fprintf(fp, "\t\"zoom box h\": %d,\n", zoom_box_h);
	fprintf(fp, "\t\"trigger cnt\": %d,\n", trigger_cnt);
	if(trigger_cnt > 0)
	{
		int nn = trigger_cnt - 1;
		fprintf(fp, "\t\"trigger\": [");
		for(loop = 0;loop < trigger_cnt;loop++)
		{
			fprintf(fp, "%d", trigger[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"image sx\": %d,\n", image_sx);
	fprintf(fp, "\t\"image sy\": %d,\n", image_sy);
	fprintf(fp, "\t\"display width\": %f,\n", display_width);
	fprintf(fp, "\t\"display height\": %f,\n", display_height);
	fprintf(fp, "\t\"image window cnt\": %d,\n", image_window_cnt);
	if(image_window_cnt > 0)
	{
		fprintf(fp, "\t\"Image Window\": [\n");
		for(loop = 0;loop < image_window_cnt;loop++)
		{
			if(image_window[loop] != NULL)
			{
				fprintf(fp, "\t\t{\n");
				char source_path[4096];
				char source_orig_path[4096];
				strcpy(source_path, image_window[loop]->camera->path);
				strcpy(source_orig_path, image_window[loop]->camera->original_path);
				fprintf(fp, "\t\t\t\"source path\": \"%s\",\n", source_path);
				fprintf(fp, "\t\t\t\"source orig path\": \"%s\",\n", source_orig_path);
				fprintf(fp, "\t\t\t\"index\": %d,\n", image_window[loop]->index);
				fprintf(fp, "\t\t\t\"layer\": %d,\n", image_window[loop]->layer);
				fprintf(fp, "\t\t\t\"transform\": %d,\n", image_window[loop]->transform);
				fprintf(fp, "\t\t\t\"width\": %f,\n", image_window[loop]->width);
				fprintf(fp, "\t\t\t\"height\": %f,\n", image_window[loop]->height);
				fprintf(fp, "\t\t\t\"orig w\": %f,\n", image_window[loop]->orig_w);
				fprintf(fp, "\t\t\t\"orig h\": %f,\n", image_window[loop]->orig_h);
				fprintf(fp, "\t\t\t\"dx\": %f,\n", image_window[loop]->dx);
				fprintf(fp, "\t\t\t\"dy\": %f,\n", image_window[loop]->dy);
				fprintf(fp, "\t\t\t\"dw\": %f,\n", image_window[loop]->dw);
				fprintf(fp, "\t\t\t\"dh\": %f,\n", image_window[loop]->dh);
				fprintf(fp, "\t\t\t\"buttonize\": %d,\n", image_window[loop]->buttonize);
				fprintf(fp, "\t\t\t\"buttonized x\": %d,\n", image_window[loop]->buttonized_x);
				fprintf(fp, "\t\t\t\"buttonized y\": %d,\n", image_window[loop]->buttonized_y);
				fprintf(fp, "\t\t\t\"buttonized w\": %d,\n", image_window[loop]->buttonized_w);
				fprintf(fp, "\t\t\t\"buttonized h\": %d,\n", image_window[loop]->buttonized_h);
				fprintf(fp, "\t\t\t\"crop x\": %d,\n", image_window[loop]->crop_x);
				fprintf(fp, "\t\t\t\"crop y\": %d,\n", image_window[loop]->crop_y);
				fprintf(fp, "\t\t\t\"crop w\": %d,\n", image_window[loop]->crop_w);
				fprintf(fp, "\t\t\t\"crop h\": %d,\n", image_window[loop]->crop_h);
				fprintf(fp, "\t\t\t\"trim x\": %d,\n", image_window[loop]->trim_x);
				fprintf(fp, "\t\t\t\"trim y\": %d,\n", image_window[loop]->trim_y);
				fprintf(fp, "\t\t\t\"overall alpha\": %f,\n", image_window[loop]->overall_alpha);
				fprintf(fp, "\t\t\t\"use as mask\": %d,\n", image_window[loop]->use_as_mask);
				fprintf(fp, "\t\t\t\"angle\": %f,\n", image_window[loop]->angle);
				fprintf(fp, "\t\t\t\"frame\": %d,\n", image_window[loop]->frame);
				fprintf(fp, "\t\t\t\"flip horizontal\": %d,\n", image_window[loop]->flip_horizontal);
				fprintf(fp, "\t\t\t\"flip vertical\": %d\n", image_window[loop]->flip_vertical);
				if(loop == image_window_cnt - 1)
				{
					fprintf(fp, "\t\t}\n");
				}
				else
				{
					fprintf(fp, "\t\t},\n");
				}
			}
		}
		fprintf(fp, "\t],\n");
	}
	fprintf(fp, "\t\"red\": %d,\n", red);
	fprintf(fp, "\t\"green\": %d,\n", green);
	fprintf(fp, "\t\"blue\": %d,\n", blue);
	fprintf(fp, "\t\"alpha\": %d,\n", alpha);
	fprintf(fp, "\t\"text red\": %d,\n", text_red);
	fprintf(fp, "\t\"text green\": %d,\n", text_green);
	fprintf(fp, "\t\"text blue\": %d,\n", text_blue);
	fprintf(fp, "\t\"text alpha\": %d,\n", text_alpha);
	fprintf(fp, "\t\"filter cnt\": %d,\n", filter_cnt);
	if(filter_cnt > 0)
	{
		int nn = filter_cnt - 1;
		fprintf(fp, "\t\"filter name\": [");
		for(loop = 0;loop < filter_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", filter_name[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"filter plugin cnt\": %d,\n", filter_plugin_cnt);
	if(filter_plugin_cnt > 0)
	{
		int nn = filter_plugin_cnt - 1;
		fprintf(fp, "\t\"filter plugin name\": [");
		for(loop = 0;loop < filter_plugin_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", filter_plugin_name[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"bound mic cnt\": %d,\n", bound_mic_cnt);
	if(bound_mic_cnt > 0)
	{
		int nn = bound_mic_cnt - 1;
		fprintf(fp, "\t\"bound mic\": [");
		for(loop = 0;loop < bound_mic_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", bound_mic[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	if(split_source_cnt > 0)
	{
		int nn = split_source_cnt - 1;
		fprintf(fp, "\t\"split source\": [");
		for(loop = 0;loop < split_source_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", split_source[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	int local_object_cnt = 0;
	for(loop = 0;loop < my_window->recognize_class_cnt;loop++)
	{
		if(object_index[loop] == 1)
		{
			local_object_cnt++;
		}
	}
	if((my_window->recognize_class_cnt > 0) && (local_object_cnt > 0))
	{
		int nn = local_object_cnt - 1;
		int cnt = 0;
		fprintf(fp, "\t\"recognize object\": [");
		for(loop = 0;loop < my_window->recognize_class_cnt;loop++)
		{
			if(object_index[loop] == 1)
			{
				fprintf(fp, "\"%s\"", my_window->recognize_class_name[loop]);
				if(cnt != nn)
				{
					fprintf(fp, ",");
				}
				else
				{
					fprintf(fp, "],\n");
				}
				cnt++;
			}
		}
	}
	fprintf(fp, "\t\"snapshot filename format\": \"%s\",\n", snapshot_filename_format);
	fprintf(fp, "\t\"snapshot initial delay\": %d,\n", snapshot_initial_delay);
	fprintf(fp, "\t\"snapshot repeat delay\": %d,\n", snapshot_repeat_delay);
	fprintf(fp, "\t\"snapshot trigger condition\": %d,\n", snapshot_trigger_condition);
	fprintf(fp, "\t\"snapshot scale\": %f,\n", snapshot_scale);
	fprintf(fp, "\t\"snapshot\": %d,\n", snapshot);
	fprintf(fp, "\t\"ptz lock interface\": %d,\n", ptz_lock_interface);
	fprintf(fp, "\t\"ptz lock camera\": %d\n", ptz_lock_camera);
	fprintf(fp, "}");
}

void	Camera::RecvNDI(Mat& in_mat)
{
NDIlib_video_frame_v2_t	video_frame;
NDIlib_metadata_frame_t	metadata_frame;

	if(NDILib != NULL)
	{
		int nn = NDILib->NDIlib_recv_capture_v3(ndi_recv, &video_frame, NULL, &metadata_frame, 1000);
		switch(nn)
		{
			// No data
			case(NDIlib_frame_type_none):
			{
				fprintf(stderr, "No NDI video data received.\n");
				if(in_mat.empty())
				{
					Mat frame = cv::Mat(height, width, CV_8UC4, cv::Scalar(76, 89, 100, 255));
					frame.copyTo(in_mat);
				}
			}
			break;
			// Video data
			case(NDIlib_frame_type_video):
			{
				char *str = "UNKNOWN";
				if(video_frame.FourCC == NDIlib_FourCC_type_UYVY) str = "NDIlib_FourCC_type_UYVY";
				else if(video_frame.FourCC == NDIlib_FourCC_type_UYVA) str = "NDIlib_FourCC_type_UYVA";
				else if(video_frame.FourCC == NDIlib_FourCC_type_P216) str = "NDIlib_FourCC_type_P216";
				else if(video_frame.FourCC == NDIlib_FourCC_type_PA16) str = "NDIlib_FourCC_type_A216";
				else if(video_frame.FourCC == NDIlib_FourCC_type_YV12) str = "NDIlib_FourCC_type_YV12";
				else if(video_frame.FourCC == NDIlib_FourCC_type_I420) str = "NDIlib_FourCC_type_I420";
				else if(video_frame.FourCC == NDIlib_FourCC_type_NV12) str = "NDIlib_FourCC_type_NV12";
				else if(video_frame.FourCC == NDIlib_FourCC_type_BGRA) str = "NDIlib_FourCC_type_BGRA";
				else if(video_frame.FourCC == NDIlib_FourCC_type_BGRX) str = "NDIlib_FourCC_type_BGRX";
				else if(video_frame.FourCC == NDIlib_FourCC_type_RGBA) str = "NDIlib_FourCC_type_RGBA";
				else if(video_frame.FourCC == NDIlib_FourCC_type_RGBX) str = "NDIlib_FourCC_type_RGBX";

				unsigned char *use_data = (unsigned char *)video_frame.p_data;
				if((video_frame.FourCC == NDIlib_FourCC_type_UYVY)
				|| (video_frame.FourCC == NDIlib_FourCC_type_UYVA))
				{
					Mat frame;
					UYVY_BGR(frame, use_data, video_frame.xres, video_frame.yres);
					frame.copyTo(in_mat);
				}
				else if((video_frame.FourCC == NDIlib_FourCC_type_P216)
				|| (video_frame.FourCC == NDIlib_FourCC_type_PA16))
				{
					Mat frame;
					P216_BGR(frame, use_data, video_frame.xres, video_frame.yres);
					frame.copyTo(in_mat);
				}
				else if(video_frame.FourCC == NDIlib_FourCC_type_I420)
				{
					Mat frame;
					I420_BGR(frame, use_data, video_frame.xres, video_frame.yres);
					frame.copyTo(in_mat);
				}
				else if(video_frame.FourCC == NDIlib_FourCC_type_YV12)
				{
					Mat frame;
					Mat yuv(video_frame.yres, video_frame.xres, CV_8UC2, use_data);
					cvtColor(yuv, frame, COLOR_YUV2BGR_YV12);
					frame.copyTo(in_mat);
				}
				else if(video_frame.FourCC == NDIlib_FourCC_type_NV12)
				{
					Mat frame;
					Mat yuv(video_frame.yres + video_frame.yres / 2, video_frame.xres, CV_8UC1, use_data);
					cvtColor(yuv, frame, COLOR_YUV2BGR_NV12);
					frame.copyTo(in_mat);
				}
				else if((video_frame.FourCC == NDIlib_FourCC_type_RGBX)
				|| (video_frame.FourCC == NDIlib_FourCC_type_RGBA))
				{
					Mat frame;
					int cv_flag = CV_8UC4;
					Mat rgb(cv::Size(video_frame.xres, video_frame.yres), cv_flag, use_data);
					cvtColor(rgb, frame, COLOR_RGB2BGR);
					frame.copyTo(in_mat);
				}
				else
				{
					int cv_flag = CV_8UC4;
					Mat frame(cv::Size(video_frame.xres, video_frame.yres), cv_flag, use_data);
					frame.copyTo(in_mat);
				}
				NDILib->NDIlib_recv_free_video_v2(ndi_recv, &video_frame);
			}
			break;
			// There is a status change on the receiver (e.g. new web interface)
			case(NDIlib_frame_type_status_change):
			{
				if(prefer_ndi == 1)
				{
					if(NDILib->NDIlib_recv_ptz_is_supported(ndi_recv))
					{
						ndi_ptz = 1;
					}
				}
			}
			break;
			case(NDIlib_frame_type_metadata):
			{
				NDILib->NDIlib_recv_free_metadata(ndi_recv, &metadata_frame); 
			}
			break;
			// Everything else
			default:
			break;
		}
	}
}

void	Camera::CaptureLoop()
{
static double cow_total = 0.0;
static int cow_cnt = 0;

	time_t start = precise_time();
	int frames = 0;
	hot_fps = 0;
	while(hot == 1)
	{
		if(ndi_capture == 1)
		{
			RecvNDI(hot_mat);
			usleep(hot_delay);
			frames++;
			time_t elapsed = precise_time() - start;
			if(elapsed > 1000000)
			{
				hot_fps = frames;
				start = precise_time();
				frames = 0;
			}
		}
		else
		{
			if(cap != NULL)
			{
				if(cap->isOpened())
				{
					int nww = 0;
					int nhh = 0;
					int nn = cap->grab();
					if(nn)
					{
						cap->retrieve(hot_mat);
						nww = hot_mat.cols;
						nhh = hot_mat.rows;
					}
					if((nn == 0) || (nww == 0) || (nhh == 0))
					{
						int use_width = width;
						int use_height = height;
						cv::Mat local_mat(use_height, use_width, CV_8UC4, cv::Scalar(55, 55, 55, 255));
						cairo_surface_t *surface = cairo_image_surface_create_for_data(local_mat.ptr(), CAIRO_FORMAT_ARGB32, local_mat.cols, local_mat.rows, local_mat.step);
						if(surface != NULL)
						{
							cairo_t *cr = cairo_create(surface);
							cairo_set_antialias(cr, CAIRO_ANTIALIAS_BEST);
							cairo_font_slant_t slant = CAIRO_FONT_SLANT_NORMAL;
							cairo_font_weight_t bold = CAIRO_FONT_WEIGHT_NORMAL;
							my_cairo_set_source_rgba(cr, 255, 255, 255, 255);
							cairo_select_font_face(cr, "Sans", slant, bold);
							cairo_set_font_size(cr, 32);
							cairo_move_to(cr, (local_mat.cols / 2) - 200, (local_mat.rows / 2) - 60);
							cairo_show_text(cr, "Video signal disrupted");
							cairo_set_font_size(cr, 24);
							cairo_move_to(cr, (local_mat.cols / 2) - 300, (local_mat.rows / 2));
							cairo_show_text(cr, "After restoring hardware, select Reset Camera.");
							hot_mat = local_mat.clone();

							cairo_destroy(cr);
							cairo_surface_destroy(surface);
						}
					}
					usleep(hot_delay);
					frames++;
					time_t elapsed = precise_time() - start;
					if(elapsed > 1000000)
					{
						hot_fps = frames;
						start = precise_time();
						frames = 0;
					}
				}
			}
		}
	}
	if(ndi_capture == 1)
	{
		ndi_capture = 0;
	}
	hot = -1;
}

void	Camera::TransferHotMat(Mat& in_mat)
{
	in_mat = hot_mat.clone();
}

void	Camera::LowerALayer(int use_layer)
{
int			loop;
Immediate	*local[1024];
ImageWindow	*local_im[128];

	int cnt = 0;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop]->layer == use_layer)
			{
				if(cnt < 1024)
				{
					local[cnt] = immediate_list[loop];
					cnt++;
				}
			}
		}
	}
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop]->layer == (use_layer - 1))
			{
				immediate_list[loop]->layer++;
			}
		}
	}
	for(loop = 0;loop < cnt;loop++)
	{
		local[loop]->layer--;
	}
	cnt = 0;
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->layer == use_layer)
			{
				if(cnt < 128)
				{
					local_im[cnt] = image_window[loop];
					cnt++;
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->layer == (use_layer - 1))
			{
				image_window[loop]->layer++;
			}
		}
	}
	for(loop = 0;loop < cnt;loop++)
	{
		local_im[loop]->layer--;
	}
}

void	Camera::RaiseALayer(int use_layer)
{
int			loop;
Immediate	*local[1024];
ImageWindow	*local_im[128];

	int cnt = 0;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop]->layer == use_layer)
			{
				if(cnt < 1024)
				{
					local[cnt] = immediate_list[loop];
					cnt++;
				}
			}
		}
	}
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop]->layer == (use_layer + 1))
			{
				immediate_list[loop]->layer--;
			}
		}
	}
	for(loop = 0;loop < cnt;loop++)
	{
		local[loop]->layer++;
	}
	cnt = 0;
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->layer == use_layer)
			{
				if(cnt < 128)
				{
					local_im[cnt] = image_window[loop];
					cnt++;
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->layer == (use_layer + 1))
			{
				image_window[loop]->layer--;
			}
		}
	}
	for(loop = 0;loop < cnt;loop++)
	{
		local_im[loop]->layer++;
	}
}

void	Camera::SetSystemAlias()
{
char	card[4096];

	strcpy(card, "");
	get_v4l_card_name(path, card);
	if(strlen(alias) < 1)
	{
		strcpy(alias, (char *)card);
	}
}

void	Camera::AddImmediate(Immediate *in)
{
int	loop;

	int done = -1;
	if(immediate_list != NULL)
	{
		for(loop = 0;((loop < immediate_cnt) && (done == -1));loop++)
		{
			if(immediate_list[loop] == NULL)
			{
				done = loop;
			}
		}
	}
	if(done > -1)
	{
		immediate_list[done] = in;
	}
	else
	{
		immediate_list = (Immediate **)realloc(immediate_list, sizeof(Fl_Widget *) * (immediate_cnt + 1));
		if(immediate_list != NULL)
		{
			immediate_list[immediate_cnt] = in;
			immediate_cnt++;
		}
	}
}

void	Camera::SaveImmediate(char *filename)
{
int		loop;

	FILE *fp = fopen(filename, "w");
	if(fp != NULL)
	{
		fprintf(fp, "{\n");
		fprintf(fp, "\t\"immediate cnt\": %d,\n", immediate_cnt);
		fprintf(fp, "\t\"Immediate\": [\n");
		for(loop = 0;loop < immediate_cnt;loop++)
		{
			if(immediate_list[loop] != NULL)
			{
			   	fprintf(fp, "\t\t{\n");
				immediate_list[loop]->SaveAsJSON(fp);
				if(loop == immediate_cnt - 1)
				{
					fprintf(fp, "\t\t}\n");
				}
				else
				{
					fprintf(fp, "\t\t},\n");
				}
			}
		}
		fprintf(fp, "\t]\n");
		fprintf(fp, "}\n");
		fclose(fp);
	}
}

void	Camera::LoadImmediate(char *filename)
{
	char *buf = ReadWholeFile(filename);
	if(buf != NULL)
	{
		cJSON *json = cJSON_Parse(buf);
		if(json == NULL)
		{
			const char *error_ptr = cJSON_GetErrorPtr();
			if(error_ptr != NULL)
			{
				fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
			}
		}
		else
		{
			int local_immediate_cnt = 0;
			int success = json_parse_int(json, "immediate cnt", local_immediate_cnt);
			if(local_immediate_cnt > 0)
			{
				cJSON *immediate = NULL;
				cJSON *immediates = json_parse_array(json, "Immediate");
				if(immediates != NULL)
				{
					int cnt = 0;
					cJSON_ArrayForEach(immediate, immediates)
					{
						Immediate *im_use = my_window->ParseJSONImmediate(immediate, this);
						AddImmediate(im_use);
						my_window->add(im_use);
						cnt++;
					}
				}
			}
			cJSON_Delete(json);
		}
		free(buf);
	}
	else
	{
		fprintf(stderr, "Error: Cannot read JSON file: %s\n", filename);
	}
}

void	Camera::DrawPIP()
{
int	loop;

	int cnt = 0;
	for(loop = 0;loop < 32;loop++)
	{
		if(pip[loop] != NULL)
		{
			pip[loop]->draw(cnt);
			cnt++;
		}
	}
}

void	Camera::AddPIP(PIP *in_pip)
{
int	loop;

	int no_go = -1;
	int use = -1;
	for(loop = 0;loop < 32;loop++)
	{
		if(pip[loop] != NULL)
		{
			if(in_pip->camera == pip[loop]->camera)
			{
				no_go = loop;
			}
		}
		else if(use == -1)
		{
			use = loop;
		}
	}
	if(use > -1)
	{
		pip[use] = in_pip;
	}
}

void	Camera::AddPIPByCamera(Camera *in_cam, int in_embed)
{
int	loop;

	int no_go = 0;
	if(in_cam != this)
	{
		for(loop = 0;loop < 32;loop++)
		{
			if(pip[loop] != NULL)
			{
				if(pip[loop]->camera == in_cam)
				{
					no_go = 1;
				}
			}
		}
		if(no_go == 0)
		{
			int px, py;
			int nw, nh;
			Mat dst = mat;
			Mat src = in_cam->mat;
			nw = (int)((double)src.cols * my_window->pip_size);
			nh = (int)((double)src.rows * my_window->pip_size);

			px = (int)((double)dst.cols * my_window->pip_x_position);
			py = (int)((double)dst.rows * my_window->pip_y_position);

			int dx = dst.cols - (px + nw);
			if(dx < 0) px += dx;
			int dy = dst.rows - (py + nh);
			if(dy < 0) py += dy;
			PIP *n_pip = new PIP(in_cam, px, py, nw, nh);
			AddPIP(n_pip);
		}
		else
		{
			RemovePIPByCamera(in_cam);
		}
	}
}

void	Camera::RemovePIPByCamera(Camera *in_cam)
{
int	loop;

	for(loop = 0;loop < 32;loop++)
	{
		if(pip[loop] != NULL)
		{
			if(pip[loop]->camera == in_cam)
			{
				delete pip[loop];
				pip[loop] = NULL;
			}
		}
	}
}

void	Camera::Resize(int ww, int hh)
{
	if((ww >= 320) && (ww <= my_window->w())
	&& (hh >= 240) && (hh <= my_window->h()))
	{
		cap->set(CAP_PROP_FRAME_WIDTH, ww);
		cap->set(CAP_PROP_FRAME_HEIGHT, hh);
		cap->set(CAP_PROP_BUFFERSIZE, 10);
		cap->set(CAP_PROP_FPS, 60);
		width = (int)cap->get(CAP_PROP_FRAME_WIDTH);
		height = (int)cap->get(CAP_PROP_FRAME_HEIGHT);
	}
}

void	Camera::SetCairo()
{
	if(cairo_surface != NULL)
	{
		if(mat.channels() == 3)
		{
			cvtColor(mat, mat, COLOR_RGB2RGBA);
		}
		void *add1 = cairo_image_surface_get_data(cairo_surface);
		void *add2 = mat.ptr();
		if(add1 != add2)
		{
			if(add1 != NULL)
			{
				cairo_surface_destroy(cairo_surface);
			}
			if(cairo_context != NULL)
			{
				cairo_destroy(cairo_context);
			}
			cairo_surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
			if(cairo_surface != NULL)
			{
				cairo_context = cairo_create(cairo_surface);
				cairo_set_antialias(cairo_context, CAIRO_ANTIALIAS_BEST);
			}
		}
	}
	else
	{
		if(mat.channels() == 3)
		{
			cvtColor(mat, mat, COLOR_RGB2RGBA);
		}
		cairo_surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
		if(cairo_surface != NULL)
		{
			cairo_context = cairo_create(cairo_surface);
			cairo_set_antialias(cairo_context, CAIRO_ANTIALIAS_BEST);
		}
	}
}

void	Camera::RunFilters()
{
void	blend_two(Mat one, Mat two, int xx, int yy, double alpha);
int		loop;

	for(loop = 0;loop < filter_cnt;loop++)
	{
		if(filter_name[loop] != NULL)
		{
			if(filter_dialog[loop] != NULL)
			{
				if(filter_dialog[loop]->disable != 1)
				{
					if(strcmp(filter_name[loop], "Grayscale") == 0)
					{
						cvtColor(mat, mat, COLOR_RGBA2GRAY);
						cvtColor(mat, mat, COLOR_GRAY2RGBA);
					}
					else if(strcmp(filter_name[loop], "Threshold") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						int sel = filter_dialog[loop]->selected;
						int use = 0;
						if(sel == 0) use = THRESH_BINARY;
						else if(sel == 1) use = THRESH_BINARY_INV;
						else if(sel == 2) use = THRESH_TRUNC;
						else if(sel == 3) use = THRESH_TOZERO;
						else if(sel == 4) use = THRESH_TOZERO_INV;
						threshold(mat, mat, val0, val1, use);
					}
					else if(strcmp(filter_name[loop], "Invert") == 0)
					{
						invert_mat(mat);
					}
					else if(strcmp(filter_name[loop], "Edge Detect") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						double val2 = filter_dialog[loop]->number[2];
						double val3 = filter_dialog[loop]->number[3];
						edge_detect(mat, val0, val1, val2, val3);
					}
					else if(strcmp(filter_name[loop], "Brightness") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						brightness_mat(mat, val0);
					}
					else if(strcmp(filter_name[loop], "Contrast") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						contrast_mat(mat, val0);
					}
					else if(strcmp(filter_name[loop], "Saturation") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						mat = change_saturation(mat, val0);
					}
					else if(strcmp(filter_name[loop], "Hue") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						if(val0 != 1.0)
						{
							mat = change_hue(mat, val0);
						}
					}
					else if(strcmp(filter_name[loop], "CLAHE") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						clahe_mat(mat, val0);
					}
					else if(strcmp(filter_name[loop], "Color Intensity") == 0)
					{
							double val0 = filter_dialog[loop]->number[0];
							double val1 = filter_dialog[loop]->number[1];
							double val2 = filter_dialog[loop]->number[2];
							double val3 = filter_dialog[loop]->number[3];
							ColorIntensity(mat, val0, val1, val2, val3);
					}
					else if(strcmp(filter_name[loop], "Blur") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						if(val0 != 1.0)
						{
							blur_mat(mat, val0);
						}
					}
					else if(strcmp(filter_name[loop], "Crop") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						double val2 = filter_dialog[loop]->number[2];
						double val3 = filter_dialog[loop]->number[3];
						double left = mat.cols * val0;
						double right = mat.cols * val1;
						if(right < left)
						{
							double tmp = left;
							left = right;
							right = tmp;
						}
						double top = mat.rows * val2;
						double bottom = mat.rows * val3;
						if(bottom < top)
						{
							double tmp = top;
							top = bottom;
							bottom = tmp;
						}
						int i_left = left;
						int i_top = top;
						int i_width = (int)right - i_left;
						int i_height = (int)bottom - i_top;
						if((i_width > 0) && (i_height > 0))
						{
							crop_mat(mat, i_left, i_top, i_width, i_height);
							width = i_width;
							height = i_height;
						}
					}
					else if(strcmp(filter_name[loop], "Scale") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						if((val0 >= 0.1) && (val1 >= 0.1))
						{
							int width = (double)mat.cols * val0;
							int height = (double)mat.rows * val1;
							cv::resize(mat, mat, cv::Size(width, height));
						}
					}
					else if(strcmp(filter_name[loop], "Blend") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						int sel = filter_dialog[loop]->selected;
						Camera *other_cam = NULL;
						if((sel > -1) && (sel < 128))
						{
							char *selected_alias = filter_dialog[loop]->str[sel];
							if(selected_alias != NULL)
							{
								if(strlen(selected_alias) > 0)
								{
									for(loop = 0;((loop < my_window->source_cnt) && (other_cam == NULL));loop++)
									{
										Camera *camera = my_window->camera[loop];
										if(camera != NULL)
										{
											if(strcmp(camera->alias, selected_alias) == 0)
											{
												other_cam = camera;
											}
										}
									}
								}
							}
							if(other_cam != NULL)
							{
								Mat in = other_cam->mat;
								blend_two(in, mat, 0, 0, val0);
							}
						}
					}
					else if(strcmp(filter_name[loop], "Bevel") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						double val2 = filter_dialog[loop]->number[2];
						double val3 = filter_dialog[loop]->number[3];
						double val4 = filter_dialog[loop]->number[4];
						if(((val0 < (mat.cols / 2)) && (val0 < (mat.rows / 2)))
						&& ((val2 < (mat.cols / 2)) && (val2 < (mat.rows / 2))))
						{
							rounded_rectangle(mat, Point(val0, val0), Point(mat.cols - val0, mat.rows - val0), Scalar(val2, val3, val4), 3, LINE_8, val1);
						}
					}
					else if(strcmp(filter_name[loop], "Gradient") == 0)
					{
						int direction = filter_dialog[loop]->selected;
						double r1 = filter_dialog[loop]->number[0];
						double g1 = filter_dialog[loop]->number[1];
						double b1 = filter_dialog[loop]->number[2];
						double a1 = filter_dialog[loop]->number[3];
						double r2 = filter_dialog[loop]->number[4];
						double g2 = filter_dialog[loop]->number[5];
						double b2 = filter_dialog[loop]->number[6];
						double a2 = filter_dialog[loop]->number[7];
						color_gradient(mat, direction, Scalar(r1, g1, b1, a1), Scalar(r2, g2, b2, a2));
					}
				}
			}
		}
	}
}

void	Camera::RunInstruments()
{
int	loop;

	for(loop = 0;loop < matrix_state_cnt;loop++)
	{
		if(matrix_state[loop] != NULL)
		{
			osg::Node *nd = matrix_state[loop]->node;
			if(nd != NULL)
			{
				double start_x = matrix_state[loop]->start_x;
				double start_y = matrix_state[loop]->start_y;
				double start_z = matrix_state[loop]->start_z;
				double end_x = matrix_state[loop]->end_x;
				double end_y = matrix_state[loop]->end_y;
				double end_z = matrix_state[loop]->end_z;
				osg::MatrixTransform *matrix = (osg::MatrixTransform *)nd;
				if(matrix_state[loop]->command == INSTRUMENT_COMMAND_SET)
				{
					matrix_state[loop]->current_x = start_x;
					matrix_state[loop]->current_y = start_y;
					matrix_state[loop]->current_z = start_z;
				}
				else if(matrix_state[loop]->command == INSTRUMENT_COMMAND_ONCE)
				{
					double diff_x = fabs(matrix_state[loop]->end_x - matrix_state[loop]->current_x);
					double diff_y = fabs(matrix_state[loop]->end_y - matrix_state[loop]->current_y);
					double diff_z = fabs(matrix_state[loop]->end_z - matrix_state[loop]->current_z);
					if((diff_x > 0.001)
					|| (diff_y > 0.001)
					|| (diff_z > 0.001))
					{
						if(matrix_state[loop]->frames < 1) matrix_state[loop]->frames = 1;
						double inc_x = (matrix_state[loop]->end_x - matrix_state[loop]->start_x) / matrix_state[loop]->frames;
						double inc_y = (matrix_state[loop]->end_y - matrix_state[loop]->start_y) / matrix_state[loop]->frames;
						double inc_z = (matrix_state[loop]->end_z - matrix_state[loop]->start_z) / matrix_state[loop]->frames;
						matrix_state[loop]->current_x += inc_x;
						matrix_state[loop]->current_y += inc_y;
						matrix_state[loop]->current_z += inc_z;
					}
				}
				else if(matrix_state[loop]->command == INSTRUMENT_COMMAND_REPEAT)
				{
					if(matrix_state[loop]->frames < 1) matrix_state[loop]->frames = 1;
					double inc_x = (matrix_state[loop]->end_x - matrix_state[loop]->start_x) / matrix_state[loop]->frames;
					double inc_y = (matrix_state[loop]->end_y - matrix_state[loop]->start_y) / matrix_state[loop]->frames;
					double inc_z = (matrix_state[loop]->end_z - matrix_state[loop]->start_z) / matrix_state[loop]->frames;
					matrix_state[loop]->current_x += inc_x;
					matrix_state[loop]->current_y += inc_y;
					matrix_state[loop]->current_z += inc_z;
					double diff_x = fabs(matrix_state[loop]->end_x - matrix_state[loop]->current_x);
					double diff_y = fabs(matrix_state[loop]->end_y - matrix_state[loop]->current_y);
					double diff_z = fabs(matrix_state[loop]->end_z - matrix_state[loop]->current_z);
					if(diff_x < 0.001)
					{
						matrix_state[loop]->current_x = matrix_state[loop]->start_x;
					}
					if(diff_y < 0.001)
					{
						matrix_state[loop]->current_y = matrix_state[loop]->start_y;
					}
					if(diff_z < 0.001)
					{
						matrix_state[loop]->current_z = matrix_state[loop]->start_z;
					}
				}
				else if(matrix_state[loop]->command == INSTRUMENT_COMMAND_CYCLE)
				{
					if(matrix_state[loop]->frames < 1) matrix_state[loop]->frames = 1;
					double inc_x = (matrix_state[loop]->end_x - matrix_state[loop]->start_x) / matrix_state[loop]->frames;
					double inc_y = (matrix_state[loop]->end_y - matrix_state[loop]->start_y) / matrix_state[loop]->frames;
					double inc_z = (matrix_state[loop]->end_z - matrix_state[loop]->start_z) / matrix_state[loop]->frames;
					matrix_state[loop]->current_x += inc_x;
					matrix_state[loop]->current_y += inc_y;
					matrix_state[loop]->current_z += inc_z;
					double diff_x = fabs(matrix_state[loop]->end_x - matrix_state[loop]->current_x);
					double diff_y = fabs(matrix_state[loop]->end_y - matrix_state[loop]->current_y);
					double diff_z = fabs(matrix_state[loop]->end_z - matrix_state[loop]->current_z);
					if(diff_x < 0.001)
					{
						double tmp = matrix_state[loop]->start_x;
						matrix_state[loop]->start_x =  matrix_state[loop]->end_x;
						matrix_state[loop]->end_x = tmp;
						matrix_state[loop]->current_x = matrix_state[loop]->start_x;
					}
					if(diff_y < 0.001)
					{
						double tmp = matrix_state[loop]->start_y;
						matrix_state[loop]->start_y =  matrix_state[loop]->end_y;
						matrix_state[loop]->end_y = tmp;
						matrix_state[loop]->current_y = matrix_state[loop]->start_y;
					}
					if(diff_z < 0.001)
					{
						double tmp = matrix_state[loop]->start_z;
						matrix_state[loop]->start_z =  matrix_state[loop]->end_z;
						matrix_state[loop]->end_z = tmp;
						matrix_state[loop]->current_z = matrix_state[loop]->start_z;
					}
				}
				double current_x = matrix_state[loop]->current_x;
				double current_y = matrix_state[loop]->current_y;
				double current_z = matrix_state[loop]->current_z;
				if(matrix_state[loop]->type == MATRIX_STATE_TYPE_TRANSLATE)
				{
					void (*osg_translate)(osg::MatrixTransform *matrix, double cx, double cy, double cz);
					osg_translate = (void (*)(osg::MatrixTransform *matrix, double cx, double cy, double cz))void_OSG_Translate;

					osg_translate(matrix, current_x, current_y, current_z);
				}
				else if(matrix_state[loop]->type == MATRIX_STATE_TYPE_ROTATE)
				{
					void (*osg_rotate)(osg::MatrixTransform *matrix, double cx, double cy, double cz);
					osg_rotate = (void (*)(osg::MatrixTransform *matrix, double cx, double cy, double cz))void_OSG_Rotate;

					osg_rotate(matrix, current_x, current_y, current_z);
				}
				else if(matrix_state[loop]->type == MATRIX_STATE_TYPE_SCALE)
				{
					void (*osg_scale)(osg::MatrixTransform *matrix, double cx, double cy, double cz);
					osg_scale = (void (*)(osg::MatrixTransform *matrix, double cx, double cy, double cz))void_OSG_Scale;

					osg_scale(matrix, current_x, current_y, current_z);
				}
				matrix_state[loop]->current_frame++;
			}
		}
	}
}

int	Camera::TriggerAlert()
{
	int trigger_it = 0;
	if(access(alert_monitor_file, F_OK) == 0)
	{
		if(alert_trigger_mode == ALERT_TRIGGER_MODE_CREATED)	
		{
			if(alert_did_exist == 0)
			{
				trigger_it = 1;
				if(strlen(alert_audio_file) > 0)
				{
					play_audio_file(my_window, alert_audio_file);
				}
				if(alert_duration > -1)
				{
					alert_end_time = time(0) + alert_duration;
				}
				else
				{
					alert_permanent_trigger = 1;
				}
			}
		}
		else
		{
			int fd = open(alert_monitor_file, O_RDONLY);
			if(fd > -1)
			{
				long int length = filelength(fd);
				if(length < 32767)
				{
					char buf[32768];
					read(fd, buf, length);
					buf[length] = '\0';
					if(strcmp(alert_old_buffer, buf) != 0)
					{
						strcpy(alert_old_buffer, buf);
						trigger_it = 1;
						if(strlen(alert_audio_file) > 0)
						{
							play_audio_file(my_window, alert_audio_file);
						}
						if(alert_duration > -1)
						{
							alert_end_time = time(0) + alert_duration;
						}
						else
						{
							alert_permanent_trigger = 1;
						}
					}
				}
				close(fd);
			}
		}
		alert_did_exist = 1;
	}
	else
	{
		alert_did_exist = 0;
	}
	return(trigger_it);
}

int	Camera::DisplayAlert()
{
	int triggered = 0;
	if(alert_display_mode == ALERT_DISPLAY_MODE_ALL)
	{
		int fd = open(alert_monitor_file, O_RDONLY);
		if(fd > -1)
		{
			long int length = filelength(fd);
			if(length < 32767)
			{
				char buf[32768];
				read(fd, buf, length);
				buf[length] = '\0';
				RenderTextToMat(buf, &literal_mat);
				triggered = 1;
			}
			close(fd);
		}
	}
	else if(alert_display_mode == ALERT_DISPLAY_MODE_FIRST_LINE)
	{
		FILE *fp = fopen(alert_monitor_file, "r");
		if(fp != NULL)
		{
			char buf[32768];
			fgets(buf, 32768, fp);
			RenderTextToMat(buf, &literal_mat);
			triggered = 1;
			fclose(fp);
		}
	}
	else if(alert_display_mode == ALERT_DISPLAY_MODE_LAST_LINE)
	{
		FILE *fp = fopen(alert_monitor_file, "r");
		if(fp != NULL)
		{
			char buf[32768];
			char final[32768];
			strcpy(final, "");
			while(fgets(buf, 32768, fp))
			{
				strcpy(final, buf);
			}
			RenderTextToMat(final, &literal_mat);
			triggered = 1;
			fclose(fp);
		}
	}
	return(triggered);
}

void	Camera::ReadVectorFile(Mat& mat, char *filename)
{
	int width = my_window->requested_w;
	int height = my_window->requested_h;

	auto document = lunasvg::Document::loadFromFile(filename);
	if(document != nullptr)
	{
		auto bitmap = document->renderToBitmap(width, height);
		if(!bitmap.isNull())
		{
			bitmap.convertToRGBA();
			uint8_t *use_data = bitmap.data();
			if(use_data != NULL)
			{
				width = bitmap.width();
				height = bitmap.height();
				int cv_flag = CV_8UC4;
				Mat frame(cv::Size(width, height), cv_flag, use_data);
				cv::resize(frame, frame, cv::Size(my_window->output_width, my_window->output_height));
				frame.copyTo(mat);
			}
		}
	}
}

void	Camera::TestObjectDetection()
{
	int tcx = -1;
	int tcy = -1;
	int second_cx = -1;
	int second_cy = -1;
	int rr = DetectObjects(&tcx, &tcy, &second_cx, &second_cy);
}

void	Camera::Capture(int test_only)
{
int				loop;
int				inner;

	if(since_time == 0)
	{
		since_time = time(0);
	}
	long int now = precise_time();
	if(now > (last_capture_time + (int)(1000000.0 * capture_interval)))
	{
		last_capture_time = now;
		newly_captured = 1;
		if(type == CAMERA_TYPE_IMAGE)
		{
			if(static_initialized == 0)
			{
				mat = imread(path, IMREAD_UNCHANGED);
				reserve_mat = mat.clone();
				if(reserve_mat.channels() == 3)
				{
					cvtColor(reserve_mat, reserve_mat, COLOR_BGR2RGBA);
				}
				else if(reserve_mat.channels() == 4)
				{
					cvtColor(reserve_mat, reserve_mat, COLOR_BGRA2RGBA);
				}
				static_initialized = 1;
			}
			reserve_mat.copyTo(mat);
		}
		else if(type == CAMERA_TYPE_VECTOR)
		{
			if(static_initialized == 0)
			{
				char *cp = path;
				if(strncmp(cp, "vector://", strlen("vector://")) == 0)
				{
					cp = path + strlen("vector://");
				}
				ReadVectorFile(mat, cp);
				reserve_mat = mat.clone();
				static_initialized = 1;
			}
			reserve_mat.copyTo(mat);
		}
		else if((type == CAMERA_TYPE_BLANK) && (!reserve_mat.empty()))
		{
			reserve_mat.copyTo(mat);
		}
		else
		{
			if(cap != NULL)
			{
				if((cap->isOpened()) || (ndi_capture == 1))
				{
					Mat temp_mat;
					if(hot == 0)
					{
						hot = 1;
						create_task((int (*)(int *))thread_read_camera, (void *)this);
						sleep(1);
					}
					TransferHotMat(temp_mat);
					if(freeze_video == 1)
					{
						if(!reserve_mat.empty())
						{
							temp_mat = reserve_mat.clone();
							cvtColor(temp_mat, temp_mat, COLOR_BGRA2RGBA);
						}
						else
						{
							cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 255));
							temp_mat = local_mat.clone();
						}
					}
					if(mute_video == 1)
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 255));
						temp_mat = local_mat.clone();
					}
					int current_frame = 0;
					if(cap_total_frames > 1)	
					{
						current_frame = cap->get(cv::CAP_PROP_POS_FRAMES);
						if(current_frame >= cap_total_frames)
						{
							cap->set(cv::CAP_PROP_POS_FRAMES, 0);
						}
					}
					if(!temp_mat.empty())
					{
						mat = temp_mat;
						reserve_mat = temp_mat.clone();
						int ch = temp_mat.channels();
						if(ch == 3)
						{
							cvtColor(reserve_mat, reserve_mat, COLOR_BGR2RGBA);
							cvtColor(mat, mat, COLOR_BGR2RGBA);
						}
						else if(ch == 4)
						{
							cvtColor(reserve_mat, reserve_mat, COLOR_BGRA2RGBA);
							cvtColor(mat, mat, COLOR_BGRA2RGBA);
						}
						else if(ch == 1)
						{
							cvtColor(reserve_mat, reserve_mat, COLOR_GRAY2RGBA);
							cvtColor(mat, mat, COLOR_GRAY2RGBA);
						}
						else
						{
							fprintf(stderr, "Error: Unusable color depth: %d\n", ch);
						}
					}
					else
					{
						if(cap_total_frames < 2)
						{
							type = CAMERA_TYPE_IMAGE;
						}
						else
						{
							cap->set(cv::CAP_PROP_POS_FRAMES, 0);
						}
					}
				}
				else if(type == CAMERA_TYPE_CLOCK)
				{
					cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					literal_mat = local_mat.clone();
					char buf[256];

					time_t t_num = time(0);
					struct tm *tm;
					tm = localtime((const time_t *)&t_num);
					int hour = tm->tm_hour;
					char *tag = "";
					if(military_clock == 0)
					{
						tag = " AM";
						if(hour >= 12) 
						{
							tag = " PM";
							if(hour > 12)
							{
								hour -= 12;
							}
						}
					}
					if((timer_format == 0) || (timer_format == 1))
					{
						sprintf(buf, "%02d:%02d:%02d%s", hour, tm->tm_min, tm->tm_sec, tag);
					}
					else if(timer_format == 2)
					{
						sprintf(buf, "%02d:%02d%s", hour, tm->tm_min, tag);
					}
					if(analog == 1)
					{
						if(cairo_context != NULL)
						{
							CairoClock(literal_mat, timer_format, -1, -1, analog_size, analog_size, -1, -1, -1);
						}
					}
					else
					{
						RenderTextToMat(buf, &literal_mat);
						static_initialized = 1;
					}
					mat = literal_mat.clone();
					reserve_mat = mat.clone();
				}
				else if(type == CAMERA_TYPE_TIMER)
				{
					cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					literal_mat = local_mat.clone();
					char buf[256];
					time_t elapsed = time(0) - initial_timer;
					time_t use_time = start_timer + elapsed;
					if(start_timer > stop_timer)
					{
						use_time = start_timer - elapsed;
					}
					int days = 0;
					int hours = 0;
					int minutes = 0;
					int seconds = 0;
					time_seconds_eval(use_time, days, hours, minutes, seconds);
					if(timer_format == 0)
					{
						sprintf(buf, "%02d:%02d:%02d:%02d", days, hours, minutes, seconds);
					}
					else if(timer_format == 1)
					{
						sprintf(buf, "%02d:%02d:%02d", hours, minutes, seconds);
					}
					else if(timer_format == 2)
					{
						sprintf(buf, "%02d:%02d", hours, minutes);
					}
					RenderTextToMat(buf, &literal_mat);
					mat = literal_mat.clone();
					reserve_mat = mat.clone();
					static_initialized = 1;
				}
				else if(type == CAMERA_TYPE_ALERT)
				{
					int trigger_it = 0;
					int use_alpha = alpha;
					if(alert_opaque == 1) use_alpha = 255;
					cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(red, green, blue, use_alpha));
					literal_mat = local_mat.clone();
					trigger_it = TriggerAlert();
					time_t now = time(0);
					int triggered = 0;
					if((trigger_it == 1) || (now < alert_end_time) || (alert_permanent_trigger == 1))
					{
						triggered = DisplayAlert();
					}
					if(triggered == 0)
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
						literal_mat = local_mat.clone();
					}
					mat = literal_mat.clone();
					reserve_mat = mat.clone();
				}
				else if(type == CAMERA_TYPE_DYNAMIC_TEXT)
				{
					cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					literal_mat = local_mat.clone();
					char *cp = path;
					if(strncmp(path, "dynamic://", strlen("dynamic://")) == 0)
					{
						cp = path + strlen("dynamic://");
					}
					RenderTextToMat(cp, &literal_mat);
					mat = literal_mat.clone();
					reserve_mat = mat.clone();
				}
				else if(type == CAMERA_TYPE_TEXT)
				{
					if(static_initialized == 0)
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
						literal_mat = local_mat.clone();
						RenderTextToMat(path, &literal_mat);
						mat = literal_mat.clone();
						reserve_mat = mat.clone();
						static_initialized = 1;
					}
					else
					{
						mat = reserve_mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_PIPED)
				{
					if(static_initialized == 0)
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
						literal_mat = local_mat.clone();
						RenderTextToMat(path, &literal_mat);
						mat = literal_mat.clone();
						reserve_mat = mat.clone();
						static_initialized = 1;
					}
					else
					{
						mat = reserve_mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_SINGLE_FRAME_FILE)
				{
					cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					if(mat.empty())
					{
						mat = local_mat.clone();
					}
					width = mat.cols;
					height = mat.rows;
				}
				else if(type == CAMERA_TYPE_OSG)
				{
					if(osg_viewer != NULL)
					{
						osg_viewer->frame();
						unsigned char *im = (unsigned char *)osg_viewer->image->getDataPointer();
						Mat src(osg_viewer->image->t(), osg_viewer->image->s(), CV_8UC4, (void *)im);
						mat = src.clone();
						width = mat.cols;
						height = mat.rows;
						RunInstruments();
					}
				}
				else if(type == CAMERA_TYPE_DESKTOP)
				{
					my_window->GrabDesktop(1);
					if((my_window->desktop_mat.cols > 0) && (my_window->desktop_mat.rows > 0))
					{
						if((grab_portion_x > -1)
						&& (grab_portion_y > -1)
						&& (grab_portion_w > -1)
						&& (grab_portion_h > -1))
						{
							Mat local_mat = my_window->desktop_mat(Rect(grab_portion_x, grab_portion_y, grab_portion_w, grab_portion_h));
							if(!local_mat.empty())
							{
								Mat new_mat;
								scale_mat_to_fit(local_mat, new_mat, my_window->output_width, my_window->output_height);
								mat = new_mat.clone();
								reserve_mat = new_mat.clone();
							}
							width = mat.cols;
							height = mat.rows;
						}
						else
						{
							mat = my_window->desktop_mat.clone();
							reserve_mat = mat.clone();
						}
					}
				}
				else if(type == CAMERA_TYPE_WINDOW)
				{
					GrabWindow();
					reserve_mat = mat.clone();
					width = mat.cols;
					height = mat.rows;
				}
				else if(type == CAMERA_TYPE_SLIDESHOW)
				{
					GrabSlideshow();
					reserve_mat = mat.clone();
					width = mat.cols;
					height = mat.rows;
				}
				else if(type == CAMERA_TYPE_PSEUDO)
				{
					void *(*pseudo_camera)(char *, int *, int *, int *);
					pseudo_camera = (void *(*)(char *, int *, int *, int *))void_pseudo_camera;
					int pseudo_width = 0;
					int pseudo_height = 0;
					int pseudo_depth = 0;
					void *ptr = pseudo_camera(pseudo_camera_name, &pseudo_width, &pseudo_height, &pseudo_depth);
					if(ptr != NULL)
					{
						width = pseudo_width;
						height = pseudo_height;
						int depth = pseudo_depth;
						if(depth == 4)
						{
							Mat src = Mat(height, width, CV_8UC4, ptr);
							mat = src.clone();
						}
						else if(depth == 3)
						{
							Mat src = Mat(height, width, CV_8UC3, ptr);
							mat = src.clone();
						}
						reserve_mat = mat.clone();
						free(ptr);
					}
				}
				else if(type == CAMERA_TYPE_PLUGIN)
				{
					if(plugin_camera != NULL)
					{
						void *(*pseudo_camera)(char *, int *, int *, int *);
						pseudo_camera = (void *(*)(char *, int *, int *, int *))plugin_camera;
						int pseudo_width = 0;
						int pseudo_height = 0;
						int pseudo_depth = 0;
						void *ptr = pseudo_camera("Text", &pseudo_width, &pseudo_height, &pseudo_depth);
						if(ptr != NULL)
						{
							width = pseudo_width;
							height = pseudo_height;
							int depth = pseudo_depth;
							if(depth == 4)
							{
								Mat src = Mat(height, width, CV_8UC4, ptr);
								mat = src.clone();
							}
							else if(depth == 3)
							{
								Mat src = Mat(height, width, CV_8UC3, ptr);
								mat = src.clone();
							}
							reserve_mat = mat.clone();
							free(ptr);
						}
					}
				}
				else if(type == CAMERA_TYPE_AV)
				{
					if(av_window != NULL)
					{
						mat = av_window->mat.clone();
						width = mat.cols;
						height = mat.rows;
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_HTML)
				{
					if(html != NULL)
					{
						Mat src = Mat(height, width, CV_8UC4, html->raw);
						mat = src.clone();
						width = mat.cols;
						height = mat.rows;
						if(mat.channels() == 3)
						{
							cvtColor(mat, mat, COLOR_BGR2RGB);
						}
						else if(mat.channels() == 4)
						{
							cvtColor(mat, mat, COLOR_BGRA2RGBA);
						}
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_SOURCED)
				{
					if(source_camera != NULL)
					{
						source_camera->Capture();
						width = source_camera->mat.cols;
						height = source_camera->mat.rows;
						if((requested_w < width) && (requested_h < height)
						&& (requested_w > 0) && (requested_h > 0))
						{
							int sx = 0;
							int sy = 0;
							if((requested_x == -1) || (requested_y == -1))
							{
								sx = (width / 2) - (requested_w / 2);
								sy = (height / 2) - (requested_h / 2);
							}
							else
							{
								sx = requested_x;
								sy = requested_y;
								width = requested_w;
								height = requested_h;
							}
							my_window->CropFrame(source_camera->mat, &mat, sx, sy, requested_w, requested_h);
							cv::resize(mat, mat, cv::Size(width, height));
							reserve_mat = mat.clone();
						}
						else
						{
							mat = source_camera->mat.clone();
							reserve_mat = mat.clone();
						}
					}
					else
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(55, 100, 150, 255));
						mat = local_mat.clone();
						width = local_mat.cols;
						height = local_mat.rows;
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_EDGE_DETECT)
				{
					if(source_camera != NULL)
					{
						source_camera->Capture();
						width = source_camera->mat.cols;
						height = source_camera->mat.rows;
						if((requested_w < width) && (requested_h < height))
						{
							int sx = (width / 2) - (requested_w / 2);
							int sy = (height / 2) - (requested_h / 2);
							my_window->CropFrame(source_camera->mat, &mat, sx, sy, requested_w, requested_h);
							cv::resize(mat, mat, cv::Size(width, height));
							edge_detect_with_blend(mat, edge_blend);
							reserve_mat = mat.clone();
						}
						else
						{
							mat = source_camera->mat.clone();
							edge_detect_with_blend(mat, edge_blend);
							reserve_mat = mat.clone();
						}
					}
					else
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(55, 100, 150, 255));
						mat = local_mat.clone();
						width = local_mat.cols;
						height = local_mat.rows;
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_CHROMAKEY)
				{
					if(source_camera != NULL)
					{
						source_camera->Capture();
						width = source_camera->mat.cols;
						height = source_camera->mat.rows;
						if((requested_w < width) && (requested_h < height))
						{
							int sx = (width / 2) - (requested_w / 2);
							int sy = (height / 2) - (requested_h / 2);
							my_window->CropFrame(source_camera->mat, &mat, sx, sy, requested_w, requested_h);
							cv::resize(mat, mat, cv::Size(width, height));
							chromakey(mat, mat, chroma_color, 4.0, 1.0);
							reserve_mat = mat.clone();
						}
						else
						{
							mat = source_camera->mat.clone();
							chromakey(mat, mat, chroma_color, 4.0, 1.0);
							reserve_mat = mat.clone();
						}
					}
					else
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(55, 100, 150, 255));
						mat = local_mat.clone();
						width = local_mat.cols;
						height = local_mat.rows;
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_ALTERNATING)
				{
					int must_advance = 0;
					Camera *use_camera = my_window->camera[alternate_index];
					if((use_camera != NULL) && (use_camera != this))
					{
						if(use_camera->power == 1)
						{
							if((use_camera->type != CAMERA_TYPE_ALTERNATING)
							&& (use_camera->type != CAMERA_TYPE_ALL)
							&& (use_camera->type != CAMERA_TYPE_SPLIT)
							&& (use_camera->type != CAMERA_TYPE_SOURCED)
							&& (use_camera->type != CAMERA_TYPE_EDGE_DETECT))
							{
								use_camera->Capture();
								width = use_camera->mat.cols;
								height = use_camera->mat.rows;
								if((requested_w < width) && (requested_h < height))
								{
									int sx = (width / 2) - (requested_w / 2);
									int sy = (height / 2) - (requested_h / 2);
									my_window->CropFrame(use_camera->mat, &mat, sx, sy, requested_w, requested_h);
									cv::resize(mat, mat, cv::Size(width, height));
								}
								else
								{
									mat = use_camera->mat.clone();
								}
								reserve_mat = mat.clone();
							}
							else
							{
								must_advance = 1;
							}
						}
						else
						{
							must_advance = 1;
						}
					}
					else
					{
						must_advance = 1;
					}
					long int interval = precise_time() - alternate_time;
					if((interval > (long int)(alternate_interval * 1000000.0)) || (must_advance == 1))
					{
						alternate_index++;
						if(alternate_index >= my_window->source_cnt)
						{
							alternate_index = 0;
						}
						alternate_time = precise_time();
					}
				}
				else if(type == CAMERA_TYPE_ALL)
				{
					cv::Mat tmp_mat(height, width, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					mat = tmp_mat.clone();
					Mat local_mat[9];
					int usable_cnt = 0;
					for(loop = 0;loop < my_window->source_cnt;loop++)
					{
						Camera *use_camera = my_window->camera[loop];
						if((use_camera != NULL) && (use_camera != this))
						{
							if(use_camera->power == 1)
							{
								if((use_camera->type != CAMERA_TYPE_ALTERNATING)
								&& (use_camera->type != CAMERA_TYPE_ALL)
								&& (use_camera->type != CAMERA_TYPE_SOURCED)
								&& (use_camera->type != CAMERA_TYPE_SPLIT)
								&& (use_camera->type != CAMERA_TYPE_EDGE_DETECT))
								{
									if(usable_cnt < 9)
									{
										use_camera->Capture();
										local_mat[usable_cnt] = use_camera->mat.clone();
									}
									usable_cnt++;
								}
							}
						}
					}
					int uw = width;
					int uh = height;
					if(usable_cnt > 1)
					{
						if(usable_cnt < 5)
						{
							uw = width / 2;
							uh = height / 2;
						}
						else
						{
							uw = width / 3;
							uh = height / 3;
						}
					}
					int px = 0;
					int py = 0;
					for(loop = 0;loop < usable_cnt;loop++)
					{
						Mat use_mat;
						cv::resize(local_mat[loop], use_mat, cv::Size(uw, uh));
						use_mat.copyTo(mat.rowRange(py, py + uh).colRange(px, px + uw));
						px += uw;
						if((px + uw) > mat.cols)
						{
							px = 0;
							py += uh;
						}
					}
					reserve_mat = mat.clone();
				}
				else if(type == CAMERA_TYPE_SPLIT)
				{
					cv::Mat tmp_mat(height, width, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					mat = tmp_mat.clone();
					Mat local_mat[128];
					int usable_cnt = 0;
					for(loop = 0;loop < split_source_cnt;loop++)
					{
						int created = 0;
						Camera *use_camera = my_window->FindCameraByAlias(split_source[loop]);
						if((use_camera != NULL) && (use_camera != this))
						{
							if((use_camera->type != CAMERA_TYPE_ALL)
							&& (use_camera->type != CAMERA_TYPE_ALTERNATING)
							&& (use_camera->type != CAMERA_TYPE_SOURCED)
							&& (use_camera->type != CAMERA_TYPE_EDGE_DETECT)
							&& (use_camera->type != CAMERA_TYPE_SPLIT)
							&& (use_camera->type != CAMERA_TYPE_CHROMAKEY))
							{
								if(use_camera->power == 1)
								{
									if((use_camera->type != CAMERA_TYPE_ALTERNATING)
									&& (use_camera->type != CAMERA_TYPE_ALL)
									&& (use_camera->type != CAMERA_TYPE_SOURCED)
									&& (use_camera->type != CAMERA_TYPE_SPLIT)
									&& (use_camera->type != CAMERA_TYPE_EDGE_DETECT))
									{
										if(usable_cnt < 128)
										{
											use_camera->Capture();
											local_mat[usable_cnt] = use_camera->mat.clone();
											created = 1;
											usable_cnt++;
										}
									}
								}
							}
						}
						if(created == 0)
						{
							if(usable_cnt < 128)
							{
								Mat use(height, width, CV_8UC4, cv::Scalar(0, 0, 0, 0));
								local_mat[usable_cnt] = use.clone();
								usable_cnt++;
							}
						}
					}
					int uw = width;
					int uh = height;
					if(usable_cnt > 1)
					{
						if(usable_cnt < 5)
						{
							uw = width / 2;
							uh = height / 2;
						}
						else
						{
							uw = width / 3;
							uh = height / 3;
						}
					}
					int px = 0;
					int py = 0;
					for(loop = 0;loop < usable_cnt;loop++)
					{
						Mat use_mat;
						cv::resize(local_mat[loop], use_mat, cv::Size(uw, uh));
						use_mat.copyTo(mat.rowRange(py, py + uh).colRange(px, px + uw));
						px += uw;
						if((px + uw) > mat.cols)
						{
							px = 0;
							py += uh;
						}
					}
					reserve_mat = mat.clone();
				}
				else
				{
					fprintf(stderr, "Error: Image is closed.\n");
					type = CAMERA_TYPE_TEXT;
					cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					literal_mat = local_mat.clone();
					RenderTextToMat("Error: Camera closed unexpectedly.", &literal_mat);
					mat = literal_mat.clone();
					reserve_mat = mat.clone();
					static_initialized = 1;
				}
			}
			else
			{
				fprintf(stderr, "Error: Camera cap is NULL.\n");
				type = CAMERA_TYPE_TEXT;
				cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
				literal_mat = local_mat.clone();
				RenderTextToMat("Error: Camera capture device is NULL.", &literal_mat);
				mat = literal_mat.clone();
				reserve_mat = mat.clone();
				static_initialized = 1;
				cap = new VideoCapture();
			}
		}
	}
	if(test_only == 0)
	{
		for(loop = 0;loop < filter_plugin_cnt;loop++)
		{
			void (*receive_image)(int, int, int, unsigned char *);
			receive_image = (void (*)(int, int, int, unsigned char*))filter_plugin[loop];
			if(receive_image != NULL)
			{
				receive_image(mat.cols, mat.rows, mat.channels(), mat.ptr());
			}
		}
		for(loop = 0;loop < global_filter_plugin_cnt;loop++)
		{
			void (*receive_image)(int, int, int, unsigned char *);
			receive_image = (void (*)(int, int, int, unsigned char*))void_filter_plugin[loop];
			if(receive_image != NULL)
			{
				receive_image(mat.cols, mat.rows, mat.channels(), mat.ptr());
			}
		}
		if(!mat.empty())
		{
			if(capture_effects == 1)
			{
				RunFilters();
			}
			if((width > 0) && (height > 0))
			{
				if((my_window->frame_scaling != 1)
				&& (my_window->crop_scaling != 1))
				{
					if((width != mat.cols) || (height != mat.rows))
					{
						cv::resize(mat, mat, cv::Size(width, height));
					}
				}
			}
			if(capture_scaling != 1.0)
			{
				int scaled_x = (int)((double)mat.cols * capture_scaling);
				int scaled_y = (int)((double)mat.rows * capture_scaling);
				cv::resize(mat, mat, cv::Size(scaled_x, scaled_y));
			}
			if((my_window->frame_scaling == 1)
			|| (my_window->crop_scaling == 1))
			{
				orig_width = mat.cols;
				orig_height = mat.rows;
				my_window->FrameImage(this, mat, mat, forced_aspect_x, forced_aspect_y);
			}
			if((my_window->test_recognition == 1) && ((true_total_frames % recognize_interval) == 0))
			{
				TestObjectDetection();
			}
			if(capture_effects == 1)
			{
				if(!mat.empty())
				{
					VideoEffects();
					SetCairo();
					int moving_element = 0;
					int someone_is_dragging = 0;
					PaintRecognizedObjects(my_window->test_recognition);
					ShowImmediateList();
					ColorIt();
					MiscCopyCommands();
					DrawShapes();
				}
			}
			if(my_window->timestamp == 1)
			{
				SetCairo();
				TimestampFrame();
			}
			if(snapshot_trigger_condition == SNAPSHOT_TRIGGER_CONTINUOUS)
			{
				snapshot_initial_delay = 0.0;
				snapshot_repeat_delay = 0.0;
				TriggerSnapshot();
			}
			if(snapshot_trigger_condition == SNAPSHOT_TRIGGER_START)
			{
				TriggerSnapshot();
				snapshot_trigger_condition = SNAPSHOT_TRIGGER_BUTTON;
			}
		}
	}
}

void	Camera::DrawShapes()
{
int	loop;
int	outer;

	int cnt = 0;
	Shape **list = my_window->FindShapesOnCamera(this, cnt);
	if(list != NULL)
	{
		for(outer = 0;outer < 7;outer++)
		{
			for(loop = 0;loop < cnt;loop++)
			{
				if(list[loop] != NULL)
				{
					if(list[loop]->hidden == 0)
					{
						if(list[loop]->layer == outer)
						{
							list[loop]->draw();
						}
					}
					if(list[loop]->highlight == 1)
					{
						int xx = list[loop]->x();
						int yy = list[loop]->y();
						int ww = list[loop]->w();
						int hh = list[loop]->h();
						fl_color(YELLOW);
						fl_rect(xx, yy, ww, hh);
					}
				}
			}
		}
		free(list);
	}
}

void	Camera::HighlightShapes()
{
int	loop;
int	outer;

	int cnt = 0;
	Shape **list = my_window->FindShapesOnCamera(this, cnt);
	if(list != NULL)
	{
		for(outer = 0;outer < 7;outer++)
		{
			for(loop = 0;loop < cnt;loop++)
			{
				if(list[loop] != NULL)
				{
					if(list[loop]->highlight == 1)
					{
						int xx = list[loop]->x();
						int yy = list[loop]->y();
						int ww = list[loop]->w();
						int hh = list[loop]->h();
						fl_color(YELLOW);
						fl_rect(xx, yy, ww, hh);
					}
				}
			}
		}
		free(list);
	}
}

int	capture_frame(int *flag)
{
	Camera *cam = (Camera *)flag;
	if(cam != NULL)
	{
		while(cam->capturing == 1)
		{
			if(cam->cap != NULL)
			{
				if(cam->cap->isOpened())
				{
					cam->cap->grab();
				}
			}
			cam->Capture();
		}
	}
	return(0);
}

void	Camera::MiscCopyCommands()
{
int	loop;
int	inner;

	MyWin *win = my_window;
	for(loop = 0;loop < win->misc_copy_cnt;loop++)
	{
		if(win->misc_copy[loop] != NULL)
		{
			if(win->misc_copy[loop]->display == 1)
			{
				if(win->misc_copy[loop]->type == MISC_COPY_DYNAMIC)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						win->CropFrame(mat, &win->misc_copy[loop]->mat, use_x, use_y, use_w, use_h);
					}
				}
				if((win->misc_copy[loop]->type == MISC_COPY_STATIC)
				|| (win->misc_copy[loop]->type == MISC_COPY_DYNAMIC))
				{
					for(inner = 0;inner < win->misc_copy[loop]->destination_cnt;inner++)
					{
						if(win->misc_copy[loop]->destination[inner] == this)
						{
							if(!win->misc_copy[loop]->mat.empty())
							{
								if(win->misc_copy[loop]->dest_display[inner] == 1)
								{
									int px = win->misc_copy[loop]->dest_x[inner];
									int py = win->misc_copy[loop]->dest_y[inner];
									int uw = win->misc_copy[loop]->ww;
									int uh = win->misc_copy[loop]->hh;
									if((uw > 0) && (uh > 0))
									{
										PasteMat(win->misc_copy[loop]->mat, px, py);
									}
								}
							}
						}
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_MASK)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						rectangle(mat, Point(use_x, use_y), Point(use_x + use_w, use_y + use_h), Vec4b(0, 0, 0, 0), cv::FILLED);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_FILL)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						int rr = win->misc_copy[loop]->red;
						int gg = win->misc_copy[loop]->green;
						int bb = win->misc_copy[loop]->blue;
						int aa = win->misc_copy[loop]->alpha;
						my_cairo_set_source_rgba(cairo_context, rr, gg, bb, aa);
						cairo_rectangle(cairo_context, use_x, use_y, use_w, use_h);
						cairo_fill(cairo_context);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_CROP)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						win->CropFrame(mat, &mat, use_x, use_y, use_w, use_h);
						cv::resize(mat, mat, cv::Size(my_window->output_width, my_window->output_height));
						SetCairo();
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_TEXT)
				{
					if(win->misc_copy[loop]->source == this)
					{
						if(win->misc_copy[loop]->quick_text != NULL)
						{
							win->misc_copy[loop]->quick_text->show();
							win->misc_copy[loop]->quick_text->draw();
							int use_x = win->misc_copy[loop]->xx;
							int use_y = win->misc_copy[loop]->yy;
							int use_w = win->misc_copy[loop]->ww;
							int use_h = win->misc_copy[loop]->hh;
						}
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_RECTANGLE)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						rectangle(mat, Point(use_x, use_y), Point(use_x + use_w, use_y + use_h), Scalar(255, 255, 255), 1);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_MAGNIFY)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						if((win->output_height > 0) && (win->output_width > 0))
						{
							if(use_w > use_h)
							{
								double use = (double)win->output_width / (double)win->output_height;
								int fh = (int)((double)use_h * use);
								win->CropFrame(mat, &mat, use_x, use_y, fh, use_h);
								if((mat.cols > 0) && (mat.rows > 0))
								{
									cv::resize(mat, mat, cv::Size(my_window->output_width, my_window->output_height));
								}
								SetCairo();
							}
							else
							{
								double use = (double)win->output_height / (double)win->output_width;
								int fh = (int)((double)use_w * use);
								win->CropFrame(mat, &mat, use_x, use_y, use_w, fh);
								if((mat.cols > 0) && (mat.rows > 0))
								{
									cv::resize(mat, mat, cv::Size(my_window->output_width, my_window->output_height));
								}
								SetCairo();
							}
						}
						else
						{
							win->CropFrame(mat, &mat, use_x, use_y, use_w, use_h);
							SetCairo();
						}
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_BORDER)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						rectangle(mat, Point(0, 0), Point(use_x, (mat.rows - 1)), Scalar(0, 0, 0), FILLED);
						rectangle(mat, Point(0, 0), Point((mat.cols - 1), use_y), Scalar(0, 0, 0), FILLED);
						rectangle(mat, Point((use_x + use_w), 0), Point((mat.cols - 1), (mat.rows - 1)), Scalar(0, 0, 0), FILLED);
						rectangle(mat, Point(0, (use_y + use_h)), Point((mat.cols - 1), (mat.rows - 1)), Scalar(0, 0, 0), FILLED);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_REVERSE)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						if(use_x < 0) use_x = 0;
						if(use_y < 0) use_y = 0;
						Mat out;
						win->CropFrame(mat, &out, use_x, use_y, use_w - 1, use_h - 1);
						bitwise_not(out, out);
						use_w = out.cols;
						use_h = out.rows;
						out.copyTo(mat.rowRange(use_y, use_y + use_h).colRange(use_x, use_x + use_w));
						SetCairo();
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_BRIGHTEN)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						cairo_save(cairo_context);
						cairo_rectangle(cairo_context, use_x, use_y, use_w, use_h);
						cairo_clip(cairo_context);
						cairo_set_source_rgba(cairo_context, 1.0, 1.0, 1.0, 0.1);
						cairo_paint(cairo_context);
						cairo_restore(cairo_context);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_VIDEO_SETTINGS)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						if(use_x < 0) use_x = 0;
						if(use_y < 0) use_y = 0;
						Mat out;
						win->CropFrame(mat, &out, use_x, use_y, use_w - 1, use_h - 1);
						if(win->misc_copy[loop]->saturation != 1.0)
						{
							out = change_saturation(out, win->misc_copy[loop]->saturation);
						}
						if(win->misc_copy[loop]->hue != 1.0)
						{
							out = change_hue(out, win->misc_copy[loop]->hue);
						}
						if(win->misc_copy[loop]->intensity != 1.0)
						{
							out = change_intensity(out, win->misc_copy[loop]->intensity);
						}
						if(win->misc_copy[loop]->contrast != 0.5)
						{
							contrast_mat(out, win->misc_copy[loop]->contrast);
						}
						if(win->misc_copy[loop]->brightness != 0.5)
						{
							brightness_mat(out, win->misc_copy[loop]->brightness);
						}
						use_w = out.cols;
						use_h = out.rows;
						out.copyTo(mat.rowRange(use_y, use_y + use_h).colRange(use_x, use_x + use_w));
						SetCairo();
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_DARKEN)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						cairo_save(cairo_context);
						cairo_rectangle(cairo_context, use_x, use_y, use_w, use_h);
						cairo_clip(cairo_context);
						cairo_set_source_rgba(cairo_context, 0.0, 0.0, 0.0, 0.1);
						cairo_paint(cairo_context);
						cairo_restore(cairo_context);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_HFLIP)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						if(use_x < 0) use_x = 0;
						if(use_y < 0) use_y = 0;
						Mat out;
						win->CropFrame(mat, &out, use_x, use_y, use_w - 1, use_h - 1);
						flip(out, out, 1);
						use_w = out.cols;
						use_h = out.rows;
						out.copyTo(mat.rowRange(use_y, use_y + use_h).colRange(use_x, use_x + use_w));
						SetCairo();
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_SATURATE)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						if(use_x < 0) use_x = 0;
						if(use_y < 0) use_y = 0;
						Mat out;
						win->CropFrame(mat, &out, use_x, use_y, use_w - 1, use_h - 1);
						change_saturation(out, 1.25);
						use_w = out.cols;
						use_h = out.rows;
						out.copyTo(mat.rowRange(use_y, use_y + use_h).colRange(use_x, use_x + use_w));
						SetCairo();
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_DESATURATE)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						if(use_x < 0) use_x = 0;
						if(use_y < 0) use_y = 0;
						Mat out;
						win->CropFrame(mat, &out, use_x, use_y, use_w - 1, use_h - 1);
						change_saturation(out, 0.75);
						use_w = out.cols;
						use_h = out.rows;
						out.copyTo(mat.rowRange(use_y, use_y + use_h).colRange(use_x, use_x + use_w));
						SetCairo();
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_VFLIP)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						if(use_x < 0) use_x = 0;
						if(use_y < 0) use_y = 0;
						Mat out;
						win->CropFrame(mat, &out, use_x, use_y, use_w - 1, use_h - 1);
						flip(out, out, 0);
						use_w = out.cols;
						use_h = out.rows;
						out.copyTo(mat.rowRange(use_y, use_y + use_h).colRange(use_x, use_x + use_w));
						SetCairo();
					}
				}
			}
		}
	}
}

void	Camera::PrepImageForNet(Mat in_mat)
{
std::vector<int> param(2);

	if(cap != NULL)
	{
		if(cap->isOpened())
		{
			if(my_window->image_memory.ready == 0)
			{
				Mat new_mat;
				param[0] = cv::IMWRITE_JPEG_QUALITY;
				param[1] = 45;
				cv::resize(in_mat, new_mat, cv::Size(640, 360));
				imencode(".jpg", new_mat, my_window->image_memory.buffer, param);
				my_window->image_memory.size = my_window->image_memory.buffer.size();
				my_window->image_memory.ptr = my_window->image_memory.buffer.data();
				my_window->image_memory.ready = 1;
			}
		}
	}
}

void	Camera::StartCapture()
{
	capturing = 1;
	pthread_t signal_thread = create_task((int (*)(int *))capture_frame, (void *)this);
}

int	Camera::PostProcessRecognition(Mat &frame, const vector<Mat> &outs, int *out_x, int *out_y, int *second_x, int *second_y)
{
vector<int> classIds;
vector<float> confidences;
vector<Rect> boxes;

	*out_x = -1;
	*out_y = -1;
	*second_x = -1;
	*second_y = -1;
	int found = -1;
	for(size_t i = 0; i < outs.size(); ++i)
	{
		float *data = (float *)outs[i].data;
		for(int j = 0;j < outs[i].rows; ++j, data += outs[i].cols)
		{
			Mat scores = outs[i].row(j).colRange(5, outs[i].cols);
			Point classIdPoint;
			double confidence;

			minMaxLoc(scores, 0, &confidence, 0, &classIdPoint);
			if(confidence > recognition_threshold)
			{
				int centerX = (int)(data[0] * frame.cols);
				int centerY = (int)(data[1] * frame.rows);
				int width = (int)(data[2] * frame.cols);
				int height = (int)(data[3] * frame.rows);
				int left = centerX - width / 2;
				int top = centerY - height / 2;
					
				classIds.push_back(classIdPoint.x);
				confidences.push_back((float)confidence);
				boxes.push_back(Rect(left, top, width, height));
			}
		}
	}
	vector<int> indices;
	NMSBoxes(boxes, confidences, recognition_threshold, 0.4, indices);
	detected_object_cnt = 0;
	int max_x = -1000000;
	int max_y = -1000000;
	int min_x = 1000000;
	int min_y = 1000000;
	for(size_t i = 0; i < indices.size(); ++i)
	{
		int idx = indices[i];
		Rect box = boxes[idx];
		if(object_index[classIds[idx]] == 1)
		{
			found = classIds[idx];

			if(box.x < min_x) min_x = box.x;
			if(box.y < min_y) min_y = box.y;
			if((box.x + box.width) > max_x) max_x = box.x + box.width;
			if((box.y + box.height) > max_y) max_y = box.y + box.height;

			detected_object[detected_object_cnt].x = box.x;
			detected_object[detected_object_cnt].y = box.y;
			detected_object[detected_object_cnt].w = box.width;
			detected_object[detected_object_cnt].h = box.height;
			detected_object[detected_object_cnt].idx = classIds[idx];
			detected_object[detected_object_cnt].confidence = confidences[idx];
			detected_object_cnt++;
		}
	}
	if((max_x > 0) && (max_y > 0) && (min_x < 10000) && (min_y < 10000))
	{
		*out_x = min_x;
		*out_y = min_y;
		*second_x = max_x;
		*second_y = max_y;
	}
	return(found);
}

vector<String> getOutputsNames(const Net& net)
{
	static vector<String> names;
	if(!net.empty()) 
	{
		if(names.empty())
		{
			// Get the indices of the output layers, i.e. the layers with unconnected outputs
			vector<int> outLayers = net.getUnconnectedOutLayers();
			
			// Get the names of all the layers in the network
			vector<String> layersNames = net.getLayerNames();
			
			// Get the names of the output layers in names
			names.resize(outLayers.size());
			for(size_t i = 0; i < outLayers.size(); ++i)
			{
				names[i] = layersNames[outLayers[i] - 1];
			}
		}
	}
	return(names);
}

int	Camera::DetectObjects(int *out_x, int *out_y, int *second_x, int *second_y)
{
Mat	blob;

	int found = 0;
	if(!net.empty()) 
	{
		Mat use = mat.clone();
		cvtColor(use, use, COLOR_RGBA2BGR);
		blob = blobFromImage(use, 1 / 255.0, cv::Size(416, 416), Scalar(0, 0, 0), true, false);
		net.setInput(blob);
	
		vector<Mat> outs;
		net.forward(outs, getOutputsNames(net));
		found = PostProcessRecognition(mat, outs, out_x, out_y, second_x, second_y);
	}
	return(found);
}

int	Camera::SetBackendFlag(char *cp)
{
	int flag = CAP_ANY;
	if(strncmp(cp, "VFW ", strlen("VFW")) == 0)
	{
		flag = CAP_VFW;
	}
	else if(strncmp(cp, "V4L ", strlen("V4L")) == 0)
	{
		flag = CAP_V4L;
	}
	else if(strncmp(cp, "V4L2 ", strlen("V4L2")) == 0)
	{
		flag = CAP_V4L2;
	}
	else if(strncmp(cp, "FIREWIRE ", strlen("FIREWIRE")) == 0)
	{
		flag = CAP_FIREWIRE;
	}
	else if(strncmp(cp, "IEEE1394 ", strlen("IEEE1394")) == 0)
	{
		flag = CAP_IEEE1394;
	}
	else if(strncmp(cp, "DC1394 ", strlen("DC1394")) == 0)
	{
		flag = CAP_DC1394;
	}
	else if(strncmp(cp, "CMU1394 ", strlen("CMU1394")) == 0)
	{
		flag = CAP_CMU1394;
	}
	else if(strncmp(cp, "QT ", strlen("QT")) == 0)
	{
		flag = CAP_QT;
	}
	else if(strncmp(cp, "UNICAP ", strlen("UNICAP")) == 0)
	{
		flag = CAP_UNICAP;
	}
	else if(strncmp(cp, "DSHOW ", strlen("DSHOW")) == 0)
	{
		flag = CAP_DSHOW;
	}
	else if(strncmp(cp, "PVAPI ", strlen("PVAPI")) == 0)
	{
		flag = CAP_PVAPI;
	}
	else if(strncmp(cp, "OPENNI ", strlen("OPENNI")) == 0)
	{
		flag = CAP_OPENNI;
	}
	else if(strncmp(cp, "OPENNI_ASUS ", strlen("OPENNI_ASUS")) == 0)
	{
		flag = CAP_OPENNI_ASUS;
	}
	else if(strncmp(cp, "ANDROID ", strlen("ANDROID")) == 0)
	{
		flag = CAP_ANDROID;
	}
	else if(strncmp(cp, "XIAPI ", strlen("XIAPI")) == 0)
	{
		flag = CAP_XIAPI;
	}
	else if(strncmp(cp, "AVFOUNDATION ", strlen("AVFOUNDATION")) == 0)
	{
		flag = CAP_AVFOUNDATION;
	}
	else if(strncmp(cp, "GIGANETIX ", strlen("GIGANETIX")) == 0)
	{
		flag = CAP_GIGANETIX;
	}
	else if(strncmp(cp, "MSMF ", strlen("MSMF")) == 0)
	{
		flag = CAP_MSMF;
	}
	else if(strncmp(cp, "WINRT ", strlen("WINRT")) == 0)
	{
		flag = CAP_WINRT;
	}
	else if(strncmp(cp, "INTELPERC ", strlen("INTELPERC")) == 0)
	{
		flag = CAP_INTELPERC;
	}
	else if(strncmp(cp, "OPENNI2 ", strlen("OPENNI2")) == 0)
	{
		flag = CAP_OPENNI2;
	}
	else if(strncmp(cp, "OPENNI2_ASUS ", strlen("OPENNI2_ASUS")) == 0)
	{
		flag = CAP_OPENNI2_ASUS;
	}
	else if(strncmp(cp, "GPHOTO2 ", strlen("GPHOTO2")) == 0)
	{
		flag = CAP_GPHOTO2;
	}
	else if(strncmp(cp, "GSTREAMER ", strlen("GSTREAMER")) == 0)
	{
		flag = CAP_GSTREAMER;
	}
	else if(strncmp(cp, "FFMPEG ", strlen("FFMPEG")) == 0)
	{
		flag = CAP_FFMPEG;
	}
	else if(strncmp(cp, "IMAGES ", strlen("IMAGES")) == 0)
	{
		flag = CAP_IMAGES;
	}
	else if(strncmp(cp, "ARAVIS ", strlen("ARAVIS")) == 0)
	{
		flag = CAP_ARAVIS;
	}
	else if(strncmp(cp, "OPENCV_MJPEG ", strlen("OPENCV_MJPEG")) == 0)
	{
		flag = CAP_OPENCV_MJPEG;
	}
	else if(strncmp(cp, "INTEL_MFX ", strlen("INTEL_MFX")) == 0)
	{
		flag = CAP_INTEL_MFX;
	}
	else if(strncmp(cp, "XINE ", strlen("XINE")) == 0)
	{
		flag = CAP_XINE;
	}
	char *cp2 = cp;
	while(*cp2 != '\0')
	{
		if(*cp2 == ':')
		{
			strcpy(format_code, cp2 + 1);
		}
		cp2++;
	}
	return(flag);
}

VideoCapture	*Camera::CreateCameraCapture(char *source, int num)
{
	int flag = CAP_V4L2;
	strcpy(format_code, "");
	VideoCapture *cam_cap = NULL;
	if(source == NULL)
	{
		cam_cap = new VideoCapture(num, flag);
		if(cam_cap->isOpened() == 0)
		{
			delete cam_cap;
			cam_cap = NULL;
		}
		sprintf(path, "/dev/video%d", num);
	}
	else
	{
		strcpy(original_path, source);
		if(strlen(source) == 1)
		{
			if((source[0] >= '0') && (source[0] <= '9'))
			{
				int nn = atoi(source);
				cam_cap = new VideoCapture(nn, flag);
				sprintf(path, "/dev/video%d", nn);
				if(cam_cap->isOpened() == 0)
				{
					delete cam_cap;
					cam_cap = NULL;
				}
			}
		}
		if(cam_cap == NULL)
		{
			char *cp = source;
			if(strncasecmp(cp, "file://", strlen("file://")) == 0)
			{
				cp += strlen("file://");
				strip_lf(cp);
				source = cp;
			}
			while(*cp != '\0')
			{
				if(strncmp(cp, "[alias=", strlen("[alias=")) == 0)
				{
					*cp = '\0';
					cp += strlen("[alias=");
					char *cp2 = cp;
					while((*cp != '\0') && (*cp != ']'))
					{
						cp++;
					}
					if(*cp == ']')
					{
						*cp = '\0';
					}
					strcpy(alias, cp2);
				}
				else
				{
					cp++;
				}
			}
			if(strncasecmp(source, "blank://", strlen("blank://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "dynamic://", strlen("dynamic://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "av://", strlen("av://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "vector://", strlen("vector://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "desktop://", strlen("desktop://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "window://", strlen("window://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "clock://", strlen("clock://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "timer://", strlen("timer://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "pseudo://", strlen("pseudo://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "sourced://", strlen("sourced://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "edge://", strlen("edge://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "chroma://", strlen("chroma://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "pipe://", strlen("pipe://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "http://", strlen("http://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "https://", strlen("https://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "html://", strlen("html://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "irc://", strlen("irc://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "ndi://", strlen("ndi://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "ndi_rgbx://", strlen("ndi_rgbx://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "ndi_bgrx://", strlen("ndi_bgrx://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "ndi_i420://", strlen("ndi_i420://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "ndi_p216://", strlen("ndi_p216://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "ndi_uyva://", strlen("ndi_uyva://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncasecmp(source, "ndi_uyvy://", strlen("ndi_uyvy://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else
			{
				char *cp = source;
				while(*cp != '\0')
				{
					if(strncmp(cp, "::", 2) == 0)
					{
						*cp = '\0';
						flag = SetBackendFlag(cp + 2);
					}
					cp++;
				}
				int no_go = my_window->ScanForDuplicateCameras(source);
				if(no_go == 0)
				{
					cam_cap = new VideoCapture(source, flag);
					if(cam_cap != NULL)
					{
						if(!cam_cap->isOpened())
						{
							delete cam_cap;
							cam_cap = new VideoCapture(source);
						}
					}
					else
					{
						cam_cap = new VideoCapture(source);
					}
				}
				else
				{
					cam_cap = new VideoCapture(source);
				}
			}
			strcpy(path, source);
		}
	}
	return(cam_cap);
}

void	Camera::RecordOn()
{
int	loop;

	record = 1;
	if(my_window->single_stream == 1)
	{
		if(my_window->follow_mode == FOLLOW_MODE_RECORDING_FOLLOWS_DISPLAY)
		{
			my_window->DisplayCamera(this);
		}
		for(loop = 0;loop < my_window->source_cnt;loop++)
		{
			if(my_window->camera[loop] != NULL)
			{
				if(my_window->camera[loop] != this)
				{
					my_window->camera[loop]->record = 0;
				}
			}
		}
	}
	if(snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
	{
		TriggerSnapshot();
	}
	triggers_requested = 1;
	recording = 1;
	my_window->recording = 1;
	my_window->recording_camera = this;
	Record();
	if(my_window->pulse_mixer != NULL)
	{
		my_window->pulse_mixer->recording = 1;
		for(loop = 0;loop < my_window->audio_thumbnail_cnt;loop++)
		{
			if(my_window->audio_thumbnail[loop] != NULL)
			{
				if(my_window->audio_thumbnail[loop]->select_button->value())
				{
					if(my_window->audio_thumbnail[loop]->microphone != NULL)
					{
						my_window->audio_thumbnail[loop]->microphone->Record();
					}
				}
			}
		}
	}
}

void	Camera::RecordOff()
{
int	loop;

	record = 0;
	if(snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
	{
		UnTriggerSnapshot();
	}
	int no_go = 0;
	for(loop = 0;loop < my_window->source_cnt;loop++)
	{
		Camera *cam = my_window->camera[loop];
		if(cam != NULL)
		{
			if(cam->record == 1)
			{
				no_go = 1;
			}
		}
	}
	if(no_go == 0)
	{
		my_window->recording = 0;
	}
	if(my_window->pulse_mixer != NULL)
	{
		my_window->pulse_mixer->Stop();
		for(loop = 0;loop < my_window->audio_thumbnail_cnt;loop++)
		{
			if(my_window->audio_thumbnail[loop] != NULL)
			{
				if(my_window->audio_thumbnail[loop]->microphone != NULL)
				{
					my_window->audio_thumbnail[loop]->microphone->Stop();
				}
			}
		}
	}
}

void	Camera::AddImageWindow(Camera *cam)
{
int	loop;

	int done = 0;
	for(loop = 0;((loop < 128) && (done == 0));loop++)
	{
		if(image_window[loop] == NULL)
		{
			int ww = cam->width;
			int hh = cam->height;
			while((ww >= (width / 2)) || (hh >= (height / 2)))
			{
				ww = ww / 2;
				hh = hh / 2;
			}
			int dw = width;
			int dh = height;
			int xx = image_sx + ((dw / 2) - (ww / 2));
			int yy = image_sy + ((dh / 2) - (hh / 2));
			if(my_window->dragging_thumb != NULL)
			{
				xx = my_window->dragging_thumb_x;
				yy = my_window->dragging_thumb_y;
			}
			ImageWindow *iw = new ImageWindow(loop, my_window, cam, this, xx, yy, ww, hh);
			image_window[loop] = iw;
			iw->show();
			done = 1;
			my_window->add(iw);
		}
	}
	CompressImageWindowList();
}

void	snapshot_timeout_cb(void *v)
{
	Camera *cam = (Camera *)v;
	cam->snapshot = 1;
	if(cam->snapshot_repeat_delay > 0)
	{
		Fl::repeat_timeout(cam->snapshot_repeat_delay, snapshot_timeout_cb, cam);
	}
}

void	Camera::TriggerSnapshot()
{
	Fl::add_timeout(snapshot_initial_delay, snapshot_timeout_cb, this);
}

void	Camera::UnTriggerSnapshot()
{
	Fl::remove_timeout(snapshot_timeout_cb, this);
}

double	Camera::FocusScore(Mat use_mat)
{
Mat image, src_gray, detected_edges, dst;

	use_mat.copyTo(image);
	crop_section(image, image, image.cols / 3, image.rows / 3, image.cols / 3, image.rows / 3);
	cvtColor(image, src_gray, COLOR_BGR2GRAY);
	blur(src_gray, detected_edges, Size(3, 3));
	Canny(detected_edges, detected_edges, 10, 10 * 3, 3);
	dst = Scalar::all(0);
	image.copyTo(dst, detected_edges);
	cvtColor(dst, dst, COLOR_BGR2GRAY);
	focus_score = 0.0;
	if((dst.rows > 0) && (dst.cols > 0))
	{
		focus_score = sum(dst)[0];
		focus_score /= (dst.rows * dst.cols);
	}
	return(focus_score);
}

int	Camera::RemoveImmediate(Immediate *ptr)
{
	int rr = 0;
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->immediate_list != NULL)
		{
			int idx = cam->FindImmediate(ptr);
			if((idx > -1) && (idx < cam->immediate_cnt))
			{
				Immediate *ptr = cam->immediate_list[idx];
				my_window->remove(ptr);
				cam->immediate_list[idx] = NULL;
				rr = 1;
			}
		}
	}
	return(rr);
}

int	Camera::FindLeft(void *sample, int layer, int xx, int yy, int ww, int hh)
{
int	loop;

	int val = -1000000;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop] != sample)
			{
				if(immediate_list[loop]->layer == layer)
				{
					int edge = immediate_list[loop]->x() + immediate_list[loop]->w();
					int y1 = immediate_list[loop]->y();
					int y2 = immediate_list[loop]->y() + immediate_list[loop]->h();
					if(((yy > y1) && (yy <= y2))
					|| ((yy + hh > y1) && (yy + hh <= y2))
					|| ((yy + hh > y2) && (yy < y2)))
					{
						if(edge < xx)
						{
							if(edge > val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop] != sample)
			{
				if(image_window[loop]->layer == layer)
				{
					int edge = image_window[loop]->x() + image_window[loop]->w();
					int y1 = image_window[loop]->y();
					int y2 = image_window[loop]->y() + image_window[loop]->h();
					if(((yy > y1) && (yy <= y2))
					|| ((yy + hh > y1) && (yy + hh <= y2))
					|| ((yy + hh > y2) && (yy < y2)))
					{
						if(edge < xx)
						{
							if(edge > val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < my_window->misc_copy_cnt;loop++)
	{
		MiscCopy *copy = my_window->misc_copy[loop];
		if(copy != NULL)
		{
			if(copy != sample)
			{
				int cx = copy->xx + image_sx;
				int cy = copy->yy + image_sy;
				int edge = cx + copy->ww;
				int y1 = cy;
				int y2 = cy + copy->hh;
				if(((yy > y1) && (yy <= y2))
				|| ((yy + hh > y1) && (yy + hh <= y2))
				|| ((yy + hh > y2) && (yy < y2)))
				{
					if(edge < xx)
					{
						if(edge > val)
						{
							val = edge;
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < my_window->guideline_cnt;loop++)
	{
		Guideline *guide = my_window->guideline[loop];
		if(guide != NULL)
		{
			if(guide != sample)
			{
				if(guide->type == VERTICAL_GUIDELINE)
				{
					int edge = guide->pos + image_sx;
					if(edge < xx)
					{
						if(edge > val)
						{
							val = edge;
						}
					}
				}
			}
		}
	}
	return(val);
}

int	Camera::FindRight(void *sample, int layer, int xx, int yy, int ww, int hh)
{
int	loop;

	int val = 1000000;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop] != sample)
			{
				if(immediate_list[loop]->layer == layer)
				{
					int edge = immediate_list[loop]->x();
					int y1 = immediate_list[loop]->y();
					int y2 = immediate_list[loop]->y() + immediate_list[loop]->h();
					if(((yy > y1) && (yy <= y2))
					|| ((yy + hh > y1) && (yy + hh <= y2))
					|| ((yy + hh > y2) && (yy < y2)))
					{
						if(edge > xx + ww)
						{
							if(edge < val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop] != sample)
			{
				if(image_window[loop]->layer == layer)
				{
					int edge = image_window[loop]->x();
					int y1 = image_window[loop]->y();
					int y2 = image_window[loop]->y() + image_window[loop]->h();
					if(((yy > y1) && (yy <= y2))
					|| ((yy + hh > y1) && (yy + hh <= y2))
					|| ((yy + hh > y2) && (yy < y2)))
					{
						if(edge > xx + ww)
						{
							if(edge < val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < my_window->misc_copy_cnt;loop++)
	{
		MiscCopy *copy = my_window->misc_copy[loop];
		if(copy != NULL)
		{
			if(copy != sample)
			{
				int cx = copy->xx + image_sx;
				int cy = copy->yy + image_sy;
				int edge = cx;
				int y1 = cy;
				int y2 = cy + copy->hh;
				if(((yy > y1) && (yy <= y2))
				|| ((yy + hh > y1) && (yy + hh <= y2))
				|| ((yy + hh > y2) && (yy < y2)))
				{
					if(edge > xx + ww)
					{
						if(edge < val)
						{
							val = edge;
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < my_window->guideline_cnt;loop++)
	{
		Guideline *guide = my_window->guideline[loop];
		if(guide != NULL)
		{
			if(guide != sample)
			{
				if(guide->type == VERTICAL_GUIDELINE)
				{
					int edge = guide->pos + image_sx;
					if(edge > xx + ww)
					{
						if(edge < val)
						{
							val = edge;
						}
					}
				}
			}
		}
	}
	return(val);
}

int	Camera::FindTop(void *sample, int layer, int xx, int yy, int ww, int hh)
{
int	loop;

	int val = -1000000;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop] != sample)
			{
				if(immediate_list[loop]->layer == layer)
				{
					int edge = immediate_list[loop]->y() + immediate_list[loop]->h();
					int x1 = immediate_list[loop]->x();
					int x2 = immediate_list[loop]->x() + immediate_list[loop]->w();
					if(((xx > x1) && (xx <= x2))
					|| ((xx + ww > x1) && (xx + ww <= x2))
					|| ((xx + ww > x2) && (xx < x2)))
					{
						if(edge < yy)
						{
							if(edge > val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop] != sample)
			{
				if(image_window[loop]->layer == layer)
				{
					int edge = image_window[loop]->y() + image_window[loop]->h();
					int x1 = image_window[loop]->x();
					int x2 = image_window[loop]->x() + image_window[loop]->w();
					if(((xx > x1) && (xx <= x2))
					|| ((xx + ww > x1) && (xx + ww <= x2))
					|| ((xx + ww > x2) && (xx < x2)))
					{
						if(edge < yy)
						{
							if(edge > val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < my_window->misc_copy_cnt;loop++)
	{
		MiscCopy *copy = my_window->misc_copy[loop];
		if(copy != NULL)
		{
			if(copy != sample)
			{
				int cx = copy->xx + image_sx;
				int cy = copy->yy + image_sy;
				int edge = cy + copy->hh;
				int x1 = cx;
				int x2 = cx + copy->ww;
				if(((xx > x1) && (xx <= x2))
				|| ((xx + ww > x1) && (xx + ww <= x2))
				|| ((xx + ww > x2) && (xx < x2)))
				{
					if(edge < yy)
					{
						if(edge > val)
						{
							val = edge;
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < my_window->guideline_cnt;loop++)
	{
		Guideline *guide = my_window->guideline[loop];
		if(guide != NULL)
		{
			if(guide != sample)
			{
				if(guide->type == HORIZONTAL_GUIDELINE)
				{
					int edge = guide->pos + image_sy;
					if(edge < yy)
					{
						if(edge > val)
						{
							val = edge;
						}
					}
				}
			}
		}
	}
	return(val);
}

int	Camera::FindBottom(void *sample, int layer, int xx, int yy, int ww, int hh)
{
int	loop;

	int val = 1000000;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop] != sample)
			{
				if(immediate_list[loop]->layer == layer)
				{
					int edge = immediate_list[loop]->y();
					int x1 = immediate_list[loop]->x();
					int x2 = immediate_list[loop]->x() + immediate_list[loop]->w();
					if(((xx > x1) && (xx <= x2))
					|| ((xx + ww > x1) && (xx + ww <= x2))
					|| ((xx + ww > x2) && (xx < x2)))
					{
						if(edge > yy + hh)
						{
							if(edge < val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop] != sample)
			{
				if(image_window[loop]->layer == layer)
				{
					int edge = image_window[loop]->y();
					int x1 = image_window[loop]->x();
					int x2 = image_window[loop]->x() + image_window[loop]->w();
					if(((xx > x1) && (xx <= x2))
					|| ((xx + ww > x1) && (xx + ww <= x2))
					|| ((xx + ww > x2) && (xx < x2)))
					{
						if(edge > yy + hh)
						{
							if(edge < val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < my_window->misc_copy_cnt;loop++)
	{
		MiscCopy *copy = my_window->misc_copy[loop];
		if(copy != NULL)
		{
			if(copy != sample)
			{
				int cx = copy->xx + image_sx;
				int cy = copy->yy + image_sy;
				int edge = cy;
				int x1 = cx;
				int x2 = cx + copy->ww;
				if(((xx > x1) && (xx <= x2))
				|| ((xx + ww > x1) && (xx + ww <= x2))
				|| ((xx + ww > x2) && (xx < x2)))
				{
					if(edge > yy + hh)
					{
						if(edge < val)
						{
							val = edge;
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < my_window->guideline_cnt;loop++)
	{
		Guideline *guide = my_window->guideline[loop];
		if(guide != NULL)
		{
			if(guide != sample)
			{
				if(guide->type == HORIZONTAL_GUIDELINE)
				{
					int edge = guide->pos + image_sy;
					if(edge > yy + hh)
					{
						if(edge < val)
						{
							val = edge;
						}
					}
				}
			}
		}
	}
	return(val);
}

int	Camera::FindImmediate(Immediate *ptr)
{
int loop;

	int done = -1;
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->immediate_list != NULL)
		{
			for(loop = 0;((loop < cam->immediate_cnt) && (done == -1));loop++)
			{
				if(cam->immediate_list[loop] == ptr)
				{
					done = loop;
				}
			}
		}
	}
	return(done);
}

void	Camera::ColorIt()
{
int	row, col;
int	loop;

	if(color_it_cnt > 0)
	{
		int cnt = 0;
		for(row = 0;row < mat.rows;row++)
		{
			for(col = 0;col < mat.cols;col++)
			{
				unsigned char *colour = mat.ptr(row, col);
				int r = colour[0];
				int g = colour[1];
				int b = colour[2];
				for(loop = 0;loop < color_it_cnt;loop++)
				{
					int diff_r = abs(r - color_it_r[loop]);
					int diff_g = abs(g - color_it_g[loop]);
					int diff_b = abs(b - color_it_b[loop]);
					if((diff_r < color_it_tolerance_r[loop])
					&& (diff_g < color_it_tolerance_g[loop])
					&& (diff_b < color_it_tolerance_b[loop]))
					{
						colour[0] = color_it_replace_r[loop];
						colour[1] = color_it_replace_g[loop];
						colour[2] = color_it_replace_b[loop];
						colour[3] = color_it_replace_a[loop];
						cnt++;
					}
				}
			}
		}
	}
}

void	Camera::ScrollTextList(char *str)
{
int	loop;
static int first = 0;

	if(strncmp(str, "[reset]", strlen("[reset]")) == 0)
	{
		list_position = 0;
		for(loop = 0;loop < list_length;loop++)
		{
			strcpy(text_list[loop], "");
		}
	}
	if(list_position > list_length)
	{
		list_position = list_length;
		for(loop = 0;loop < list_position;loop++)
		{
			strcpy(text_list[loop], text_list[loop + 1]);
		}
	}
	strcpy(text_list[list_position], str);
	if(list_position <= list_length)
	{
		list_position++;
	}
}

void	Camera::CairoClock(Mat& mat, int show_digits, int xx, int yy, int ww, int hh, int in_hour, int in_min, int in_sec)
{
void	my_cairo_push_matrix(cairo_t *cr);
void	my_cairo_pop_matrix(cairo_t *cr);
void	my_cairo_draw_text(cairo_t *cr, int in_xx, int in_yy, char *text, int sz);
int		loop;
char	buf[256];

	cairo_surface_t *surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
	if(surface != NULL)
	{
		if((xx == -1) || (yy == -1))
		{
			xx = 10;
			yy = 10;
		}
		if((ww == -1) || (hh == -1))
		{
			ww = height - 20;
			hh = height - 20;
		}
		cairo_t *cr = cairo_create(surface);
		cairo_set_antialias(cr, CAIRO_ANTIALIAS_BEST);
		my_cairo_set_source_rgba(cr, red, green, blue, alpha);
		cairo_rectangle(cr, 0, 0, mat.cols, mat.rows);
		cairo_fill(cr);

		my_cairo_set_source_rgba(cr, text_red, text_green, text_blue, text_alpha);
		cairo_save(cr);

		cairo_translate(cr, xx + (ww / 2), yy + (hh / 2));
		cairo_set_line_width(cr, 5);
		cairo_arc(cr, 0, 0, ww / 2.0, 0.0, 2 * M_PI);
		cairo_stroke(cr);
		cairo_set_line_width(cr, 3);
		cairo_arc(cr, 0, 0, (ww / 2.0) - 7, 0.0, 2 * M_PI);
		cairo_stroke(cr);
		cairo_set_line_width(cr, 2);
		for(loop = 0;loop < 60;loop++)
		{
			int ext = -7;
			cairo_set_line_width(cr, 2);
			if((loop % 5) == 0)
			{
				cairo_set_line_width(cr, 4);
				ext = -11;
			}
			double nn = (M_PI * 2.0) / 60.0;
			double n1 = (nn * (double)loop);
			double x1 = (cos(n1) * (ww / 2));
			double y1 = (sin(n1) * (ww / 2));
			double x2 = (cos(n1) * ((ww / 2) + ext));
			double y2 = (sin(n1) * ((ww / 2) + ext));
			cairo_move_to(cr, x1, y1);
			cairo_line_to(cr, x2, y2);
			cairo_stroke(cr);
		}
		int sec = 0;
		int min = 0;
		int hour = 0;
		int pm = 0;
		if((in_hour > -1) && (in_min > -1) && (in_sec > -1))
		{
			sec = in_sec;
			min = in_min;
			hour = in_hour;
		}
		else
		{
			time_t tt = time(0);
			struct tm *now = localtime(&tt);
			sec = now->tm_sec;
			min = now->tm_min;
			hour = now->tm_hour;
		}
		// seconds
		if((show_digits == 0) || (show_digits == 1))
		{
			double nn = (M_PI * 2.0) / 60.0;
			double n1 = (nn * (double)sec);
			my_cairo_push_matrix(cr);
			cairo_set_line_width(cr, 3);
			cairo_rotate(cr, n1);
			cairo_move_to(cr, 0, 0);
			cairo_line_to(cr, 0, -((hh / 2) * 0.95));
			cairo_stroke(cr);
			my_cairo_pop_matrix(cr);
		}
		// minutes
		{
			double nn = (M_PI * 2.0) / 60.0;
			double n1 = nn * (double)min;
			my_cairo_push_matrix(cr);
			cairo_set_line_width(cr, 5);
			cairo_rotate(cr, n1);
			cairo_move_to(cr, 0, 0);
			cairo_line_to(cr, 0, -((hh / 2) * 0.8));
			cairo_stroke(cr);
			cairo_set_line_width(cr, 1);
			my_cairo_pop_matrix(cr);
		}
		// hours
		{
			if(hour > 12)
			{
				hour -= 12;
				pm = 1;
			}
			int precise = (hour * 60) + min;
			double nn = (M_PI * 2.0) / (12.0 * 60.0);
			double n1 = nn * (double)precise;
			my_cairo_push_matrix(cr);
			cairo_set_line_width(cr, 9);
			cairo_rotate(cr, n1);
			cairo_move_to(cr, 0, 0);
			cairo_line_to(cr, 0, -((hh / 2) * 0.6));
			cairo_stroke(cr);
			cairo_set_line_width(cr, 1);
			my_cairo_pop_matrix(cr);
		}
		cairo_restore(cr);
		cairo_destroy(cr);
		cairo_surface_destroy(surface);
	}
}

void	Camera::RenderTextToMat(char *lit, Mat *mat)
{
char	buf[1024];
int		loop;

	cairo_surface_t *surface = cairo_image_surface_create_for_data(mat->ptr(), CAIRO_FORMAT_ARGB32, mat->cols, mat->rows, mat->step);
	if(surface != NULL)
	{
		cairo_t *context = cairo_create(surface);
		cairo_set_antialias(context, CAIRO_ANTIALIAS_BEST);
		my_cairo_set_source_rgba(context, red, green, blue, alpha);
		cairo_rectangle(context, 0, 0, mat->cols, mat->rows);
		cairo_fill(context);
		if(piping_text == 1)
		{
			list_length = (height - font_sz) / font_sz;
			int y_pos = 0;
			for(loop = 0;loop < list_position;loop++)
			{
				int extent_w = 0;
				int extent_h = 0;
				my_cairo_draw_text(my_window, this, context, 0, y_pos + font_sz, text_list[loop], font_name, 0, font_sz, -1, text_red, text_green, text_blue, text_alpha, 0, 0, 0, 0, extent_w, extent_h);
				y_pos += font_sz;
			}
		}
		else
		{
			int extent_w = 0;
			int extent_h = 0;
			my_cairo_draw_text(my_window, this, context, 0, font_sz, lit, font_name, 0, font_sz, -1, text_red, text_green, text_blue, text_alpha, 0, 0, 0, 0, extent_w, extent_h);
		}
		cairo_destroy(context);
		cairo_surface_destroy(surface);
	}
}

void	MyWin::StreamToNDI(Camera *cam, int which)
{
int	loop;

	if(NDILib != NULL)
	{
		if(((time(0) - ndi_initialized) > 5) && (ndi_initialized > 0))
		{
			SetErrorMessage("NDI transmit timed out");
		}
		if(ndi_send == NULL)
		{
			pthread_mutex_lock(&ndi_send_mutex);
			NDIlib_send_create_t NDI_send_create_desc;
			if(strlen(ndi_stream_name) > 0)
			{
				NDI_send_create_desc.p_ndi_name = ndi_stream_name;
			}
			else
			{
				NDI_send_create_desc.p_ndi_name = "CowCam NDI";
			}
			ndi_send = NDILib->NDIlib_send_create(&NDI_send_create_desc);
			ndi_video_frame.xres = output_width;
			ndi_video_frame.yres = output_height;
			if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_BGRX)
			{
				ndi_video_frame.FourCC = NDIlib_FourCC_type_BGRX;
			}
			else if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_RGBX)
			{
				ndi_video_frame.FourCC = NDIlib_FourCC_type_RGBX;
			}
			else if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_I420)
			{
				ndi_video_frame.FourCC = NDIlib_FourCC_type_I420;
			}
			else if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_UYVA)
			{
				ndi_video_frame.FourCC = NDIlib_FourCC_type_UYVA;
			}
			else if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_UYVY)
			{
				ndi_video_frame.FourCC = NDIlib_FourCC_type_UYVY;
			}
			ndi_audio_frame.no_samples = pulse_mixer->size / 2;
			ndi_audio_frame.no_channels = pulse_mixer->channels;
			ndi_audio_frame.sample_rate = audio_sample_rate;
			ndi_initialized = time(0);
			pthread_mutex_unlock(&ndi_send_mutex);
		}
		if(ndi_send != NULL)
		{
			pthread_mutex_lock(&ndi_send_mutex);
			if((which == SEND_NDI_AUDIO) && (pulse_mixer != NULL))
			{
				ndi_audio_frame.p_data = pulse_mixer->buffer;
				NDILib->NDIlib_util_send_send_audio_interleaved_16s(ndi_send, &ndi_audio_frame);
			}
			else if(cam != NULL)
			{
				void *result = NULL;
				Mat local_mat;
				if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_BGRX)
				{
					Mat local_mat;
					cvtColor(cam->mat, local_mat, COLOR_BGRA2RGBA);
					ndi_video_frame.p_data = local_mat.ptr();
				}
				else if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_RGBX)
				{
					ndi_video_frame.p_data = cam->mat.ptr();
				}
				else if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_I420)
				{
					cvtColor(cam->mat, local_mat, COLOR_RGB2YUV_I420);
					ndi_video_frame.p_data = local_mat.ptr();
				}
				else if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_UYVA)
				{
					result = BGRA_UYVA(cam->mat, output_width, output_height);
					if(result != NULL)
					{
						ndi_video_frame.p_data = (unsigned char *)result;
					}
				}
				else if(ndi_send_video_format == NDI_SEND_VIDEO_FORMAT_UYVY)
				{
					Mat out_mat;
					BGRA_UYVY(cam->mat, out_mat, output_width, output_height);
					ndi_video_frame.p_data = (unsigned char *)out_mat.ptr();
				}
				NDILib->NDIlib_send_send_video_v2(ndi_send, &ndi_video_frame);
				ndi_initialized = time(0);
				if(result != NULL)
				{
					free(result);
				}
			}
			pthread_mutex_unlock(&ndi_send_mutex);
		}
	}
}

int	Camera::Record()
{
int	loop;
char	buf[4096];
struct tm *tm;
Mat	use_mat;
static Mat local_mat;

	int record_error = 0;
	if((record == 1) || (last == 1))
	{
		if(capture_interval > 0.0)
		{
			if(newly_captured == 1)
			{
				char filename[256];
				time_t t_num = time(0);
				tm = localtime((const time_t *)&t_num);
				long int lts = local_timestamp();
				sprintf(filename, "frame_%04d_%02d_%02d_%02d_%02d_%02d_%ld.png", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, lts);
				Mat out;
				cvtColor(mat, out, COLOR_RGB2BGR);
				imwrite(filename, out);
				newly_captured = 0;
			}
		}
		else
		{
			int ww = 0;
			int hh = 0;
			int flags = O_WRONLY | O_CREAT | O_TRUNC;
			if(ever_opened == 1)
			{
				flags = O_WRONLY | O_CREAT | O_APPEND;
			}
			if(my_window->muxing == 1)
			{
				if(my_window->single_stream == 0)
				{
					int use = id;
					if(last == 0)
					{
						if(my_window->my_muxer[use] == NULL)
						{
							my_window->SetCodec();
							int	num_mics = my_window->CountActiveMics();
							int use_audio = my_window->audio;

							double ifps = (current_fps * my_window->speed_factor);
							if(ifps < 24) ifps = 24;
							else if(ifps > 30) ifps = 30;
							if(num_mics <= 0)
							{
								use_audio = 2;
							}
							if(my_window->streaming == STREAMING_NET)
							{
								ifps = 30;
							}
							time_t t_num = time(0);
							tm = localtime((const time_t *)&t_num);
							sprintf(buf, "muxed_video_%02d_%04d_%02d_%02d_%02d_%02d_%02d.%s", id, tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, my_window->use_extension);

							if(my_window->streaming == STREAMING_NDI)
							{
								my_window->ndi_streaming = 1;
								my_window->ndi_initialized = 0;
							}
							else if(my_window->streaming == STREAMING_NET)
							{
								my_window->video_count++;
								my_window->my_muxer[use] = new Muxer(my_window, NULL, 0);
								int init_mux_err = my_window->my_muxer[use]->InitMux(
									use_audio,
									(AVCodecID)AV_CODEC_ID_H264,
									(AVCodecID)AV_CODEC_ID_AAC,
									NULL,
									NULL,
									buf,
									my_window->stream_url,
									my_window->desktop_monitor,
									my_window->pulse_mixer,
									-1,
									my_window->output_width,
									my_window->output_height,
									ifps,
									(double)my_window->streaming_audio_quality,
									my_window->audio_channels,
									-1,
									NULL,
									NULL);
								if(init_mux_err != 0)
								{
									pthread_mutex_lock(&my_window->muxer_mutex);
									delete my_window->my_muxer[use];
									my_window->my_muxer[use] = NULL;
									my_window->muxer_cnt = 0;
									pthread_mutex_unlock(&my_window->muxer_mutex);
									record_error = 1;
									record = 0;
									my_window->SetErrorMessage("Encoding Error: Not recording.");
								}
								else
								{
									my_window->AddLastMuxed(buf);
									my_window->muxer_cnt++;
								}
							}
							else if(my_window->streaming == STREAMING_FILE)
							{
								my_window->video_count++;
								my_window->my_muxer[use] = new Muxer(my_window, NULL, 0);
								int init_mux_err = my_window->my_muxer[use]->InitMux(
									use_audio,
									my_window->use_video_codec,
									my_window->use_audio_codec,
									NULL,
									NULL,
									buf,
									NULL,
									my_window->desktop_monitor,
									my_window->pulse_mixer,
									-1,
									my_window->output_width,
									my_window->output_height,
									ifps,
									(double)my_window->audio_sample_rate,
									my_window->audio_channels,
									-1,
									NULL,
									NULL);
								if(init_mux_err != 0)
								{
									pthread_mutex_lock(&my_window->muxer_mutex);
									delete my_window->my_muxer[use];
									my_window->my_muxer[use] = NULL;
									pthread_mutex_unlock(&my_window->muxer_mutex);
									record_error = 1;
									record = 0;
									my_window->SetErrorMessage("Encoding Error: Not recording.");
								}
								else
								{
									my_window->AddLastMuxed(buf);
									my_window->muxer_cnt++;
								}
							}
						}
						else
						{
							if(my_window->my_muxer[use]->paused == 1)
							{
								my_window->my_muxer[use]->Resume();
							}
						}
					}
					else
					{
						if(my_window->my_muxer[use] != NULL)
						{
							my_window->my_muxer[use]->Pause();
							my_window->my_muxer[use]->Stop();
							my_window->my_muxer[use]->FinishMux();
							pthread_mutex_lock(&my_window->muxer_mutex);
							delete my_window->my_muxer[use];
							my_window->my_muxer[use] = NULL;
							pthread_mutex_unlock(&my_window->muxer_mutex);
						}
					}
				}
				else
				{
					my_window->muxer_cnt = 0;
					for(loop = 0;loop < my_window->output_path_cnt;loop++)
					{
						if(my_window->output_active[loop] == 1)
						{
							if(last == 0)
							{
								if(my_window->my_muxer[loop] == NULL)
								{
									my_window->SetCodec();
									int	num_mics = my_window->CountActiveMics();
									int use_audio = my_window->audio;

									double ifps = (current_fps * my_window->speed_factor);
									if(ifps < 24) ifps = 24;
									else if(ifps > 30) ifps = 30;
									if(num_mics <= 0)
									{
										use_audio = 2;
									}
									if(my_window->streaming == STREAMING_NET)
									{
										ifps = 30;
									}
									time_t t_num = time(0);
									tm = localtime((const time_t *)&t_num);
									strcpy(buf, "");
									if(my_window->single_stream == 0)
									{
										sprintf(buf, "muxed_video_%02d_%04d_%02d_%02d_%02d_%02d_%02d.%s", id, tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, my_window->use_extension);
									}
									else
									{
										my_window->SetUseOutputPath(loop, buf);
									}
									if(my_window->streaming == STREAMING_NDI)
									{
										my_window->ndi_streaming = 1;
										my_window->ndi_initialized = 0;
									}
									else if(my_window->streaming == STREAMING_NET)
									{
										my_window->video_count++;
										my_window->my_muxer[loop] = new Muxer(my_window, NULL, 0);
										int init_mux_err = my_window->my_muxer[loop]->InitMux(
											use_audio,
											(AVCodecID)AV_CODEC_ID_H264,
											(AVCodecID)AV_CODEC_ID_AAC,
											NULL,
											NULL,
											buf,
											my_window->stream_url,
											my_window->desktop_monitor,
											my_window->pulse_mixer,
											-1,
											my_window->output_width,
											my_window->output_height,
											ifps,
											(double)my_window->streaming_audio_quality,
											my_window->audio_channels,
											-1,
											NULL,
											NULL);
										if(init_mux_err != 0)
										{
											pthread_mutex_lock(&my_window->muxer_mutex);
											delete my_window->my_muxer[loop];
											my_window->my_muxer[loop] = NULL;
											my_window->muxer_cnt = 0;
											pthread_mutex_unlock(&my_window->muxer_mutex);
											record_error = 1;
											record = 0;
											my_window->SetErrorMessage("Encoding Error: Not recording.");
										}
										else
										{
											my_window->AddLastMuxed(buf);
											my_window->muxer_cnt++;
										}
									}
									else if(my_window->streaming == STREAMING_FILE)
									{
										my_window->video_count++;
										my_window->my_muxer[loop] = new Muxer(my_window, NULL, 0);
										int init_mux_err = my_window->my_muxer[loop]->InitMux(
											use_audio,
											my_window->use_video_codec,
											my_window->use_audio_codec,
											NULL,
											NULL,
											buf,
											NULL,
											my_window->desktop_monitor,
											my_window->pulse_mixer,
											-1,
											my_window->output_width,
											my_window->output_height,
											ifps,
											(double)my_window->audio_sample_rate,
											my_window->audio_channels,
											-1,
											NULL,
											NULL);
										if(init_mux_err != 0)
										{
											pthread_mutex_lock(&my_window->muxer_mutex);
											delete my_window->my_muxer[loop];
											my_window->my_muxer[loop] = NULL;
											pthread_mutex_unlock(&my_window->muxer_mutex);
											record_error = 1;
											record = 0;
											my_window->SetErrorMessage("Encoding Error: Not recording.");
										}
										else
										{
											my_window->AddLastMuxed(buf);
											my_window->muxer_cnt++;
										}
									}
								}
								else
								{
									my_window->muxer_cnt++;
									if(my_window->my_muxer[loop]->paused == 1)
									{
										my_window->my_muxer[loop]->Resume();
									}
								}
							}
							else
							{
								if(my_window->my_muxer[loop] != NULL)
								{
									my_window->my_muxer[loop]->Pause();
									my_window->my_muxer[loop]->Stop();
									my_window->my_muxer[loop]->FinishMux();
									pthread_mutex_lock(&my_window->muxer_mutex);
									delete my_window->my_muxer[loop];
									my_window->my_muxer[loop] = NULL;
									pthread_mutex_unlock(&my_window->muxer_mutex);
								}
							}
						}
					}
				}
			}
			else
			{
				int depth = 4;
				unsigned char *ptr = NULL;
				if((my_window->output_width == mat.cols) && (my_window->output_height == mat.rows))
				{
					Mat out;
					cvtColor(mat, out, COLOR_RGBA2BGRA);
					ptr = (unsigned char *)out.ptr();
					ww = width;
					hh = height;
					depth = out.channels();
				}
				else
				{
					Mat out;
					cv::resize(mat, local_mat, cv::Size(my_window->output_width, my_window->output_height));
					cvtColor(local_mat, out, COLOR_RGBA2BGRA);
					ptr = (unsigned char *)out.ptr();
					ww = my_window->output_width;
					hh = my_window->output_height;
					depth = out.channels();
				}
				int opened = 0;
				if(my_window->stream_only == 0)
				{
					start_ts = local_ts;
					if(fd == -1)
					{
						paused_accumulation_ts = 0;
						paused_start_ts = 0;
						resuming = 0;

						if(my_window->single_stream == 0)
						{
							sprintf(buf, "main_%02d.bin", id);
						}
						else
						{
							sprintf(buf, "single_stream.bin");
						}
						fd = open(buf, flags, 0644);
						int depth = 4;
						if(ever_opened == 0)
						{
							write(fd, &ww, sizeof(int));
							write(fd, &hh, sizeof(int));
							write(fd, &depth, sizeof(int));
							int ifps = (int)fps;
							write(fd, &ifps, sizeof(int));
							ever_opened = 1;
						}
						opened = 1;
						int sz = ww * hh * depth;
						if(save_fifo != NULL)
						{
							delete save_fifo;
							save_fifo = NULL;
						}
						save_fifo = new SaveFIFO(my_window, fd, sz, ww, hh, start_ts);
						if(my_window->single_stream == 1)
						{
							my_window->SetAllCamerasToStream(this);
						}
					}
				}
				int sz = ww * hh * depth;
				if(fd > -1)
				{
					if(save_fifo != NULL)
					{
						if(last == 0)
						{
							if(resuming == 1)
							{
								resuming = 0;
								paused_accumulation_ts += ((local_timestamp() - paused_start_ts));
							}
						}
						save_fifo->Save(ptr, local_ts, paused_accumulation_ts);
						if(my_window->muxing == 0)
						{
							my_window->recorded_frames++;
						}
					}
				}
				if(last == 1)
				{
					paused_start_ts = local_timestamp();
					resuming = 1;
				}
				total_frames++;
			}
			last = 0;
		}
	}
	return(record_error);
}

void	Camera::V4L_Motion(int direction)
{
struct v4l2_control ctrl;

	if(v4l_capable == 1)
	{
		int fd = open(path, O_WRONLY);
		if(fd > -1)
		{
			if((direction & V4L_RIGHT) == V4L_RIGHT)
			{
				ctrl.id = V4L2_CID_PAN_SPEED;
				ctrl.value = 1;
				xioctl(fd, VIDIOC_S_CTRL, &ctrl);
			}
			if((direction & V4L_LEFT) == V4L_LEFT)
			{
				ctrl.id = V4L2_CID_PAN_SPEED;
				ctrl.value = -1;
				xioctl(fd, VIDIOC_S_CTRL, &ctrl);
			}
			if((direction & V4L_UP) == V4L_UP)
			{
				ctrl.id = V4L2_CID_TILT_SPEED;
				ctrl.value = 1;
				xioctl(fd, VIDIOC_S_CTRL, &ctrl);
			}
			if((direction & V4L_DOWN) == V4L_DOWN)
			{
				ctrl.id = V4L2_CID_TILT_SPEED;
				ctrl.value = -1;
				xioctl(fd, VIDIOC_S_CTRL, &ctrl);
			}
			if((direction & V4L_ZOOM_IN) == V4L_ZOOM_IN)
			{
				ctrl.id = V4L2_CID_ZOOM_CONTINUOUS;
				ctrl.value = 1;
				xioctl(fd, VIDIOC_S_CTRL, &ctrl);
			}
			if((direction & V4L_ZOOM_OUT) == V4L_ZOOM_OUT)
			{
				ctrl.id = V4L2_CID_ZOOM_CONTINUOUS;
				ctrl.value = -1;
				xioctl(fd, VIDIOC_S_CTRL, &ctrl);
			}
			if(direction == V4L_STOP)
			{
				ctrl.id = V4L2_CID_PAN_SPEED;
				ctrl.value = 0;
				xioctl(fd, VIDIOC_S_CTRL, &ctrl);
				ctrl.id = V4L2_CID_TILT_SPEED;
				ctrl.value = 0;
				xioctl(fd, VIDIOC_S_CTRL, &ctrl);
				ctrl.id = V4L2_CID_ZOOM_CONTINUOUS;
				ctrl.value = 0;
				xioctl(fd, VIDIOC_S_CTRL, &ctrl);
			}
			close(fd);
		}
		else
		{
			fprintf(stderr, "Error: Camera at [%s] failed to open for V4L commands.\n", path);
		}
	}
}

int	Camera::V4L_Test()
{
	int rr = 0;
	int nn = cap->get(CAP_PROP_FOCUS);
	if(nn > -1)
	{
		rr = 1;
	}
	return(rr);
}

int	Camera::V4L_Test2()
{
struct v4l2_capability video_cap;

	int rr = 0;
	int fd = -1;
	if((fd = open(path, O_RDONLY)) != -1)
	{
		if(ioctl(fd, VIDIOC_QUERYCAP, &video_cap) != -1)
		{
			rr = 1;
		}
		close(fd);
	}
	return(rr);
}

void	v4l_repeat_command(void *v)
{
	Camera *cam = (Camera *)v;
	if(cam->v4l_capable == 1)
	{
		if(cam->v4l_pending_command != 0)
		{
			cam->V4L_Command(cam->v4l_pending_command);
			Fl::repeat_timeout(0.01, v4l_repeat_command, cam);
		}
	}
}

void	Camera::V4L_RepeatCommand(int command)
{
	if(v4l_capable == 1)
	{
		v4l_pending_command = command;
		Fl::add_timeout(0.01, v4l_repeat_command, this);
	}
}

void	Camera::V4L_Command(int command)
{
//			 brightness 0x00980900 (int)	: min=1 max=9 step=1 default=5 value=5
//			   contrast 0x00980901 (int)	: min=0 max=4 step=1 default=2 value=2
//			 saturation 0x00980902 (int)	: min=0 max=10 step=1 default=5 value=5
// white_balance_temperature_auto 0x0098090c (bool)   : default=1 value=1
//	   power_line_frequency 0x00980918 (menu)   : min=0 max=2 default=0 value=0
//				0: Disabled
//				1: 50 Hz
//				2: 60 Hz
//	  white_balance_temperature 0x0098091a (int)	: min=2800 max=10000 step=1 default=2800 value=4828 flags=inactive
//			  sharpness 0x0098091b (int)	: min=0 max=3 step=1 default=2 value=2
//	 backlight_compensation 0x0098091c (int)	: min=0 max=2 step=1 default=0 value=0
//		   pan_absolute 0x009a0908 (int)	: min=-471420 max=471420 step=1620 default=0 value=236520
//		  tilt_absolute 0x009a0909 (int)	: min=-103680 max=311040 step=1620 default=0 value=-103680
//		 focus_absolute 0x009a090a (int)	: min=0 max=300 step=1 default=1 value=33 flags=inactive
//			 focus_auto 0x009a090c (bool)   : default=1 value=1
//		  zoom_absolute 0x009a090d (int)	: min=0 max=909 step=1 default=0 value=909
//		zoom_continuous 0x009a090f (int)	: min=0 max=1 step=1 default=1 value=0
//			  pan_speed 0x009a0920 (int)	: min=-1 max=1 step=1 default=1 value=0
//			 tilt_speed 0x009a0921 (int)	: min=-1 max=1 step=1 default=1 value=0

	if(v4l_capable == 1)
	{
		if(command == V4L_RIGHT)
		{
			V4L_Motion(V4L_RIGHT);
		}
		else if(command == V4L_LEFT)
		{
			V4L_Motion(V4L_LEFT);
		}
		else if(command == V4L_DOWN)
		{
			V4L_Motion(V4L_DOWN);
		}
		else if(command == V4L_UP)
		{
			V4L_Motion(V4L_UP);
		}
		else if(command == V4L_ZOOM_OUT)
		{
			int nn = cap->get(CAP_PROP_ZOOM);
			cap->set(CAP_PROP_ZOOM, nn - 1);
		}
		else if(command == V4L_ZOOM_IN)
		{
			int nn = cap->get(CAP_PROP_ZOOM);
			cap->set(CAP_PROP_ZOOM, nn + 1);
		}
		else if(command == V4L_FOCUS_FAR)
		{
			cap->set(CAP_PROP_AUTOFOCUS, 0);
			int nn = cap->get(CAP_PROP_FOCUS);
			cap->set(CAP_PROP_FOCUS, nn - 1);
		}
		else if(command == V4L_FOCUS_NEAR)
		{
			cap->set(CAP_PROP_AUTOFOCUS, 0);
			int nn = cap->get(CAP_PROP_FOCUS);
			cap->set(CAP_PROP_FOCUS, nn + 1);
		}
		else if(command == V4L_AUTOFOCUS)
		{
			int nn = cap->get(CAP_PROP_AUTOFOCUS);
			if(nn == 0)
			{
				cap->set(CAP_PROP_AUTOFOCUS, 1);
			}
			else
			{
				cap->set(CAP_PROP_AUTOFOCUS, 0);
			}
		}
		else if(command == V4L_STOP)
		{
			V4L_Motion(V4L_STOP);
		}
	}
}

void	Camera::ZoomBoxDisplay()
{
	cv::Rect roi;
	roi.x = zoom_box_x - image_sx;
	roi.y = zoom_box_y - image_sy;

	roi.width = zoom_box_w;
	roi.height = zoom_box_h;
	Mat crop = mat(roi);

	double amt1 = (double)mat.cols / (double)zoom_box_w;
	double amt2 = (double)mat.rows / (double)zoom_box_h;
	double amt = amt1;
	if(amt2 < amt1) amt = amt2;
	Size sz(display_width, display_height);
	cv::resize(crop, crop, sz, 0, 0, INTER_AREA);
	mat = crop.clone();
}

void	Camera::VideoEffects()
{
	if(!mat.empty())
	{
		if(saturation != 1.0)
		{
			mat = change_saturation(mat, saturation);
		}
		if(hue != 1.0)
		{
			mat = change_hue(mat, hue);
		}
		if(intensity != 1.0)
		{
			mat = change_intensity(mat, intensity);
		}
		if(contrast != 0.5)
		{
			contrast_mat(mat, contrast);
		}
		if((red_intensity != 1.0)
		|| (green_intensity != 1.0)
		|| (blue_intensity != 1.0)
		|| (alpha_intensity != 1.0))
		{
			ColorIntensity(mat, red_intensity, green_intensity, blue_intensity, alpha_intensity);
		}
		if(brightness != 0.5)
		{
			brightness_mat(mat, brightness);
		}
		if((flip_vertical == 1) && (flip_horizontal == 0))
		{
			flip(mat, mat, 0);
		}
		else if((flip_vertical == 0) && (flip_horizontal == 1))
		{
			flip(mat, mat, 1);
		}
		else if((flip_vertical == 1) && (flip_horizontal == 1))
		{
			flip(mat, mat, -1);
		}
		if(zoom_box_display == 1)
		{
			ZoomBoxDisplay();
		}
		if(zoom > 1.0)
		{
			Mat dst;
			
			int orig_w = mat.cols;
			int orig_h = mat.rows;
			int sw = (int)(zoom * (double)mat.cols);
			int sh = (int)(zoom * (double)mat.rows);
			Size sz(sw, sh);
			cv::resize(mat, dst, sz, 0, 0, INTER_AREA);
			int n_width = dst.cols;
			int n_height = dst.rows;

			int sx = ((n_width / 2) - (orig_w / 2)) + my_window->offset_x + my_window->save_offset_x;
			if(sx < 0) sx = 0;
			if(sx > sw - orig_w) sx = sw - orig_w;
			int sy = ((n_height / 2) - (orig_h / 2)) + my_window->offset_y + my_window->save_offset_y;
			if(sy < 0) sy = 0;
			if(sy > sh - orig_h) sy = sh - orig_h;

			Rect crop_region(sx, sy, orig_w, orig_h);
			Mat mat3 = dst(crop_region);
			mat = mat3.clone();
		}
	}
	if(my_window->single_stream == 1)
	{
		if(my_window->last_cam != NULL)
		{
			if((my_window->last_cam->mat.cols == mat.cols)
			&& (my_window->last_cam->mat.rows == mat.rows))
			{
				double interval = 0.1;
				if(my_window->transition == TRANSITION_BLEND)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					addWeighted(mat, my_window->transition_cnt, new_mat, 1.0 - my_window->transition_cnt, 0.0, mat);
				}
				else if(my_window->transition == TRANSITION_FADE_TO_BLACK)
				{
					Mat new_mat;
					cv::Mat local_mat(mat.rows, mat.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					new_mat = my_window->last_cam->mat.clone();
					double use = my_window->transition_cnt;
					addWeighted(new_mat, 1.0 - use, local_mat, use, 0.0, mat);
					interval = 0.025;
				}
				else if(my_window->transition == TRANSITION_FADE_FROM_BLACK)
				{
					Mat new_mat;
					cv::Mat local_mat(mat.rows, mat.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					new_mat = my_window->last_cam->mat.clone();
					double use = my_window->transition_cnt;
					addWeighted(local_mat, 1.0 - use, mat, use, 0.0, mat);
					interval = 0.025;
				}
				else if(my_window->transition == TRANSITION_L2R_WIPE)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					int the_rest = new_mat.cols - (int)((double)new_mat.cols * my_window->transition_cnt);
					int start_x = new_mat.cols - the_rest;
					Rect region(start_x, 0, the_rest, new_mat.rows);
					Mat cropped = new_mat(region);
					int sx = start_x;
					int sy = 0;
					int ex = mat.cols;
					int ey = mat.rows;
					if(sx < mat.cols)
					{
						cropped.copyTo(mat.rowRange(sy, ey).colRange(sx, ex));
					}
					interval = 0.2;
				}
				else if(my_window->transition == TRANSITION_R2L_WIPE)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					int the_rest = new_mat.cols - (int)((double)new_mat.cols * my_window->transition_cnt);
					int start_x = new_mat.cols - the_rest;
					Rect region(0, 0, the_rest, new_mat.rows);
					Mat cropped = new_mat(region);
					int sx = 0;
					int sy = 0;
					int ex = the_rest;
					int ey = mat.rows;
					if(ex > 0)
					{
						cropped.copyTo(mat.rowRange(sy, ey).colRange(sx, ex));
					}
					interval = 0.2;
				}
				else if(my_window->transition == TRANSITION_T2B_WIPE)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					int the_rest = new_mat.rows - (int)((double)new_mat.rows * my_window->transition_cnt);
					int start_y = new_mat.rows - the_rest;
					Rect region(0, start_y, new_mat.cols, the_rest);
					Mat cropped = new_mat(region);
					int sx = 0;
					int sy = start_y;
					int ex = mat.cols;
					int ey = mat.rows;
					if(sy < mat.rows)
					{
						cropped.copyTo(mat.rowRange(sy, ey).colRange(sx, ex));
					}
					interval = 0.2;
				}
				else if(my_window->transition == TRANSITION_B2T_WIPE)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					int the_rest = new_mat.rows - (int)((double)new_mat.rows * my_window->transition_cnt);
					int start_y = new_mat.rows - the_rest;
					Rect region(0, 0, new_mat.cols, the_rest);
					Mat cropped = new_mat(region);
					int sx = 0;
					int sy = 0;
					int ex = mat.cols;
					int ey = the_rest;
					if(ey > 0)
					{
						cropped.copyTo(mat.rowRange(sy, ey).colRange(sx, ex));
					}
					interval = 0.2;
				}
				else if(my_window->transition == TRANSITION_PLUGIN)
				{
					if(void_transition_plugin != NULL)
					{
						void (*plug_transition)(int, int, int, unsigned char *, unsigned char *, double);
						plug_transition = (void (*)(int, int, int, unsigned char *, unsigned char *, double))void_transition_plugin;
						plug_transition(mat.cols, mat.rows, mat.channels(), my_window->last_cam->mat.ptr(), mat.ptr(), my_window->transition_cnt);
						interval = 0.025;
					}
				}
				my_window->transition_cnt += interval;
				if(my_window->transition_cnt > 1.0)
				{
					if(my_window->transition == TRANSITION_FADE_TO_BLACK)
					{
						my_window->transition = TRANSITION_FADE_FROM_BLACK;
					}
					else
					{
						my_window->last_cam = NULL;
					}
					my_window->transition_cnt = 0.0;
				}
			}
		}
	}
}

void	Camera::TimestampFrame()
{
int		interpret_output_path(MyWin *win, char *in, char *out, int *clock_type);

	if(cairo_context != NULL)
	{
		char buf[4096];
		int clock_type = 0;
		interpret_output_path(my_window, my_window->timestamp_format, buf, &clock_type);

		int rr = my_window->timestamp_rr;
		int gg = my_window->timestamp_gg;
		int bb = my_window->timestamp_bb;
		int aa = my_window->timestamp_aa;
		int back_r = my_window->timestamp_background_rr;
		int back_g = my_window->timestamp_background_gg;
		int back_b = my_window->timestamp_background_bb;
		int back_a = my_window->timestamp_background_aa;
		int sz = my_window->timestamp_font_sz;
		int xx = my_window->timestamp_position_x;
		int yy = my_window->timestamp_position_y;
		int use_y = yy;
		if(strlen(buf) > 0)
		{
			cairo_font_slant_t slant = CAIRO_FONT_SLANT_NORMAL;
			cairo_font_weight_t bold = CAIRO_FONT_WEIGHT_NORMAL;
			cairo_select_font_face(cairo_context, "Sans", slant, bold);
			cairo_set_font_size(cairo_context, sz);

			cairo_text_extents_t extents;
			cairo_text_extents(cairo_context, buf, &extents);
			int sz_x = extents.x_advance;
			int sz_y = extents.height;
			use_y = sz_y;

			if(back_a > 0)
			{
				my_cairo_set_source_rgba(cairo_context, back_r, back_g, back_b, back_a);
				cairo_rectangle(cairo_context, xx, yy - sz_y, sz_x, sz_y + (sz_y / 4));
				cairo_fill(cairo_context);
			}
			int extent_w = 0;
			int extent_h = 0;
			my_cairo_draw_text(my_window, this, cairo_context, xx, yy, buf, "Sans", 0, sz, -1, rr, gg, bb, aa, 0, 0, 0, 255, extent_w, extent_h);
		}
		if((clock_type & CLOCK_TYPE_TOD) == CLOCK_TYPE_TOD)
		{
			draw_clock(this, -1, -1, -1, xx, use_y + 15, sz * 4, sz * 4, rr, gg, bb, aa, back_r, back_g, back_b, back_a);
			xx += (sz * 4);
		}
		if((clock_type & CLOCK_TYPE_ELAPSED) == CLOCK_TYPE_ELAPSED)
		{
			int total_seconds = running_time / 1000;
			int hours = total_seconds / 3600;
			int minutes = total_seconds / 60;
			int seconds = total_seconds % 60;
			draw_clock(this, hours, minutes, seconds, xx, use_y + 15, sz * 4, sz * 4, rr, gg, bb, aa, back_r, back_g, back_b, back_a);
			xx += (sz * 4);
		}
	}
}

void	Camera::SnapshotFrame()
{
	char buf[4096];
	interpret_output_path(my_window, snapshot_filename_format, buf, NULL);
	if(strlen(buf) > 0)
	{
		Mat out;
		cvtColor(mat, out, COLOR_RGB2BGR);
		if(snapshot_scale > 0.0)
		{
			cv::resize(out, out, cv::Size(), snapshot_scale, snapshot_scale);
			imwrite(buf, out);
		}
	}
}

void	Camera::BlurDetectedRegions()
{
int	loop;
static int last_x = -1;
static int last_y = -1;
static int last_w = -1;
static int last_h = -1;
static int last = 0;

	for(loop = 0;loop < detected_object_cnt;loop++)
	{
		int xx = detected_object[loop].x;
		int yy = detected_object[loop].y;
		int ww = detected_object[loop].w;
		int hh = detected_object[loop].h;
		last = 300;
	}
	if(last > 0)
	{
		blur_it(this, 73, last_x, last_y, last_w, last_h);
		last--;
	}
}

void	Camera::ColorIntensity(Mat frame, double red, double green, double blue, double alpha)
{
vector<Mat>	layer;
int		i, j, n;

	unsigned char *ptr = frame.ptr();
	int channels = frame.channels();
	if(ptr != NULL)
	{
		for(j = 0; j < frame.rows; j++)
		{
			for(i = 0; i < frame.cols; i++)
			{
				for(n = 0;n < channels;n++)
				{
					int val = (int)*ptr;
					if(n == 0)
					{
						val = (int)((double)val * red);
					}
					else if(n == 1)
					{
						val = (int)((double)val * green);
					}
					else if(n == 2)
					{
						val = (int)((double)val * blue);
					}
					else if(n == 3)
					{
						val = (int)((double)val * alpha);
					}
					if(val < 0) val = 0;
					if(val > 255) val = 255;
					*ptr = (unsigned char)val;
					ptr++;
				}
			}
		}
	}
}

void	Camera::ShowImmediateList()
{
int	loop;
int	outer;

	for(outer = 0;outer < 8;outer++)
	{
		if(layer_state[outer] == 1)
		{
			int moving_element = 0;
			int someone_is_dragging = 0;
			DrawImageWindowsBefore(outer, 0, mat, moving_element, someone_is_dragging);
			if(immediate_list != NULL)
			{
				for(loop = 0;loop < immediate_cnt;loop++)
				{
					if(immediate_list[loop] != NULL)
					{
						if(immediate_list[loop]->layer == outer)
						{
							immediate_list[loop]->show();
							immediate_list[loop]->redraw();
							immediate_list[loop]->Draw();
						}
					}
				}
			}
		}
	}
	if(my_window->DisplayedCamera() != this)
	{
		HideImmediateList();
	}
}

void	Camera::HideImmediateList()
{
int	loop;

	if(immediate_list != NULL)
	{
		for(loop = 0;loop < immediate_cnt;loop++)
		{
			if(immediate_list[loop] != NULL)
			{
				immediate_list[loop]->hide();
			}
		}
	}
}

int	Camera::CheckRecurseChildren(Camera *in, Camera *find)
{
int	loop;

	int rr = 0;
	for(loop = 0;((loop < 128) && (rr == 0));loop++)
	{
		if(in->image_window[loop] != NULL)
		{
			Camera *camera = in->image_window[loop]->camera;
			if(camera != NULL)
			{
				if(camera == find)
				{
					rr = 1;
				}
				else
				{
					rr = camera->CheckRecurseChildren(camera, find);
				}
			}
		}
	}
	return(rr);
}

int	Camera::CheckRecursion(Camera *dest)
{
int	loop;

	int rr = 0;
	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			Camera *camera = image_window[loop]->camera;
			if(camera != NULL)
			{
				if(camera == dest)
				{
					rr = 1;
				}
			}
		}
	}
	return(rr);
}

void	Camera::DrawImageWindowsBefore(int current_layer, int check_only, Mat& in_mat, int& moving_element, int& someone_is_dragging)
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->buttonize == 0)
			{
				if(check_only == 0)
				{
					if((image_window[loop]->layer == current_layer)
					|| (current_layer == -1))
					{
						image_window[loop]->Draw(this);
						in_mat = mat;
					}
				}
				if(image_window[loop]->transform == MODE_MOVING)
				{
					moving_element = 1;
				}
				if(image_window[loop]->dragging == 1)
				{
					someone_is_dragging = 1;
				}
			}
		}
	}
}

void	Camera::DrawImageWindowsAfter()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->buttonize == 1)
			{
				image_window[loop]->Draw(this);
			}
			else if(image_window[loop]->dragging == 1)
			{
				fl_color(WHITE);
				int xx = image_window[loop]->x();
				int yy = image_window[loop]->y();
				int ww = image_window[loop]->w();
				int hh = image_window[loop]->h();
				fl_rect(xx, yy, ww, hh);
			}
		}
	}
}

void	Camera::HighlightImageWindows()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->buttonize == 0)
			{
				int xx = image_window[loop]->x() - image_sx;
				int yy = image_window[loop]->y() - image_sy;
				int ww = image_window[loop]->w();
				int hh = image_window[loop]->h();
				xx *= image_window[loop]->parent_scale_width;
				yy *= image_window[loop]->parent_scale_height;
				ww *= image_window[loop]->parent_scale_width;
				hh *= image_window[loop]->parent_scale_height;
				xx += image_sx;
				yy += image_sy;
				if(my_window->resize_frame->use != image_window[loop])
				{
					fl_color(YELLOW);
					fl_rect(xx, yy, ww, hh);
				}
				image_window[loop]->displayed_x = xx;
				image_window[loop]->displayed_y = yy;
				image_window[loop]->displayed_w = ww;
				image_window[loop]->displayed_h = hh;
			}
		}
	}
}

void	Camera::DrawEmbeddedPIP()
{
	if((pip_idx > -1) && (pip_idx != my_window->displayed_source))
	{
		Camera *local_cam = my_window->camera[pip_idx];
		if(local_cam != NULL)
		{
			if(local_cam->power == 1)
			{
				VideoCapture *cap = local_cam->cap;
				if(cap != NULL)
				{
					my_window->DrawEmbeddedPIP();
				}
			}
		}
	}
}

void	Camera::DrawImageWindowGrid(int grid_size)
{
int	loop;

	int cam_x = image_sx;
	int cam_y = image_sy;
	int cam_w = width;
	int cam_h = height;
	fl_color(GRAY);
	for(loop = cam_x;loop < cam_x + cam_w;loop += grid_size)
	{
		fl_line(loop, cam_y, loop, cam_y + cam_h);
	}
	for(loop = cam_y;loop < cam_y + cam_h;loop += grid_size)
	{
		fl_line(cam_x, loop, cam_x + cam_w, loop);
	}
}

void	Camera::DisplayAVWindow()
{
	if(av_window != NULL)
	{
		double position = av_window->Position();
		int ww = mat.cols;
		int pp = (int)((double)ww * position);
		int nx = image_sx;
		int ny = (image_sy + mat.rows);
		int val = (image_sx + pp);
		if(my_window->progress_scrubber != NULL)
		{
			my_window->progress_scrubber->resize(nx, ny, ww, 40);
			my_window->progress_scrubber->Position(position);
			my_window->progress_scrubber->show();
			my_window->progress_scrubber->draw();
		}
	}
}

void	Camera::DrawFilterDialogs()
{
int	loop;

	int yy = Fl::event_y();
	if(yy > (my_window->h() - 220))
	{
		int cnt = 0;
		Camera *show_em = my_window->DisplayedCamera();
		for(loop = 0;loop < filter_cnt;loop++)
		{
			if(filter_name[loop] != NULL)
			{
				if(filter_dialog[loop] != NULL)
				{
					if(show_em == this)
					{
						filter_dialog[loop]->resize(345 + (cnt * 102), my_window->h() - 220, filter_dialog[loop]->w(), filter_dialog[loop]->h());
						filter_dialog[loop]->show();
					}
					else
					{
						filter_dialog[loop]->hide();
					}
				}
				cnt++;
			}
		}
	}
	else
	{
		for(loop = 0;loop < filter_cnt;loop++)
		{
			if(filter_dialog[loop] != NULL)
			{
				filter_dialog[loop]->hide();
			}
		}
	}
}

void	Camera::GrabWindowImage(Window win, Mat& use_mat)
{
XWindowAttributes attributes;
XColor colors;

	attributes.width = 0;
	attributes.height = 0;
	Status status = XGetWindowAttributes(fl_display, win, &attributes);
	int width = attributes.width;
	int height = attributes.height;
	int depth = attributes.depth / 8;

	if((width > 0) && (height > 0) && (status != 0))
	{
		XImage *image = NULL;
		if(shared_image == NULL)
		{
			shared_image = x11_create_shared_image(&shminfo, width, height);
		}
		image = shared_image;
		if(image != NULL)
		{
			XCompositeRedirectWindow(fl_display, win, CompositeRedirectAutomatic);
			Pixmap pixmap = XCompositeNameWindowPixmap(fl_display, win);
			XFlush(fl_display);
			XShmGetImage(fl_display, pixmap, image, 0, 0, AllPlanes);

			depth = 4;
			unsigned char *use_data = (unsigned char *)image->data;
			int cv_flag = CV_8UC4;
			Mat frame(cv::Size(width, height), cv_flag, use_data);

			// COW - CLEAR THE ALPHA CHANNEL
			cvtColor(frame, frame, COLOR_BGRA2BGR);
			cvtColor(frame, frame, COLOR_BGR2RGBA);


			int out_w = my_window->output_width;
			int out_h = my_window->output_height;
			scale_mat_to_fit(frame, use_mat, out_w, out_h);
			XFreePixmap(fl_display, pixmap);
			XCompositeUnredirectWindow(fl_display, win, CompositeRedirectAutomatic);
		}
		else
		{
			Mat frame(requested_h, requested_w, CV_8UC4, cv::Scalar(0, 100, 200, 0));
			frame.copyTo(use_mat);
		}
	}
	else
	{
		Mat frame(requested_h, requested_w, CV_8UC4, cv::Scalar(0, 100, 200, 0));
		frame.copyTo(use_mat);
	}
}

void	Camera::GrabSlideshow()
{
	slideshow_mat.copyTo(mat);
}

void	slideshow_cb(void *v)
{
char	filename[4096];

	Camera *cam = (Camera *)v;
	double interval = 5.0;
	if(cam->slideshow_fp != NULL)
	{
		if(fgets(filename, 4096, cam->slideshow_fp))
		{
			strip_lf(filename);
			char *cp = filename;
			while((*cp != ':') && (*cp != '\0')) cp++;
			if(*cp == ':')
			{
				*cp = '\0';
				cp++;
				double ii = atof(cp);
				if(ii > 0.0)
				{
					interval = ii;
				}
			}
			Mat local_mat = imread(filename, IMREAD_UNCHANGED);
			if(!local_mat.empty())
			{
				if(local_mat.channels() == 3)
				{
					cvtColor(local_mat, local_mat, COLOR_BGR2RGBA);
				}
				else
				{
					cvtColor(local_mat, local_mat, COLOR_BGRA2RGBA);
				}
				cam->slideshow_mat = local_mat.clone();
			}
		}
		else
		{
			rewind(cam->slideshow_fp);
		}
		Fl::repeat_timeout(interval, slideshow_cb, cam);
	}
	else if(cam->slideshow_list_cnt > 0)
	{
		Mat local_mat = imread(cam->slideshow_list[cam->slideshow_current], IMREAD_UNCHANGED);
		if(!local_mat.empty())
		{
			if(local_mat.channels() == 3)
			{
				cvtColor(local_mat, local_mat, COLOR_BGR2RGBA);
			}
			else
			{
				cvtColor(local_mat, local_mat, COLOR_BGRA2RGBA);
			}
			cam->slideshow_mat = local_mat.clone();
		}
		cam->slideshow_current++;
		if(cam->slideshow_current >= cam->slideshow_list_cnt)
		{
			cam->slideshow_current = 0;
		}
		Fl::repeat_timeout(interval, slideshow_cb, cam);
	}
}

void	Camera::GrabWindow()
{
	if(grab_window_id != 0)
	{
		GrabWindowImage(grab_window_id, mat);
	}
}

void	Camera::GrabThisWindow()
{
	Window x_id = fl_xid(my_window);
	GrabWindowImage(x_id, mat);
}

void	Camera::PaintRecognizedObjects(int test_run)
{
int	loop;

	if(((record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT) || (test_run == 1))
	{
		fl_color(YELLOW);
		for(loop = 0;loop < detected_object_cnt;loop++)
		{
			int xx = detected_object[loop].x;
			int yy = detected_object[loop].y;
			int ww = detected_object[loop].w;
			int hh = detected_object[loop].h;

			double adj_x1 = ((double)display_width / (double)mat.cols);
			double adj_y1 = ((double)display_height / (double)mat.rows);
			int adj_xx = (int)(double)xx * adj_x1;
			int adj_yy = (int)(double)yy * adj_y1;
			int adj_ww = (int)(double)ww * adj_x1;
			int adj_hh = (int)(double)hh * adj_y1;

			if(this == my_window->DisplayedCamera())
			{
				fl_rect(image_sx + adj_xx, image_sy + adj_yy, adj_ww, adj_hh);
			}
			if(detected_object[loop].idx > -1)
			{
				int nn = detected_object[loop].idx;
				char *label = my_window->recognize_class_name[nn];
				char buf[256];
				sprintf(buf, "%s (%f)", label, detected_object[loop].confidence);
				if(this == my_window->DisplayedCamera())
				{
					if(my_window->visible_debug == 0)
					{
						fl_draw(buf, image_sx + adj_xx, image_sy + adj_yy);
					}
				}
				if(my_window->visible_debug == 1)
				{
					rectangle(mat, Point(xx, yy), Point(xx + ww, yy + hh), Scalar(255, 255, 255), 1);
					putText(mat, buf, cv::Point(xx, yy - 4), cv::FONT_HERSHEY_DUPLEX, 0.5, CV_RGB(255, 255, 255), 1, cv::LINE_AA);
				}
			}
		}
	}
}

int	Camera::ScheduleTrigger()
{
	int weekday = my_window->weekday;
	int minute = my_window->minute;
	int hour = my_window->hour;
	int triggered = 0;
	int right_day = 1;
	if(schedule_day != 0)
	{
		right_day = 0;
		int day_bit = (1 << weekday);
		if((schedule_day & day_bit) == day_bit)
		{
			right_day = 1;
		}
	}
	if(right_day == 1)
	{
		triggered = 1;
		if((schedule_stop > 0) && (schedule_stop > schedule_start))
		{
			triggered = 0;
			int minutes = (hour * 60) + minute;
			if((minutes >= schedule_start) && (minutes < schedule_stop))
			{
				triggered = 1;
				result_trigger |= ON_SCHEDULE;
			}
		}
	}
	return(triggered);
}

int	Camera::DarknessTrigger()
{
	int triggered = 0;
	cv::Scalar temp = cv::mean(mat);
	double val = (double)temp.val[0];
	darkness_score = (1.0 / 255.0) * val;
	if((record_trigger & ON_DETECT_LIGHT) == ON_DETECT_LIGHT)
	{
		if(darkness_score >= darkness_trigger)
		{
			triggered = 1;
			result_trigger |= ON_DETECT_DARK;
		}
	}
	else if((record_trigger & ON_DETECT_DARK) == ON_DETECT_DARK)
	{
		if(darkness_score <= darkness_trigger)
		{
			triggered = 1;
			result_trigger |= ON_DETECT_LIGHT;
		}
	}
	return(triggered);
}

int	Camera::MotionTrigger()
{
	int triggered = 0;
	int tcx = -1;
	int tcy = -1;
	int second_cx = -1;
	int second_cy = -1;
	int rr = my_window->FindMovement(this, motion_threshold, &tcx, &tcy, &second_cx, &second_cy, 0, 0, width, height);
	if(rr == 1)
	{
		triggered = 1;
		detect_time = time(0);
		result_trigger |= ON_DETECT_MOTION;
	}
	if((record == 1) && (triggered == 0))
	{
		time_t current_time = time(0);
		int diff_time = (int)(current_time - detect_time);
		if(diff_time < 12)
		{
			triggered = 1;
			result_trigger |= ON_DETECT_MOTION;
		}
	}
	return(triggered);
}

int	Camera::ObjectTrigger()
{
int		loop;

	int triggered = 0;
	if((true_total_frames % recognize_interval) == 0)
	{
		int tcx = -1;
		int tcy = -1;
		int second_cx = -1;
		int second_cy = -1;
		int rr = DetectObjects(&tcx, &tcy, &second_cx, &second_cy);
		if(rr > -1)
		{
			triggered = 1;
			result_trigger |= ON_DETECT_OBJECT;
			detect_time = time(0);
		}
	}
	if((record == 1) && (triggered == 0))
	{
		time_t current_time = time(0);
		int diff_time = (int)(current_time - detect_time);
		if(diff_time < 12)
		{
			triggered = 1;
			result_trigger |= ON_DETECT_OBJECT;
		}
	}
	return(triggered);
}

int	Camera::Triggers()
{
	int triggered = 0;
	result_trigger = 0;
	if(triggers_requested == 1)
	{
		if((record_trigger == 0) || (trigger_override == 1))
		{
			if((my_window->single_stream == 0) 
			|| (my_window->DisplayedCamera() == this) 
			|| (my_window->follow_mode != FOLLOW_MODE_RECORDING_FOLLOWS_DISPLAY))
			{
				triggered = 1;
			}
		}
		else
		{
			if((record_trigger & ON_SCHEDULE) == ON_SCHEDULE)
			{
				triggered = ScheduleTrigger();
				if(triggered == 1)
				{
					if(((record_trigger & ON_DETECT_LIGHT) == ON_DETECT_LIGHT)
					|| ((record_trigger & ON_DETECT_DARK) == ON_DETECT_DARK))
					{
						triggered = 0;
						triggered = DarknessTrigger();
						if(triggered == 1)
						{
							if((record_trigger & ON_DETECT_MOTION) == ON_DETECT_MOTION)
							{
								triggered = 0;
								triggered = MotionTrigger();
								if(triggered == 1)
								{
									if((record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
									{
										triggered = 0;
										triggered = ObjectTrigger();
									}
								}
							}
							else
							{
								if((record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
								{
									triggered = 0;
									triggered = ObjectTrigger();
								}
							}
						}
					}
					else
					{
						if((record_trigger & ON_DETECT_MOTION) == ON_DETECT_MOTION)
						{
							triggered = MotionTrigger();
							if(triggered == 1)
							{
								if((record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
								{
									triggered = 0;
									triggered = ObjectTrigger();
								}
							}
						}
						else
						{
							if((record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
							{
								triggered = 0;
								triggered = ObjectTrigger();
							}
						}
					}
				}
			}
			else
			{
				if(((record_trigger & ON_DETECT_LIGHT) == ON_DETECT_LIGHT)
				|| ((record_trigger & ON_DETECT_DARK) == ON_DETECT_DARK))
				{
					triggered = DarknessTrigger();
					if(triggered == 1)
					{
						if((record_trigger & ON_DETECT_MOTION) == ON_DETECT_MOTION)
						{
							triggered = 0;
							triggered = MotionTrigger();
							if(triggered == 1)
							{
								triggered = 0;
								if((record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
								{
									triggered = ObjectTrigger();
								}
							}
						}
						else
						{
							if((record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
							{
								triggered = 0;
								triggered = ObjectTrigger();
							}
						}
					}
				}
				else
				{
					if((record_trigger & ON_DETECT_MOTION) == ON_DETECT_MOTION)
					{
						triggered = 0;
						triggered = MotionTrigger();
					}
					else
					{
						if((record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
						{
							triggered = 0;
							triggered = ObjectTrigger();
						}
					}
				}
			}
		}
	}
	return(triggered);
}

void	Camera::CompressImageWindowList()
{
ImageWindow	*list[1024];
int			loop;

	for(loop = 0;loop < 1024;loop++)
	{
		list[loop] = NULL;
	}
	int cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			list[cnt] = image_window[loop];
			cnt++;
		}
	}
	image_window_cnt = cnt;
	for(loop = 0;loop < 128;loop++)
	{
		image_window[loop] = list[loop];
	}
}

void	Camera::OffsetPositionImageWindows(int off_x, int off_y)
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			int xx = image_window[loop]->dx;
			int yy = image_window[loop]->dy;
			int ww = image_window[loop]->dw;
			int hh = image_window[loop]->dh;
			image_window[loop]->resize(xx + off_x, yy + off_y, ww, hh);
		}
	}
}

void	Camera::PositionAllButtonized()
{
int	loop;

	int done = 0;
	int x_pos = 280;
	int y_pos = Fl::h() - 160;
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->buttonize == 1)
			{
				image_window[loop]->buttonized_x = x_pos;
				image_window[loop]->buttonized_y = y_pos;
				x_pos += (image_window[loop]->buttonized_w) + 10;
				if((x_pos + image_window[loop]->buttonized_w) > (Fl::w() - 180))
				{
					x_pos = 280;
					y_pos += (image_window[loop]->buttonized_h + 8);
					if(y_pos + image_window[loop]->buttonized_h > Fl::h())
					{
						image_window[loop]->buttonized_x = -1;
						image_window[loop]->buttonized_y = -1;
						image_window[loop]->buttonized_w = -1;
						image_window[loop]->buttonized_h = -1;
					}
				}
			}
		}
	}
}

void	Camera::PasteMat(Mat mat, int sx, int sy)
{
	cairo_surface_t *surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
	if((surface != NULL) && (cairo_surface != NULL))
	{
		cairo_set_source_surface(cairo_context, surface, sx, sy);
		cairo_paint(cairo_context);
		cairo_surface_destroy(surface);
	}
}

// SECTION *********************************** CAMERA CAPS *******************************************

CameraCaps::CameraCaps()
{
int	loop;

	path = NULL;
	alias = NULL;
	for(loop = 0;loop < 128;loop++)
	{
		fourcc[loop] = 0;
		fourcc_description[loop] = NULL;
	}
	fourcc_cnt = 0;
}

CameraCaps::~CameraCaps()
{
int	loop;

	if(path != NULL) free(path);
	if(alias != NULL) free(alias);
	for(loop = 0;loop < fourcc_cnt;loop++)
	{
		if(fourcc_description[loop] != NULL) free(fourcc_description[loop]);
	}
}

// SECTION *********************************** NET CONTROL *******************************************

int	requesting_control(int *flag)
{
void	request_control(ImageMemory *, char *ip, int port);

	MyWin *win = (MyWin *)flag;
	if(win != NULL)
	{
		request_control(&win->image_memory, win->jpeg_streaming, win->jpeg_streaming_port + 1);
	}
	return(0);
}

int	send_to_network(int *flag)
{
void	send_images(ImageMemory *, char *ip, int port);

	MyWin *win = (MyWin *)flag;
	if(win != NULL)
	{
		send_images(&win->image_memory, win->jpeg_streaming, win->jpeg_streaming_port);
	}
	return(0);
}

int	respond_to_control(int *flag)
{
void	send_images(ImageMemory *, char *ip, int port);

	MyWin *win = (MyWin *)flag;
	if(win != NULL)
	{
		int old = 0;
		int panning = 0;
		int zooming = 0;
		int focusing = 0;
		while(win->image_memory.done == 0)
		{
			Camera *cam = win->DisplayedCamera();
			if(cam->ptz_lock_interface != -1)
			{
				int instance = -1;
				if(win->ptz_window[cam->ptz_lock_interface] != NULL)
				{
					instance = win->ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
				}
				if(instance != -1)
				{
					if(win->image_memory.ptz != old)
					{
						if(win->image_memory.ptz == 1)
						{
							win->ViscaCommand(instance, PTZ_UP_LEFT);
							panning = 1;
						}
						else if(win->image_memory.ptz == 2)
						{
							win->ViscaCommand(instance, PTZ_UP);
							panning = 1;
						}
						else if(win->image_memory.ptz == 3)
						{
							win->ViscaCommand(instance, PTZ_UP_RIGHT);
							panning = 1;
						}
						else if(win->image_memory.ptz == 4)
						{
							win->ViscaCommand(instance, PTZ_LEFT);
							panning = 1;
						}
						else if(win->image_memory.ptz == 5)
						{
							win->ViscaCommand(instance, PTZ_HOME);
							panning = 1;
						}
						else if(win->image_memory.ptz == 6)
						{
							win->ViscaCommand(instance, PTZ_RIGHT);
							panning = 1;
						}
						else if(win->image_memory.ptz == 7)
						{
							win->ViscaCommand(instance, PTZ_DOWN_LEFT);
							panning = 1;
						}
						else if(win->image_memory.ptz == 8)
						{
							win->ViscaCommand(instance, PTZ_DOWN);
							panning = 1;
						}
						else if(win->image_memory.ptz == 9)
						{
							win->ViscaCommand(instance, PTZ_DOWN_RIGHT);
							panning = 1;
						}
						else if(win->image_memory.ptz == 10)
						{
							win->ViscaCommand(instance, PTZ_ZOOM_IN);
							zooming = 1;
						}
						else if(win->image_memory.ptz == 11)
						{
							win->ViscaCommand(instance, PTZ_ZOOM_OUT);
							zooming = 1;
						}
						else if(win->image_memory.ptz == 12)
						{
							win->ViscaCommand(instance, PTZ_FOCUS_FAR);
							focusing = 1;
						}
						else if(win->image_memory.ptz == 13)
						{
							win->ViscaCommand(instance, PTZ_FOCUS_NEAR);
							focusing = 1;
						}
						else if(win->image_memory.ptz == 0)
						{
							if(panning == 1)
							{
								win->ViscaCommand(instance, PTZ_PAN_STOP);
								panning = 0;
							}
							if(zooming == 1)
							{
								win->ViscaCommand(instance, PTZ_ZOOM_STOP);
								zooming = 0;
							}
							if(focusing == 1)
							{
								win->ViscaCommand(instance, PTZ_FOCUS_STOP);
								focusing = 0;
							}
						}
					}
				}
				old = win->image_memory.ptz;
			}
		}
	}
	return(0);
}

// SECTION *********************************** FILTER DIALOGS *******************************************

FilterDialog::FilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Double_Window(xx, yy, ww, hh, lbl)
{
int	loop;

	my_window = in_win;

	align(FL_ALIGN_INSIDE | FL_ALIGN_TOP);
	labelcolor(WHITE);

	selected = 0;
	disable = 0;
	limit = 0;

	my_box = new Fl_Box(0, 0, w(), h());
	my_box->copy_label(lbl);
	my_box->labelsize(8);
	my_box->align(FL_ALIGN_INSIDE | FL_ALIGN_TOP | FL_ALIGN_CENTER);
	my_box->labelcolor(WHITE);
	my_box->color(BLACK);
	my_box->box(FL_FRAME_BOX);
	for(loop = 0;loop < 128;loop++)
	{
		str[loop] = NULL;
	}
	end();
	set_non_modal();
	hide();
}

FilterDialog::~FilterDialog()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(str[loop] != NULL)
		{
			free(str[loop]);
			str[loop] = NULL;
		}
	}
}

int	FilterDialog::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		int yy = Fl::event_y();
		if(yy < 10)
		{
			if(disable == 0)
			{
				disable = 1;
			}
			else
			{
				disable = 0;
			}
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

void	FilterDialog::draw()
{
	if(disable == 0)
	{
		my_box->color(BLACK);
	}
	else
	{
		my_box->color(GRAY);
	}
	Fl_Double_Window::draw();
}

GrayscaleFilterDialog::GrayscaleFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

GrayscaleFilterDialog::~GrayscaleFilterDialog()
{
}

ThresholdFilterDialog::ThresholdFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ThresholdFilterDialog::~ThresholdFilterDialog()
{
}

int	ThresholdFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		double use = (255.0 / (double)width) * (double)xx;
		if(use < 0.0)
		{
			use = 0.0;
		}
		if(use > 255.0)
		{
			use = 255.0;
		}
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			selected++;
			if(selected >= limit)
			{
				selected = 0;
			}
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ThresholdFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Threshold", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Max Value", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Type", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 14);
	fl_color(YELLOW);
	fl_draw(str[selected], 14, y_pos + 10);
	y_pos += 20;
}

InvertFilterDialog::InvertFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

InvertFilterDialog::~InvertFilterDialog()
{
}

EdgeDetectFilterDialog::EdgeDetectFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

EdgeDetectFilterDialog::~EdgeDetectFilterDialog()
{
}

int	EdgeDetectFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		double use = (255.0 / (double)width) * (double)xx;
		if(use < 0.0)
		{
			use = 0.0;
		}
		if(use > 255.0)
		{
			use = 255.0;
		}
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (32.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 32.0)
			{
				use = 32.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 1.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[3] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	EdgeDetectFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Blur Radius", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 32.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Low", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("High", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Blend", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 1.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

BrightnessFilterDialog::BrightnessFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

BrightnessFilterDialog::~BrightnessFilterDialog()
{
}

int	BrightnessFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	BrightnessFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Brightness", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 1.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

ContrastFilterDialog::ContrastFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ContrastFilterDialog::~ContrastFilterDialog()
{
}

int	ContrastFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ContrastFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Contrast", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 1.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

SaturationFilterDialog::SaturationFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

SaturationFilterDialog::~SaturationFilterDialog()
{
}

int	SaturationFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	SaturationFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Saturation", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 2.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

HueFilterDialog::HueFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

HueFilterDialog::~HueFilterDialog()
{
}

int	HueFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	HueFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Hue", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 2.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

ClaheFilterDialog::ClaheFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ClaheFilterDialog::~ClaheFilterDialog()
{
}

int	ClaheFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (4.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 4.0)
			{
				use = 4.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ClaheFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("CLAHE", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 4.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

ColorIntensityFilterDialog::ColorIntensityFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ColorIntensityFilterDialog::~ColorIntensityFilterDialog()
{
}

int	ColorIntensityFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[3] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ColorIntensityFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Red", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 2.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Green", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 2.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Blue", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 2.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Alpha", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 2.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

BlurFilterDialog::BlurFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

BlurFilterDialog::~BlurFilterDialog()
{
}

int	BlurFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (64.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 64.0)
			{
				use = 64.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	BlurFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Radius", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 64.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

CropFilterDialog::CropFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

CropFilterDialog::~CropFilterDialog()
{
}

int	CropFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[3] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	CropFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Left", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 1.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Right", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 1.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Top", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 1.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Bottom", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 1.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

ScaleFilterDialog::ScaleFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ScaleFilterDialog::~ScaleFilterDialog()
{
}

int	ScaleFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (10.0 / (double)width) * (double)xx;
			if(use < 0.1)
			{
				use = 0.1;
			}
			if(use > 10.0)
			{
				use = 10.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (10.0 / (double)width) * (double)xx;
			if(use < 0.1)
			{
				use = 0.1;
			}
			if(use > 10.0)
			{
				use = 10.0;
			}
			number[1] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ScaleFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Horizontal", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 10.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Vertical", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 10.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

BlendFilterDialog::BlendFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

BlendFilterDialog::~BlendFilterDialog()
{
}

int	BlendFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		double use = (1.0 / (double)width) * (double)xx;
		if(use < 0.0)
		{
			use = 0.0;
		}
		if(use > 1.0)
		{
			use = 1.0;
		}
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			selected++;
			if(selected >= limit)
			{
				selected = 0;
			}
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	BlendFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Balance", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 1.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Camera", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 14);
	fl_color(YELLOW);
	fl_push_clip(10, y_pos, width, 14);
	fl_draw(str[selected], 14, y_pos + 10);
	fl_pop_clip();
	y_pos += 20;
}

BevelFilterDialog::BevelFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

BevelFilterDialog::~BevelFilterDialog()
{
}

int	BevelFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (100.0 / (double)width) * (double)xx;
			if(use < 8.0)
			{
				use = 8.0;
			}
			if(use > 100.0)
			{
				use = 10.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (100.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 100.0)
			{
				use = 100.0;
			}
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[3] = use;
			flag = 1;
		}
		else if((yy > y_marker[4]) && (yy < y_marker[4] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[4] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	BevelFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(WHITE);
	fl_draw("Offset", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 100.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Radius", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 100.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 24;

	fl_color(WHITE);
	fl_draw("Red", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Green", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Blue", 10, y_pos);
	y_pos += 2;
	y_marker[4] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[4];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

GradientFilterDialog::GradientFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

GradientFilterDialog::~GradientFilterDialog()
{
}

int	GradientFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			selected++;
			if(selected >= limit)
			{
				selected = 0;
			}
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[4]) && (yy < y_marker[4] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[3] = use;
			flag = 1;
		}
		else if((yy > y_marker[5]) && (yy < y_marker[5] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[4] = use;
			flag = 1;
		}
		else if((yy > y_marker[6]) && (yy < y_marker[6] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[5] = use;
			flag = 1;
		}
		else if((yy > y_marker[7]) && (yy < y_marker[7] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[6] = use;
			flag = 1;
		}
		else if((yy > y_marker[8]) && (yy < y_marker[8] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[7] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	GradientFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;

	fl_color(WHITE);
	fl_draw("Direction", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 14);
	fl_color(YELLOW);
	fl_push_clip(10, y_pos, width, 14);
	fl_draw(str[selected], 14, y_pos + 10);
	fl_pop_clip();
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Start Red", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	double use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Start Green", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Start Blue", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("Start Alpha", 10, y_pos);
	y_pos += 2;
	y_marker[4] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("End Red", 10, y_pos);
	y_pos += 2;
	y_marker[5] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[4];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("End Green", 10, y_pos);
	y_pos += 2;
	y_marker[6] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[5];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("End Blue", 10, y_pos);
	y_pos += 2;
	y_marker[7] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[6];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(WHITE);
	fl_draw("End Alpha", 10, y_pos);
	y_pos += 2;
	y_marker[8] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[7];
	use = (int)(((double)width / 255.0) * val);
	fl_color(YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

// SECTION *********************************** PIP *******************************************

PIP::PIP(Camera *cam, int xx, int yy, int ww, int hh)
{
	camera = cam;
	x = xx;
	y = yy;
	w = ww;
	h = hh;
	visible = 0;
}

PIP::~PIP()
{
}

void	PIP::draw(int idx)
{
	Mat local_mat;
	local_mat = camera->mat.clone();
	if(!local_mat.empty())
	{
		MyWin *win = camera->my_window;
		Camera *cam = win->DisplayedCamera();
		Mat new_mat;
		Mat dst = cam->mat;
		int nw = (int)((double)local_mat.cols * win->pip_size);
		int nh = (int)((double)local_mat.rows * win->pip_size);
		cv::resize(local_mat, new_mat, cv::Size(nw, nh));

		int px = dst.cols - (nw + 10);
		int py = 10 + ((nh + 10) * idx);
		if(win->multipip == MULTIPIP_SIDE_RIGHT)
		{
			px = dst.cols - (nw + 10);
			py = 10 + ((nh + 10) * idx);
			if((py + nh) > local_mat.rows)
			{
				px = dst.cols - ((nw + 10) * 2);
			}
		}
		else if(win->multipip == MULTIPIP_SIDE_LEFT)
		{
			px = 10;
		}
		else if(win->multipip == MULTIPIP_SIDE_TOP)
		{
			px = 10 + ((nw + 10) * idx);
			py = 10;
		}
		else if(win->multipip == MULTIPIP_SIDE_BOTTOM)
		{
			px = 10 + ((nw + 10) * idx);
			py = local_mat.rows - (nh + 10);
		}
		if(win->embed_pip == 1)
		{
			if(((py + nh) < local_mat.rows) && ((px + nw) < local_mat.cols))
			{
				new_mat.copyTo(dst.rowRange(py, py + nh).colRange(px, px + nw));
				if((win->pip_red > -1) && (win->pip_green > -1) && (win->pip_blue > -1))
				{
					rectangle(dst, Point(px, py), Point(px + nw, py + nh), Scalar(win->pip_blue, win->pip_green, win->pip_red), 1);
				}
			}
		}
		else
		{
			fl_draw_image((unsigned char *)new_mat.ptr(), win->w() - (nw + 50), win->h() - (nh + 50), new_mat.cols, new_mat.rows, new_mat.channels());
			if(cam->keep_pip == 0)
			{
				fl_color(WHITE);
			}
			else
			{
				fl_color(YELLOW);
			}
			fl_rect(win->w() - (nw + 50), win->h() - (nh + 50), new_mat.cols, new_mat.rows);
		}
	}
}

// SECTION *********************************** SHAPES *******************************************

Shape::Shape(MyWin *in_win, int in_x, int in_y, int in_w, int in_h) : Fl_Box(in_x, in_y, in_w, in_h)
{
void	shape_popup_cb(Fl_Widget *w, void *v);

	my_window = in_win;
	type = SHAPE_NO_TYPE;

	xx = in_x;
	yy = in_y;
	ww = in_w;
	hh = in_h;
	mode = SHAPE_MODE_MOVE;
	layer = 0;
	hidden = 0;
	highlight = 0;

	background_r = 0;
	background_g = 0;
	background_b = 0;
	background_a = 0;
	foreground_r = 0;
	foreground_g = 0;
	foreground_b = 0;
	foreground_a = 0;
	
	font = 0;
	style = 0;
	font_sz = 0;

	thickness = 0;

	source = NULL;
	destination = NULL;
	popup = new PopupMenu(0, 0, 160, 300);
	popup->browser->callback(shape_popup_cb, this);
	popup->browser->add("Move");
	popup->browser->add("Resize");
	popup->browser->add("Remove");
	popup->browser->add("Up a Layer");
	popup->browser->add("Down a Layer");
	popup->browser->add("Hide");
	popup->set_non_modal();

	last_x = 0;
	last_y = 0;
}

Shape::~Shape()
{
}

void	Shape::Remove()
{
	hide();
	my_window->RemoveShape(this);
}

void	Shape::draw()
{
}

void	shape_popup_cb(Fl_Widget *w, void *v)
{
	Shape *shape = (Shape *)v;
	if(shape->popup != NULL)
	{
		shape->popup->hide();
	}
	Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
	char *str = (char *)browser->text(browser->value());
	if(str != NULL)
	{
		if(strcmp(str, "Move") == 0)
		{
			shape->mode = SHAPE_MODE_MOVE;
		}
		else if(strcmp(str, "Resize") == 0)
		{
			shape->mode = SHAPE_MODE_RESIZE;
		}
		else if(strcmp(str, "Remove") == 0)
		{
			shape->Remove();
			delete shape;
		}
		else if(strcmp(str, "Set Line Thickness") == 0)
		{
			shape->mode = SHAPE_MODE_THICKNESS;
		}
		else if(strcmp(str, "Set Filled") == 0)
		{
			shape->filled = 1;
			browser->text(browser->value(), "Set Hollow");
		}
		else if(strcmp(str, "Set Hollow") == 0)
		{
			shape->filled = 0;
			browser->text(browser->value(), "Set Filled");
		}
		else if(strcmp(str, "Set Line Color") == 0)
		{
			my_color_chooser("Line Color", shape->foreground_r, shape->foreground_g, shape->foreground_b, shape->foreground_a);
		}
		else if(strcmp(str, "Set Fill Color") == 0)
		{
			my_color_chooser("Fill Color", shape->foreground_r, shape->background_g, shape->background_b, shape->background_a);
		}
		else if(strcmp(str, "Set to Erase") == 0)
		{
			shape->erase = 1;
			browser->text(browser->value(), "Set to Draw");
		}
		else if(strcmp(str, "Set to Draw") == 0)
		{
			shape->erase = 0;
			browser->text(browser->value(), "Set to Erase");
		}
		else if(strcmp(str, "Up a Layer") == 0)
		{
			shape->layer++;
			if(shape->layer > 6) shape->layer = 6;
		}
		else if(strcmp(str, "Down a Layer") == 0)
		{
			shape->layer--;
			if(shape->layer < 0) shape->layer = 0;
		}
		else if(strcmp(str, "Hide") == 0)
		{
			shape->hidden = 1;
			browser->text(browser->value(), "Reveal");
		}
		else if(strcmp(str, "Reveal") == 0)
		{
			shape->hidden = 0;
			browser->text(browser->value(), "Hide");
		}
	}
}

int	Shape::handle(int event)
{
	int flag = 0;
	Camera *cam = destination;
	if(cam != NULL)
	{
		int push_x = Fl::event_x();
		int push_y = Fl::event_y();
		switch(event)
		{
			case(FL_PUSH):
			{
				if(Fl::event_state(FL_BUTTON1) == FL_BUTTON1)
				{
					last_x = Fl::event_x_root();
					last_y = Fl::event_y_root();
				}
				else if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
				{
					if(popup != NULL)
					{
						popup->Fit();
						popup->resize(Fl::event_x_root(), Fl::event_y_root(), popup->w(), popup->h());
						popup->show();
					}
				}
				flag = 1;
			}
			break;
			case(FL_RELEASE):
			{
				last_x = 0;
				last_y = 0;
				flag = 1;
			}
			break;
			case(FL_DRAG):
			{
				if(Fl::event_state(FL_BUTTON1) == FL_BUTTON1)
				{
					if(mode == SHAPE_MODE_MOVE)
					{
						DragMove(cam);
					}
					else if(mode == SHAPE_MODE_RESIZE)
					{
						DragResize(cam);
					}
					else if(mode == SHAPE_MODE_THICKNESS)
					{
						DragThickness(cam);
					}
					flag = 1;
				}
			}
			break;
			case(FL_ENTER):
			{
				flag = 1;
				highlight = 1;
			}
			break;
			case(FL_LEAVE):
			{
				flag = 1;
				highlight = 0;
			}
			break;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Box::handle(event);
	}
	return(flag);
}

void	Shape::DragMove(Camera *cam)
{
	int xxx = Fl::event_x_root();
	int yyy = Fl::event_y_root();
	int ddx = last_x - xxx;
	int ddy = last_y - yyy;
	resize(x() - ddx, y() - ddy, ww, hh);
	xx = x() - cam->image_sx;
	yy = y() - cam->image_sy;
	last_x = xxx;
	last_y = yyy;
}

void	Shape::DragResize(Camera *cam)
{
	int xxx = Fl::event_x_root();
	int yyy = Fl::event_y_root();
	int ddx = last_x - xxx;
	int ddy = last_y - yyy;
	if((ddx < ww) && (ddy < hh))
	{
		ww -= ddx;
		hh -= ddy;
	}
	resize(x(), y(), ww, hh);
	last_x = xxx;
	last_y = yyy;
}

void	Shape::DragThickness(Camera *cam)
{
	int xxx = Fl::event_x_root();
	int yyy = Fl::event_y_root();
	int ddy = last_y - yyy;
	if(ddy > 0)
	{
		thickness++;
	}
	else
	{
		thickness--;
	}
	if(thickness < 0) thickness = 0;
	if(thickness > ww) thickness = ww;
	last_x = xxx;
	last_y = yyy;
}

ShapeRectangle::ShapeRectangle(MyWin *in_win, Camera *in_cam, int in_x, int in_y, int in_w, int in_h, 
					int in_filled,
					int in_thick,
					int in_erase,
					int fr, int fg, int fb, int fa, 
					int br, int bg, int bb, int ba) : Shape(in_win, in_x, in_y, in_w, in_h)
{
	destination = in_cam;
	foreground_r = fr;
	foreground_g = fg;
	foreground_b = fb;
	foreground_a = fa;
	background_r = br;
	background_g = bg;
	background_b = bb;
	background_a = ba;
	thickness = in_thick;
	filled = in_filled;
	erase = in_erase;
	resize(xx + destination->image_sx, yy + destination->image_sy, ww, hh);
	popup->browser->add("Set Line Thickness");
	popup->browser->add("Set Line Color");
	popup->browser->add("Set Fill Color");
	if(filled == 0)
	{
		popup->browser->add("Set Filled");
	}
	else
	{
		popup->browser->add("Set Hollow");
	}
	if(erase == 0)
	{
		popup->browser->add("Set to Erase");
	}
	else
	{
		popup->browser->add("Set to Draw");
	}
}

ShapeRectangle::~ShapeRectangle()
{
}

void	ShapeRectangle::draw()
{
	Camera *cam = destination;
	if(erase == 1)
	{
		int x1 = xx;
		int y1 = yy;
		int x2 = x1 + ww;
		if(x2 >= cam->mat.cols) 
		{
			x2 = cam->mat.cols - 1;
		}
		int y2 = y1 + hh;
		if(y2 >= cam->mat.rows) 
		{
			y2 = cam->mat.rows - 1;
		}
		if(x1 < 0) 
		{
			x1 = 0;
		}
		if(y1 < 0) 
		{
			y1 = 0;
		}
		rectangle(cam->mat, Point(x1, y1), Point(x2, y2), Vec4b(0, 0, 0, 0), cv::FILLED);
	}
	else
	{
		my_cairo_set_line_style(cam->cairo_context, style, thickness);
		cairo_rectangle(cam->cairo_context, xx, yy, ww, hh);
		if(filled == 1)
		{
			my_cairo_set_source_rgba(cam->cairo_context, background_r, background_g, background_b, background_a);
			cairo_fill(cam->cairo_context);
		}
		cairo_rectangle(cam->cairo_context, xx, yy, ww, hh);
		my_cairo_set_source_rgba(cam->cairo_context, foreground_r, foreground_g, foreground_b, foreground_a);
		cairo_stroke(cam->cairo_context);
	}
}

int	ShapeRectangle::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Shape::handle(event);
	}
	return(flag);
}

// SECTION *********************************** SAVE FIFO *******************************************

SaveFIFO::SaveFIFO(MyWin *in_win, int in_fd, int in_sz, int ww, int hh, long int in_start_ts)
{
int	loop;

	my_window = in_win;
	fd = in_fd;
	frame_sz = in_sz;
	top = 0;
	done = 0;
	start_ts = in_start_ts;
	use_ts = 0;
	width = ww;
	height = hh;
	for(loop = 0;loop < 128;loop++)
	{
		frame[loop] = NULL;
		mutex[loop] = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
	}
	pthread_t signal_thread = create_task((int (*)(int *))fifo_save_frame, (void *)this);
}

SaveFIFO::~SaveFIFO()
{
int	loop;

	done = 1;
	usleep(1000);
	for(loop = 0;loop < my_window->source_cnt;loop++)
	{
		if(my_window->camera[loop] != NULL)
		{
			if(my_window->camera[loop]->save_fifo == this)
			{
				my_window->camera[loop]->save_fifo = NULL;
			}
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(frame[loop] != NULL)
		{
			free(frame[loop]);
		}
	}
}

void	SaveFIFO::Save(void *in_frame, long int in_ts, long int paused_accum)
{
	if(top < 127)
	{
		use_ts = in_ts - (start_ts + paused_accum);
		while(frame[top] != NULL)
		{
			usleep(10);
		}
		pthread_mutex_lock(&mutex[top]);
		frame[top] = malloc(frame_sz);
		if(frame[top] != NULL)
		{
			memcpy(frame[top], in_frame, frame_sz);
		}
		pthread_mutex_unlock(&mutex[top]);
		top++;
	}
}

// SECTION *********************************** FACE DETECT *******************************************

FaceDetect::FaceDetect()
{
	cascade.load("/usr/local/share/opencv4/haarcascades/haarcascade_frontalface_default.xml"); 
}

FaceDetect::~FaceDetect()
{
}

void FaceDetect::Detect(Mat& img, double scale)
{
vector<Rect> faces, faces2;
Mat gray, smallImg;

	cvtColor(img, gray, COLOR_BGR2GRAY );
	double fx = 1 / scale;

	resize(gray, smallImg, Size(), fx, fx, INTER_LINEAR); 
	equalizeHist(smallImg, smallImg);

	vector<int> levels;
	vector<double> weight;
	cascade.detectMultiScale(smallImg, faces, levels, weight, 1.1, 3, 0, Size(), Size(), true);
	for(size_t i = 0;i < faces.size();i++)
	{
		Rect r = faces[i];
		vector<Rect> nestedObjects;
		Point center;
		Scalar color = Scalar(255, 0, 0); // Color for Drawing tool
		int radius;

		rectangle(img, cv::Point(cvRound(r.x*scale), cvRound(r.y*scale)),
					cv::Point(cvRound((r.x + r.width-1)*scale), 
					cvRound((r.y + r.height-1)*scale)), color, 3, 8, 0);
	}
}

// SECTION *********************************** ALIAS WINDOW  *******************************************

void	alias_cb(Fl_Widget *w, void *v)
{
int	loop;

	AliasWindow *aw = (AliasWindow *)v;
	MyWin *my_win = aw->my_window;
	Camera *cam = my_win->DisplayedCamera();
	if(cam != NULL)
	{
		char *str = (char *)aw->alias->value();
		if(str != NULL)
		{
			strcpy(cam->alias, str);
		}
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(my_win->ptz_window[loop] != NULL)
			{
				if(my_win->ptz_window[loop]->bound_camera == cam)
				{
					my_win->ptz_window[loop]->ptz_bound_name_box->value(cam->alias);
				}
			}
		}
	}
	aw->hide();
	my_win->showing_alias_window = 0;
}

AliasWindow::AliasWindow(MyWin *in_win) : Dialog(260, 300, 490, 70, "Aliases")
{
	my_window = in_win;
	last_x = 0;
	last_y = 0;
	resize(x(), y(), w(), h());

	int yp = 30;
	alias = new Fl_Input(60, yp, 404, 20, "Alias:");
	alias->color(BLACK);
	alias->textcolor(WHITE);
	alias->textsize(11);
	alias->cursor_color(WHITE);
	alias->labelcolor(YELLOW);
	alias->labelsize(11);
	alias->box(FL_FRAME_BOX);
	alias->align(FL_ALIGN_LEFT);
	alias->when(FL_WHEN_ENTER_KEY);
	alias->copy_tooltip("Set the alias for the displayed camera.");
	alias->callback(alias_cb, this);
	yp += 28;

	MyButton *accept = new MyButton((w() * 0.33) - 40, yp, 80, 20, "Accept");
	accept->box(FL_FLAT_BOX);
	accept->labelcolor(YELLOW);
	accept->labelsize(11);
	accept->color(BLACK);
	accept->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	accept->copy_tooltip("Accept the alias specified above.");
	accept->callback(alias_cb, this);
	accept->show();

	MyButton *cancel = new MyButton((w() * 0.66) - 40, yp, 80, 20, "Cancel");
	cancel->box(FL_FLAT_BOX);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(11);
	cancel->color(BLACK);
	cancel->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	cancel->copy_tooltip("Close the dialog without accepting the edited alias.");
	cancel->callback(hide_window_cb, this);
	cancel->show();

	end();
	hide();
}

AliasWindow::~AliasWindow()
{
}

int	AliasWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == FL_Escape)
		{
			hide();
			my_window->showing_alias_window = 0;
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	AliasWindow::show()
{
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		alias->value(cam->alias);
	}
	Fl_Window::show();
}

// ************************************************ SECTION IMMEDIATE NAME WINDOW ************************************

void	name_immediate_cb(Fl_Widget *w, void *v)
{
	ImmediateNameWindow *inw = (ImmediateNameWindow *)v;
	if(inw->my_im != NULL)
	{
		if(inw->my_im->name != NULL)
		{
			free(inw->my_im->name);
		}
		char *name = (char *)inw->name->value();
		if(name != NULL)
		{
			inw->my_im->name = strdup(name);
		}
	}
	inw->hide();
}

ImmediateNameWindow::ImmediateNameWindow(MyWin *in_win, Immediate *in_im) : Dialog(260, 300, 490, 70, "Immediate Drawing Name")
{
	my_window = in_win;
	my_im = in_im;
	last_x = 0;
	last_y = 0;
	resize(x(), y(), w(), h());

	int yp = 30;
	name = new Fl_Input(60, yp, 404, 20, "Name:");
	name->color(BLACK);
	name->textcolor(WHITE);
	name->textsize(11);
	name->cursor_color(WHITE);
	name->labelcolor(YELLOW);
	name->labelsize(11);
	name->box(FL_FRAME_BOX);
	name->align(FL_ALIGN_LEFT);
	name->when(FL_WHEN_ENTER_KEY);
	name->copy_tooltip("Set the alias for the displayed camera.");
	name->callback(name_immediate_cb, this);
	yp += 28;

	MyButton *accept = new MyButton((w() * 0.33) - 40, yp, 80, 20, "Accept");
	accept->box(FL_FLAT_BOX);
	accept->labelcolor(YELLOW);
	accept->labelsize(11);
	accept->color(BLACK);
	accept->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	accept->copy_tooltip("Accept the alias specified above.");
	accept->callback(name_immediate_cb, this);
	accept->show();

	MyButton *cancel = new MyButton((w() * 0.66) - 40, yp, 80, 20, "Cancel");
	cancel->box(FL_FLAT_BOX);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(11);
	cancel->color(BLACK);
	cancel->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	cancel->copy_tooltip("Close the dialog without accepting the edited alias.");
	cancel->callback(hide_window_cb, this);
	cancel->show();

	end();
	hide();
}

ImmediateNameWindow::~ImmediateNameWindow()
{
	if(my_im != NULL)
	{
		if(my_im->inw == this)
		{
			my_im->inw = NULL;
		}
	}
}

int	ImmediateNameWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == FL_Escape)
		{
			hide();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

// SECTION *********************************** SPECIFY IRC WINDOW  *******************************************

void	specify_irc_accept_cb(Fl_Widget *w, void *v)
{
char	buf[32768];

	SpecifyIRCWindow *me = (SpecifyIRCWindow *)v;
	if(me != NULL)
	{
		MyWin *win = me->my_window;
		if(win != NULL)
		{
			if(win->new_source_window != NULL)
			{
				char *server_str = (char *)me->server->value();
				if(strncasecmp(server_str, "irc://", strlen("irc://")) == 0)
				{
					server_str += strlen("irc://");
				}
				NewSourceWindow *nsw = win->new_source_window;
				sprintf(buf, "irc://%s\n%s\n%s\n%s\n%s",
					me->server->value(),
					me->port->value(),
					me->user->value(),
					me->password->value(),
					me->channel->value());
				nsw->source->value(buf);
			}
		}
		me->hide();
	}
}

SpecifyIRCWindow::SpecifyIRCWindow(MyWin *in_win) : Dialog(420, 190, "Specify IRC")
{
	my_window = in_win;

	int yp = 40;
	server = new Fl_Input(75, yp, 320, 20, "Server");
	server->color(BLACK);
	server->textcolor(WHITE);
	server->textsize(11);
	server->cursor_color(WHITE);
	server->labelcolor(YELLOW);
	server->labelsize(9);
	server->box(FL_FRAME_BOX);
	server->align(FL_ALIGN_LEFT);
	yp += 22;

	port = new Fl_Input(75, yp, 100, 20, "Port");
	port->color(BLACK);
	port->textcolor(WHITE);
	port->textsize(11);
	port->cursor_color(WHITE);
	port->labelcolor(YELLOW);
	port->labelsize(9);
	port->box(FL_FRAME_BOX);
	port->align(FL_ALIGN_LEFT);
	port->value("6667");
	yp += 22;

	user = new Fl_Input(75, yp, 200, 20, "User");
	user->color(BLACK);
	user->textcolor(WHITE);
	user->textsize(11);
	user->cursor_color(WHITE);
	user->labelcolor(YELLOW);
	user->labelsize(9);
	user->box(FL_FRAME_BOX);
	user->align(FL_ALIGN_LEFT);
	yp += 22;

	password = new Fl_Input(75, yp, 320, 20, "Password");
	password->color(BLACK);
	password->textcolor(WHITE);
	password->textsize(11);
	password->cursor_color(WHITE);
	password->labelcolor(YELLOW);
	password->labelsize(9);
	password->box(FL_FRAME_BOX);
	password->align(FL_ALIGN_LEFT);
	yp += 22;

	channel = new Fl_Input(75, yp, 200, 20, "Channel");
	channel->color(BLACK);
	channel->textcolor(WHITE);
	channel->textsize(11);
	channel->cursor_color(WHITE);
	channel->labelcolor(YELLOW);
	channel->labelsize(9);
	channel->box(FL_FRAME_BOX);
	channel->align(FL_ALIGN_LEFT);
	channel->value("#channel");
	yp += 40;

	accept = new MyButton((420 / 3) - 35, yp, 70, 20, "Accept");
	accept->color(BLACK);
	accept->labelcolor(YELLOW);
	accept->labelsize(10);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->callback(specify_irc_accept_cb, this);
	accept->box(FL_FLAT_BOX);
	accept->down_box(FL_FLAT_BOX);

	cancel = new MyButton(((420 / 3) * 2) - 35, yp, 70, 20, "Cancel");
	cancel->color(BLACK);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(10);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->callback(hide_window_cb, this);
	cancel->box(FL_FLAT_BOX);

	end();
}

SpecifyIRCWindow::~SpecifyIRCWindow()
{
}

// SECTION *********************************** SPECIFY URL WINDOW  *******************************************

void	specify_url_accept_cb(Fl_Widget *w, void *v)
{
char	buf[32768];

	SpecifyURLWindow *me = (SpecifyURLWindow *)v;
	if(me != NULL)
	{
		MyWin *win = me->my_window;
		if(win != NULL)
		{
			if(win->new_source_window != NULL)
			{
				NewSourceWindow *nsw = win->new_source_window;
				char *url_string = (char *)me->url->value();
				char *css_string = (char *)me->css->value();
				if(strncasecmp(url_string, "http://", strlen("http://")) == 0)
				{
					url_string += strlen("http://");
				}
				if(strncasecmp(url_string, "https://", strlen("https://")) == 0)
				{
					url_string += strlen("https://");
				}
				if(strlen(css_string) > 0)
				{
					sprintf(buf, "html://%s\ncss://%s", url_string, css_string);
				}
				else
				{
					sprintf(buf, "html://%s", url_string);
				}
				nsw->source->value(buf);
			}
		}
		me->hide();
	}
}

SpecifyURLWindow::SpecifyURLWindow(MyWin *in_win) : Dialog(420, 330, "Specify URL")
{
	my_window = in_win;
	int new_yp = 20;

	url = new Fl_Input(40, new_yp + 20, 360, 20, "URL");
	url->color(BLACK);
	url->textcolor(WHITE);
	url->textsize(11);
	url->cursor_color(WHITE);
	url->labelcolor(YELLOW);
	url->labelsize(9);
	url->box(FL_FRAME_BOX);
	url->align(FL_ALIGN_LEFT);

	css = new Fl_Multiline_Input(20, new_yp + 70, 380, 200, "CSS");
	css->color(BLACK);
	css->textcolor(WHITE);
	css->textsize(11);
	css->cursor_color(WHITE);
	css->labelcolor(YELLOW);
	css->labelsize(9);
	css->box(FL_FRAME_BOX);
	css->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);

	accept = new MyButton((420 / 3) - 35, new_yp + 290, 70, 20, "Accept");
	accept->color(BLACK);
	accept->labelcolor(YELLOW);
	accept->labelsize(10);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->callback(specify_url_accept_cb, this);
	accept->box(FL_FLAT_BOX);
	accept->down_box(FL_FLAT_BOX);

	cancel = new MyButton(((420 / 3) * 2) - 35, new_yp + 290, 70, 20, "Cancel");
	cancel->color(BLACK);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(10);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->callback(hide_window_cb, this);
	cancel->box(FL_FLAT_BOX);

	end();
}

SpecifyURLWindow::~SpecifyURLWindow()
{
}

// SECTION *********************************** SOURCE MULTILINE  ****************************************

void	source_popup_cb(Fl_Widget *w, void *v)
{
char	buf[256];

	Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
	SourceMultiline *sm = (SourceMultiline *)v;
	char *str = (char *)browser->data(browser->value());
	if(str != NULL)
	{
		char *cp = str;
		char *cp2 = buf;
		while(*cp != '\0')
		{
			if((*cp == '\\') && (*(cp + 1) == 'n'))
			{
				*cp2 = '\n';
				cp2++;
				cp++;
			}
			else
			{
				if((*cp != '<') && (*cp != '>'))
				{
					*cp2 = *cp;
					cp2++;
				}
			}
			cp++;
		}
		*cp2 = '\0';
		sm->value(buf);
	}
	browser->window()->hide();
}

SourceMultiline::SourceMultiline(int xx, int yy, int ww, int hh, char *lbl) : Fl_Multiline_Input(xx, yy, ww, hh, lbl)
{
}

SourceMultiline::~SourceMultiline()
{
}

int	SourceMultiline::handle(int event)
{
	int	flag = 0;
	if(event == FL_PUSH)
	{
		if(Fl::event_button() == FL_RIGHT_MOUSE)
		{
			PopupMenu *popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 160, 40);
			popup->browser->callback(source_popup_cb, this);
			int cnt = 0;
			while(available_scheme[cnt] != NULL)
			{
				popup->browser->add(available_scheme[cnt], available_scheme[cnt + 1]);
				cnt += 2;
			}
			popup->set_non_modal();
			popup->Fit();
			popup->show();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Multiline_Input::handle(event);
	}
	return(flag);
}

// SECTION *********************************** SELECT X11 WINDOW  *******************************************

SelectX11Window::SelectX11Window(MyWin *in_win) : Dialog(200, 800, "Select X11 Window")
{
void			select_window_to_monitor_cb(Fl_Widget *w, void *v);
char			*window_list[128];
int				loop;
char			buf[4096];

	int new_yp = 20;
	my_window = in_win;
	int cnt = x11_iterate_windows2(fl_display, window_list);
	if(cnt > 0)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		MyButton *close_button = new MyButton(150, new_yp + 2, 50, 18, "Close");
		close_button->box(FL_FLAT_BOX);
		close_button->labelcolor(YELLOW);
		close_button->labelsize(11);
		close_button->color(BLACK);
		close_button->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		close_button->callback(hide_window_cb, this);

		Fl_Scroll *scroll = new Fl_Scroll(0, new_yp + 20, 200, 780);
		int ay = 4;
		int max_w = -1000;
		fl_font(FL_HELVETICA, 9);
		for(loop = 0;loop < cnt;loop++)
		{
			int mw = 0;
			int mh = 0;
			fl_measure(window_list[loop], mw, mh);
			if(mw > max_w) max_w = mw;
		}
		if(max_w < 170) max_w = 170;
		for(loop = 0;loop < cnt;loop++)
		{
			unsigned long int window_id = (unsigned long int)atol(window_list[loop]);
			char *cp = window_list[loop];
			while((*cp != '\0') && (*cp != ':')) cp++;
			while((*cp != '\0') && (*cp == ':')) cp++;
			
			char *str = strdup(cp);
			cp = str;
			while(*cp != '\0')
			{
				if(*cp == '@')
				{
					*cp = '_';
				}
				cp++;
			}
			int im_w = 0;
			int im_h = 0;
			int im_d = 0;
			unsigned char *image_data = x11_grab_window_image(NULL, window_id, &im_w, &im_h, &im_d);
			if(image_data != NULL)
			{
				Fl_RGB_Image image(image_data, im_w, im_h, im_d);
				if(im_w <= 0) im_w = 1;
				double proportion = (double)max_w / (double)im_w;
				int set_h = (int)((double)im_h * proportion);
				Fl_RGB_Image *n_image = (Fl_RGB_Image *)image.copy(max_w, set_h);

				MyToggleButton *window_button = new MyToggleButton(4, ay, n_image->w(), n_image->h());
				window_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
				window_button->box(FL_FLAT_BOX);
				window_button->color(BLACK);
				window_button->down_color(GRAY);
				window_button->type(FL_RADIO_BUTTON);
				window_button->clear_visible_focus();
				window_button->image(n_image);
				window_button->callback(select_window_to_monitor_cb, (void *)window_id);
				ay += n_image->h();
				Fl_Box *window_label = new Fl_Box(4, ay, n_image->w(), 20, str);
				window_label->box(FL_FLAT_BOX);
				window_label->color(BLACK);
				window_label->labelcolor(YELLOW);
				window_label->labelsize(9);
				window_label->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
				ay += 20;
			}
		}
		scroll->end();
		scroll->box(FL_FRAME_BOX);
		scroll->color(BLACK);
		scroll->type(Fl_Scroll::VERTICAL);
		scroll->hscrollbar.hide();
		end();
		int sz = 800;
		if(ay < 800) sz = ay + 20 + new_yp;
		resize(x(), y(), max_w + 32, sz);
		scroll->resize(0, new_yp + 20, max_w + 32, sz - (20 + new_yp));
		close_button->resize(150, new_yp + 2, 50, 18);
		color(BLACK);
		set_non_modal();
		show();
		for(loop = 0;loop < cnt;loop++)
		{
			free(window_list[loop]);
		}
	}
}

SelectX11Window::~SelectX11Window()
{
	if(my_window->new_source_window->select_x11_window == this)
	{
		my_window->new_source_window->select_x11_window = NULL;
	}
}

// SECTION *********************************** NEW SOURCE WINDOW  *******************************************

void	cancel_new_source_cb(Fl_Widget *w, void *v)
{
	MyWin *my_win = (MyWin *)v;
	my_win->new_source_button->show();
	my_win->pseudo_camera_window->hide();
	my_win->new_source_window->hide();
	my_win->cursor(FL_CURSOR_DEFAULT);
}

void	reset_new_source_cb(Fl_Widget *w, void *v)
{
char	buf[4096];

	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	nsw->source->value("");
	nsw->alias->value("");
	sprintf(buf, "%d", my_win->requested_w);
	nsw->width->value(buf);
	sprintf(buf, "%d", my_win->requested_h);
	nsw->height->value(buf);
	nsw->font_sz->value("32");

	nsw->local_text_red = 255;
	nsw->local_text_green = 255;
	nsw->local_text_blue = 255;
	nsw->local_text_alpha = 255;
	nsw->font_browser->select(1);
}

void	new_source_cb(Fl_Widget *w, void *v)
{
char buf[4096];

	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	int use_chroma = CHROMA_ON_GREEN;
	if(w == nsw->chromakey_blue_select)
	{
		use_chroma = CHROMA_ON_BLUE;
	}
	my_win->new_source_button->show();
	my_win->edit_source_button->show();
	int nn = 4;
	if(w != NULL)
	{
		Fl_Input *in = (Fl_Input *)w;
		NewSourceWindow *win = (NewSourceWindow *)in->window();
		nn = win->children();
	}
	if(nn >= 4)
	{
		Fl_Input *source = (Fl_Input *)nsw->source;
		Fl_Input *alias_in = (Fl_Input *)nsw->alias;
		Fl_Input *width = (Fl_Input *)nsw->width;
		Fl_Input *height = (Fl_Input *)nsw->height;
		Fl_Input *font_sz = (Fl_Input *)nsw->font_sz;

		char *text = (char *)source->value();
		char *alias = (char *)alias_in->value();
		char *ww = (char *)width->value();
		char *hh = (char *)height->value();
		char *fz = (char *)font_sz->value();
		char *font_name = (char *)nsw->font_browser->text(nsw->font_browser->value());
		if(font_name != NULL)
		{
			if(strlen(font_name) > 7)
			{
				font_name += 7;
			}
		}
		int rr = (int)nsw->local_red;
		int gg = (int)nsw->local_green;
		int bb = (int)nsw->local_blue;
		int aa = (int)nsw->local_alpha;

		int t_rr = (int)nsw->local_text_red;
		int t_gg = (int)nsw->local_text_green;
		int t_bb = (int)nsw->local_text_blue;
		int t_aa = (int)nsw->local_text_alpha;
		if(text != NULL)
		{
			if(strlen(text) == 0)
			{
				sprintf(buf, "blank://%d,%d,%d,%d", rr, gg, bb, aa);
				text = buf;
			}
			else
			{
				if(strcmp(text, "blank://") == 0)
				{
					sprintf(buf, "blank://%d,%d,%d,%d", rr, gg, bb, aa);
					text = buf;
				}
			}
			int nw = atoi(ww);
			int nh = atoi(hh);
			int nfz = atoi(fz);
			if((nw > 0) && (nh > 0))
			{
				char alias_arg[4096];
				strcpy(alias_arg, "Text");
				if(alias != NULL)
				{
					if(strlen(alias) > 0)
					{
						strcpy(alias_arg, alias);
					}
				}
				if(strncmp(text, "audio://", strlen("audio://")) == 0)
				{
					char *use_text = text + strlen("audio://");
					int started_here = 0;
					if(my_win->pulse_mixer == NULL)
					{
						my_win->pulse_mixer = new PulseMixer(my_win, FRAMES_PER_BUFFER, my_win->audio_channels);
						started_here = 1;
					}
					if(alias == NULL)
					{
						alias = use_text;
					}
					else
					{
						if(strlen(alias) < 1)
						{
							alias = use_text;
						}
					}
					my_win->AddAudioSource(started_here, use_text, alias);
				}
				else
				{
					int cam_n = my_win->SetupCamera(text, alias_arg, nw, nh, nfz, font_name, rr, gg, bb, aa, t_rr, t_gg, t_bb, t_aa, use_chroma);
					if(cam_n > -1)
					{
						my_win->DisplayCamera(cam_n);
						my_win->video_thumbnail_group->ScrollToDisplayed();
						my_win->UpdateThumbButtons();
					}
					else
					{
						my_win->SetErrorMessage("Cannot Open Camera");
					}
				}
			}
		}
		source->value("");
		alias_in->value("");
	}
	my_win->new_source_window->hide();
	my_win->cursor(FL_CURSOR_DEFAULT);
}

void	edit_source_cb(Fl_Widget *w, void *v)
{
char buf[4096];

	MyWin *my_win = (MyWin *)v;
	Camera *cam = my_win->DisplayedCamera();
	NewSourceWindow *nsw = my_win->new_source_window;
	my_win->new_source_button->show();

	my_win->edit_source_button->show();
	if(cam != NULL)
	{
		Fl_Input *in = (Fl_Input *)w;
		NewSourceWindow *win = (NewSourceWindow *)in->window();
		if(win->children() >= 4)
		{
			Fl_Input *source = (Fl_Input *)nsw->source;
			Fl_Input *alias_in = (Fl_Input *)nsw->alias;
			Fl_Input *width = (Fl_Input *)nsw->width;
			Fl_Input *height = (Fl_Input *)nsw->height;
			Fl_Input *font_sz = (Fl_Input *)nsw->font_sz;

			char *text = (char *)source->value();
			char *alias = (char *)alias_in->value();
			char *ww = (char *)width->value();
			char *hh = (char *)height->value();
			char *fz = (char *)font_sz->value();
			char *font_name = (char *)nsw->font_browser->text(nsw->font_browser->value());

			int rr = (int)nsw->local_red;
			int gg = (int)nsw->local_green;
			int bb = (int)nsw->local_blue;
			int aa = (int)nsw->local_alpha;

			int t_rr = (int)nsw->local_text_red;
			int t_gg = (int)nsw->local_text_green;
			int t_bb = (int)nsw->local_text_blue;
			int t_aa = (int)nsw->local_text_alpha;
			if(strlen(text) > 0)
			{
				if(strcmp(cam->path, text) != 0)
				{
					if((cam->type == CAMERA_TYPE_TEXT)
					|| (cam->type == CAMERA_TYPE_DYNAMIC_TEXT)
					|| (cam->type == CAMERA_TYPE_ALERT))
					{
						strcpy(cam->path, text);
					}
					else
					{
						int displayed = my_win->displayed_source;
						my_win->RemoveCamera(cam);
						new_source_cb(w, v);
						cam = my_win->camera[displayed];
					}
				}
			}
			if(strlen(alias) > 0)
			{
				strcpy(cam->alias, alias);
			}
			int f_sz = atoi(fz);
			if((f_sz > 0) && (f_sz < 256))
			{
				cam->font_sz = f_sz;
			}
			if(strlen(font_name) > 0)
			{
				strcpy(cam->font_name, font_name);
			}
			cam->red = rr;
			cam->green = gg;
			cam->blue = bb;
			cam->alpha = aa;
			cam->text_red = t_rr;
			cam->text_green = t_gg;
			cam->text_blue = t_bb;
			cam->text_alpha = t_aa;
			int r_ww = atoi(ww);
			if(r_ww > 0)
			{
				cam->requested_w = r_ww;
			}
			int r_hh = atoi(hh);
			if(r_hh > 0)
			{
				cam->requested_h = r_hh;
			}
			if((r_ww > 0) && (r_hh > 0))
			{
				if(cam->mat.empty())
				{
					cam->mat = Mat(cv::Size(r_ww, r_hh), CV_8UC4);
				}
				cv::resize(cam->mat, cam->mat, cv::Size(r_ww, r_hh));
				cam->width = r_ww;
				cam->height = r_hh;
			}
			cam->static_initialized = 0;
			source->value("");
			alias_in->value("");
		}
	}
	my_win->new_source_window->hide();
	my_win->cursor(FL_CURSOR_DEFAULT);
}

void	new_source_camera_select_cb(Fl_Widget *w, void *v)
{
char buf[4096];

	MyWin *win = (MyWin *)v;
	char *text = (char *)win->new_source_window->source->value();
	int no_go = 0;
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			if(strncmp(text, "camera://", strlen("camera://")) != 0)
			{
				sprintf(buf, "camera://%s", text);
			}
			else
			{
				sprintf(buf, "%s", text);
			}
			win->new_source_window->source->value(buf);
			no_go = 1;
		}
	}
	if(no_go == 0)
	{
		if(win->new_source_window->select_camera_window != NULL)
		{
			win->new_source_window->select_camera_window->hide();
			Fl::delete_widget(win->new_source_window->select_camera_window);
			win->new_source_window->select_camera_window = NULL;
		}
		win->new_source_window->select_camera_window = new SelectCameraWindow(win);
		win->new_source_window->select_camera_window->show();
	}
}

void	new_source_audio_select_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	char *use_text = NULL;
	char *use_alias = NULL;
	char *text = (char *)win->new_source_window->source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			use_text = text;
		}
	}
	if(use_text != NULL)
	{
		char buf[4096];
		if(strncmp(use_text, "audio://", strlen("audio://")) != 0)
		{
			sprintf(buf, "audio://%s", use_text);
		}
		else
		{
			sprintf(buf, "%s", use_text);
		}
		win->new_source_window->source->value(buf);
	}
	else
	{
		if(win->new_source_window->select_audio_window != NULL)
		{
			win->new_source_window->select_audio_window->hide();
			Fl::delete_widget(win->new_source_window->select_audio_window);
			win->new_source_window->select_audio_window = NULL;
		}
		win->new_source_window->select_audio_window = new SelectAudioWindow(win);
		win->new_source_window->select_audio_window->show();
	}
}

void	new_source_box_select_cb(Fl_Widget *w, void *v)
{
void	iconize_cb(void *v);

	MyWin *win = (MyWin *)v;
	win->iconize();
	Fl::add_timeout(1.0, iconize_cb, win);
}

void	select_window_to_monitor_cb(Fl_Widget *w, void *v)
{
char	buf[8192];
int	loop;

	MyToggleButton *b = (MyToggleButton *)w;
	unsigned long int window_id = (unsigned long int)v;
	char buf2[4096];
	strcpy(buf2, "Window");
	if(global_window->new_source_window != NULL)
	{
		Fl_Input *alias_in = (Fl_Input *)global_window->new_source_window->alias;
		char *alias = (char *)alias_in->value();
		if(alias != NULL)
		{
			if(strlen(alias) > 0)
			{
				strcpy(buf2, alias);
			}
		}
	}
	sprintf(buf, "window://%lu", (unsigned long int)b->user_data());
	global_window->new_source_window->source->value(buf);
	Fl_Window *win = b->window();
	win->hide();
	Fl::delete_widget(win);
}

void	new_source_desktop_select_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	MyWin *win = (MyWin *)v;
	if(win->new_source_window != NULL)
	{
		win->new_source_window->source->value("desktop://");
	}
	win->pseudo_camera_window->hide();
}

void	new_source_av_file_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *win = (MyWin *)v;
	NewSourceWindow *nsw = win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	int no_go = 0;
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			if(strncmp(text, "av://", strlen("av://")) != 0)
			{
				sprintf(buf, "av://%s", text);
			}
			else
			{
				sprintf(buf, "%s", text);
			}
			nsw->source->value(buf);
			no_go = 1;
		}
	}
	if(no_go == 0)
	{
		char filename[4096];
		int nn = my_file_chooser("Select an A/V file", "*.*", "./", filename);
		if(nn > 0)
		{
			sprintf(buf, "av://%s", filename);
			nsw->source->value(buf);
		}
	}
	win->pseudo_camera_window->hide();
}

void	new_source_vector_file_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *win = (MyWin *)v;
	NewSourceWindow *nsw = win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	int no_go = 0;
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			if(strncmp(text, "vector://", strlen("vector://")) != 0)
			{
				sprintf(buf, "vector://%s", text);
			}
			else
			{
				sprintf(buf, "%s", text);
			}
			nsw->source->value(buf);
			no_go = 1;
		}
	}
	if(no_go == 0)
	{
		char filename[4096];
		int nn = my_file_chooser("Select a vector file", "*.svg", "./", filename);
		if(nn > 0)
		{
			sprintf(buf, "vector://%s", filename);
			nsw->source->value(buf);
		}
	}
	win->pseudo_camera_window->hide();
}


void	new_source_image_file_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *win = (MyWin *)v;
	char buf2[4096];
	strcpy(buf2, "Image File");
	NewSourceWindow *nsw = win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	int no_go = 0;
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			if(strncmp(text, "image://", strlen("image://")) != 0)
			{
				sprintf(buf, "image://%s", text);
			}
			else
			{
				sprintf(buf, "%s", text);
			}
			win->new_source_window->source->value(buf);
			no_go = 1;
		}
	}
	if(no_go == 0)
	{
		char filename[4096];
		strcpy(filename, "");
		int nn = my_file_chooser("Select an image file", "*.{png,jpg,jpeg,webp,tiff,tif,bmp}", "./", filename);
		if(nn > 0)
		{
			sprintf(buf, "image://%s", filename);
			win->new_source_window->source->value(buf);
		}
	}
	win->pseudo_camera_window->hide();
}

void	new_source_html_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "html://", strlen("html://")) == 0)
			{
				ss += strlen("html://");
			}
			sprintf(buf, "html://%s", ss);
			source->value(buf);
		}
		else
		{
			my_win->specify_url_window->show();
			my_win->specify_url_window->set_non_modal();
		}
	}
}

void	new_source_irc_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "irc://", strlen("irc://")) == 0)
			{
				ss += strlen("irc://");
			}
			sprintf(buf, "irc://%s", ss);
			source->value(buf);
		}
		else
		{
			my_win->specify_irc_window->show();
			my_win->specify_irc_window->set_non_modal();
		}
	}
}

void	new_source_ndi_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "ndi://", strlen("ndi://")) == 0)
			{
				ss += strlen("ndi://");
			}
			sprintf(buf, "ndi://%s", ss);
			source->value(buf);
		}
		else
		{
			my_win->ndi_source_window->Update();
			my_win->ndi_source_window->show();
			my_win->ndi_source_window->set_non_modal();
		}
	}
}

void	new_alternating_source_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		strcpy(buf, "alternating://");
		source->value(buf);
		char *use_alias = "Alternating";
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
	}
}

void	new_all_source_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		strcpy(buf, "all://");
		source->value(buf);
		char *use_alias = "All";
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
	}
}

void	new_split_source_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *win = (MyWin *)v;
	win->source_select_window->Update();
	win->source_select_window->show();
}

void	new_source_html_source_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "html source://", strlen("html source://")) == 0)
			{
				ss += strlen("html source://");
			}
			sprintf(buf, "html source://%s", ss);
			source->value(buf);
		}
	}
}

void	new_source_pipe_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		char filename[4096];
		strcpy(filename, "");
		if(strlen(text) < 1)
		{
			int r = my_file_chooser("Select a file to execute", "*", "./", filename);
			if(r > 0)
			{
				if(strlen(filename) > 0)
				{
					text = filename;
				}
			}
		}
		if(text != NULL)
		{
			if(strlen(text) > 0)
			{
				char *ss = text;
				if(strncasecmp(text, "pipe://", strlen("pipe://")) == 0)
				{
					ss += strlen("pipe://");
				}
				sprintf(buf, "pipe://%s", ss);
				source->value(buf);
			}
		}
	}
}

void	new_source_frame_file_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	int found = 0;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "sff://", strlen("sff://")) == 0)
			{
				ss += strlen("sff://");
			}
			sprintf(buf, "sff://%s", ss);
			source->value(buf);
			found = 1;
		}
	}
	if(found == 0)
	{
		char filename[4096];
		strcpy(filename, "");
		int nn = my_file_chooser("Select a SFF file", "*.*", "./", filename);
		if(nn > 0)
		{
			if(access(filename, 0) == 0)
			{
				sprintf(buf, "sff://%s", filename);
				source->value(buf);
			}
		}
	}
}

void	alert_window_accept_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	AlertWindow *tw = (AlertWindow *)v;
	if(tw->new_source_window != NULL)
	{
		int trigger_mode = 0;
		int display_mode = 0;
		strcpy(tw->monitor_file, tw->alert_file_path->value());
		if(tw->alert_trigger_changed->value())
		{
			trigger_mode = ALERT_TRIGGER_MODE_CHANGED;
		}
		else if(tw->alert_trigger_created->value())
		{
			trigger_mode = ALERT_TRIGGER_MODE_CREATED;
		}
		if(tw->alert_display_all->value())
		{
			display_mode = ALERT_DISPLAY_MODE_ALL;
		}
		else if(tw->alert_display_last_line->value())
		{
			display_mode = ALERT_DISPLAY_MODE_LAST_LINE;
		}
		else if(tw->alert_display_first_line->value())
		{
			display_mode = ALERT_DISPLAY_MODE_FIRST_LINE;
		}
		int duration = atoi(tw->alert_duration->value());
		int opaque = tw->alert_opaque->value();
		char *aa_file = (char *)tw->alert_audio_file->value();
		sprintf(buf, "alert://%s:%d:%d:%d:%d:%s", tw->monitor_file, trigger_mode, display_mode, duration, opaque, aa_file);
		tw->new_source_window->source->value(buf);
		tw->new_source_window->source->redraw();
	}
	tw->hide();
}

void	alert_file_select_cb(Fl_Widget *w, void *v)
{
	char path[4096];
	AlertWindow *aw = (AlertWindow *)v;
	int nn = my_file_chooser("Select a file to be monitored", "*", "./", path);
	if(nn > 0)
	{
		strcpy(aw->monitor_file, path);
		aw->alert_file_path->value(aw->monitor_file);
		aw->redraw();
	}
}

void	alert_audio_file_select_cb(Fl_Widget *w, void *v)
{
	char path[4096];
	AlertWindow *aw = (AlertWindow *)v;
	int nn = my_file_chooser("Select an audio file to be played", "*.wav", "./", path);
	if(nn > 0)
	{
		aw->alert_audio_file->value(path);
		aw->redraw();
	}
}

AlertWindow::AlertWindow(MyWin *in_win, int ww, int hh) : Dialog(ww, hh, "Alert Setup")
{
	my_window = in_win;
	new_source_window = NULL;
	strcpy(monitor_file, "");
	set_non_modal();
	int new_yp = 20;

	int y_pos = new_yp + 10;
	alert_file_path = new Fl_Input(80, y_pos, 400, 20, "Alert File");
	alert_file_path->color(BLACK);
	alert_file_path->textcolor(WHITE);
	alert_file_path->textsize(11);
	alert_file_path->cursor_color(WHITE);
	alert_file_path->labelcolor(YELLOW);
	alert_file_path->labelsize(9);
	alert_file_path->box(FL_FRAME_BOX);
	alert_file_path->align(FL_ALIGN_LEFT);
	alert_file_path->copy_tooltip("The path to a file to be monitored");
	alert_file_path->value(monitor_file);

	alert_file_button = new MyButton(480, y_pos, 20, 20, "@fileopen");
	alert_file_button->color(BLACK);
	alert_file_button->labelcolor(YELLOW);
	alert_file_button->labelsize(10);
	alert_file_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	alert_file_button->callback(alert_file_select_cb, this);
	alert_file_button->box(FL_FLAT_BOX);
	alert_file_button->copy_tooltip("Select a file using the file browser");
	alert_file_button->down_box(FL_FLAT_BOX);
	y_pos += 22;

	alert_audio_file = new Fl_Input(80, y_pos, 400, 20, "Audio File");
	alert_audio_file->color(BLACK);
	alert_audio_file->textcolor(WHITE);
	alert_audio_file->textsize(11);
	alert_audio_file->cursor_color(WHITE);
	alert_audio_file->labelcolor(YELLOW);
	alert_audio_file->labelsize(9);
	alert_audio_file->box(FL_FRAME_BOX);
	alert_audio_file->align(FL_ALIGN_LEFT);
	alert_audio_file->copy_tooltip("The path to a file to be monitored");
	alert_audio_file->value(monitor_file);

	alert_audio_file_button = new MyButton(480, y_pos, 20, 20, "@fileopen");
	alert_audio_file_button->color(BLACK);
	alert_audio_file_button->labelcolor(YELLOW);
	alert_audio_file_button->labelsize(10);
	alert_audio_file_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	alert_audio_file_button->callback(alert_audio_file_select_cb, this);
	alert_audio_file_button->box(FL_FLAT_BOX);
	alert_audio_file_button->copy_tooltip("Select a file using the file browser");
	alert_audio_file_button->down_box(FL_FLAT_BOX);
	y_pos += 50;
	
	int old_y_pos = y_pos;
	Fl_Group *grp = new Fl_Group(20, y_pos, 120, 50, "Alert Triggers");
	grp->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
	grp->box(FL_NO_BOX);
	grp->color(FL_BLACK);
	grp->labelcolor(FL_WHITE);
	grp->labelsize(11);
	y_pos += 10;

	alert_trigger_changed = new MyLightButton(20, y_pos, 120, 20, "When Changed");
	alert_trigger_changed->box(FL_FLAT_BOX);
	alert_trigger_changed->color(BLACK);
	alert_trigger_changed->labelcolor(YELLOW);
	alert_trigger_changed->labelsize(9);
	alert_trigger_changed->box(FL_NO_BOX);
	alert_trigger_changed->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	alert_trigger_changed->type(FL_RADIO_BUTTON);
	alert_trigger_changed->copy_tooltip("Trigger the alert when the file changes");
	alert_trigger_changed->value(1);
	y_pos += 20;

	alert_trigger_created = new MyLightButton(20, y_pos, 120, 20, "On Creation");
	alert_trigger_created->box(FL_FLAT_BOX);
	alert_trigger_created->color(BLACK);
	alert_trigger_created->labelcolor(YELLOW);
	alert_trigger_created->labelsize(9);
	alert_trigger_created->box(FL_NO_BOX);
	alert_trigger_created->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	alert_trigger_created->type(FL_RADIO_BUTTON);
	alert_trigger_created->copy_tooltip("Trigger the alert when the file is created");
	y_pos += 20;
	grp->end();

	y_pos = old_y_pos;
	Fl_Group *grp2 = new Fl_Group(230, y_pos, 120, 70, "Display");
	grp2->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
	grp2->box(FL_NO_BOX);
	grp2->color(FL_BLACK);
	grp2->labelcolor(FL_WHITE);
	grp2->labelsize(11);
	y_pos += 10;

	alert_display_all = new MyLightButton(230, y_pos, 120, 20, "All");
	alert_display_all->box(FL_FLAT_BOX);
	alert_display_all->color(BLACK);
	alert_display_all->labelcolor(YELLOW);
	alert_display_all->labelsize(9);
	alert_display_all->box(FL_NO_BOX);
	alert_display_all->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	alert_display_all->type(FL_RADIO_BUTTON);
	alert_display_all->copy_tooltip("Display the entire file");
	alert_display_all->value(1);
	y_pos += 20;

	alert_display_last_line = new MyLightButton(230, y_pos, 120, 20, "Last Line");
	alert_display_last_line->box(FL_FLAT_BOX);
	alert_display_last_line->color(BLACK);
	alert_display_last_line->labelcolor(YELLOW);
	alert_display_last_line->labelsize(9);
	alert_display_last_line->box(FL_NO_BOX);
	alert_display_last_line->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	alert_display_last_line->type(FL_RADIO_BUTTON);
	alert_display_last_line->copy_tooltip("Display only the last line");
	y_pos += 20;

	alert_display_first_line = new MyLightButton(230, y_pos, 120, 20, "First Line");
	alert_display_first_line->box(FL_FLAT_BOX);
	alert_display_first_line->color(BLACK);
	alert_display_first_line->labelcolor(YELLOW);
	alert_display_first_line->labelsize(9);
	alert_display_first_line->box(FL_NO_BOX);
	alert_display_first_line->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	alert_display_first_line->type(FL_RADIO_BUTTON);
	alert_display_first_line->copy_tooltip("Display only the first line");
	y_pos += 20;
	grp2->end();

	int use_y = old_y_pos;
	alert_duration = new Fl_Int_Input(440, use_y, 60, 20, "Duration");
	alert_duration->color(BLACK);
	alert_duration->textcolor(WHITE);
	alert_duration->textsize(11);
	alert_duration->cursor_color(WHITE);
	alert_duration->labelcolor(YELLOW);
	alert_duration->labelsize(9);
	alert_duration->box(FL_FRAME_BOX);
	alert_duration->align(FL_ALIGN_LEFT);
	alert_duration->value("10");
	alert_duration->copy_tooltip("How long the alert will remain on screen in seconds. Use -1 for permanent.");
	use_y += 20;

	alert_opaque = new MyLightButton(440, use_y, 120, 20, "Opaque");
	alert_opaque->box(FL_FLAT_BOX);
	alert_opaque->color(BLACK);
	alert_opaque->labelcolor(YELLOW);
	alert_opaque->labelsize(9);
	alert_opaque->box(FL_NO_BOX);
	alert_opaque->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	alert_opaque->copy_tooltip("Make the background opaque");
	y_pos += 20;

	y_pos += 20;
	
	accept = new MyButton((w() / 2) - 100, y_pos, 70, 20, "Accept");
	accept->color(BLACK);
	accept->labelcolor(YELLOW);
	accept->labelsize(11);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->callback(alert_window_accept_cb, this);
	accept->box(FL_FLAT_BOX);
	accept->down_box(FL_FLAT_BOX);

	cancel = new MyButton((w() / 2) + 30, y_pos, 70, 20, "Cancel");
	cancel->color(BLACK);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(11);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->callback(hide_window_cb, this);
	cancel->box(FL_FLAT_BOX);
	cancel->down_box(FL_FLAT_BOX);

	y_pos += 30;
	resize(x(), y(), w(), y_pos);
}

AlertWindow::~AlertWindow()
{
}

void	timer_window_accept_cb(Fl_Widget *w, void *v)
{
char	buf[256];

	TimerWindow *tw = (TimerWindow *)v;
	if(tw->new_source_window != NULL)
	{
		if(tw->format0->value()) tw->analog = 1;
		if(tw->format1->value()) tw->format = 0;
		else if(tw->format2->value()) tw->format = 1;
		else if(tw->format3->value()) tw->format = 2;
		if(tw->use_clock->value())
		{
			sprintf(buf, "clock://%d:%d:%d", tw->use_military->value(), tw->format, tw->analog);
		}
		else if(tw->use_timer->value())
		{
			sprintf(buf, "timer://%ld,%ld:%d", tw->start_seconds, tw->stop_seconds, tw->format);
		}
		tw->new_source_window->source->value(buf);
		tw->new_source_window->source->redraw();
	}
	tw->hide();
}

void	timer_window_use_clock_cb(Fl_Widget *w, void *v)
{
	TimerWindow *tw = (TimerWindow *)v;
	tw->use_military->show();
	tw->start_label->hide();
	tw->start->hide();
	tw->stop_label->hide();
	tw->stop->hide();
	tw->format1->hide();
	tw->format0->value(0);
	tw->format1->value(0);
	tw->format2->value(1);
	tw->format2->value(0);
}

void	timer_window_use_timer_cb(Fl_Widget *w, void *v)
{
	TimerWindow *tw = (TimerWindow *)v;
	tw->use_military->hide();
	tw->start_label->show();
	tw->start->show();
	tw->stop_label->show();
	tw->stop->show();
	tw->format0->value(0);
	tw->format1->show();
	tw->format1->value(1);
	tw->format2->value(0);
	tw->format3->value(0);
}

void	timer_window_times_cb(Fl_Widget *w, void *v)
{
	TimerWindow *tw = (TimerWindow *)v;
	char *start_str = (char *)tw->start->value();
	char *stop_str = (char *)tw->stop->value();
	tw->start_seconds = time_str_eval(start_str);
	tw->stop_seconds = time_str_eval(stop_str);
}

TimerWindow::TimerWindow(MyWin *in_win, int ww, int hh) : Dialog(ww, hh, "Timer Setup")
{
	set_non_modal();
	my_window = in_win;
	new_source_window = NULL;
	start_seconds = 0;
	stop_seconds = 0;
	format = 1;
	analog = 0;
	int new_yp = 20;

	int y_pos = new_yp + 10;
	Fl_Group *grp = new Fl_Group(10, y_pos, 100, 44);
	use_clock = new MyToggleButton(10, y_pos, 100, 20, "Clock");
	use_clock->color(BLACK);
	use_clock->labelcolor(YELLOW);
	use_clock->labelsize(9);
	use_clock->type(FL_RADIO_BUTTON);
	use_clock->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	use_clock->callback(timer_window_use_clock_cb, this);
	use_clock->value(1);
	if(my_window->transparent_interface == 0)
	{
		use_clock->box(FL_FLAT_BOX);
	}
	else
	{
		use_clock->box(FL_NO_BOX);
	}
	y_pos += 20;
	use_timer = new MyToggleButton(10, y_pos, 100, 20, "Timer");
	use_timer->color(BLACK);
	use_timer->labelcolor(YELLOW);
	use_timer->labelsize(9);
	use_timer->type(FL_RADIO_BUTTON);
	use_timer->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	use_timer->callback(timer_window_use_timer_cb, this);
	if(my_window->transparent_interface == 0)
	{
		use_timer->box(FL_FLAT_BOX);
	}
	else
	{
		use_timer->box(FL_NO_BOX);
	}
	grp->end();
	y_pos += 24;
	use_military = new MyToggleButton(10, y_pos, 100, 20, "Military Time");
	use_military->color(BLACK);
	use_military->labelcolor(YELLOW);
	use_military->labelsize(9);
	use_military->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	if(my_window->transparent_interface == 0)
	{
		use_military->box(FL_FLAT_BOX);
	}
	else
	{
		use_military->box(FL_NO_BOX);
	}
	y_pos += 35;
	Fl_Pack *pack = new Fl_Pack(9, y_pos, 212, 62, "Formats");
	pack->color(FL_BLACK);
	pack->align(FL_ALIGN_CENTER | FL_ALIGN_TOP);
	pack->labelsize(10);
	pack->labelcolor(WHITE);
	y_pos += 1;
	format0 = new MyToggleButton(10, y_pos, 210, 20, "Analog");
	format0->color(BLACK);
	format0->labelcolor(YELLOW);
	format0->labelsize(9);
	format0->type(FL_TOGGLE_BUTTON);
	format0->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	if(my_window->transparent_interface == 0)
	{
		format0->box(FL_FLAT_BOX);
	}
	else
	{
		format0->box(FL_NO_BOX);
	}
	format1 = new MyToggleButton(10, y_pos, 210, 20, "days:hours:minutes:seconds");
	format1->color(BLACK);
	format1->labelcolor(YELLOW);
	format1->labelsize(9);
	format1->type(FL_RADIO_BUTTON);
	format1->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	format1->hide();
	if(my_window->transparent_interface == 0)
	{
		format1->box(FL_FLAT_BOX);
	}
	else
	{
		format1->box(FL_NO_BOX);
	}
	y_pos += 20;
	format2 = new MyToggleButton(10, y_pos, 210, 20, "hours:minutes:seconds");
	format2->color(BLACK);
	format2->labelcolor(YELLOW);
	format2->labelsize(9);
	format2->type(FL_RADIO_BUTTON);
	format2->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	format2->value(1);
	if(my_window->transparent_interface == 0)
	{
		format2->box(FL_FLAT_BOX);
	}
	else
	{
		format2->box(FL_NO_BOX);
	}
	y_pos += 20;
	format3 = new MyToggleButton(10, y_pos, 210, 20, "hours:minutes");
	format3->color(BLACK);
	format3->labelcolor(YELLOW);
	format3->labelsize(9);
	format3->type(FL_RADIO_BUTTON);
	format3->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	if(my_window->transparent_interface == 0)
	{
		format3->box(FL_FLAT_BOX);
	}
	else
	{
		format3->box(FL_NO_BOX);
	}
	pack->end();
	y_pos += 26;
	int save_y = y_pos;
	int x_pos = 10;
	start_label = new Fl_Box(x_pos, y_pos, 100, 20, "Start (dd:hh:mm:ss):");
	start_label->color(BLACK);
	start_label->labelcolor(YELLOW);
	start_label->labelsize(8);
	start_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	start_label->box(FL_FLAT_BOX);
	start_label->hide();
	y_pos += 20;
	start = new Fl_Input(x_pos + 15, y_pos, 70, 16);
	start->color(BLACK);
	start->textcolor(WHITE);
	start->cursor_color(WHITE);
	start->textsize(9);
	start->box(FL_FRAME_BOX);
	start->value("00:00:00:00");
	start->when(FL_WHEN_CHANGED);
	start->callback(timer_window_times_cb, this);
	start->hide();
	y_pos = save_y;
	x_pos += 110;
	stop_label = new Fl_Box(x_pos, y_pos, 100, 20, "Stop (dd:hh:mm:ss):");
	stop_label->color(BLACK);
	stop_label->labelcolor(YELLOW);
	stop_label->labelsize(8);
	stop_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	stop_label->box(FL_FLAT_BOX);
	stop_label->hide();
	y_pos += 20;
	stop = new Fl_Input(x_pos + 15, y_pos, 70, 16);
	stop->color(BLACK);
	stop->textcolor(WHITE);
	stop->cursor_color(WHITE);
	stop->textsize(9);
	stop->box(FL_FRAME_BOX);
	stop->value("00:00:00:00");
	stop->when(FL_WHEN_CHANGED);
	stop->callback(timer_window_times_cb, this);
	stop->hide();
	y_pos += 26;

	accept = new MyButton(40, y_pos, 70, 20, "Accept");
	accept->color(BLACK);
	accept->labelcolor(YELLOW);
	accept->labelsize(10);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->callback(timer_window_accept_cb, this);
	accept->box(FL_FLAT_BOX);
	accept->down_box(FL_FLAT_BOX);

	cancel = new MyButton(120, y_pos, 70, 20, "Cancel");
	cancel->color(BLACK);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(10);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->callback(hide_window_cb, this);
	cancel->box(FL_FLAT_BOX);
	cancel->down_box(FL_FLAT_BOX);

	y_pos += 30;
	resize(x(), y(), w(), y_pos);
}

TimerWindow::~TimerWindow()
{
}

void	new_source_clock_timer_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	int found = 0;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "timer://", strlen("timer://")) == 0)
			{
				ss += strlen("timer://");
				sprintf(buf, "timer://%s", ss);
			}
			else if(strncasecmp(text, "clock://", strlen("clock://")) == 0)
			{
				ss += strlen("clock://");
				sprintf(buf, "clock://%s", ss);
			}
			source->value(buf);
			found = 1;
		}
		else
		{
			my_win->timer_window->new_source_window = nsw;
			my_win->timer_window->show();
		}
	}
}

void	new_source_alert_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	int found = 0;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "alert://", strlen("alert://")) != 0)
			{
				sprintf(buf, "alert://%s", ss);
			}
			else
			{
				sprintf(buf, "%s", ss);
			}
			source->value(buf);
			found = 1;
		}
		else
		{
			my_win->alert_window->new_source_window = nsw;
			my_win->alert_window->show();
		}
	}
}

void	new_source_slideshow_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	int found = 0;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "slideshow://", strlen("slideshow://")) != 0)
			{
				sprintf(buf, "slideshow://%s", ss);
			}
			else
			{
				sprintf(buf, "%s", ss);
			}
			source->value(buf);
			found = 1;
		}
		else
		{
			char path[4096];
			strcpy(path, "");
			int nn = my_file_chooser("Select a slideshow file", "*.*", "./", path);
			if(nn > 0)
			{
				sprintf(buf, "slideshow://%s", path);
				source->value(buf);
			}
		}
	}
}

void	new_source_directory_slideshow_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	int found = 0;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "slideshow://", strlen("slideshow://")) != 0)
			{
				sprintf(buf, "slideshow://%s", ss);
			}
			else
			{
				sprintf(buf, "%s", ss);
			}
			source->value(buf);
			found = 1;
		}
		else
		{
			char path[4096];
			strcpy(path, "");
			int nn = my_file_chooser("Select a slideshow file", "*.*", "./", path, 1);
			if(nn > 0)
			{
				sprintf(buf, "slideshow://%s", path);
				source->value(buf);
			}
		}
	}
}

void	new_source_dynamic_text_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	int found = 0;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "dynamic://", strlen("dynamic://")) == 0)
			{
				ss += strlen("dynamic://");
				sprintf(buf, "dynamic://%s", ss);
			}
			else
			{
				sprintf(buf, "dynamic://%s", ss);
			}
			source->value(buf);
			found = 1;
		}
	}
}

void	new_source_osg_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	int loaded = 0;
	strcpy(buf, "");
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncasecmp(text, "osg://", strlen("osg://")) == 0)
			{
				ss += strlen("osg://");
			}
			sprintf(buf, "osg://%s", ss);
			loaded = 1;
		}
	}
	if(loaded == 0)
	{
		char path[4096];
		strcpy(path, "");
		int nn = my_file_chooser("Select an OSG file", "*.*", "./", path);
		if(nn > 0)
		{
			if(access(path, 0) == 0)
			{
				sprintf(buf, "osg://%s", path);
				loaded = 1;
			}
		}
	}
	if(loaded == 1)
	{
		source->value(buf);
	}
}

void	new_sourced_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		char use_alias[8192];
		int use_width = 0;
		int use_height = 0;
		char *ss = "";
		if(strlen(text) > 0)
		{
			ss = text;
			if(strncasecmp(text, "sourced://", strlen("sourced://")) == 0)
			{
				ss += strlen("sourced://");
			}
		}
		if(strlen(ss) < 1)
		{
			Camera *cam = my_win->DisplayedCamera();
			if(cam != NULL)
			{
				if(strlen(cam->alias) > 0)
				{
					ss = cam->alias;
					sprintf(use_alias, "Copy of %s", cam->alias);
				}
				else
				{
					ss = cam->path;
					sprintf(use_alias, "Copy of %s", cam->path);
				}
				use_width = cam->width;
				use_height = cam->height;
			}
		}
		char *width_str = (char *)nsw->width->value();
		if(width_str != NULL)
		{
			double val = atof(width_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_width;
				sprintf(buf, "%d", (int)val);
				nsw->width->value(buf);
			}
		}
		char *height_str = (char *)nsw->height->value();
		if(height_str != NULL)
		{
			double val = atof(height_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_height;
				sprintf(buf, "%d", (int)val);
				nsw->height->value(buf);
			}
		}
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
		sprintf(buf, "sourced://%s", ss);
		source->value(buf);
	}
}

void	new_edge_detect_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		char use_alias[8192];
		int use_width = 0;
		int use_height = 0;
		char *ss = "";
		if(strlen(text) > 0)
		{
			ss = text;
			if(strncasecmp(text, "edge://", strlen("edge://")) == 0)
			{
				ss += strlen("edge://");
			}
		}
		if(strlen(ss) < 1)
		{
			Camera *cam = my_win->DisplayedCamera();
			if(cam != NULL)
			{
				if(strlen(cam->alias) > 0)
				{
					ss = cam->alias;
					sprintf(use_alias, "Copy of %s", cam->alias);
				}
				else
				{
					ss = cam->path;
					sprintf(use_alias, "Copy of %s", cam->path);
				}
				use_width = cam->width;
				use_height = cam->height;
			}
		}
		char *width_str = (char *)nsw->width->value();
		if(width_str != NULL)
		{
			double val = atof(width_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_width;
				sprintf(buf, "%d", (int)val);
				nsw->width->value(buf);
			}
		}
		char *height_str = (char *)nsw->height->value();
		if(height_str != NULL)
		{
			double val = atof(height_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_height;
				sprintf(buf, "%d", (int)val);
				nsw->height->value(buf);
			}
		}
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
		sprintf(buf, "edge://%s", ss);
		source->value(buf);
	}
}

void	new_chromakey_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		char use_alias[8192];
		int use_width = 0;
		int use_height = 0;
		char *ss = "";
		if(strlen(text) > 0)
		{
			ss = text;
			if(strncasecmp(text, "chroma://", strlen("chroma://")) == 0)
			{
				ss += strlen("chroma://");
			}
		}
		if(strlen(ss) < 1)
		{
			Camera *cam = my_win->DisplayedCamera();
			if(cam != NULL)
			{
				if(strlen(cam->alias) > 0)
				{
					ss = cam->alias;
					sprintf(use_alias, "Copy of %s", cam->alias);
				}
				else
				{
					ss = cam->path;
					sprintf(use_alias, "Copy of %s", cam->path);
				}
				use_width = cam->width;
				use_height = cam->height;
			}
		}
		char *width_str = (char *)nsw->width->value();
		if(width_str != NULL)
		{
			double val = atof(width_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_width;
				sprintf(buf, "%d", (int)val);
				nsw->width->value(buf);
			}
		}
		char *height_str = (char *)nsw->height->value();
		if(height_str != NULL)
		{
			double val = atof(height_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_height;
				sprintf(buf, "%d", (int)val);
				nsw->height->value(buf);
			}
		}
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
		sprintf(buf, "chroma://%s", ss);
		source->value(buf);
	}
}

void	new_source_pseudo_camera_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			sprintf(buf, "pseudo://%s", text);
			source->value(buf);
		}
	}
}

void	new_source_plugin_camera_select_cb(Fl_Widget *w, void *v)
{
char	buf[4096];

	MyButton *b = (MyButton *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	int located = 0;
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			if(strncmp(text, "plugin://", strlen("plugin://")) == 0)
			{
				text += strlen("plugin://");
			}
			test_plugin_camera_name(my_win, text);
			located = 1;
		}
	}
	if(located == 0)
	{
		my_win->pseudo_camera_window->show();
	}
}

void	new_source_window_select_cb(Fl_Widget *w, void *v)
{
char			*window_list[128];
int				loop;
char			buf[4096];

	MyButton *b = (MyButton *)w;
	MyWin *win = (MyWin *)v;
	Window xwin = RootWindow(fl_display, fl_screen);

	int found = 0;
	char *use_text = NULL;
	char *text = (char *)win->new_source_window->source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			use_text = text;
		}
	}
	if(use_text != NULL)
	{
		if(strncmp(text, "window://", strlen("window://")) == 0)
		{
			use_text = text + strlen("window://");
		}
		long int id = x11_find_window_by_name(use_text);
		if(id != 0)
		{
			sprintf(buf, "window://%lu", id);
			win->new_source_window->source->value(buf);
			found = 1;
		}
	}
	if(found == 0)
	{
		if(win->new_source_window->select_x11_window != NULL)
		{
			win->new_source_window->select_x11_window->hide();
			Fl::delete_widget(win->new_source_window->select_x11_window);
			win->new_source_window->select_x11_window = NULL;
		}
		win->new_source_window->select_x11_window = new SelectX11Window(win);
		win->pseudo_camera_window->hide();
	}
}

void	new_source_adj_color_cb(Fl_Widget *w, void *v)
{
	NewSourceWindow *nsw = (NewSourceWindow *)v;
	int rr = (int)nsw->local_red;
	int gg = (int)nsw->local_green;
	int bb = (int)nsw->local_blue;
	nsw->redraw();
}

void	new_source_adj_text_color_cb(Fl_Widget *w, void *v)
{
	NewSourceWindow *nsw = (NewSourceWindow *)v;
	int rr = (int)nsw->local_text_red;
	int gg = (int)nsw->local_text_green;
	int bb = (int)nsw->local_text_blue;
	nsw->redraw();
}

NewSourceWindow::NewSourceWindow(MyWin *in_win, int in_xx, int in_yy) : Dialog(in_xx, in_yy, 690, 700, "New Source")
{
char	buf[256];
int		loop;

	my_window = in_win;
	edit_mode = 0;
	select_camera_window = NULL;
	select_x11_window = NULL;
	select_audio_window = NULL;

	int new_yp = 20;

	source = new SourceMultiline(20, new_yp + 20, 560, 140, "Source:");
	source->color(BLACK);
	source->textcolor(WHITE);
	source->textsize(11);
	source->cursor_color(WHITE);
	source->labelcolor(YELLOW);
	source->labelsize(9);
	source->box(FL_FRAME_BOX);
	source->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
	source->copy_tooltip("Source schemes are specified here. A single digit can be used to specify a camera number. If the text is not recognized as either one of the schemes or a single digit, it becoames a text source. Leaving this blank and selecting 'Create' will make a blank source.");

	alias = new Fl_Input(60, new_yp + 167, 520, 22, "Alias:");
	alias->color(BLACK);
	alias->textcolor(WHITE);
	alias->textsize(11);
	alias->cursor_color(WHITE);
	alias->labelcolor(YELLOW);
	alias->labelsize(9);
	alias->box(FL_FRAME_BOX);
	alias->align(FL_ALIGN_LEFT);
	alias->copy_tooltip("An alias for the source. The alias takes the place of the source path, and should be unique and easily readible.");

	int cx = 60;
	width = new Fl_Float_Input(cx, new_yp + 200, 50, 20, "Width:");
	width->color(BLACK);
	width->textcolor(WHITE);
	width->cursor_color(WHITE);
	width->labelcolor(YELLOW);
	width->labelsize(9);
	width->textsize(9);
	width->box(FL_FRAME_BOX);
	width->when(FL_WHEN_ENTER_KEY | FL_WHEN_NOT_CHANGED);
	sprintf(buf, "%d", my_window->requested_w);
	width->value(buf);
	width->copy_tooltip("The width resolution of the source.");
	cx += 100;
	height = new Fl_Float_Input(cx, new_yp + 200, 50, 20, "Height:");
	height->color(BLACK);
	height->textcolor(WHITE);
	height->cursor_color(WHITE);
	height->labelcolor(YELLOW);
	height->labelsize(9);
	height->textsize(9);
	height->box(FL_FRAME_BOX);
	height->when(FL_WHEN_ENTER_KEY | FL_WHEN_NOT_CHANGED);
	sprintf(buf, "%d", my_window->requested_h);
	height->value(buf);
	height->copy_tooltip("The height resolution of the source.");
	cx += 110;
	font_sz = new Fl_Int_Input(cx, new_yp + 200, 50, 20, "Font Size:");
	font_sz->color(BLACK);
	font_sz->textcolor(WHITE);
	font_sz->cursor_color(WHITE);
	font_sz->labelcolor(YELLOW);
	font_sz->labelsize(9);
	font_sz->textsize(9);
	font_sz->box(FL_FRAME_BOX);
	font_sz->when(FL_WHEN_ENTER_KEY | FL_WHEN_NOT_CHANGED);
	sprintf(buf, "%d", 32);
	font_sz->value(buf);
	font_sz->copy_tooltip("The font size for text-based sources.");
	cx += 110;

	int y_pos = new_yp + 240;
	local_red = 0;
	local_blue = 0;
	local_green = 0;
	local_alpha = 255;
	local_text_red = 255;
	local_text_blue = 255;
	local_text_green = 255;
	local_text_alpha = 255;

	color_panel = new ColorPanel(in_win, &local_red, &local_green, &local_blue, &local_alpha, 4, y_pos, 450, 142);
	color_panel->red->copy_tooltip("The red value for the background of the source, if applicable.");
	color_panel->green->copy_tooltip("The green value for the background of the source, if applicable.");
	color_panel->blue->copy_tooltip("The blue value for the background of the source, if applicable.");
	color_panel->alpha->copy_tooltip("The alpha value for the background of the source, if applicable.");
	y_pos += 150;

	local_text_red = 255;
	local_text_blue = 255;
	local_text_green = 255;
	local_text_alpha = 255;
	text_color_panel = new ColorPanel(in_win, &local_text_red, &local_text_green, &local_text_blue, &local_text_alpha, 4, y_pos, 450, 142);
	text_color_panel->red->copy_tooltip("The red value for the text appearing in the source, if applicable.");
	text_color_panel->green->copy_tooltip("The green value for the text appearing in the source, if applicable.");
	text_color_panel->blue->copy_tooltip("The blue value for the text appearing in the source, if applicable.");
	text_color_panel->alpha->copy_tooltip("The alpha value for the text appearing in the source, if applicable.");
	y_pos += 150;

	font_browser = new Fl_Hold_Browser(60, y_pos, 385, 70, "Font");
	font_browser->color(BLACK);
	font_browser->box(FL_FRAME_BOX);
	font_browser->textcolor(WHITE);
	font_browser->labelcolor(YELLOW);
	font_browser->labelsize(9);
	font_browser->textsize(9);
	font_browser->selection_color(YELLOW);
	font_browser->scrollbar.color(BLACK);
	font_browser->align(FL_ALIGN_LEFT_TOP);
	font_browser->copy_tooltip("The font for text appearing in the source, if applicable.");
	int nn = my_window->number_of_fonts;
	for(loop = 0;loop < nn;loop++)
	{
		char *str = (char *)Fl::get_font_name(loop);
		char buf[256];
		sprintf(buf, "@F%05d%s", loop, str);
		font_browser->add(buf);
	}
	font_browser->select(1);

	create = new MyButton(cx, new_yp + 200, 60, 20, "Create");
	create->color(DARK_GRAY);
	create->labelcolor(YELLOW);
	create->labelsize(9);
	create->box(FL_FRAME_BOX);
	create->callback(new_source_cb, my_window);
	create->copy_tooltip("Creates a new source based on specified values in this dialog.");
	cx += 70;

	reset = new MyButton(cx, new_yp + 200, 60, 20, "Reset");
	reset->color(DARK_GRAY);
	reset->labelcolor(YELLOW);
	reset->labelsize(9);
	reset->box(FL_FRAME_BOX);
	reset->callback(reset_new_source_cb, my_window);
	reset->copy_tooltip("Resets fields to default values.");
	cx += 70;

	cancel = new MyButton(cx, new_yp + 200, 60, 20, "Cancel");
	cancel->color(DARK_GRAY);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(9);
	cancel->box(FL_FRAME_BOX);
	cancel->callback(cancel_new_source_cb, my_window);
	cancel->copy_tooltip("Closes the dialog without creating a new source.");
	
	int yp = 20 + new_yp;
	camera_select = new MyButton(590, yp, 80, 20, "Camera");
	camera_select->color(DARK_GRAY);
	camera_select->labelcolor(YELLOW);
	camera_select->labelsize(9);
	camera_select->box(FL_FRAME_BOX);
	camera_select->callback(new_source_camera_select_cb, my_window);
	camera_select->copy_tooltip("Create a new source from one of the others.");
	yp += 24;

	audio_select = new MyButton(590, yp, 80, 20, "Audio");
	audio_select->color(DARK_GRAY);
	audio_select->labelcolor(YELLOW);
	audio_select->labelsize(9);
	audio_select->box(FL_FRAME_BOX);
	audio_select->callback(new_source_audio_select_cb, my_window);
	audio_select->copy_tooltip("Create a new audio source.");
	yp += 24;

	box_select = new MyButton(590, yp, 80, 20, "Box Select");
	box_select->color(DARK_GRAY);
	box_select->labelcolor(YELLOW);
	box_select->labelsize(9);
	box_select->box(FL_FRAME_BOX);
	box_select->callback(new_source_box_select_cb, my_window);
	box_select->copy_tooltip("Use a mouse-drag rubberband select to create a new source from a portion of the screen.");
	yp += 24;

	window_select = new MyButton(590, yp, 80, 20, "Window Select");
	window_select->color(DARK_GRAY);
	window_select->labelcolor(YELLOW);
	window_select->labelsize(9);
	window_select->box(FL_FRAME_BOX);
	window_select->callback(new_source_window_select_cb, my_window);
	window_select->copy_tooltip("Create a new source from an existing window.");
	yp += 24;

	desktop_select = new MyButton(590, yp, 80, 20, "Desktop Select");
	desktop_select->color(DARK_GRAY);
	desktop_select->labelcolor(YELLOW);
	desktop_select->labelsize(9);
	desktop_select->box(FL_FRAME_BOX);
	desktop_select->callback(new_source_desktop_select_cb, my_window);
	desktop_select->copy_tooltip("Create a new source from the desktop.");
	yp += 24;

	image_file_select = new MyButton(590, yp, 80, 20, "Image File");
	image_file_select->color(DARK_GRAY);
	image_file_select->labelcolor(YELLOW);
	image_file_select->labelsize(9);
	image_file_select->box(FL_FRAME_BOX);
	image_file_select->callback(new_source_image_file_select_cb, my_window);
	image_file_select->copy_tooltip("Create a new source from an image file.");
	yp += 24;

	av_file_select = new MyButton(590, yp, 80, 20, "AV File");
	av_file_select->color(DARK_GRAY);
	av_file_select->labelcolor(YELLOW);
	av_file_select->labelsize(9);
	av_file_select->box(FL_FRAME_BOX);
	av_file_select->callback(new_source_av_file_select_cb, my_window);
	av_file_select->copy_tooltip("Create a new source from an audio/video file.");
	yp += 24;

	vector_file_select = new MyButton(590, yp, 80, 20, "Vector File");
	vector_file_select->color(DARK_GRAY);
	vector_file_select->labelcolor(YELLOW);
	vector_file_select->labelsize(9);
	vector_file_select->box(FL_FRAME_BOX);
	vector_file_select->callback(new_source_vector_file_select_cb, my_window);
	vector_file_select->copy_tooltip("Create a new source from a vector graphics file.");
	yp += 24;

	html_select = NULL;
	html_source_select = NULL;
	if(global_html == 1)
	{
		html_select = new MyButton(590, yp, 80, 20, "HTTP");
		html_select->color(DARK_GRAY);
		html_select->labelcolor(YELLOW);
		html_select->labelsize(9);
		html_select->box(FL_FRAME_BOX);
		html_select->callback(new_source_html_select_cb, my_window);
		html_select->copy_tooltip("Create a new source from a URL.");
		yp += 24;

		html_source_select = new MyButton(590, yp, 80, 20, "HTML");
		html_source_select->color(DARK_GRAY);
		html_source_select->labelcolor(YELLOW);
		html_source_select->labelsize(9);
		html_source_select->box(FL_FRAME_BOX);
		html_source_select->callback(new_source_html_source_select_cb, my_window);
		html_source_select->copy_tooltip("Create a new source from HTML specified in this dialog.");
		yp += 24;
	}
	if(NDILib != NULL)
	{
		ndi_source_select = new MyButton(590, yp, 80, 20, "NDI");
		ndi_source_select->color(DARK_GRAY);
		ndi_source_select->labelcolor(YELLOW);
		ndi_source_select->labelsize(9);
		ndi_source_select->box(FL_FRAME_BOX);
		ndi_source_select->callback(new_source_ndi_select_cb, my_window);
		ndi_source_select->copy_tooltip("Create a new source from a NDI stream on the network.");
		yp += 24;
	}
	irc_source_select = new MyButton(590, yp, 80, 20, "IRC");
	irc_source_select->color(DARK_GRAY);
	irc_source_select->labelcolor(YELLOW);
	irc_source_select->labelsize(9);
	irc_source_select->box(FL_FRAME_BOX);
	irc_source_select->callback(new_source_irc_select_cb, my_window);
	irc_source_select->copy_tooltip("Create a new source from an IRC stream on the network.");
	yp += 24;

	sourced_select = new MyButton(590, yp, 80, 20, "Source Camera");
	sourced_select->color(DARK_GRAY);
	sourced_select->labelcolor(YELLOW);
	sourced_select->labelsize(9);
	sourced_select->box(FL_FRAME_BOX);
	sourced_select->callback(new_sourced_select_cb, my_window);
	sourced_select->copy_tooltip("Create a new source linked to the currently displayed source.");
	yp += 24;
	edge_detect_select = new MyButton(590, yp, 80, 20, "Edge Detect");
	edge_detect_select->color(DARK_GRAY);
	edge_detect_select->labelcolor(YELLOW);
	edge_detect_select->labelsize(9);
	edge_detect_select->box(FL_FRAME_BOX);
	edge_detect_select->callback(new_edge_detect_select_cb, my_window);
	edge_detect_select->copy_tooltip("Create a new source from one of the others and highlight found edges.");
	yp += 24;
	chromakey_green_select = new MyButton(590, yp, 80, 20, "Green Key");
	chromakey_green_select->color(DARK_GRAY);
	chromakey_green_select->labelcolor(YELLOW);
	chromakey_green_select->labelsize(9);
	chromakey_green_select->box(FL_FRAME_BOX);
	chromakey_green_select->callback(new_chromakey_select_cb, my_window);
	chromakey_green_select->copy_tooltip("Create a new source from one of the others and mask the green content.");
	yp += 24;
	chromakey_blue_select = new MyButton(590, yp, 80, 20, "Blue Key");
	chromakey_blue_select->color(DARK_GRAY);
	chromakey_blue_select->labelcolor(YELLOW);
	chromakey_blue_select->labelsize(9);
	chromakey_blue_select->box(FL_FRAME_BOX);
	chromakey_blue_select->callback(new_chromakey_select_cb, my_window);
	chromakey_blue_select->copy_tooltip("Create a new source from one of the others and mask the blue content.");
	yp += 24;
	alternating_select = new MyButton(590, yp, 80, 20, "Alternating");
	alternating_select->color(DARK_GRAY);
	alternating_select->labelcolor(YELLOW);
	alternating_select->labelsize(9);
	alternating_select->box(FL_FRAME_BOX);
	alternating_select->callback(new_alternating_source_select_cb, my_window);
	alternating_select->copy_tooltip("Create a new source from all of the others and slowly alternate between them.");
	yp += 24;
	all_select = new MyButton(590, yp, 80, 20, "All");
	all_select->color(DARK_GRAY);
	all_select->labelcolor(YELLOW);
	all_select->labelsize(9);
	all_select->box(FL_FRAME_BOX);
	all_select->callback(new_all_source_select_cb, my_window);
	all_select->copy_tooltip("Create a new source from all of the others and arrange them on a split screen.");
	yp += 24;
	split_select = new MyButton(590, yp, 80, 20, "Split");
	split_select->color(DARK_GRAY);
	split_select->labelcolor(YELLOW);
	split_select->labelsize(9);
	split_select->box(FL_FRAME_BOX);
	split_select->callback(new_split_source_select_cb, my_window);
	split_select->copy_tooltip("Create a new source on a split screen allowing selection of number of splits and sources within each.");
	yp += 24;
	pipe_select = new MyButton(590, yp, 80, 20, "Pipe");
	pipe_select->color(DARK_GRAY);
	pipe_select->labelcolor(YELLOW);
	pipe_select->labelsize(9);
	pipe_select->box(FL_FRAME_BOX);
	pipe_select->callback(new_source_pipe_select_cb, my_window);
	pipe_select->copy_tooltip("Create a new source by collecting text arriving from a pipe of another program.");
	yp += 24;
	single_frame_file_select = new MyButton(590, yp, 80, 20, "Frame File");
	single_frame_file_select->color(DARK_GRAY);
	single_frame_file_select->labelcolor(YELLOW);
	single_frame_file_select->labelsize(9);
	single_frame_file_select->box(FL_FRAME_BOX);
	single_frame_file_select->callback(new_source_frame_file_select_cb, my_window);
	single_frame_file_select->copy_tooltip("Create a new source from a file that is a collection of still frames.");
	yp += 24;
	clock_timer_select = new MyButton(590, yp, 80, 20, "Clock / Timer");
	clock_timer_select->color(DARK_GRAY);
	clock_timer_select->labelcolor(YELLOW);
	clock_timer_select->labelsize(9);
	clock_timer_select->box(FL_FRAME_BOX);
	clock_timer_select->callback(new_source_clock_timer_select_cb, my_window);
	clock_timer_select->copy_tooltip("Create a new source that is the text representation of a clock or timer.");
	yp += 24;
	dynamic_text_select = new MyButton(590, yp, 80, 20, "Dynamic Text");
	dynamic_text_select->color(DARK_GRAY);
	dynamic_text_select->labelcolor(YELLOW);
	dynamic_text_select->labelsize(9);
	dynamic_text_select->box(FL_FRAME_BOX);
	dynamic_text_select->callback(new_source_dynamic_text_select_cb, my_window);
	dynamic_text_select->copy_tooltip("Create a new text source that updates dynamically.");
	yp += 24;
	alert_select = new MyButton(590, yp, 80, 20, "Alert");
	alert_select->color(DARK_GRAY);
	alert_select->labelcolor(YELLOW);
	alert_select->labelsize(9);
	alert_select->box(FL_FRAME_BOX);
	alert_select->callback(new_source_alert_select_cb, my_window);
	alert_select->copy_tooltip("Create a new source that can be triggered by external conditions.");
	yp += 24;
	slideshow_select = new MyButton(590, yp, 80, 20, "Slideshow");
	slideshow_select->color(DARK_GRAY);
	slideshow_select->labelcolor(YELLOW);
	slideshow_select->labelsize(9);
	slideshow_select->box(FL_FRAME_BOX);
	slideshow_select->callback(new_source_slideshow_select_cb, my_window);
	slideshow_select->copy_tooltip("Create a new source using a list of image files as a slideshow.");
	yp += 24;
	slideshow_directory_select = new MyButton(590, yp, 80, 20, "Dir Slideshow");
	slideshow_directory_select->color(DARK_GRAY);
	slideshow_directory_select->labelcolor(YELLOW);
	slideshow_directory_select->labelsize(9);
	slideshow_directory_select->box(FL_FRAME_BOX);
	slideshow_directory_select->callback(new_source_directory_slideshow_select_cb, my_window);
	slideshow_directory_select->copy_tooltip("Create a new source using a directory of image files as a slideshow.");
	yp += 24;
	if(global_osg_enabled == 1)
	{
		osg_select = new MyButton(590, yp, 80, 20, "OSG");
		osg_select->color(DARK_GRAY);
		osg_select->labelcolor(YELLOW);
		osg_select->labelsize(9);
		osg_select->box(FL_FRAME_BOX);
		osg_select->callback(new_source_osg_select_cb, my_window);
		osg_select->copy_tooltip("Create a new source by rendering an OSG 3D file.");
		yp += 24;
	}
	pseudo_camera_select = NULL;
	if(void_pseudo_camera != NULL)
	{
		pseudo_camera_select = new MyButton(590, yp, 80, 20, "Pseudo Camera");
		pseudo_camera_select->color(DARK_GRAY);
		pseudo_camera_select->labelcolor(YELLOW);
		pseudo_camera_select->labelsize(9);
		pseudo_camera_select->box(FL_FRAME_BOX);
		pseudo_camera_select->callback(new_source_pseudo_camera_select_cb, my_window);
		pseudo_camera_select->copy_tooltip("Create a new source with the frames coming in from another program.");
		yp += 24;
	}
	plugin_camera_select = NULL;
	if(global_potential_camera_cnt > 0)
	{
		plugin_camera_select = new MyButton(590, yp, 80, 20, "Plugin Camera");
		plugin_camera_select->color(DARK_GRAY);
		plugin_camera_select->labelcolor(YELLOW);
		plugin_camera_select->labelsize(9);
		plugin_camera_select->box(FL_FRAME_BOX);
		plugin_camera_select->callback(new_source_plugin_camera_select_cb, my_window);
		plugin_camera_select->copy_tooltip("Create a new source with the frames coming in a plug-in in a shared library.");
		yp += 24;
	}
	end();
	hide();
}

NewSourceWindow::~NewSourceWindow()
{
	if(select_camera_window != NULL)
	{
		select_camera_window->hide();
		Fl::delete_widget(select_camera_window);
		select_camera_window = NULL;
	}
	if(select_x11_window != NULL)
	{
		select_x11_window->hide();
		Fl::delete_widget(select_x11_window);
		select_x11_window = NULL;
	}
	if(select_audio_window != NULL)
	{
		select_audio_window->hide();
		Fl::delete_widget(select_audio_window);
		select_audio_window = NULL;
	}
	if(my_window->specify_url_window != NULL)
	{
		my_window->specify_url_window->hide();
	}
}

void	NewSourceWindow::Show(int e_mode)
{
int	loop;

	edit_mode = e_mode;
	if(edit_mode == 1)
	{
		if(create != NULL) 
		{
			create->copy_label("Accept");
			create->callback(edit_source_cb, my_window);
		}
		if(camera_select != NULL) camera_select->hide();
		if(audio_select != NULL) audio_select->hide();
		if(box_select != NULL) box_select->hide();
		if(window_select != NULL) window_select->hide();
		if(desktop_select != NULL) desktop_select->hide();
		if(av_file_select != NULL) av_file_select->hide();
		if(image_file_select != NULL) image_file_select->hide();
		if(html_select != NULL) html_select->hide();
		if(html_source_select != NULL) html_source_select->hide();
		if(sourced_select != NULL) sourced_select->hide();
		if(edge_detect_select != NULL) edge_detect_select->hide();
		if(chromakey_green_select != NULL) chromakey_green_select->hide();
		if(chromakey_blue_select != NULL) chromakey_blue_select->hide();
		if(alternating_select != NULL) alternating_select->hide();
		if(all_select != NULL) all_select->hide();
		if(pseudo_camera_select != NULL) pseudo_camera_select->hide();
		if(plugin_camera_select != NULL) plugin_camera_select->hide();
		Camera *cam = my_window->DisplayedCamera();
		if(cam != NULL)
		{
			source->value(cam->path);
			alias->value(cam->alias);
			width->value(cam->mat.cols);
			height->value(cam->mat.rows);
			font_sz->value(cam->font_sz);
			if(strlen(cam->font_name) > 0)
			{
				for(loop = 1;loop <= font_browser->size();loop++)
				{
					char *txt = (char *)font_browser->text(loop);
					if(txt != NULL)
					{
						if(strcmp(cam->font_name, txt) == 0)
						{
							font_browser->value(loop);
						}
					}
				}
			}
			local_red = cam->red;
			local_green = cam->green;
			local_blue = cam->blue;
			local_alpha = cam->alpha;
			local_text_red = cam->text_red;
			local_text_green = cam->text_green;
			local_text_blue = cam->text_blue;
			local_text_alpha = cam->text_alpha;
		}
		show();
		resize(x(), y(), 590, h());
	}
	else
	{
		if(create != NULL) 
		{
			create->copy_label("Create");
			create->callback(new_source_cb, my_window);
		}
		if(camera_select != NULL) camera_select->show();
		if(audio_select != NULL) audio_select->show();
		if(box_select != NULL) box_select->show();
		if(window_select != NULL) window_select->show();
		if(desktop_select != NULL) desktop_select->show();
		if(av_file_select != NULL) av_file_select->show();
		if(image_file_select != NULL) image_file_select->show();
		if(html_select != NULL) html_select->show();
		if(html_source_select != NULL) html_source_select->show();
		if(sourced_select != NULL) sourced_select->show();
		if(edge_detect_select != NULL) edge_detect_select->show();
		if(chromakey_green_select != NULL) chromakey_green_select->show();
		if(chromakey_blue_select != NULL) chromakey_blue_select->show();
		if(alternating_select != NULL) alternating_select->show();
		if(all_select != NULL) all_select->show();
		if(pseudo_camera_select != NULL) pseudo_camera_select->show();
		if(plugin_camera_select != NULL) plugin_camera_select->show();
		width->value(my_window->requested_w);
		height->value(my_window->requested_h);
		show();
		resize(x(), y(), 690, h());
	}
}

void	NewSourceWindow::hide()
{
	if(select_camera_window != NULL)
	{
		select_camera_window->hide();
		Fl::delete_widget(select_camera_window);
		select_camera_window = NULL;
	}
	if(select_x11_window != NULL)
	{
		select_x11_window->hide();
		Fl::delete_widget(select_x11_window);
		select_x11_window = NULL;
	}
	if(select_audio_window != NULL)
	{
		select_audio_window->hide();
		Fl::delete_widget(select_audio_window);
		select_audio_window = NULL;
	}
	if(my_window->ndi_source_window != NULL)
	{
		my_window->ndi_source_window->hide();
	}
	if(my_window->specify_irc_window != NULL)
	{
		my_window->specify_irc_window->hide();
	}
	if(my_window->specify_url_window != NULL)
	{
		my_window->specify_url_window->hide();
	}
	if(my_window->timer_window != NULL)
	{
		my_window->timer_window->hide();
	}
	if(my_window->alert_window != NULL)
	{
		my_window->alert_window->hide();
	}
	if(my_window->pseudo_camera_window != NULL)
	{
		my_window->pseudo_camera_window->hide();
	}
	Dialog::hide();
}

int	NewSourceWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == FL_Escape)
		{
			hide();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

// SECTION *********************************** SELECT OBJECTS *******************************************

void	Camera::SetObjectInAllOtherCameras()
{
int	loop;
int	inner;

	for(loop = 0;loop < my_window->source_cnt;loop++)
	{
		if(my_window->camera[loop] != NULL)
		{
			Camera *cam = my_window->camera[loop];
			if(cam->type == CAMERA_TYPE_CAMERA)
			{
				for(inner = 0;inner < my_window->recognize_class_cnt;inner++)
				{
					cam->object_index[inner] = object_index[inner];
				}
			}
		}
	}
}

void	select_objects_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			char *label = (char *)w->label();
			if(label != NULL)
			{
				for(loop = 0;loop < win->recognize_class_cnt;loop++)
				{
					if(strcmp(label, win->recognize_class_name[loop]) == 0)
					{
						if(cam->object_index[loop] == 0)
						{
							cam->object_index[loop] = 1;
							w->labelcolor(WHITE);
						}
						else
						{
							cam->object_index[loop] = 0;
							w->labelcolor(YELLOW);
						}
					}
				}
			}
			win->redraw();
		}
	}
}

void	clear_select_objects_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			for(loop = 0;loop < win->recognize_class_cnt;loop++)
			{
				cam->object_index[loop] = 0;
			}
			win->redraw();
			win->ShowObjects();
		}
	}
}

void	select_all_objects_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			for(loop = 0;loop < win->recognize_class_cnt;loop++)
			{
				cam->object_index[loop] = 1;
			}
			win->redraw();
			win->ShowObjects();
		}
	}
}

void	apply_all_select_objects_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			cam->SetObjectInAllOtherCameras();
		}
	}
}

void	done_select_objects_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->HideObjects();
		win->toggle_objects_button->copy_label("Select Objects");
	}
}

void	next_page_objects_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->object_menu->object_page++;
		win->ShowObjects();
	}
}

void	prev_page_objects_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		if(win->object_menu->object_page > 0)
		{
			win->object_menu->object_page--;
		}
		win->ShowObjects();
	}
}

// SECTION *********************************** PULSE AUDIO FILTER *******************************************

void	pulse_audio_filter_window_cb(Fl_Widget *b, void *v)
{
	PulseAudioFilterWindow *pafw = (PulseAudioFilterWindow *)v;
	if(pafw->mic != NULL)
	{
		pafw->mic->low_pass = pafw->low_pass_button->value();
		pafw->mic->high_pass = pafw->high_pass_button->value();
		pafw->mic->reverb = pafw->reverb_button->value();
		pafw->mic->compress = pafw->compress_button->value();

		pafw->mic->low_pass_frequency = pafw->low_pass_slider->value();
		pafw->mic->high_pass_frequency = pafw->high_pass_slider->value();
		pafw->mic->reverb_delay = pafw->reverb_delay_slider->value();
		pafw->mic->reverb_decay = pafw->reverb_decay_slider->value();
		pafw->mic->compress_low = pafw->compress_low_slider->value();
		pafw->mic->compress_high = pafw->compress_high_slider->value();
		pafw->mic->compress_percent = pafw->compress_percent_slider->value();
	}
}

PulseAudioFilterWindow::PulseAudioFilterWindow(MyWin *in_win) : Dialog(320, 290, "Audio Effects")
{
	my_window = in_win;
	set_non_modal();
	box(FL_FRAME_BOX);
	color(BLACK);
	int new_yp = 20;

	mic = NULL;

	int start_y = 10 + new_yp;
	low_pass_button = new MyToggleButton(90, start_y, 200, 20, "Low Pass Filter");
	low_pass_button->color(BLACK);
	low_pass_button->labelcolor(YELLOW);
	low_pass_button->labelsize(9);
	low_pass_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	low_pass_button->box(FL_FLAT_BOX);
	low_pass_button->callback(pulse_audio_filter_window_cb, this);
	start_y += 21;

	low_pass_slider = new MySlider(90, start_y, 200, 16, "Low Pass Cut");
	low_pass_slider->range(0.0, 1.0);
	low_pass_slider->value(0.5);
	low_pass_slider->step(0.01);
	low_pass_slider->initial_value = 0.5;
	low_pass_slider->labelsize(9);
	low_pass_slider->callback(pulse_audio_filter_window_cb, this);
	start_y += 24;

	high_pass_button = new MyToggleButton(90, start_y, 200, 20, "High Pass Filter");
	high_pass_button->color(BLACK);
	high_pass_button->labelcolor(YELLOW);
	high_pass_button->labelsize(9);
	high_pass_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	high_pass_button->box(FL_FLAT_BOX);
	high_pass_button->callback(pulse_audio_filter_window_cb, this);
	start_y += 21;

	high_pass_slider = new MySlider(90, start_y, 200, 16, "High Pass Cut");
	high_pass_slider->range(0.0, 1.0);
	high_pass_slider->value(0.5);
	high_pass_slider->step(0.01);
	high_pass_slider->initial_value = 0.5;
	high_pass_slider->labelsize(9);
	high_pass_slider->callback(pulse_audio_filter_window_cb, this);
	start_y += 24;

	reverb_button = new MyToggleButton(90, start_y, 200, 20, "Reverb");
	reverb_button->color(BLACK);
	reverb_button->labelcolor(YELLOW);
	reverb_button->labelsize(9);
	reverb_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	reverb_button->box(FL_FLAT_BOX);
	reverb_button->callback(pulse_audio_filter_window_cb, this);
	start_y += 21;

	reverb_delay_slider = new MySlider(90, start_y, 200, 16, "Delay");
	reverb_delay_slider->range(0.0, 1.0);
	reverb_delay_slider->value(0.25);
	reverb_delay_slider->step(0.01);
	reverb_delay_slider->initial_value = 0.25;
	reverb_delay_slider->labelsize(9);
	reverb_delay_slider->callback(pulse_audio_filter_window_cb, this);
	start_y += 21;

	reverb_decay_slider = new MySlider(90, start_y, 200, 16, "Decay");
	reverb_decay_slider->range(0.0, 1.0);
	reverb_decay_slider->value(0.75);
	reverb_decay_slider->step(0.01);
	reverb_decay_slider->initial_value = 0.75;
	reverb_decay_slider->labelsize(9);
	reverb_decay_slider->callback(pulse_audio_filter_window_cb, this);
	start_y += 24;

	compress_button = new MyToggleButton(90, start_y, 200, 20, "Compress");
	compress_button->color(BLACK);
	compress_button->labelcolor(YELLOW);
	compress_button->labelsize(9);
	compress_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	compress_button->box(FL_FLAT_BOX);
	compress_button->callback(pulse_audio_filter_window_cb, this);
	start_y += 21;

	compress_low_slider = new MySlider(90, start_y, 200, 16, "Low Amp");
	compress_low_slider->range(0.0, 1.0);
	compress_low_slider->value(0.25);
	compress_low_slider->step(0.01);
	compress_low_slider->initial_value = 0.25;
	compress_low_slider->labelsize(9);
	compress_low_slider->callback(pulse_audio_filter_window_cb, this);
	start_y += 21;

	compress_high_slider = new MySlider(90, start_y, 200, 16, "High Amp");
	compress_high_slider->range(0.0, 1.0);
	compress_high_slider->value(0.75);
	compress_high_slider->step(0.01);
	compress_high_slider->initial_value = 0.75;
	compress_high_slider->labelsize(9);
	compress_high_slider->callback(pulse_audio_filter_window_cb, this);
	start_y += 21;

	compress_percent_slider = new MySlider(90, start_y, 200, 16, "Amount");
	compress_percent_slider->range(0.0, 1.0);
	compress_percent_slider->value(0.1);
	compress_percent_slider->step(0.01);
	compress_percent_slider->initial_value = 0.1;
	compress_percent_slider->labelsize(9);
	compress_percent_slider->callback(pulse_audio_filter_window_cb, this);
	start_y += 28;

	close = new MyButton((w() / 2) - 30, start_y, 60, 20, "Close");
	close->box(FL_FLAT_BOX);
	close->color(BLACK);
	close->labelcolor(YELLOW);
	close->labelsize(11);
	close->callback(hide_window_cb, this);
	end();
}

PulseAudioFilterWindow::~PulseAudioFilterWindow()
{
}

void	PulseAudioFilterWindow::show()
{
	if(mic != NULL)
	{
		low_pass_button->value(mic->low_pass);
		low_pass_slider->value(mic->low_pass_frequency);
		high_pass_button->value(mic->high_pass);
		high_pass_slider->value(mic->high_pass_frequency);
		reverb_button->value(mic->reverb);
		reverb_delay_slider->value(mic->reverb_delay);
		reverb_decay_slider->value(mic->reverb_decay);
		compress_button->value(mic->compress);
		compress_high_slider->value(mic->compress_high);
		compress_low_slider->value(mic->compress_low);
		compress_percent_slider->value(mic->compress_percent);
	}
	Dialog::show();
}

// SECTION *********************************** PULSE AUDIO *******************************************

void	pulse_audio_select_cb(Fl_Widget *w, void *v)
{
	PulseAudioButton *b = (PulseAudioButton *)v;
	MyWin *win = b->my_window;
	if(b->select_button->value())
	{
		b->Start();
	}
	else
	{
		b->Stop();
	}
	b->redraw();
}

void	pulse_audio_filter_cb(Fl_Widget *w, void *v)
{
	PulseAudioButton *b = (PulseAudioButton *)v;
	MyWin *win = b->my_window;
	if(b->filter_button->value())
	{
		win->pulse_audio_filter_window->mic = b->microphone;
		win->pulse_audio_filter_window->show();
	}
	else
	{
		win->pulse_audio_filter_window->hide();
	}
}

PulseMixer::PulseMixer(MyWin *in_win, int sz, int ch)
{
int	loop;

	my_window = in_win;
	direct_mix_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
	buffer = (SAMPLE *)malloc(sz * sizeof(SAMPLE) * ch);
	memset(buffer, 0, sz * sizeof(SAMPLE) * ch);
	preserve = (SAMPLE *)malloc(sz * sizeof(SAMPLE) * ch);
	memset(preserve, 0, sz * sizeof(SAMPLE) * ch);
	size = sz * ch;
	mix_ready = 0;
	recording = 0;
	first = 1;
	done = 0;
	mute = 0;
	out_fd = -1;
	continued = 0;
	channels = ch;

	monitor = 0;
	fft_calc = 0;

	for(loop = 0;loop < 10;loop++)
	{
		supplemental_buffer[loop] = NULL;
		supplemental_current_position[loop] = 0;
		supplemental_total_size[loop] = 0;
	}
	for(loop = 0;loop < 10;loop++)
	{
		play_buffer[loop] = (SAMPLE *)malloc(sz * sizeof(SAMPLE) * ch);
		pa_monitor[loop] = new PulseAudio(NULL, MODE_PLAY, sz, my_window->audio_sample_rate, ch, play_buffer[loop]);
		pa_monitor[loop]->sample_ready_cb = NULL;
		pa_monitor[loop]->Play();
		pa_monitor[loop]->Pause();
	}
	monitor_cnt = 1;

	fft_in_buffer = (double *)malloc(sz * sizeof(double));
	fft_out_buffer = (double *)malloc(sz * sizeof(double));
	fft_plan = fftw_plan_r2r_1d(sz, fft_in_buffer, fft_out_buffer, FFTW_R2HC, FFTW_ESTIMATE);

	double sampleRatio = sz / (double)my_window->audio_sample_rate;
	fft_start_index = std::ceil(sampleRatio * 20.0);
	fft_spectro_size = min(std::ceil(sampleRatio * 8000.0), sz / 2.0) - fft_start_index;
	for(loop = 0;loop < 100;loop++)
	{
		fft_frequency[loop] = 0.0;
	}
	fft_frequency_cnt = 0;
}

PulseMixer::~PulseMixer()
{
int	loop;

	done = 1;
	fft_calc = 0;
	my_window->audio_direct_mix = 0;
	usleep(100000);
	pthread_mutex_lock(&direct_mix_mutex);
	for(loop = 0;loop < 10;loop++)
	{
		if(supplemental_buffer[loop] != NULL)
		{
			free(supplemental_buffer[loop]);
			supplemental_buffer[loop] = NULL;
		}
	}
	for(loop = 0;loop < 10;loop++)
	{
		if(pa_monitor[loop] != NULL)
		{
			pa_monitor[loop]->Pause();
			pa_monitor[loop]->Stop();
			usleep(100000);
			delete pa_monitor[loop];
		}
	}
	if(buffer != NULL)
	{
		free(buffer);
	}
	if(preserve != NULL)
	{
		free(preserve);
	}
	fftw_destroy_plan(fft_plan);
	fftw_free(fft_in_buffer);
	fftw_free(fft_out_buffer);
	pthread_mutex_unlock(&direct_mix_mutex);
}

void	PulseMixer::MixSupplemental(int idx, SAMPLE *wav, int number_of_samples, int channels)
{
int	loop;

	pthread_mutex_lock(&direct_mix_mutex);
	if(supplemental_buffer[idx] != NULL)
	{
		free(supplemental_buffer[idx]);
		supplemental_buffer[idx] = NULL;
	}
	supplemental_buffer[idx] = (SAMPLE *)malloc(number_of_samples * (sizeof(SAMPLE) * channels));
	if(supplemental_buffer[idx] != NULL)
	{
		memcpy(supplemental_buffer[idx], wav, number_of_samples * (sizeof(SAMPLE) * channels));
		supplemental_current_position[idx] = 0;
		supplemental_total_size[idx] = number_of_samples * channels;
	}
	else
	{
		fprintf(stderr, "Error: Could not allocate audio supplemental buffer.\n");
	}
	pthread_mutex_unlock(&direct_mix_mutex);
}

void	PulseMixer::Mix(PulseMicrophone *mic)
{
int	loop;

	if(mute == 0)
	{
		if(first == 1)
		{
			for(loop = 0;loop < size;loop++)
			{
				int n1 = (int)mic->buffer[loop];
				int nn = 0;
				if((loop % 2) == 0)
				{
					nn = (int)((double)n1 * mic->volume1);
				}
				else
				{
					nn = (int)((double)n1 * mic->volume2);
				}
				buffer[loop] = (SAMPLE)nn;
			}
		}
		else
		{
			for(loop = 0;loop < size;loop++)
			{
				int n1 = (int)buffer[loop];
				int n2 = (int)mic->buffer[loop];
				int n3 = 0;
				if((loop % 2) == 0)
				{
					n3 = (int)((double)n2 * mic->volume1);
				}
				else
				{
					n3 = (int)((double)n2 * mic->volume2);
				}
				int nn = (n1 + n3) / 2;
				buffer[loop] = (SAMPLE)nn;
			}
		}
	}
	else
	{
		memset(buffer, 0, mic->buffer_size);
	}
	if(fft_calc == 1)
	{
		int cnt = 0;
		for(loop = 0;loop < size;loop += 2)
		{
			double avg = (double)((buffer[loop] + buffer[loop + 1]) / 2.0);
			double nn = (1.0 / 32768.0) * avg;
			fft_in_buffer[cnt] = nn;
			cnt++;
		}
		fftw_execute(fft_plan);
		fft_frequency_cnt = 0;
		int last_nn = -1;
		for(loop = 0;loop < 100;loop++) 
		{
			double proportion = std::pow(loop / 100.0, 4);
			int nn = (int)(fft_start_index + proportion * fft_spectro_size);
			if(nn != last_nn)
			{
				fft_frequency[fft_frequency_cnt] = fft_out_buffer[nn];
				fft_frequency_cnt++;
				last_nn = nn;
			}
		}
	}
}

void	PulseMixer::Mix(SAMPLE *wav, double volume)
{
int	loop;

	if(mute == 0)
	{
		if(first == 1)
		{
			for(loop = 0;loop < size;loop++)
			{
				int n1 = (int)wav[loop];
				int nn = 0;
				nn = (int)((double)n1 * volume);
				buffer[loop] = (SAMPLE)nn;
			}
		}
		else
		{
			for(loop = 0;loop < size;loop++)
			{
				int n1 = (int)buffer[loop];
				int n2 = (int)wav[loop];
				int n3 = 0;
				n3 = (int)((double)n2 * volume);
				int nn = (n1 + n3) / 2;
				buffer[loop] = (SAMPLE)nn;
			}
		}
	}
	else
	{
		memset(buffer, 0, size);
	}
	if(fft_calc == 1)
	{
		int cnt = 0;
		for(loop = 0;loop < size;loop += 2)
		{
			double avg = (double)((buffer[loop] + buffer[loop + 1]) / 2.0);
			double nn = (1.0 / 32768.0) * avg;
			fft_in_buffer[cnt] = nn;
			cnt++;
		}
		fftw_execute(fft_plan);
		fft_frequency_cnt = 0;
		int last_nn = -1;
		for(loop = 0;loop < 100;loop++) 
		{
			double proportion = std::pow(loop / 100.0, 4);
			int nn = (int)(fft_start_index + proportion * fft_spectro_size);
			if(nn != last_nn)
			{
				fft_frequency[fft_frequency_cnt] = fft_out_buffer[nn];
				fft_frequency_cnt++;
				last_nn = nn;
			}
		}
	}
}

void	PulseMixer::Mute()
{
	mute = 1;
}

void	PulseMixer::Unmute()
{
	mute = 0;
}

void	PulseMixer::Stop()
{
	recording = 0;
}

void	PulseMixer::Resume()
{
	recording = 1;
}

void pulse_grab_sample(void *in_win, PulseAudio *pa)
{
int	loop;

	MyWin *win = NULL;
	PulseMixer *mixer = NULL;
	if(in_win != NULL)
	{
		win = (MyWin *)in_win;
		mixer = win->pulse_mixer;
	}
	else if(pa != NULL)
	{
		PulseMicrophone *pm = (PulseMicrophone *)pa;
		win = pm->my_window;
		mixer = win->pulse_mixer;
	}
	if(pa != NULL)
	{
		PulseMicrophone *pm = (PulseMicrophone *)pa;
		if(pm->stop == 0)
		{
			if(pm->ndi_capture == 1)
			{
				pm->RecvNDI(pm->buffer);
				if(pa->buffer_size > 0)
				{
					int total = 0;
					int nn = pa->buffer_size / sizeof(SAMPLE);
					if(nn > 0)
					{
						for(loop = 0;loop < nn;loop++)
						{
							total += abs(pa->buffer[loop]);
						}
						double avg = (double)(total / nn);
						if(avg > 0.0)
						{
							pa->average = avg;
						}
					}
				}
			}
			for(loop = 0;loop < pm->filter_plugin_cnt;loop++)
			{
				void (*filter_audio)(int, int, int, int, int, double, void *);
				filter_audio = (void (*)(int, int, int, int, int, double, void *))pm->filter_plugin[loop];
				if(filter_audio != NULL)
				{
					filter_audio(pm->number_of_samples, pm->number_of_channels, pm->sample_count, pm->hz, pm->buffer_size, pm->volume1, (void *)pm->buffer);
				}
			}
			mixer->Mix(pm);
		}
	}
	if(mixer != NULL)
	{
		for(loop = 0;loop < 10;loop++)
		{
			if(mixer->supplemental_buffer[loop] != NULL)
			{
				pthread_mutex_lock(&mixer->direct_mix_mutex);
				if(mixer->pa_monitor[loop] != NULL)
				{
					if(mixer->pa_monitor[loop]->stop == 0)
					{
						if(mixer->pa_monitor[loop]->mini_pause == 0)
						{
							if((mixer->supplemental_current_position[loop] + mixer->size) < mixer->supplemental_total_size[loop])
							{
								mixer->Mix(mixer->supplemental_buffer[loop] + mixer->supplemental_current_position[loop], win->audio_incidental_volume);
								mixer->supplemental_current_position[loop] += mixer->size;
								if(mixer->supplemental_current_position[loop] >= mixer->supplemental_total_size[loop])
								{
									free(mixer->supplemental_buffer[loop]);
									mixer->supplemental_buffer[loop] = NULL;
								}
							}
							else
							{
								free(mixer->supplemental_buffer[loop]);
								mixer->supplemental_buffer[loop] = NULL;
							}
						}
					}
					else
					{
						free(mixer->supplemental_buffer[loop]);
						mixer->supplemental_buffer[loop] = NULL;
					}
				}
				pthread_mutex_unlock(&mixer->direct_mix_mutex);
			}
		}
	}
}

PulseMicrophone::PulseMicrophone(MyWin *in_win, char *dev_name, int hz, int ch) : PulseAudio(dev_name, MODE_RECORD, FRAMES_PER_BUFFER, hz, ch, NULL)
{
int	loop;

	my_window = in_win;
	in_use = 0;
	if(ch < 2) ch = 2;
	int sz = FRAMES_PER_BUFFER * sizeof(SAMPLE) * ch;
	buffer = (SAMPLE *)malloc(sz);
	memset(buffer, 0, sz);
	sample_ready_cb = pulse_grab_sample;
	strcpy(name, dev_name);
	filter_plugin_cnt = 0;
	ndi_recv = NULL;
	for(loop = 0;loop < 128;loop++)
	{
		filter_plugin[loop] = NULL;
		filter_plugin_name[loop] = NULL;
	}
	if(ndi_capture == 1)
	{
		if(strlen(ndi_path) > 0)
		{
			ndi_recv = FindNDI(ndi_path);
		}
	}
}

PulseMicrophone::~PulseMicrophone()
{
int	loop;

	if(ndi_recv != NULL)
	{
		if(NDILib != NULL)
		{
			NDILib->NDIlib_recv_destroy(ndi_recv);
			ndi_recv = NULL;
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(filter_plugin_name[loop] != NULL)
		{
			free(filter_plugin_name[loop]);
			filter_plugin_name[loop] = NULL;
		}
	}
	if(buffer != NULL)
	{
		free(buffer);
		buffer = NULL;
	}
}

void	PulseMicrophone::SaveAsJSON(FILE *fp)
{
int	loop;

	fprintf(fp, "{\n");
	fprintf(fp, "\t\"name\": \"%s\",\n", name);
	fprintf(fp, "\t\"in use\": %d,\n", in_use);
	fprintf(fp, "\t\"mute\": %d,\n", mute);
	fprintf(fp, "\t\"number of samples\": %d,\n", number_of_samples);
	fprintf(fp, "\t\"number of channels\": %d,\n", number_of_channels);
	fprintf(fp, "\t\"sample rate\": %d,\n", sample_rate);
	fprintf(fp, "\t\"ch\": %d,\n", ch);
	fprintf(fp, "\t\"sample count\": %d,\n", sample_count);
	fprintf(fp, "\t\"hz\": %d,\n", hz);
	fprintf(fp, "\t\"buffer size\": %d,\n", buffer_size);
	fprintf(fp, "\t\"volume1\": %f,\n", volume1);
	fprintf(fp, "\t\"volume2\": %f,\n", volume2);
	fprintf(fp, "\t\"is microphone\": %d,\n", is_microphone);
	fprintf(fp, "\t\"repeating\": %d,\n", repeating);
	fprintf(fp, "\t\"low pass\": %d,\n", low_pass);
	fprintf(fp, "\t\"low pass frequency\": %f,\n", low_pass_frequency);
	fprintf(fp, "\t\"high pass\": %d,\n", high_pass);
	fprintf(fp, "\t\"high pass frequency\": %f,\n", high_pass_frequency);
	fprintf(fp, "\t\"reverb\": %d,\n", reverb);
	fprintf(fp, "\t\"reverb delay\": %f,\n", reverb_delay);
	fprintf(fp, "\t\"reverb decay\": %f,\n", reverb_decay);
	fprintf(fp, "\t\"compress\": %d,\n", compress);
	fprintf(fp, "\t\"compress high\": %f,\n", compress_high);
	fprintf(fp, "\t\"compress low\": %f,\n", compress_low);
	fprintf(fp, "\t\"compress percent\": %f,\n", compress_percent);
	fprintf(fp, "\t\"filter plugin cnt\": %d,\n", filter_plugin_cnt);
	if(filter_plugin_cnt > 0)
	{
		int nn = filter_plugin_cnt - 1;
		fprintf(fp, "\t\t\"filter plugin name\": [");
		for(loop = 0;loop < filter_plugin_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", filter_plugin_name[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"ndi capture\": %d,\n", ndi_capture);
	fprintf(fp, "\t\"ndi path\": \"%s\"\n", ndi_path);
	fprintf(fp, "}");
}

void	MyWin::SaveMicrophones()
{
	if(access("./Microphones", 0) != 0)
	{
		mkdir("./Microphones", 0755);
	}
	chdir("./Microphones");
	char filename[4096];
	int r = my_file_chooser("Save an audio source set to a file", "*.json", "./Microphones", filename, 0, 1);
	if(r > 0)
	{
		if(strlen(filename) > 0)
		{
			FILE *fp = fopen(filename, "w");
			if(fp != NULL)
			{
				fprintf(fp, "{\n");
				SaveMicrophonesAsJSON(fp);
				fprintf(fp, "\n}\n");
				fclose(fp);
			}
			else
			{
				SetErrorMessage("Error: Cannot open file.");
			}
		}
	}
	chdir("..");
}

void	MyWin::LoadMicrophones()
{
struct stat sz;

	char path[4096];
	strcpy(path, "");
	int nn = my_file_chooser("Select an audio source set file", "*.json", "./Microphones", path);
	if(nn > 0)
	{
		if(access(path, 0) == 0)
		{
			char *buf = ReadWholeFile(path);
			if(buf != NULL)
			{
				cJSON *json = cJSON_Parse(buf);
				if(json == NULL)
				{
					const char *error_ptr = cJSON_GetErrorPtr();
					if(error_ptr != NULL)
					{
						fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
					}
				}
				else
				{
					ParseJSONMicrophones(json);
					cJSON_Delete(json);
				}
				free(buf);
			}
		}
	}
}

void	PulseMicrophone::RecvNDI(SAMPLE *audio_buffer)
{
NDIlib_video_frame_v2_t video_frame;
NDIlib_audio_frame_v2_t audio_frame;
NDIlib_metadata_frame_t metadata_frame;

	if(NDILib != NULL)
	{
		switch(NDILib->NDIlib_recv_capture_v2(ndi_recv, NULL, &audio_frame, NULL, 1000))
		{
			// No data
			case(NDIlib_frame_type_none):
			{
				fprintf(stderr, "No NDI audio data received.\n");
			}
			break;
			// Audio data
			case(NDIlib_frame_type_audio):
			{
				// Allocate enough space for 16bpp interleaved buffer
				NDIlib_audio_frame_interleaved_16s_t audio_frame_16bpp_interleaved;
				audio_frame_16bpp_interleaved.reference_level = 20; // We are going to have 20dB of headroom
				audio_frame_16bpp_interleaved.p_data = new short[audio_frame.no_samples * audio_frame.no_channels];
				int total_incoming_size = audio_frame.no_samples * audio_frame.no_channels * sizeof(short);

				// Convert it
				NDILib->NDIlib_util_audio_to_interleaved_16s_v2(&audio_frame, &audio_frame_16bpp_interleaved);

				// Free the original buffer
				NDILib->NDIlib_recv_free_audio_v2(ndi_recv, &audio_frame);

				// Feel free to do something with the interleaved audio data here
				if(total_incoming_size >= number_of_samples * number_of_channels * sizeof(SAMPLE))
				{
					memcpy(audio_buffer, audio_frame_16bpp_interleaved.p_data, number_of_samples * number_of_channels * sizeof(SAMPLE));
				}
				else
				{
					memcpy(audio_buffer, audio_frame_16bpp_interleaved.p_data, total_incoming_size);
				}
				// Free the interleaved audio data
				delete[] audio_frame_16bpp_interleaved.p_data;
			} 
			break;
			default:
			{
			}
			break;
		}
	}
}

int	pulse_play_all(int *flag)
{
int	pulse_play(int *flag);

	MyWin *in_win = (MyWin *)flag;
	if(in_win->pulse_mixer != NULL)
	{
		int cnt = in_win->pulse_mixer->monitor_cnt;
		if(in_win->pulse_mixer->pa_monitor[cnt] != NULL)
		{
			pulse_play((int *)in_win->pulse_mixer->pa_monitor[cnt]);
		}
		in_win->pulse_mixer->monitor_cnt++;
		if(in_win->pulse_mixer->monitor_cnt >= 10)
		{
			in_win->pulse_mixer->monitor_cnt = 1;
		}
	}
	return(0);
}

int	 pulse_record_all(int *flag)
{
int		simple_record(int *flag);
void	read_pulse_mic(PulseAudio *pa, int any_recording);
int		loop;

	time_t start = 0;
	double accum = 0;
	double adjust = 0.01575;
	MyWin *my_window = (MyWin *)flag;
	if(my_window->pulse_mixer != NULL)
	{
		while(my_window->pulse_mixer->done == 0)
		{
			int cnt = 0;
			int any_recording = 0;
			if((my_window->pulse_mixer->recording == 1) || (my_window->pulse_mixer->monitor == 1) || (my_window->ndi_streaming == 1))
			{
				if(start == 0)
				{
					start = time(0);
				}
				double elapsed = (double)(time(0) - start);
				accum += (double)((double)FRAMES_PER_BUFFER / (double)my_window->audio_sample_rate);
				if(accum > elapsed)
				{
					adjust += 0.0001;
				}
				else
				{
					adjust -= 0.0001;
				}
				any_recording = 1;
				PulseMixer *mix = my_window->pulse_mixer;
				mix->mix_ready = 0;
				mix->first = 1;
				memset(mix->buffer, 0, mix->size * sizeof(SAMPLE));
				for(loop = 0;loop < my_window->pulse_microphone_cnt;loop++)
				{
					if(my_window->pulse_microphone[loop] != NULL)
					{
						if(mix->done == 0)
						{
							if(my_window->pulse_microphone[loop]->failure == 0)
							{
								read_pulse_mic(my_window->pulse_microphone[loop], any_recording);
								mix->first = 0;
								if(my_window->pulse_microphone[loop]->stop == 0)
								{
									cnt++;
								}
							}
						}
					}
				}
				if(cnt > 0)
				{
					memcpy(mix->preserve, mix->buffer, mix->size * sizeof(SAMPLE));
				}
				else
				{
					int nn = (int)(1000000.0 * adjust);
					if(nn > 0)
					{
						usleep(nn);
					}
					pulse_grab_sample(my_window, NULL);
				}
				mix->mix_ready = 1;
				if(my_window->ndi_streaming == 1)
				{
					if(my_window->recording == 1)
					{
						if(my_window->pulse_mixer->done == 0)
						{
							my_window->StreamToNDI(NULL, SEND_NDI_AUDIO);
						}
					}
				}
				if(mix->monitor == 1)
				{
					if(mix->pa_monitor[0] != NULL)
					{
						PulseAudio *pa = mix->pa_monitor[0];
						int error = 0;
						int n = pa_simple_write(pa->stream, mix->buffer, pa->buffer_size, &error);
					}
				}
				if(my_window->muxing == 1)
				{
					for(loop = 0;loop < 128;loop++)
					{
						if(my_window->my_muxer[loop] != NULL)
						{
							if(my_window->pulse_mixer->recording == 1)
							{
								if(my_window->my_muxer[loop]->recording == 1)
								{
									simple_record((int *)my_window->my_muxer[loop]);
									my_window->recorded_frames = my_window->my_muxer[loop]->current_frame;
								}
							}
						}
					}
					if(cnt == 0)
					{
						int local = 0;
						pthread_mutex_lock(&my_window->muxer_mutex);
						for(loop = 0;loop < 128;loop++)
						{
							if(my_window->my_muxer[loop] != NULL)
							{
								while((my_window->pulse_mixer->done == 0) && (my_window->my_muxer[loop]->fresh_image == 0) && (local < 1000))
								{
									usleep(1000);
									local++;
								}
							}
						}
						pthread_mutex_unlock(&my_window->muxer_mutex);
					}
				}
				else
				{
					if(mix->out_fd == -1)
					{
						int flags = O_WRONLY | O_CREAT | O_TRUNC;
						if((access("audio.bin", 0) == 0) && (mix->continued == 1))
						{
							flags = O_WRONLY | O_APPEND;
						}
						mix->out_fd = open("audio.bin", flags, 0666);
						if(mix->out_fd > -1)
						{
							if(mix->continued == 0)
							{
								int hz = my_window->audio_sample_rate;
								int channels = 2;
								write(mix->out_fd, &channels, sizeof(int));
								write(mix->out_fd, &hz, sizeof(int));
							}
						}
					}
					if(mix->out_fd > -1)
					{
						write(mix->out_fd, mix->buffer, mix->size * sizeof(SAMPLE));
					}
				}
			}
			else
			{
				start = 0;
				accum = 0.0;
				if(my_window->pulse_mixer->out_fd > -1)
				{
					close(my_window->pulse_mixer->out_fd);
					my_window->pulse_mixer->out_fd = -1;
					my_window->pulse_mixer->continued = 1;
				}
				if(my_window->pulse_mixer != NULL)
				{
					if(my_window->pulse_mixer->done == 0)
					{
						for(loop = 0;loop < my_window->pulse_microphone_cnt;loop++)
						{
							if(my_window->pulse_microphone[loop] != NULL)
							{
								if(my_window->pulse_microphone[loop]->failure == 0)
								{
									read_pulse_mic(my_window->pulse_microphone[loop], any_recording);
								}
							}
						}
					}
				}
				usleep(10000);
			}
		}
		my_window->pulse_mixer->done = -1;
	}
	else
	{
		my_window->SetErrorMessage("Error: Mixer is NULL.");
	}
	return(0);
}

void	pulse_volume_cb(Fl_Widget *w, void *v)
{
	PulseAudioButton *pab = (PulseAudioButton *)v;
	pab->microphone->volume1 = pab->volume1->value();
	pab->microphone->volume2 = pab->volume2->value();
}

void	update_audio_button_cb(void *v)
{
	PulseAudioButton *b = (PulseAudioButton *)v;
	b->redraw();
}

void	pulse_audio_button_repeat_cb(Fl_Widget *w, void *v)
{
	PulseAudioButton *b = (PulseAudioButton *)v;
	MyToggleButton *button = (MyToggleButton *)w;
	if(b != NULL)
	{
		int nn = button->value();
		if(b->microphone != NULL)
		{
			b->microphone->repeating = nn;
		}
	}
}

void	pulse_audio_button_delete_cb(Fl_Widget *w, void *v)
{
int	loop;
int	inner;

	PulseAudioButton *b = (PulseAudioButton *)v;
	int done = 0;
	MyWin *win = b->my_window;
	for(loop = 0;((loop < win->audio_thumbnail_cnt) && (done == 0));loop++)
	{
		if(win->audio_thumbnail[loop] == b)
		{
			for(inner = 0;inner < 3;inner++)
			{
				Fl_Pack *pack = win->audio_thumbnail_pack[inner];
				pack->remove(b);
			}
			win->audio_thumbnail[loop] = NULL;
			win->CompressAudioThumbnailList();
			for(inner = 0;inner < 2;inner++)
			{
				Fl_Pack *pack1 = win->audio_thumbnail_pack[inner];
				Fl_Pack *pack2 = win->audio_thumbnail_pack[inner + 1];
				while((pack1->children() < 7) && (pack2->children() > 0))
				{
					PulseAudioButton *move = (PulseAudioButton *)pack2->child(0);
					pack1->add(move);
				}
			}
			b->hide();
			Fl::delete_widget(b);
			done = 1;
		}
	}
	int last = 0;
	for(loop = 0;loop < 3;loop++)
	{
		Fl_Pack *pack1 = win->audio_thumbnail_pack[loop];
		if(pack1->children() > 0)
		{
			last = loop;
		}
	}
	int use_w = win->audio_thumbnail_pack[0]->children() * 160;
	win->audio_thumbnail_group->resize(win->audio_thumbnail_group->x(), win->audio_thumbnail_group->y(), use_w, (last + 1) * 81);
}

void	pulse_audio_edit_alias(Fl_Widget *w, void *v)
{
	PulseAudioButton *b = (PulseAudioButton *)v;
	if(b->alias != NULL)
	{
		free(b->alias);
	}
	char *str = (char *)b->alias_in->value();
	if(str != NULL)
	{
		b->alias = strdup(str);
		b->alias_button->copy_label(b->alias);
	}
	b->alias_in->hide();
	b->alias_button->show();
	b->redraw();
}

void	pulse_audio_button_invoke_alias_editor(Fl_Widget *w, void *v)
{
	PulseAudioButton *b = (PulseAudioButton *)v;
	char *str = (char *)b->alias_button->label();
	b->alias_in->value(b->alias);
	b->alias_in->insert_position(b->alias_in->size(), 0);
	b->alias_in->wrap(1);
	b->alias_in->take_focus();
	b->alias_in->show();
	Fl::focus(b->alias_in);
	b->alias_button->hide();
}

PulseAudioButton::PulseAudioButton(MyWin *in_win, char *in_dev_name, int hz, int ch, int xx, int yy, int ww, int hh, char *lbl) : MyGroup(xx, yy, ww, hh)
{
	my_window = in_win;
	device_name = strdup(in_dev_name);
	if(lbl != NULL)
	{
		alias = strdup(lbl);
	}
	else
	{
		alias = strdup("");
	}
	box(FL_NO_BOX);

	int start_y = yy;
	alias_button = new MyButton(xx, yy, ww, 30, alias);
	alias_button->color(BLACK);
	alias_button->labelcolor(GRAY);
	alias_button->labelsize(9);
	alias_button->align(FL_ALIGN_LEFT | FL_ALIGN_WRAP | FL_ALIGN_INSIDE);
	if(my_window->transparent_interface == 0)
	{
		alias_button->box(FL_FLAT_BOX);
	}
	else
	{
		alias_button->box(FL_NO_BOX);
	}
	alias_button->callback(pulse_audio_button_invoke_alias_editor, this);
	start_y += 30;

	select_button = new MyToggleButton(xx, start_y, ww - 16, 16, "Select");
	select_button->color(BLACK);
	select_button->labelcolor(YELLOW);
	select_button->labelsize(9);
	select_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	if(my_window->transparent_interface == 0)
	{
		select_button->box(FL_FLAT_BOX);
	}
	else
	{
		select_button->box(FL_NO_BOX);
	}
	select_button->callback(pulse_audio_select_cb, this);

	filter_button = new MyToggleButton(xx + (ww - 16), start_y, 16, 16, "E");
	filter_button->color(BLACK);
	filter_button->labelcolor(YELLOW);
	filter_button->labelsize(10);
	filter_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	filter_button->box(FL_FRAME_BOX);
	filter_button->callback(pulse_audio_filter_cb, this);
	start_y += 18;
	
	volume1 = new Fl_Hor_Fill_Slider(xx + 30, start_y, ww - 30, 10);
	volume1->box(FL_FRAME_BOX);
	volume1->color(BLACK);
	volume1->bounds(0.0, 1.0);
	volume1->slider_size(4);
	volume1->value(0.5);
	volume1->callback(pulse_volume_cb, this);

	volume2 = new Fl_Hor_Fill_Slider(xx + 30, start_y + 11, ww - 30, 10);
	volume2->box(FL_FRAME_BOX);
	volume2->color(BLACK);
	volume2->bounds(0.0, 1.0);
	volume2->slider_size(4);
	volume2->value(0.5);
	volume2->callback(pulse_volume_cb, this);
	if(my_window->audio_channels == 1)
	{
		volume2->hide();
	}
	delete_button = new MyButton(xx, start_y, 11, 11, "x");
	delete_button->color(BLACK);
	delete_button->labelcolor(GRAY);
	delete_button->labelsize(9);
	delete_button->align(FL_ALIGN_CENTER | FL_ALIGN_WRAP | FL_ALIGN_INSIDE);
	delete_button->box(FL_FRAME_BOX);
	delete_button->callback(pulse_audio_button_delete_cb, this);

	repeat_button = new MyToggleButton(xx + 13, start_y, 11, 11, "r");
	repeat_button->color(BLACK);
	repeat_button->labelcolor(GRAY);
	repeat_button->labelsize(9);
	repeat_button->align(FL_ALIGN_CENTER | FL_ALIGN_WRAP | FL_ALIGN_INSIDE);
	repeat_button->box(FL_FRAME_BOX);
	repeat_button->callback(pulse_audio_button_repeat_cb, this);
	repeat_button->value(0);
	repeat_button->hide();
	start_y += 11;

	alias_in = new Fl_Multiline_Input(xx, yy, ww, 30);
	alias_in->color(BLACK);
	alias_in->textcolor(WHITE);
	alias_in->textsize(9);
	alias_in->cursor_color(WHITE);
	alias_in->box(FL_FLAT_BOX);
	alias_in->align(FL_ALIGN_LEFT | FL_ALIGN_TOP | FL_ALIGN_INSIDE);
	alias_in->value(alias);
	alias_in->when(FL_WHEN_ENTER_KEY);
	alias_in->hide();
	alias_in->callback(pulse_audio_edit_alias, this);

	microphone = new PulseMicrophone(my_window, device_name, hz, ch);
	if(microphone->failure != 1)
	{
		microphone->volume1 = 0.5;
		microphone->volume2 = 0.5;
		if(my_window->pulse_microphone_cnt < 128)
		{
			my_window->pulse_microphone[my_window->pulse_microphone_cnt] = microphone;
			my_window->pulse_microphone_cnt++;
		}
		if(microphone->is_microphone == 0)
		{
			repeat_button->show();
		}
	}
	else
	{
		char buf[4096];
		sprintf(buf, "Non-responsive audio device removed:\n%s\n", device_name);
		start_win->Update(buf);

		delete microphone;
		microphone = NULL;
	}
	end();
	peak = 0;
}

PulseAudioButton::~PulseAudioButton()
{
	if(device_name != NULL)
	{
		free(device_name);
	}
	if(microphone != NULL)
	{
		microphone->shutdown = 1;
		usleep(10000);
		microphone->Stop();
		delete microphone;
		microphone = NULL;
	}
	if(alias != NULL)
	{
		free(alias);
	}
}

int		PulseAudioButton::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		if(Fl::event_button() == 3)
		{
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = MyGroup::handle(event);
	}
	return(flag);
}

void	PulseAudioButton::show()
{
	if(my_window->audio_channels == 1)
	{
		volume2->hide();
	}
	else
	{
		volume2->show();
	}
	Fl_Group::show();
}

void	PulseAudioButton::draw()
{
int		loop;

	MyGroup::draw();
	if(microphone != NULL)
	{
		double avg = microphone->average * ((microphone->volume1 + microphone->volume2) / 2);
		int ww = (int)(((double)w() / (32768.0 / 2.0)) * abs(avg));
		int red = (int)((255.0 / (32768.0 / 2.0)) * abs(avg));
		int green = 255 - (int)((255.0 / (32768.0 / 2.0)) * abs(avg));
		if(ww > peak) peak = ww;
		fl_color(BLACK);
		fl_rectf(x(), y() + (h() - 5), w(), 5);
		for(loop = 0;loop < ww;loop += 3)
		{
			fl_color(fl_rgb_color(red, green, 0));
			fl_rectf(x() + loop, y() + (h() - 5), 2, 5);
		}
		fl_color(RED);
		fl_rectf(x() + peak, y() + (h() - 5), 5, 5);
	}
}

void	PulseAudioButton::Start()
{
	if(microphone != NULL)
	{
		microphone->stop = 0;
		microphone->Record();
	}
	select_button->box(FL_FLAT_BOX);
	select_button->value(1);
	redraw();
}

void	PulseAudioButton::Stop()
{
	if(microphone != NULL)
	{
		microphone->Stop();
	}
	if(my_window->transparent_interface == 0)
	{
		select_button->box(FL_FLAT_BOX);
	}
	else
	{
		select_button->box(FL_NO_BOX);
	}
	select_button->value(0);
	redraw();
}

// SECTION *********************************** PTZ AND V4L *******************************************

void	v4l_zoom_out_cb(void *v)
{
	V4L_Button *b = (V4L_Button *)v;
	if(b->zooming == 1)
	{
		MyWin *main_win = b->my_win->my_win;
		if(main_win != NULL)
		{
			Camera *cam = main_win->camera[b->my_win->index];
			if(cam->v4l_capable == 1)
			{
				cam->V4L_Command(V4L_ZOOM_OUT);
				Fl::repeat_timeout(0.01, v4l_zoom_out_cb, b);
			}
		}
	}
}

void	v4l_zoom_in_cb(void *v)
{
	V4L_Button *b = (V4L_Button *)v;
	if(b->zooming == 1)
	{
		MyWin *main_win = b->my_win->my_win;
		if(main_win != NULL)
		{
			Camera *cam = main_win->camera[b->my_win->index];
			if(cam->v4l_capable == 1)
			{
				cam->V4L_Command(V4L_ZOOM_IN);
				Fl::repeat_timeout(0.01, v4l_zoom_in_cb, b);
			}
		}
	}
}

void	v4l_focus_far_cb(void *v)
{
	V4L_Button *b = (V4L_Button *)v;
	if(b->focusing == 1)
	{
		MyWin *main_win = b->my_win->my_win;
		if(main_win != NULL)
		{
			Camera *cam = main_win->camera[b->my_win->index];
			if(cam->v4l_capable == 1)
			{
				cam->V4L_Command(V4L_FOCUS_FAR);
				Fl::repeat_timeout(0.01, v4l_focus_far_cb, b);
			}
		}
	}
}

void	v4l_focus_near_cb(void *v)
{
	V4L_Button *b = (V4L_Button *)v;
	if(b->focusing == 1)
	{
		MyWin *main_win = b->my_win->my_win;
		if(main_win != NULL)
		{
			Camera *cam = main_win->camera[b->my_win->index];
			if(cam->v4l_capable == 1)
			{
				cam->V4L_Command(V4L_FOCUS_NEAR);
				Fl::repeat_timeout(0.01, v4l_focus_near_cb, b);
			}
		}
	}
}

V4L_Button::V4L_Button(ThumbGroup *in_win, int xx, int yy, int ww, int hh, char *lbl) : MyButton(xx, yy, ww, hh, lbl)
{
	my_win = in_win;
	zooming = 0;
	focusing = 0;
}

V4L_Button::~V4L_Button()
{
}

int	V4L_Button::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		if(event == FL_PUSH)
		{
			MyWin *main_win = my_win->my_win;
			if(main_win != NULL)
			{
				Camera *cam = main_win->camera[my_win->index];
				if(cam->v4l_capable == 1)
				{
					if(this == my_win->up_left)
					{
						cam->V4L_Motion(V4L_UP | V4L_LEFT);
					}
					else if(this == my_win->up)
					{
						cam->V4L_Motion(V4L_UP);
					}
					else if(this == my_win->up_right)
					{
						cam->V4L_Motion(V4L_UP | V4L_RIGHT);
					}
					else if(this == my_win->left)
					{
						cam->V4L_Motion(V4L_LEFT);
					}
					else if(this == my_win->right)
					{
						cam->V4L_Motion(V4L_RIGHT);
					}
					else if(this == my_win->down_left)
					{
						cam->V4L_Motion(V4L_DOWN | V4L_LEFT);
					}
					else if(this == my_win->down)
					{
						cam->V4L_Motion(V4L_DOWN);
					}
					else if(this == my_win->down_right)
					{
						cam->V4L_Motion(V4L_DOWN | V4L_RIGHT);
					}
					else if(this == my_win->zoom_out)
					{
						zooming = 1;
						Fl::add_timeout(0.01, v4l_zoom_out_cb, this);
					}
					else if(this == my_win->zoom_in)
					{
						zooming = 1;
						Fl::add_timeout(0.01, v4l_zoom_in_cb, this);
					}
					else if(this == my_win->focus_far)
					{
						focusing = 1;
						Fl::add_timeout(0.01, v4l_focus_far_cb, this);
					}
					else if(this == my_win->focus_near)
					{
						focusing = 1;
						Fl::add_timeout(0.01, v4l_focus_near_cb, this);
					}
				}
			}
		}
		else if(event == FL_RELEASE)
		{
			MyWin *main_win = my_win->my_win;
			if(main_win != NULL)
			{
				Camera *cam = main_win->camera[my_win->index];
				if(cam->v4l_capable == 1)
				{
					if((this == my_win->up_left)
					|| (this == my_win->up)
					|| (this == my_win->up_right)
					|| (this == my_win->left)
					|| (this == my_win->right)
					|| (this == my_win->down_left)
					|| (this == my_win->down)
					|| (this == my_win->down_right)
					|| (this == my_win->zoom_in)
					|| (this == my_win->zoom_out))
					{
						cam->V4L_Motion(V4L_STOP);
					}
					zooming = 0;
					focusing = 0;
				}
			}
		}
		flag = MyButton::handle(event);
	}
	return(flag);
}

void	ptz_select_camera_cb(Fl_Widget *w, void *v)
{
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	MyWin *my_win = win->my_window;
	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		win->ptz_camera_select_button[loop]->labelcolor(YELLOW);
		win->ptz_camera_select_button[loop]->box(FL_NO_BOX);
		win->ptz_camera_select_button[loop]->redraw();
	}
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		win->ptz_camera_preset_button[loop]->labelcolor(YELLOW);
		win->ptz_camera_preset_button[loop]->box(FL_NO_BOX);
		win->ptz_camera_preset_button[loop]->redraw();
	}
	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		if(w == win->ptz_camera_select_button[loop])
		{
			win->ptz_current_camera_idx = loop;
			win->ptz_current_camera = &my_win->visca_camera[loop];
			win->ptz_remember_camera[win->ptz_interface_index] = loop;
			win->ptz_camera_select_button[loop]->box(FL_FRAME);
			win->ptz_camera_select_button[loop]->redraw();
		}
	}
	win->UpdatePresets();
	win->UpdatePTZButtons();
	win->redraw();
}

void	ptz_set_preset_cb(Fl_Widget *w, void *v)
{
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	MyButton *tb = (MyButton *)w;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(win->ptz_position[win->ptz_interface_index][win->ptz_current_camera_idx][loop]->set == 0)
		{
			win->ptz_camera_set_button[loop]->box(FL_FRAME);
		}
		else
		{
			win->ptz_camera_set_button[loop]->box(FL_FRAME_BOX);
		}
		if(w == win->ptz_camera_set_button[loop])
		{
			if(win->ptz_position[win->ptz_interface_index][win->ptz_current_camera_idx][loop]->set == 0)
			{
				win->ptz_camera_set_button[loop]->box(FL_FRAME_BOX);
				win->PTZ_RememberPosition(loop);
			}
			else
			{
				win->ptz_camera_set_button[loop]->box(FL_FRAME);
				win->PTZ_UnRememberPosition(loop);
			}
			tb->redraw();
		}
	}
	win->redraw();
}

void	ptz_select_preset_cb(Fl_Widget *w, void *v)
{
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		win->ptz_camera_preset_button[loop]->box(FL_NO_BOX);
		win->ptz_camera_preset_button[loop]->redraw();
	}
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(w == win->ptz_camera_preset_button[loop])
		{
			win->ptz_camera_preset_button[loop]->box(FL_FRAME_BOX);
			win->ptz_camera_preset_button[loop]->redraw();
			win->PTZ_RecallPosition(20, loop);
		}
	}
	win->redraw();
}

void	ptz_select_interface_cb(Fl_Widget *w, void *v)
{
int	loop;
int	inner;

	PTZ_Window *win = (PTZ_Window *)v;
	MyWin *my_win = win->my_window;
	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		if(win->ptz_camera_select_button[loop] != NULL)
		{
			win->ptz_camera_select_button[loop]->labelcolor(YELLOW);
			win->ptz_camera_select_button[loop]->box(FL_THIN_UP_BOX);
			win->ptz_camera_select_button[loop]->redraw();
		}
	}
	int nn = win->ptz_interface_button->current;
	if(my_win->ptz_interface_type[nn] != VISCA_INTERFACE_TYPE_ERROR)
	{
		win->ptz_interface_index = nn;
		win->ptz_current_interface = &my_win->iface[nn];
		win->ptz_current_device_path = my_win->ptz_device_path[nn];
		int cam_idx = win->ptz_remember_camera[win->ptz_interface_index];
		if(cam_idx > -1)
		{
			win->ptz_current_camera_idx = cam_idx;
			win->ptz_current_camera = &my_win->visca_camera[cam_idx];
			win->ptz_camera_select_button[cam_idx]->box(FL_THIN_DOWN_BOX);
			win->ptz_camera_select_button[cam_idx]->redraw();
		}
		win->UpdatePresets();
		win->UpdatePTZButtons();
	}
	else
	{
		win->ptz_current_interface = NULL;
	}
	win->redraw();
}

void	accept_ptz_lock_window_cb(Fl_Widget *w, void *v)
{
int	loop;
int	inner;

	PTZ_LockWindow *lw = (PTZ_LockWindow *)v;
	for(loop = 0;loop < lw->unassigned_camera_list->children();loop++)
	{
		DragBox *button = (DragBox *)lw->unassigned_camera_list->child(loop);
		char *lbl = (char *)button->label();
		if(lbl != NULL)
		{
			for(inner = 0;inner < lw->my_window->source_cnt;inner++)
			{
				Camera *cam = lw->my_window->camera[inner];
				if(cam != NULL)
				{
					if(strcmp(cam->alias, lbl) == 0)
					{
						cam->ptz_lock_interface = -1;
						cam->ptz_lock_camera = -1;
					}
				}
			}
		}
	}
	for(loop = 0;loop < lw->assigned_camera_list->children();loop++)
	{
		DragBox *button = (DragBox *)lw->assigned_camera_list->child(loop);
		if(button->index > -1)
		{
			char *lbl = (char *)button->label();
			if(lbl != NULL)
			{
				for(inner = 0;inner < lw->my_window->source_cnt;inner++)
				{
					Camera *cam = lw->my_window->camera[inner];
					if(cam != NULL)
					{
						if(strcmp(cam->alias, lbl) == 0)
						{
							int interface = button->index / NUMBER_OF_CAMERAS;
							int camera = button->index - (interface * NUMBER_OF_CAMERAS);
							cam->ptz_lock_interface = interface;
							cam->ptz_lock_camera = camera;
						}
					}
				}
			}
		}
	}
	lw->hide();
}

PTZ_LockWindow::PTZ_LockWindow(MyWin *in_win) : Dialog(360, 300, 620, 600, "PTZ Lock Window")
{
	my_window = in_win;
	int new_yp = 20;
	last_x = 0;
	last_y = 0;

	scroll = new Fl_Scroll(2, new_yp + 34, 408, h() - 98, "Assigned");
	scroll->box(FL_FLAT_BOX);
	scroll->color(fl_rgb_color(20, 20, 25));
	scroll->type(Fl_Scroll::VERTICAL);
	scroll->labelsize(11);
	scroll->labelcolor(WHITE);
	scroll->align(FL_ALIGN_TOP | FL_ALIGN_CENTER);
		ptz_list = new MyGroup(2, new_yp + 34, 200, h() - 50);
		ptz_list->box(FL_FLAT_BOX);
		ptz_list->color(fl_rgb_color(20, 20, 25));
		ptz_list->end();

		assigned_camera_list = new ArrangeGroup(scroll, 20, 204, new_yp + 34, 200, h() - 50);
		assigned_camera_list->box(FL_FLAT_BOX);
		assigned_camera_list->color(fl_rgb_color(25, 25, 30));
		assigned_camera_list->end();
	scroll->end();

	unassigned_camera_list = new ArrangeGroup(NULL, 20, 410, new_yp + 34, 200, h() - 98, "Unassigned");
	unassigned_camera_list->box(FL_FLAT_BOX);
	unassigned_camera_list->color(fl_rgb_color(30, 30, 35));
	unassigned_camera_list->align(FL_ALIGN_TOP | FL_ALIGN_CENTER);
	unassigned_camera_list->labelsize(11);
	unassigned_camera_list->labelcolor(WHITE);
	unassigned_camera_list->end();

	MyButton *accept = new MyButton((w() / 3) - 50, h() - 37, 100, 20, "Accept");
	accept->box(FL_FLAT_BOX);
	accept->color(BLACK);
	accept->labelcolor(YELLOW);
	accept->labelsize(11);
	accept->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	accept->callback(accept_ptz_lock_window_cb, this);

	MyButton *cancel = new MyButton(((w() / 3) * 2) - 50, h() - 37, 100, 20, "Cancel");
	cancel->box(FL_FLAT_BOX);
	cancel->color(BLACK);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(11);
	cancel->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	cancel->callback(hide_window_cb, this);

	end();
	Populate();
}

PTZ_LockWindow::~PTZ_LockWindow()
{
}

void	PTZ_LockWindow::Populate()
{
int		loop;
int		inner;
char	buf[8192];

	static MyGroup *parent_list[2];
	parent_list[0] = unassigned_camera_list;
	parent_list[1] = assigned_camera_list;
	int cnt = 0;
	ptz_list->resize(ptz_list->x(), ptz_list->y(), ptz_list->w(), my_window->ptz_device_cnt * NUMBER_OF_CAMERAS * 20);
	assigned_camera_list->resize(assigned_camera_list->x(), assigned_camera_list->y(), assigned_camera_list->w(), my_window->ptz_device_cnt * NUMBER_OF_CAMERAS * 20);
	for(loop = 0;loop < my_window->ptz_device_cnt;loop++)
	{
		char *str = NULL;
		if(my_window->ptz_alias[loop] != NULL)
		{
			str = my_window->ptz_alias[loop];
			if(strlen(str) < 1)
			{
				str = my_window->ptz_device_path[loop];
			}
		}
		else
		{
			str = my_window->ptz_device_path[loop];
		}
		if(str != NULL)
		{
			int c_add = -25;
			if((cnt % 2) == 0) c_add = 25;
			for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
			{
				sprintf(buf, "%s : %d", str, inner + 1);
				MyButton *button = new MyButton(ptz_list->x(), scroll->y() + (cnt * 20), ptz_list->w(), 20, strdup(buf)); 
				button->box(FL_FLAT_BOX);
				button->color(fl_rgb_color(50 - c_add, 40, 50 + c_add));
				button->labelcolor(WHITE);
				button->labelsize(11);
				button->align(FL_ALIGN_INSIDE | FL_ALIGN_RIGHT);
				ptz_list->add(button);
				cnt++;
			}
		}
	}
	assigned_camera_list->limit = cnt;
	cnt = 0;
	for(loop = 0;loop < my_window->source_cnt;loop++)
	{
		if(my_window->camera[loop] != NULL)
		{
			Camera *cam = my_window->camera[loop];
			if(cam->type == CAMERA_TYPE_CAMERA)
			{
				char *str = NULL;
				if(strlen(cam->alias) > 0)
				{
					str = cam->alias;
				}
				else
				{
					str = cam->path;
				}
				if(str != NULL)
				{
					if(cam->ptz_lock_interface > -1)
					{
						int y_pos = (cam->ptz_lock_interface * NUMBER_OF_CAMERAS);
						if(cam->ptz_lock_camera > -1)
						{
							y_pos += cam->ptz_lock_camera;
						}
						DragBox *button = new DragBox(parent_list, 2, assigned_camera_list->x(), assigned_camera_list->y() + (y_pos * 20), assigned_camera_list->w(), 20, str); 
						button->box(FL_FLAT_BOX);
						button->color(fl_rgb_color(50, 50, 55));
						button->labelcolor(WHITE);
						button->labelsize(11);
						button->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
						assigned_camera_list->add(button);
					}
					else
					{
						int y_pos = cnt;
						DragBox *button = new DragBox(parent_list, 2, unassigned_camera_list->x(), unassigned_camera_list->y() + (y_pos * 20), unassigned_camera_list->w(), 20, str); 
						button->box(FL_FLAT_BOX);
						button->color(fl_rgb_color(50, 50, 55));
						button->labelcolor(WHITE);
						button->labelsize(11);
						button->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
						unassigned_camera_list->add(button);
						cnt++;
					}
				}
			}
		}
	}
}

int	PTZ_LockWindow::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	PTZ_LockWindow::draw()
{
	Fl_Window::draw();
}

PTZ_Button::PTZ_Button(PTZ_Window *in_win, int xx, int yy, int ww, int hh, char *lbl) : MyButton(xx, yy, ww, hh, lbl)
{
	my_window = in_win;
}

PTZ_Button::~PTZ_Button()
{
}

int	PTZ_Button::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		if((event == FL_PUSH)
		|| (event == FL_RELEASE)
		|| (event == FL_SHORTCUT))
		{
			my_window->ViscaButtonCommands(this, event);
		}
		flag = MyButton::handle(event);
	}
	return(flag);
}

PTZ_Position::PTZ_Position(int in_set, int in_pan, int in_tilt, int in_zoom, int in_focus)
{
	set = in_set;
	pan = in_pan;
	tilt = in_tilt;
	zoom = in_zoom;
	focus = in_focus;
}

PTZ_Position::~PTZ_Position()
{
}

void	PTZ_Position::Set(int in_pan, int in_tilt, int in_zoom, int in_focus)
{
	set = 1;
	pan = in_pan;
	tilt = in_tilt;
	zoom = in_zoom;
	focus = in_focus;
}

void	PTZ_Position::UnSet()
{
	set = 0;
	pan = 0;
	tilt = 0;
	zoom = 0;
	focus = 0;
}

void	PTZ_Position::Save(FILE *fp)
{
	fprintf(fp, "\t\t{\n");
	fprintf(fp, "\t\t\t\"set\": %d,\n", set);
	fprintf(fp, "\t\t\t\"pan\": %d,\n", pan);
	fprintf(fp, "\t\t\t\"tilt\": %d,\n", tilt);
	fprintf(fp, "\t\t\t\"zoom\": %d,\n", zoom);
	fprintf(fp, "\t\t\t\"focus\": %d\n", focus);
	fprintf(fp, "\t\t}");
}

void	ptz_calibrate_cb(Fl_Widget *w, void *v)
{
int	loop;
Mat	out;

	MyWin *win = (MyWin *)v;
	Mat local_mat = win->in_mat;

	int use_x = (local_mat.cols / 2) - 50;
	int use_y = (local_mat.rows / 2) - 50;
	win->CropFrame(win->in_mat, &out, use_x, use_y, 100, 100);

	for(loop = 0;loop < 250;loop++)
	{
		win->ViscaCommand(0, PTZ_RELATIVE_POSITION, 4, 1, 1, 1, 1);
		win->redraw();
		Fl::check();
		int xx = 0;
		int yy = 0;
		matching_method(0, win->in_mat, out, &xx, &yy);
		win->magic_x = xx;
		win->magic_y = yy;
		win->ptz_travel_x = (double)(xx - use_x) / (double)loop;
		win->ptz_travel_y = (double)(yy - use_y) / (double)loop;
	}
}

void	ptz_preset_page_back_cb(Fl_Widget *w, void *v)
{
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	if(win->ptz_preset_page > 0)
	{
		int start = win->ptz_preset_page * 7;
		for(loop = start;loop < start + 7;loop++)
		{
			win->ptz_camera_preset_button[loop]->hide();
			win->ptz_camera_set_button[loop]->hide();
		}
		win->ptz_preset_page--;
		start = win->ptz_preset_page * 7;
		for(loop = start;loop < start + 7;loop++)
		{
			win->ptz_camera_preset_button[loop]->show();
			win->ptz_camera_set_button[loop]->show();
		}
	}
}

void	ptz_preset_page_forward_cb(Fl_Widget *w, void *v)
{
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	if(win->ptz_preset_page < 2)
	{
		int start = win->ptz_preset_page * 7;
		for(loop = start;loop < start + 7;loop++)
		{
			win->ptz_camera_preset_button[loop]->hide();
			win->ptz_camera_set_button[loop]->hide();
		}
		win->ptz_preset_page++;
		start = win->ptz_preset_page * 7;
		for(loop = start;loop < start + 7;loop++)
		{
			win->ptz_camera_preset_button[loop]->show();
			win->ptz_camera_set_button[loop]->show();
		}
	}
}

int	TestPTZPort(char *path)
{
int					OpenInterface(VISCAInterface_t *iface, char *path, int *interface_type);
VISCAInterface_t	iface;
VISCACamera_t		camera;

	int rr = 0;
	memset(&iface, 0, sizeof(iface));
	int type = 0;
	int err = OpenInterface(&iface, path, &type);
	if(err == 0)
	{
		int assigned = 0;
		camera.address = 1;
		if(type == VISCA_INTERFACE_TYPE_SERIAL)
		{
			err = VISCA_set_address(&iface, &assigned);
			if(err == 0)
			{
				camera.address = assigned;
			}
		}
		err = VISCA_clear(&iface, &camera);
		if(err == 0)
		{
			err = VISCA_get_camera_info(&iface, &camera);
		}
		VISCA_close(&iface);
	}
	if(err == 0)
	{
		rr = 1;
	}
	return(rr);
}

int	ScanViableTTYPorts(char **final)
{
int	test_serial_ports(char **); 
int	loop;

	int cnt = 0;
	char *out_list[1024];
	int	out_nn = test_serial_ports(out_list);
	for(loop = 0;loop < out_nn;loop++)
	{
		int rr = 0;
		if(out_list[loop] != NULL)
		{
			rr = TestPTZPort(out_list[loop]);
			if(rr == 1)
			{
				final[cnt] = strdup(out_list[loop]);
				cnt++;
			}
			free(out_list[loop]);
		}
	}
	return(cnt);
}

void	ptz_spawn_another_cb(Fl_Widget *w, void *v)
{
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	MyWin *my_win = win->my_window;
	int done = 0;
	for(loop = 0;((loop < PTZ_WINDOW_LIMIT) && (done == 0));loop++)
	{
		if(my_win->ptz_window[loop] != NULL)
		{
			if(!my_win->ptz_window[loop]->visible())
			{
				my_win->ptz_window[loop]->show();
				my_win->ptz_window[loop]->showing = 1;
				done = 1;
			}
		}
	}
	int cnt = 0;
	for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
	{
		if(my_win->ptz_window[loop] != NULL)
		{
			my_win->ptz_window[loop]->ptz_lock_to_camera_button->hide();
			if(my_win->ptz_window[loop]->visible())
			{
				cnt++;
			}
		}
	}
	if(cnt >= PTZ_WINDOW_LIMIT)
	{
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(my_win->ptz_window[loop] != NULL)
			{
				my_win->ptz_window[loop]->ptz_spawn_another_button->hide();
			}
		}
	}
	for(loop = 0;loop < my_win->source_cnt;loop++)
	{
		Camera *cam = my_win->camera[loop];
		if(cam != NULL)
		{
			cam->ptz_lock_interface = -1;
			cam->ptz_lock_camera = -1;
		}
	}
}

void	ptz_hide_cb(Fl_Widget *w, void *v)
{
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	MyWin *my_win = win->my_window;
	win->hide();
	win->showing = 0;
	int cnt = 0;
	for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
	{
		if(my_win->ptz_window[loop] != NULL)
		{
			my_win->ptz_window[loop]->ptz_spawn_another_button->show();
			if(my_win->ptz_window[loop]->visible())
			{
				cnt++;
			}
		}
	}
	if(cnt == 1)
	{
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(my_win->ptz_window[loop] != NULL)
			{
				my_win->ptz_window[loop]->ptz_lock_to_camera_button->show();
			}
		}
	}
}

void	ptz_pin_cb(Fl_Widget *w, void *v)
{
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	MyWin *my_win = win->my_window;
	if(win->ptz_pin_button->value())
	{
		win->pinned = 1;
		win->ptz_pin_button->copy_label("Unpin");
	}
	else
	{
		win->pinned = 0;
		win->ptz_pin_button->copy_label("Pin");
	}
}

void	ptz_auto_focus_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	MyLightButton *b = (MyLightButton *)w;
	int val = b->value();
	win->AutoFocus(val);
}

void	ptz_auto_exp_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	MyLightButton *b = (MyLightButton *)w;
	int val = b->value();
	win->AutoExposure(val);
}

void	ptz_backlight_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	MyLightButton *b = (MyLightButton *)w;
	int val = b->value();
	win->BacklightCompensation(val);
}

void	ptz_dzoom_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	MyLightButton *b = (MyLightButton *)w;
	int val = b->value();
	win->DigitalZoom(val);
}

void	ptz_tour_cb(Fl_Widget *w, void *v)
{
void	ptz_tour_presets_cb(void *v);
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	int cnt = 0;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(win->ptz_position[win->ptz_interface_index][win->ptz_current_camera_idx][loop]->set == 1)
		{
			cnt++;
		}
	}
	if(cnt > 1)
	{
		MyLightButton *b = (MyLightButton *)w;
		int val = b->value();
		if(val == 1)
		{
			win->ptz_tour_index = 0;
			Fl::repeat_timeout(0.0, ptz_tour_presets_cb, win);
		}
		else
		{
			Fl::remove_timeout(ptz_tour_presets_cb, win);
		}
	}
}

void	ptz_reverse_horizontal_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	MyLightButton *b = (MyLightButton *)w;
	int val = b->value();
	win->ptz_reverse_horizontal = val;
}

void	ptz_reverse_vertical_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	MyLightButton *b = (MyLightButton *)w;
	int val = b->value();
	win->ptz_reverse_vertical = val;
}

void	ptz_follow_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	MyLightButton *b = (MyLightButton *)w;
	int val = b->value();
	win->ptz_follow = val;
	if(val == 1)
	{
		win->ptz_follow_home_pan = win->ptz_pan_reading / 16;
		win->ptz_follow_home_tilt = win->ptz_tilt_reading / 16;
	}
}

void	ptz_show_joystick_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	MyLightButton *b = (MyLightButton *)w;
	int val = b->value();
	win->ptz_joystick = val;
	for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
	{
		if(win->ptz_window[loop] != NULL)
		{
			win->ptz_window[loop]->ptz_joystick_button->value(val);
		}
	}
}

void	ptz_soft_memory_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	MyLightButton *b = (MyLightButton *)w;
	int val = b->value();
	if((win->ptz_interface_index > -1) && (win->ptz_interface_index < NUMBER_OF_INTERFACES)
	&& (win->ptz_current_camera_idx > -1) && (win->ptz_current_camera_idx < NUMBER_OF_CAMERAS))
	{
		win->ptz_soft_memory[win->ptz_interface_index][win->ptz_current_camera_idx] = val;
	}
}

void	ptz_set_speed_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	Fl_Hor_Fill_Slider *slider = (Fl_Hor_Fill_Slider *)w;
	double val = slider->value();
	MyVISCACamera *local_cam = win->ptz_current_camera;
	if(local_cam != NULL)
	{
		if(win->ptz_adjust_speed_for_zoom == 0)
		{
			win->ptz_pan_speed = (int)((double)local_cam->param_pan_max_speed * val);
			win->ptz_tilt_speed = (int)((double)local_cam->param_tilt_max_speed * val);
			win->ptz_focus_speed = (int)((4.0) * val);
		}
		else
		{
			if(win->ptz_zoomer_speed == 0)
			{
				win->ptz_zoom_speed = (int)((40959.0 / 1000.0) * val);
				if(win->ptz_zoom_speed > 39) win->ptz_zoom_speed = 39;
			}
			else
			{
				win->ptz_zoom_speed = win->ptz_zoomer_speed;
			}
		}
	}
}

void	ptz_lock_camera_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	MyWin *my_win = win->my_window;
	Camera *cam = my_win->DisplayedCamera();
	if(my_win != NULL)
	{
		MyLightButton *b = (MyLightButton *)w;
		int val = b->value();
		if(val == 1)
		{
			cam->ptz_lock_interface = win->ptz_interface_index;
			cam->ptz_lock_camera = win->ptz_current_camera_idx;
		}
		else
		{
			cam->ptz_lock_interface = -1;
			cam->ptz_lock_camera = -1;
		}
	}
}

void	ptz_bind_camera_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	MyWin *my_win = win->my_window;
	Camera *cam = my_win->DisplayedCamera();
	if(my_win != NULL)
	{
		MyLightButton *b = (MyLightButton *)w;
		int val = b->value();
		if(val == 1)
		{
			win->bound_camera = cam;
			win->ptz_bound_name_box->value(cam->alias);
			win->bound_camera->prefer_ndi = win->prefer_ndi;
			win->bound_camera->prefer_v4l = win->prefer_v4l;
		}
		else
		{
			win->ptz_bound_name_box->value("");
			win->bound_camera = NULL;
		}
	}
}

void	ptz_zoom_speed_adjust_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	MyToggleButton *b = (MyToggleButton *)w;
	win->ptz_adjust_speed_for_zoom = b->value();
}

void	ptz_alias_input_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	char *str = (char *)win->ptz_alias_input->value();
	if(str != NULL)
	{
		strncpy(win->alias, str, 4096);
		win->ptz_alias_button->copy_label(str);
	}
	win->ptz_alias_input->hide();
}

void	ptz_alias_button_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	win->ptz_alias_input->show();
	win->ptz_alias_input->take_focus();
}

void	ptz_contract_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	if(win->ptz_contract_group->visible())
	{
		win->ptz_contract_group->hide();
		win->resize(win->x(), win->my_window->h() - 24, win->w(), 24);
		win->ptz_alias_button->resize(win->x() + 2, win->y() + 2, win->w() - 24, 20);
		win->ptz_contract_button->resize(win->x() + (win->w() - 20), win->y() + 2, 20, 20);
		win->ptz_contract_button->copy_label("@8>");
		win->ptz_contract_button->copy_tooltip("Expand this window");
		win->ptz_alias_button->callback(ptz_contract_cb, win);
		win->ptz_alias_button->copy_tooltip("Expand this window");
		win->ptz_alias_input->hide();
		win->contracted = 1;
	}
	else
	{
		win->ptz_contract_group->show();
		win->resize(win->x(), win->my_window->h() - 330, win->w(), 330);
		win->ptz_contract_button->copy_label("@2>");
		win->ptz_contract_button->copy_tooltip("Contract this window");
		win->ptz_alias_button->callback(ptz_alias_button_cb, win);
		win->ptz_alias_button->copy_tooltip("Set the PTZ alias");
		win->ptz_alias_input->hide();
		win->contracted = 0;
	}
	win->redraw();
}

PTZ_Window::PTZ_Window(MyWin *in_win, char *in_alias, int in_instance, int in_xx, int in_yy, int in_ww, int in_hh) : SlidingElement(in_win, OPEN_UP, 0, 0, in_ww, in_hh)
{
int	loop;
int	inner;
int	outer;
int	aa, ab, ac;

	my_window = in_win;
	bound_camera = NULL;
	contracted = 0;
	hovering = 0;
	key_table[KEY_DOWN] = 0;
	key_table[KEY_UP] = 0;
	key_table[KEY_RIGHT] = 0;
	key_table[KEY_LEFT] = 0;
	zooming = 0;
	focusing = 0;
	dir = 0;
	pan_tilt_style = PAN_TILT_STYLE_BUTTONS;

	color(BLACK);
	if(my_window->transparent_interface == 0)
	{
		box(FL_FLAT_BOX);
	}
	else
	{
		box(FL_NO_BOX);
	}
	sprintf(alias, "%d", in_instance);
	if(in_alias != NULL)
	{
		strcpy(alias, in_alias);
	}
	instance = in_instance;
	showing = 0;
	pinned = 0;
	ptz_current_camera_idx = 0;
	ptz_pan_speed = 24.0 * 0.5;
	ptz_tilt_speed = 20.0 * 0.5;
	ptz_focus_speed = 1;
	ptz_zoom_speed = 20;
	ptz_zoomer_speed = 0;
	ptz_adjust_speed_for_zoom = 0;
	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		ptz_camera_select_button[loop] = NULL;
	}
	for(outer = 0;outer < NUMBER_OF_INTERFACES;outer++)
	{
		for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
		{
			ptz_soft_memory[outer][inner] = 0;
		}
	}
	int start_x = 2;
	int start_y = 2;
	ptz_alias_button = new MyButton(2, 2, w() - 24, 20, alias);
	ptz_alias_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_alias_button->box(FL_NO_BOX);
	ptz_alias_button->color(BLACK);
	ptz_alias_button->labelcolor(WHITE);
	ptz_alias_button->labelsize(11);
	ptz_alias_button->copy_tooltip("Set the PTZ alias");
	ptz_alias_button->callback(ptz_alias_button_cb, this);

	ptz_alias_input = new MyInput(40, 2, w() - 64, 20, "Alias");
	ptz_alias_input->align(FL_ALIGN_LEFT);
	ptz_alias_input->box(FL_FRAME_BOX);
	ptz_alias_input->color(BLACK);
	ptz_alias_input->labelcolor(YELLOW);
	ptz_alias_input->labelsize(11);
	ptz_alias_input->textcolor(WHITE);
	ptz_alias_input->textsize(11);
	ptz_alias_input->value(alias);
	ptz_alias_input->copy_tooltip("Set the PTZ alias");
	ptz_alias_input->when(FL_WHEN_RELEASE | FL_WHEN_ENTER_KEY | FL_WHEN_NOT_CHANGED);
	ptz_alias_input->callback(ptz_alias_input_cb, this);
	ptz_alias_input->hide();

	ptz_contract_button = new MyButton(w() - 20, 2, 20, 20, "@2>");
	ptz_contract_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_contract_button->box(FL_NO_BOX);
	ptz_contract_button->color(BLACK);
	ptz_contract_button->labelcolor(WHITE);
	ptz_contract_button->labelsize(8);
	ptz_contract_button->copy_tooltip("Contract this window");
	ptz_contract_button->callback(ptz_contract_cb, this);

	start_y += 34;
	int save_y = start_y;

	ptz_contract_group = new Fl_Group(0, start_y, w(), h() - start_y);
	int failed = 0;
	start_y = AddInterfaceButton(10, start_y);
	start_y = AddCamerasAndPresets(5, start_y);
	int save_y2 = start_y;
	start_y = AddPanTiltButtons(0, start_y);
	start_y = AddSpeedSlider(15, start_y);
	start_y = AddWindowControls(200, save_y);
	start_y = AddZoomFocusAperture(60, save_y2);
	start_y = AddCameraControlButtons(15, 168);
	ptz_contract_group->end();
	resize(in_xx, in_yy, w(), h());

	pan_tilt_button_group->hide();
	pan_tilt_joystick_group->hide();
	if(pan_tilt_style == PAN_TILT_STYLE_BUTTONS)
	{
		pan_tilt_button_group->show();
	}
	else
	{
		pan_tilt_joystick_group->show();
	}
	if((my_window->initial_ptz_x[instance] > -1) && (my_window->initial_ptz_y[instance] > -1))
	{
		resize(my_window->initial_ptz_x[instance], my_window->initial_ptz_y[instance], w(), h());
		ptz_contract_cb(NULL, this);
	}
	else
	{
		ptz_contract_cb(NULL, this);
	}
	UpdatePresets();
}

void	PTZ_Window::show()
{
	SlidingElement::show();
}

void	PTZ_Window::hide()
{
	Fl_Group::hide();
}

int	PTZ_Window::AddCameraControlButtons(int start_x, int start_y)
{
	int yy = start_y;
	ptz_lock_to_camera_button = new MyLightButton((40 - 25), yy + 100, 70, 14, "Lock to Camera");
	ptz_lock_to_camera_button->box(FL_FLAT_BOX);
	ptz_lock_to_camera_button->color(BLACK);
	ptz_lock_to_camera_button->labelcolor(YELLOW);
	ptz_lock_to_camera_button->labelsize(8);
	ptz_lock_to_camera_button->box(FL_NO_BOX);
	ptz_lock_to_camera_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_lock_to_camera_button->copy_tooltip("Lock these controls to currently selected camera");
	ptz_lock_to_camera_button->callback(ptz_lock_camera_cb, this);

	ptz_bind_camera_button = new MyLightButton((40 - 25), yy + 114, 70, 14, "Bind Camera");
	ptz_bind_camera_button->box(FL_FLAT_BOX);
	ptz_bind_camera_button->color(BLACK);
	ptz_bind_camera_button->labelcolor(YELLOW);
	ptz_bind_camera_button->labelsize(8);
	ptz_bind_camera_button->box(FL_NO_BOX);
	ptz_bind_camera_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_bind_camera_button->copy_tooltip("Display the currenly selected camera when these controls are in use");
	ptz_bind_camera_button->callback(ptz_bind_camera_cb, this);

	ptz_auto_focus = new MyLightButton(((40 - 25) + 80), yy + 80, 60, 15, "Auto Focus");
	ptz_auto_focus->box(FL_FLAT_BOX);
	ptz_auto_focus->color(BLACK);
	ptz_auto_focus->labelcolor(YELLOW);
	ptz_auto_focus->labelsize(8);
	ptz_auto_focus->box(FL_NO_BOX);
	ptz_auto_focus->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_auto_focus->copy_tooltip("Toggle autofocus");
	ptz_auto_focus->callback(ptz_auto_focus_cb, this);

	ptz_auto_exp = new MyLightButton(((40 - 25) + 80), yy + 95, 60, 15, "Auto Exp");
	ptz_auto_exp->box(FL_FLAT_BOX);
	ptz_auto_exp->color(BLACK);
	ptz_auto_exp->labelcolor(YELLOW);
	ptz_auto_exp->labelsize(8);
	ptz_auto_exp->box(FL_NO_BOX);
	ptz_auto_exp->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_auto_exp->copy_tooltip("Toggle autoexposure");
	ptz_auto_exp->value(1);
	ptz_auto_exp->callback(ptz_auto_exp_cb, this);

	ptz_backlight = new MyLightButton(((40 - 25) + 80 + 60), yy + 80, 60, 15, "Backlight");
	ptz_backlight->box(FL_FLAT_BOX);
	ptz_backlight->color(BLACK);
	ptz_backlight->labelcolor(YELLOW);
	ptz_backlight->labelsize(8);
	ptz_backlight->box(FL_NO_BOX);
	ptz_backlight->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_backlight->copy_tooltip("Toggle backlight compensation");
	ptz_backlight->value(0);
	ptz_backlight->callback(ptz_backlight_cb, this);

	ptz_follow_button = new MyLightButton(((40 - 25) + 80 + 60), yy + 95, 60, 15, "Follow");
	ptz_follow_button->box(FL_FLAT_BOX);
	ptz_follow_button->color(BLACK);
	ptz_follow_button->labelcolor(YELLOW);
	ptz_follow_button->labelsize(8);
	ptz_follow_button->box(FL_NO_BOX);
	ptz_follow_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_follow_button->copy_tooltip("Toggle PTZ object following");
	ptz_follow_button->value(my_window->ptz_follow);
	ptz_follow_button->callback(ptz_follow_cb, my_window);

	ptz_dzoom_button = new MyLightButton(((40 - 25) + 80), yy + 110, 60, 15, "Digital Zoom");
	ptz_dzoom_button->box(FL_FLAT_BOX);
	ptz_dzoom_button->color(BLACK);
	ptz_dzoom_button->labelcolor(YELLOW);
	ptz_dzoom_button->labelsize(8);
	ptz_dzoom_button->box(FL_NO_BOX);
	ptz_dzoom_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_dzoom_button->copy_tooltip("Toggle digital zoom within the camera");
	ptz_dzoom_button->value(0);
	ptz_dzoom_button->callback(ptz_dzoom_cb, this);

	ptz_tour_button = new MyLightButton(((40 - 25) + 80 + 60), yy + 110, 60, 15, "Tour");
	ptz_tour_button->box(FL_FLAT_BOX);
	ptz_tour_button->color(BLACK);
	ptz_tour_button->labelcolor(YELLOW);
	ptz_tour_button->labelsize(8);
	ptz_tour_button->box(FL_NO_BOX);
	ptz_tour_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_tour_button->copy_tooltip("Toggle touring between PTZ preset positions");
	ptz_tour_button->value(0);
	ptz_tour_button->callback(ptz_tour_cb, this);

	ptz_reverse_horizontal_button = new MyLightButton(((40 - 25) + 80), yy + 125, 60, 15, "Rev Hor");
	ptz_reverse_horizontal_button->box(FL_FLAT_BOX);
	ptz_reverse_horizontal_button->color(BLACK);
	ptz_reverse_horizontal_button->labelcolor(YELLOW);
	ptz_reverse_horizontal_button->labelsize(8);
	ptz_reverse_horizontal_button->box(FL_NO_BOX);
	ptz_reverse_horizontal_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_reverse_horizontal_button->copy_tooltip("Toggle horizontal video reversal");
	ptz_reverse_horizontal_button->value(0);
	ptz_reverse_horizontal_button->callback(ptz_reverse_horizontal_cb, my_window);

	ptz_reverse_vertical_button = new MyLightButton(((40 - 25) + 80 + 60), yy + 125, 60, 15, "Rev Vert");
	ptz_reverse_vertical_button->box(FL_FLAT_BOX);
	ptz_reverse_vertical_button->color(BLACK);
	ptz_reverse_vertical_button->labelcolor(YELLOW);
	ptz_reverse_vertical_button->labelsize(8);
	ptz_reverse_vertical_button->box(FL_NO_BOX);
	ptz_reverse_vertical_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_reverse_vertical_button->copy_tooltip("Toggle vertical video reversal");
	ptz_reverse_vertical_button->value(0);
	ptz_reverse_vertical_button->callback(ptz_reverse_vertical_cb, my_window);

	ptz_joystick_button = new MyLightButton(((40 - 25) + 80), yy + 140, 60, 15, "Joystick");
	ptz_joystick_button->box(FL_FLAT_BOX);
	ptz_joystick_button->color(BLACK);
	ptz_joystick_button->labelcolor(YELLOW);
	ptz_joystick_button->labelsize(8);
	ptz_joystick_button->box(FL_NO_BOX);
	ptz_joystick_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_joystick_button->copy_tooltip("Toggle joystick mode for motion");
	ptz_joystick_button->value(my_window->ptz_joystick);
	ptz_joystick_button->shortcut("j");
	ptz_joystick_button->callback(ptz_show_joystick_cb, my_window);

	ptz_soft_memory_button = new MyLightButton(((40 - 25) + 80 + 60), yy + 140, 60, 15, "Soft Memory");
	ptz_soft_memory_button->box(FL_FLAT_BOX);
	ptz_soft_memory_button->color(BLACK);
	ptz_soft_memory_button->labelcolor(YELLOW);
	ptz_soft_memory_button->labelsize(8);
	ptz_soft_memory_button->box(FL_NO_BOX);
	ptz_soft_memory_button->copy_tooltip("Toggle whether presents are stored locally or in the camera's memory");
	ptz_soft_memory_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_soft_memory_button->value(0);
	ptz_soft_memory_button->callback(ptz_soft_memory_cb, this);
	return(start_y);
}

int	PTZ_Window::AddZoomFocusAperture(int start_x, int start_y)
{
	int yy = start_y;
	zoom_label = new Fl_Box(start_x, yy, 100, 20, "Zoom");
	zoom_label->box(FL_NO_BOX);
	zoom_label->color(YELLOW);
	zoom_label->labelcolor(YELLOW);
	zoom_label->labelsize(9);
	zoom_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_zoom_in_button = new PTZ_Button(this, start_x + 40, yy + 20, 20, 20, "@#8>");
	ptz_zoom_in_button->box(FL_FRAME);
	ptz_zoom_in_button->color(DARK_BLUE);
	ptz_zoom_in_button->labelcolor(YELLOW);
	ptz_zoom_in_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_zoom_in_button->copy_tooltip("Zoom in using VISCA or V4L");
	ptz_zoom_in_button->user_data((void *)PTZ_ZOOM_IN);

	ptz_zoom_out_button = new PTZ_Button(this, start_x + 40, yy + 40, 20, 20, "@#2>");
	ptz_zoom_out_button->box(FL_FRAME);
	ptz_zoom_out_button->color(DARK_BLUE);
	ptz_zoom_out_button->labelcolor(YELLOW);
	ptz_zoom_out_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_zoom_out_button->copy_tooltip("Zoom out using VISCA or V4L");
	ptz_zoom_out_button->user_data((void *)PTZ_ZOOM_OUT);

	ptz_zoom_value_label = new Fl_Box(start_x + 40, yy + 61, 20, 10, "zoom");
	ptz_zoom_value_label->box(FL_NO_BOX);
	ptz_zoom_value_label->color(YELLOW);
	ptz_zoom_value_label->labelcolor(YELLOW);
	ptz_zoom_value_label->labelsize(7);
	ptz_zoom_value_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	start_x += 45;

	focus_label = new Fl_Box(start_x, yy, 80, 20, "Focus");
	focus_label->box(FL_NO_BOX);
	focus_label->color(YELLOW);
	focus_label->labelcolor(YELLOW);
	focus_label->labelsize(9);
	focus_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_focus_far_button = new PTZ_Button(this, start_x + 28, yy + 20, 20, 20, "@#8>");
	ptz_focus_far_button->box(FL_FRAME);
	ptz_focus_far_button->color(DARK_BLUE);
	ptz_focus_far_button->labelcolor(YELLOW);
	ptz_focus_far_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_focus_far_button->copy_tooltip("Focus far using VISCA or V4L");
	ptz_focus_far_button->user_data((void *)PTZ_FOCUS_FAR);

	ptz_focus_near_button = new PTZ_Button(this, start_x + 28, yy + 40, 20, 20, "@#2>");
	ptz_focus_near_button->box(FL_FRAME);
	ptz_focus_near_button->color(DARK_BLUE);
	ptz_focus_near_button->labelcolor(YELLOW);
	ptz_focus_near_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_focus_near_button->copy_tooltip("Focus near using VISCA or V4L");
	ptz_focus_near_button->user_data((void *)PTZ_FOCUS_NEAR);

	ptz_focus_value_label = new Fl_Box(start_x + 28, yy + 61, 20, 10, "focus");
	ptz_focus_value_label->box(FL_NO_BOX);
	ptz_focus_value_label->color(YELLOW);
	ptz_focus_value_label->labelcolor(YELLOW);
	ptz_focus_value_label->labelsize(7);
	ptz_focus_value_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	start_x += 30;

	aperture_label = new Fl_Box(start_x, yy, 80, 20, "App");
	aperture_label->box(FL_NO_BOX);
	aperture_label->color(YELLOW);
	aperture_label->labelcolor(YELLOW);
	aperture_label->labelsize(9);
	aperture_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_aperture_open_button = new PTZ_Button(this, start_x + 30, yy + 20, 20, 20, "@#8>");
	ptz_aperture_open_button->box(FL_FRAME);
	ptz_aperture_open_button->color(DARK_BLUE);
	ptz_aperture_open_button->labelcolor(YELLOW);
	ptz_aperture_open_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_aperture_open_button->copy_tooltip("Open the aperture using VISCA or V4L");
	ptz_aperture_open_button->user_data((void *)PTZ_APERTURE_OPEN);

	ptz_aperture_close_button = new PTZ_Button(this, start_x + 30, yy + 40, 20, 20, "@#2>");
	ptz_aperture_close_button->box(FL_FRAME);
	ptz_aperture_close_button->color(DARK_BLUE);
	ptz_aperture_close_button->labelcolor(YELLOW);
	ptz_aperture_close_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_aperture_close_button->copy_tooltip("Close the aperture using VISCA or V4L");
	ptz_aperture_close_button->user_data((void *)PTZ_APERTURE_CLOSE);
	start_y = yy + 100;
	return(start_y);
}

int	PTZ_Window::AddWindowControls(int start_x, int start_y)
{
	int yy = start_y;
	ptz_spawn_another_button = new MyButton(start_x, yy, 80, 15, "Spawn Another");
	ptz_spawn_another_button->box(FL_FLAT_BOX);
	ptz_spawn_another_button->color(BLACK);
	ptz_spawn_another_button->labelcolor(YELLOW);
	ptz_spawn_another_button->labelsize(9);
	ptz_spawn_another_button->box(FL_NO_BOX);
	ptz_spawn_another_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_spawn_another_button->copy_tooltip("Reveal and addition PTZ / VISCA control dialog");
	ptz_spawn_another_button->value(0);
	ptz_spawn_another_button->callback(ptz_spawn_another_cb, this);
	yy += 16;

	ptz_hide_button = new MyButton(start_x, yy, 80, 15, "Hide");
	ptz_hide_button->box(FL_FLAT_BOX);
	ptz_hide_button->color(BLACK);
	ptz_hide_button->labelcolor(YELLOW);
	ptz_hide_button->labelsize(9);
	ptz_hide_button->box(FL_NO_BOX);
	ptz_hide_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_hide_button->copy_tooltip("Hide this PTZ / VISCA dialog");
	ptz_hide_button->value(0);
	ptz_hide_button->callback(ptz_hide_cb, this);
	if(instance == 0)
	{
		ptz_hide_button->hide();
	}
	yy += 16;
	ptz_pin_button = new MyLightButton(start_x, yy, 80, 15, "Pin");
	ptz_pin_button->box(FL_FLAT_BOX);
	ptz_pin_button->color(BLACK);
	ptz_pin_button->labelcolor(YELLOW);
	ptz_pin_button->labelsize(9);
	ptz_pin_button->box(FL_NO_BOX);
	ptz_pin_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_pin_button->copy_tooltip("Pin this dialog open");
	ptz_pin_button->value(0);
	ptz_pin_button->callback(ptz_pin_cb, this);
	yy += 16;

	ptz_bound_name_box = new Fl_Output(start_x, yy, 95, 15, "Bound:");
	ptz_bound_name_box->align(FL_ALIGN_LEFT);
	ptz_bound_name_box->box(FL_NO_BOX);
	ptz_bound_name_box->color(BLACK);
	ptz_bound_name_box->textcolor(WHITE);
	ptz_bound_name_box->textsize(9);
	ptz_bound_name_box->labelcolor(WHITE);
	ptz_bound_name_box->labelsize(9);
	ptz_bound_name_box->copy_tooltip("The camera to which the PTZ control is bound");
	ptz_bound_name_box->value("");
	if(bound_camera != NULL)
	{
		ptz_bound_name_box->value(bound_camera->alias);
	}
	yy += 16;
	start_y = yy;
	return(start_y);
}

int	PTZ_Window::AddSpeedSlider(int start_x, int start_y)
{
	int yy = start_y;
	ptz_speed_slider = new Fl_Hor_Fill_Slider(start_x, yy, 60, 10, "Speed");
	ptz_speed_slider->box(FL_NO_BOX);
	ptz_speed_slider->slider(FL_FRAME_BOX);
	ptz_speed_slider->color(BLACK);
	ptz_speed_slider->labelsize(9);
	ptz_speed_slider->labelcolor(YELLOW);
	ptz_speed_slider->align(FL_ALIGN_CENTER | FL_ALIGN_TOP);
	ptz_speed_slider->value(0.5);
	ptz_speed_slider->bounds(0.01, 1.0);
	ptz_speed_slider->copy_tooltip("Set the PTZ speed");
	ptz_speed_slider->callback(ptz_set_speed_cb, this);

	ptz_zoom_speed_adjust_button = new MyToggleButton(start_x + 60, yy, 10, 10, "Z");
	ptz_zoom_speed_adjust_button->box(FL_FLAT_BOX);
	ptz_zoom_speed_adjust_button->color(BLACK);
	ptz_zoom_speed_adjust_button->labelcolor(YELLOW);
	ptz_zoom_speed_adjust_button->labelsize(8);
	ptz_zoom_speed_adjust_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_zoom_speed_adjust_button->copy_tooltip("Toggle between motion and zoom speed control");
	ptz_zoom_speed_adjust_button->value(0);
	ptz_zoom_speed_adjust_button->callback(ptz_zoom_speed_adjust_cb, this);

	start_y += 22;
	return(start_y);
}

void	change_pan_tilt_style_cb(Fl_Widget *w, void *v)
{
	PTZ_Window *win = (PTZ_Window *)v;
	if(win->pan_tilt_style == PAN_TILT_STYLE_BUTTONS)
	{
		win->pan_tilt_style = PAN_TILT_STYLE_JOYSTICK;
		win->pan_tilt_button_group->hide();
		win->pan_tilt_joystick_group->show();
	}
	else
	{
		win->pan_tilt_style = PAN_TILT_STYLE_BUTTONS;
		win->pan_tilt_joystick_group->hide();
		win->pan_tilt_button_group->show();
	}
	win->redraw();
}

int	PTZ_Window::AddPanTiltButtons(int start_x, int start_y)
{
	int yy = start_y;
	pt_label = new Fl_Button(start_x, yy, 100, 20, "Pan/Tilt");
	pt_label->box(FL_NO_BOX);
	pt_label->color(YELLOW);
	pt_label->labelcolor(YELLOW);
	pt_label->labelsize(9);
	pt_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	pt_label->copy_tooltip("Select between joystick and button interfaces for pan/zoom/tilt");
	pt_label->callback(change_pan_tilt_style_cb, this);
	yy += 21;
	int other_yy = PTZ_Window::AddPanTiltButtonPanel(start_x, yy);
	yy = PTZ_Window::AddPanTiltJoystickPanel(start_x, yy);
	return(yy);
}

int	PTZ_Window::AddPanTiltButtonPanel(int start_x, int yy)
{
	pan_tilt_button_group = new Fl_Window(start_x + 15, yy, 70, 70);
	pan_tilt_button_group->box(FL_FLAT_BOX);
	pan_tilt_button_group->color(BLACK);

	ptz_up_button = new PTZ_Button(this, 25, 5, 20, 20, "@#8>");
	ptz_up_button->box(FL_FRAME);
	ptz_up_button->color(YELLOW);
	ptz_up_button->labelcolor(YELLOW);
	ptz_up_button->copy_tooltip("Move camera up using VISCA or V4L");
	ptz_up_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_up_button->user_data((void *)PTZ_UP);

	ptz_up_right_button = new PTZ_Button(this, 50, 0, 20, 20, "@#9>");
	ptz_up_right_button->box(FL_FRAME);
	ptz_up_right_button->color(YELLOW);
	ptz_up_right_button->labelcolor(YELLOW);
	ptz_up_right_button->copy_tooltip("Move camera up and right using VISCA or V4L");
	ptz_up_right_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_up_right_button->user_data((void *)PTZ_UP_RIGHT);

	ptz_up_left_button = new PTZ_Button(this, 0, 0, 20, 20, "@#7>");
	ptz_up_left_button->box(FL_FRAME);
	ptz_up_left_button->color(YELLOW);
	ptz_up_left_button->labelcolor(YELLOW);
	ptz_up_left_button->copy_tooltip("Move camera up and left using VISCA or V4L");
	ptz_up_left_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_up_left_button->user_data((void *)PTZ_UP_LEFT);

	ptz_down_button = new PTZ_Button(this, 25, 45, 20, 20, "@#2>");
	ptz_down_button->box(FL_FRAME);
	ptz_down_button->color(DARK_BLUE);
	ptz_down_button->labelcolor(YELLOW);
	ptz_down_button->copy_tooltip("Move camera down using VISCA or V4L");
	ptz_down_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_down_button->user_data((void *)PTZ_DOWN);

	ptz_down_right_button = new PTZ_Button(this, 50, 50, 20, 20, "@#3>");
	ptz_down_right_button->box(FL_FRAME);
	ptz_down_right_button->color(DARK_BLUE);
	ptz_down_right_button->labelcolor(YELLOW);
	ptz_down_right_button->copy_tooltip("Move camera down and right using VISCA or V4L");
	ptz_down_right_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_down_right_button->user_data((void *)PTZ_DOWN_RIGHT);

	ptz_down_left_button = new PTZ_Button(this, 0, 50, 20, 20, "@#1>");
	ptz_down_left_button->box(FL_FRAME);
	ptz_down_left_button->color(DARK_BLUE);
	ptz_down_left_button->labelcolor(YELLOW);
	ptz_down_left_button->copy_tooltip("Move camera down and left using VISCA or V4L");
	ptz_down_left_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_down_left_button->user_data((void *)PTZ_DOWN_LEFT);

	ptz_left_button = new PTZ_Button(this, 5, 25, 20, 20, "@#4>");
	ptz_left_button->box(FL_FRAME);
	ptz_left_button->color(DARK_BLUE);
	ptz_left_button->labelcolor(YELLOW);
	ptz_left_button->copy_tooltip("Move camera left using VISCA or V4L");
	ptz_left_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_left_button->user_data((void *)PTZ_LEFT);

	ptz_home_button = new PTZ_Button(this, 26, 26, 17, 17, "");
	ptz_home_button->box(FL_FRAME);
	ptz_home_button->color(DARK_BLUE);
	ptz_home_button->labelcolor(YELLOW);
	ptz_home_button->copy_tooltip("Move to the camera to home position using VISCA or V4L");
	ptz_home_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_home_button->user_data((void *)PTZ_HOME);

	ptz_right_button = new PTZ_Button(this, 45, 25, 20, 20, "@#>");
	ptz_right_button->box(FL_FRAME);
	ptz_right_button->color(DARK_BLUE);
	ptz_right_button->labelcolor(YELLOW);
	ptz_right_button->copy_tooltip("Move the camera right using VISCA or V4L");
	ptz_right_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_right_button->user_data((void *)PTZ_RIGHT);

	pan_tilt_button_group->end();
	int start_y = yy + 88;
	return(start_y);
}

PanTiltJoystick::PanTiltJoystick(MyWin *in_win, PTZ_Window *in_ptz_window, int xx, int yy, int ww, int hh) : Fl_Box(xx, yy, ww, hh)
{
	my_window = in_win;
	ptz_window = in_ptz_window;
	pos_x = w() / 2;
	pos_y = h() / 2;
	dragging = 0;
	box(FL_FRAME_BOX);
	color(FL_BLACK);
}

PanTiltJoystick::~PanTiltJoystick()
{
}

void	PanTiltJoystick::draw()
{
	if(visible())
	{
		Fl_Box::draw();
		fl_color(WHITE);
		fl_arc(1, 1, w() - 2, h() - 2, 0, 360);
		fl_color(YELLOW);
		fl_pie(pos_x - 5, pos_y - 5, 10, 10, 0, 360);
		fl_color(GRAY);
		fl_line(w() / 2, 0, w() / 2, h());
		fl_line(0, h() / 2, w(), h() / 2);
	}
}

int		PanTiltJoystick::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		if((xx > pos_x - 5) && (xx < pos_x + 5)
		&& (yy > pos_y - 5) && (yy < pos_y + 5))
		{
			dragging = 1;
		}
		flag = 1;
	}
	else if(event == FL_DRAG)
	{
		if(dragging == 1)
		{
			int xx = Fl::event_x();
			int yy = Fl::event_y();

			if(xx < 0) xx = 0;
			if(xx > w()) xx = w();
			if(yy < 0) yy = 0;
			if(yy > h()) yy = h();

			pos_x = xx;
			pos_y = yy;
			Move();
			redraw();
			flag = 1;
		}
	}
	else if(event == FL_RELEASE)
	{
		pos_x = w() / 2;
		pos_y = w() / 2;
		redraw();
		my_window->ViscaCommand(ptz_window->instance, PTZ_PAN_STOP);
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Box::handle(event);
	}
	return(flag);
}

void	PanTiltJoystick::Move()
{
	int instance = ptz_window->instance;
	int use_x = pos_x - (w() / 2);
	int use_y = pos_y - (h() / 2);

	double dx_speed = 0.0;
	double dy_speed = 0.0;
	if((use_x != 0) && (use_y != 0))
	{
		double slope = (double)use_y / (double)use_x;
		dx_speed = cos(slope);
		dy_speed = sin(slope);
	}
	else if(use_x == 0)
	{
		dx_speed = 0;
		if(use_y > 0) dy_speed = 1.0;
		else dy_speed = -1.0;
	}
	else if(use_y == 0)
	{
		dy_speed = 0;
		if(use_x > 0) dx_speed = 1.0;
		else dx_speed = -1.0;
	}
	int x_speed = (int)abs((dx_speed * (double)use_x) / 4);
	int y_speed = (int)abs((dy_speed * (double)use_y) / 4);
	if((use_x > 0) && (use_y > 0))
	{
		my_window->ViscaCommand(instance, PTZ_DOWN_RIGHT, 2, x_speed, y_speed);
	}
	else if((use_x < 0) && (use_y > 0))
	{
		my_window->ViscaCommand(instance, PTZ_DOWN_LEFT, 2, x_speed, y_speed);
	}
	else if((use_x < 0) && (use_y < 0))
	{
		my_window->ViscaCommand(instance, PTZ_UP_LEFT, 2, x_speed, y_speed);
	}
	else if((use_x > 0) && (use_y < 0))
	{
		my_window->ViscaCommand(instance, PTZ_UP_RIGHT, 2, x_speed, y_speed);
	}
	else if((use_x > 0) && (use_y == 0))
	{
		my_window->ViscaCommand(instance, PTZ_RIGHT, 2, x_speed, y_speed);
	}
	else if((use_x < 0) && (use_y == 0))
	{
		my_window->ViscaCommand(instance, PTZ_LEFT, 2, x_speed, y_speed);
	}
	else if((use_x == 0) && (use_y > 0))
	{
		my_window->ViscaCommand(instance, PTZ_DOWN, 2, x_speed, y_speed);
	}
	else if((use_x == 0) && (use_y < 0))
	{
		my_window->ViscaCommand(instance, PTZ_UP, 2, x_speed, y_speed);
	}
}

int	PTZ_Window::AddPanTiltJoystickPanel(int start_x, int yy)
{
	pan_tilt_joystick_group = new Fl_Window(start_x + 15, yy, 70, 70);
	pan_tilt_joystick_group->box(FL_NO_BOX);

	pt_joystick = new PanTiltJoystick(my_window, this, 0, 0, 70, 70);

	pan_tilt_joystick_group->end();
	int start_y = yy + 88;
	return(start_y);
}

int	PTZ_Window::AddCamerasAndPresets(int start_x, int start_y)
{
int	loop;

	int yy = start_y;
	Fl_Box *camera_label = new Fl_Box(0, yy, 150, 20, "Cameras");
	camera_label->box(FL_NO_BOX);
	camera_label->color(YELLOW);
	camera_label->labelcolor(YELLOW);
	camera_label->labelsize(9);
	camera_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		char buf[128];
		sprintf(buf, "%d", loop + 1);
		ptz_camera_select_button[loop] = new MyButton((10 + (loop * 20)), yy + 20, 18, 18, strdup(buf));
		ptz_camera_select_button[loop]->box(FL_THIN_UP_FRAME);
		ptz_camera_select_button[loop]->box(FL_NO_BOX);
		ptz_camera_select_button[loop]->color(DARK_BLUE);
		ptz_camera_select_button[loop]->labelcolor(YELLOW);
		ptz_camera_select_button[loop]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		ptz_camera_select_button[loop]->labelsize(11);
		ptz_camera_select_button[loop]->copy_tooltip("Select the VISCA camera controlled by this dialog");
		ptz_camera_select_button[loop]->callback(ptz_select_camera_cb, this);
	}
	yy += 40;
	Fl_Box *preset_label = new Fl_Box(start_x, yy, 150, 20, "Presets");
	preset_label->box(FL_NO_BOX);
	preset_label->color(YELLOW);
	preset_label->labelcolor(YELLOW);
	preset_label->labelsize(9);
	preset_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	yy += 20;

	ptz_preset_page = 0;
	ptz_camera_preset_page_back_button = new MyButton(start_x + 5, yy, 10, 18, "@4>");
	ptz_camera_preset_page_back_button->box(FL_THIN_UP_BOX);
	ptz_camera_preset_page_back_button->box(FL_NO_BOX);
	ptz_camera_preset_page_back_button->color(DARK_BLUE);
	ptz_camera_preset_page_back_button->labelcolor(YELLOW);
	ptz_camera_preset_page_back_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_camera_preset_page_back_button->labelsize(11);
	ptz_camera_preset_page_back_button->copy_tooltip("Page back through camera numbers");
	ptz_camera_preset_page_back_button->callback(ptz_preset_page_back_cb, this);
	int cnt = 0;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		char buf[128];
		sprintf(buf, "%d", loop + 1);
		ptz_camera_preset_button[loop] = new MyButton((start_x + 15 + (cnt * 20)), yy, 18, 18, strdup(buf));
		ptz_camera_preset_button[loop]->box(FL_THIN_UP_BOX);
		ptz_camera_preset_button[loop]->box(FL_NO_BOX);
		ptz_camera_preset_button[loop]->color(DARK_BLUE);
		ptz_camera_preset_button[loop]->labelcolor(YELLOW);
		ptz_camera_preset_button[loop]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		ptz_camera_preset_button[loop]->labelsize(11);
		ptz_camera_preset_button[loop]->copy_tooltip("Select a preset position for a VISCA camera");
		ptz_camera_preset_button[loop]->callback(ptz_select_preset_cb, this);
		if(loop > 6)
		{
			ptz_camera_preset_button[loop]->hide();
		}
		ptz_camera_set_button[loop] = new MyToggleButton((start_x + 15 + (cnt * 20)), yy + 18, 18, 8);
		ptz_camera_set_button[loop]->box(FL_FRAME);
		ptz_camera_set_button[loop]->color(YELLOW);
		ptz_camera_set_button[loop]->down_color(YELLOW);
		ptz_camera_set_button[loop]->labelcolor(YELLOW);
		ptz_camera_set_button[loop]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		ptz_camera_set_button[loop]->labelsize(11);
		ptz_camera_set_button[loop]->copy_tooltip("Set a preset position for a VISCA camera");
		ptz_camera_set_button[loop]->callback(ptz_set_preset_cb, this);
		if(loop > 6)
		{
			ptz_camera_set_button[loop]->hide();
		}
		cnt++;
		if(cnt > 6)
		{
			cnt = 0;
		}
	}
	ptz_camera_preset_page_forward_button = new MyButton((start_x + 15 + (7 * 20)), yy, 10, 18, "@6>");
	ptz_camera_preset_page_forward_button->box(FL_THIN_UP_BOX);
	ptz_camera_preset_page_forward_button->box(FL_NO_BOX);
	ptz_camera_preset_page_forward_button->color(DARK_BLUE);
	ptz_camera_preset_page_forward_button->labelcolor(YELLOW);
	ptz_camera_preset_page_forward_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_camera_preset_page_forward_button->labelsize(11);
	ptz_camera_preset_page_forward_button->copy_tooltip("Page forward through VISCA camera numbers");
	ptz_camera_preset_page_forward_button->callback(ptz_preset_page_forward_cb, this);
	yy += 32;
	start_y = yy;
	return(start_y);
}

int	OpenInterface(VISCAInterface_t *iface, char *path, int *interface_type)
{
	int err = -1;
	int is_network = 0;
	if(strncmp(path, "tcp://", strlen("tcp://")) == 0)
	{
		char *sep = strrchr(path, ':');
		if(sep != NULL)
		{
			char *host = strdup(path + strlen("tcp://"));
			int port = atoi(sep + 1);
			char *cp = host;
			while((*cp != ':') && (*cp != '\0')) cp++;
			if(*cp == ':') *cp = '\0';
			err = VISCA_open_tcp(iface, host, port);
			if(err == 0)
			{
				is_network = 1;
				*interface_type = VISCA_INTERFACE_TYPE_TCP;
			}
		}
	}
	else if(strncmp(path, "udp://", strlen("udp://")) == 0)
	{
		char *sep = strrchr(path, ':');
		if(sep != NULL)
		{
			char *host = strdup(path + strlen("udp://"));
			int port = atoi(sep + 1);
			char *cp = host;
			while((*cp != ':') && (*cp != '\0')) cp++;
			if(*cp == ':') *cp = '\0';
			err = VISCA_open_udp(iface, host, port);
			if(err == 0)
			{
				is_network = 1;
				*interface_type = VISCA_INTERFACE_TYPE_UDP;
			}
		}
	}
	else
	{
		err = VISCA_open_serial(iface, path);
		if(err == 0)
		{
			*interface_type = VISCA_INTERFACE_TYPE_SERIAL;
		}
	}
	iface->broadcast = 0;
	if((is_network == 0) && (err == 0))
	{
		int assigned = 0;
		err = VISCA_set_address(iface, &assigned);
	}
	else if(err != 0)
	{
		*interface_type = VISCA_INTERFACE_TYPE_ERROR;
	}
	return(err);
}

int	PTZ_Window::AddInterfaceButton(int start_x, int start_y)
{
int	aa, ab, ac;
int	loop;
int	inner;

	for(aa = 0;aa < NUMBER_OF_INTERFACES;aa++)
	{
		for(ab = 0;ab < NUMBER_OF_CAMERAS;ab++)
		{
			for(ac = 0;ac < NUMBER_OF_PRESETS;ac++)
			{
				ptz_position[aa][ab][ac] = new PTZ_Position(0, 0, 0, 0, 0);
			}
		}
	}
	int camera_num = 0;
	int err = 0;
	ptz_current_interface = NULL;
	ptz_current_camera = NULL;
	ptz_interface_index = 0;

	ptz_interface_button = new SelectButton(start_x, start_y, 160, 20, "Interfaces");
	ptz_interface_button->box(FL_FLAT_BOX);
	ptz_interface_button->color(BLACK);
	ptz_interface_button->labelcolor(YELLOW);
	ptz_interface_button->labelsize(9);
	ptz_interface_button->box(FL_NO_BOX);
	ptz_interface_button->align(FL_ALIGN_CENTER | FL_ALIGN_TOP);
	ptz_interface_button->copy_tooltip("Select the VISCA interface controlled by this dialog");
	ptz_interface_button->callback(ptz_select_interface_cb, this);
	start_y += 18;

	for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
	{
		ptz_remember_camera[inner] = -1;
	}
	ptz_current_device_path = NULL;
	for(loop = 0;loop < my_window->ptz_device_cnt;loop++)
	{
		if(instance == 0)
		{
			if(start_win != NULL)
			{
				if(start_win->visible())
				{
					char buf[8192];
					sprintf(buf, "Initialize PTZ:\n%s", my_window->ptz_device_path[loop]);
					start_win->Update(buf);
				}
			}
			int rr = TestPTZPort(my_window->ptz_device_path[loop]);
			if(rr == 1)
			{
				memset(&my_window->iface[loop], 0, sizeof(my_window->iface[loop]));
				int interface_type = 0;
				err = OpenInterface(&my_window->iface[loop], my_window->ptz_device_path[loop], &interface_type);
				my_window->ptz_interface_type[loop] = interface_type;
			}
			else
			{
				err = -1;
				my_window->ptz_interface_type[loop] = VISCA_INTERFACE_TYPE_ERROR;
			}
		}
		if(err == 0)
		{
			char *use_path = my_window->ptz_device_path[loop];
			if(my_window->ptz_alias[loop] != NULL)
			{
				if(strlen(my_window->ptz_alias[loop]) > 0)
				{
					use_path = my_window->ptz_alias[loop];
				}
			}
			ptz_interface_button->Add(use_path);
			if(ptz_current_interface == NULL)
			{
				ptz_current_interface = &my_window->iface[loop];
				ptz_current_device_path = my_window->ptz_device_path[loop];
				ptz_interface_index = loop;
			}
			if(my_window->ptz_lock_alias[loop] != NULL)
			{
				for(inner = 0;inner < my_window->source_cnt;inner++)
				{
					Camera *cam = my_window->camera[inner];
					if(cam != NULL)
					{
						if(strlen(cam->alias) > 0)
						{
							for(int nn = 0;nn < NUMBER_OF_CAMERAS;nn++)
							{
								if(my_window->ptz_lock_alias[loop][nn] != NULL)
								{
									if(strcmp(cam->alias, my_window->ptz_lock_alias[loop][nn]) == 0)
									{
										cam->ptz_lock_interface = loop;
										cam->ptz_lock_camera = nn;
									}
								}
							}
							if(my_window->ptz_bind_alias[instance] != NULL)
							{
								if(strcmp(cam->alias, my_window->ptz_bind_alias[instance]) == 0)
								{
									bound_camera = cam;
									cam->prefer_ndi = my_window->ptz_prefer_ndi[instance];
									cam->prefer_v4l = my_window->ptz_prefer_v4l[instance];
								}
							}
						}
					}
				}
			}
			if(instance == 0)
			{
				for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
				{
					memset(&my_window->visca_camera[inner], 0, sizeof(my_window->visca_camera[inner]));
					int assigned = 0;
					if(my_window->ptz_interface_type[loop] == VISCA_INTERFACE_TYPE_SERIAL)
					{
						int nn = VISCA_set_address(&my_window->iface[loop], &assigned);
						my_window->visca_camera[inner].address = assigned;
					}
					else
					{
						my_window->visca_camera[inner].address = 1;
					}
					if(ptz_current_camera == NULL)
					{
						ptz_current_camera = &my_window->visca_camera[inner];
						ptz_remember_camera[ptz_interface_index] = inner;
					}
				}
				ptz_current_camera = &my_window->visca_camera[0];
				my_window->StartVisca();
				for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
				{
					my_window->ViscaSpecs(&my_window->iface[loop], &my_window->visca_camera[inner]);
				}
				if(my_window->ptz_home_on_launch == 1)
				{
					my_window->ViscaCommand(instance, PTZ_HOME);
				}
			}
			else
			{
				for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
				{
					if(ptz_current_camera == NULL)
					{
						ptz_current_camera = &my_window->visca_camera[inner];
						ptz_remember_camera[ptz_interface_index] = inner;
					}
				}
				ptz_current_camera = &my_window->visca_camera[0];
			}
		}
		else
		{
			fprintf(stderr, "Error: Cannot open VISCA device at: [%s]\n", my_window->ptz_device_path[loop]);
			my_window->SetErrorMessage("Error: Cannot open VISCA device");
		}
	}
	return(start_y);
}

PTZ_Window::~PTZ_Window()
{
int	aa, ab, ac;
int	loop;

	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		ptz_camera_select_button[loop] = NULL;
	}
	for(aa = 0;aa < NUMBER_OF_INTERFACES;aa++)
	{
		for(ab = 0;ab < NUMBER_OF_CAMERAS;ab++)
		{
			for(ac = 0;ac < NUMBER_OF_PRESETS;ac++)
			{
				if(ptz_position[aa][ab][ac] != NULL)
				{
					delete ptz_position[aa][ab][ac];
					ptz_position[aa][ab][ac] = NULL;
				}
			}
		}
	}
}

int	PTZ_Window::handle(int event)
{
int	loop;

	int flag = 0;
	if(event == FL_FOCUS)
	{
		flag = 1;
	}
	else if(event == FL_UNFOCUS)
	{
		flag = 1;
	}
	else if(event == FL_SHOW)
	{
		if(bound_camera != NULL)
		{
			if(bound_camera->ptz_lock_interface > -1)
			{
				ptz_interface_button->SetCurrent(bound_camera->ptz_lock_interface);
			}
		}
	}
	else if(event == FL_PUSH)
	{
		if(bound_camera != NULL)
		{
			if((!Fl::event_inside(ptz_alias_button))
			&& (!Fl::event_inside(ptz_contract_button)))
			{
				if(bound_camera != my_window->DisplayedCamera())
				{
					my_window->DisplayCamera(bound_camera);
				}
			}
		}
		Fl_Group *p = parent();
		p->remove(this);
		p->add(this);
		p->redraw();
		redraw();
	}
	else if(event == FL_ENTER)
	{
		hovering = 1;
		Fl::focus(this);
	}
	else if(event == FL_LEAVE)
	{
		hovering = 0;
	}
	else if(event == FL_MOUSEWHEEL)
	{
		if(hovering == 1)
		{
			ptz_contract_cb(NULL, this);
			flag = 1;
		}
	}
	else if(event == FL_KEYBOARD)
	{
		int ctrl = Fl::event_state(FL_CTRL);
		int shift = Fl::event_state(FL_SHIFT);
		if(hovering == 1)
		{
			int key = Fl::event_key();
			if(key == FL_Down)
			{
				if((shift == 0) && (ctrl == 0))
				{
					key_table[KEY_DOWN] = 1;
				}
				else if(shift)
				{
					my_window->ViscaCommand(instance, PTZ_ZOOM_OUT);
					zooming = 1;
				}
				else if(ctrl)
				{
					my_window->ViscaCommand(instance, PTZ_FOCUS_NEAR);
					focusing = 1;
				}
				flag = 1;
			}
			else if(key == FL_Up)
			{
				if((shift == 0) && (ctrl == 0))
				{
					key_table[KEY_UP] = 1;
				}
				else if(shift)
				{
					my_window->ViscaCommand(instance, PTZ_ZOOM_IN);
					zooming = 1;
				}
				else if(ctrl)
				{
					my_window->ViscaCommand(instance, PTZ_FOCUS_FAR);
					focusing = 1;
				}
				flag = 1;
			}
			else if(key == FL_Right)
			{
				key_table[KEY_RIGHT] = 1;
				flag = 1;
			}
			else if(key == FL_Left)
			{
				key_table[KEY_LEFT] = 1;
				flag = 1;
			}
			else if(key == FL_Home)
			{
				my_window->ViscaCommand(instance, PTZ_HOME);
				flag = 1;
			}
			else if(key == FL_Page_Up)
			{
				my_window->ViscaCommand(instance, PTZ_ZOOM_IN);
				zooming = 1;
				flag = 1;
			}
			else if(key == FL_Page_Down)
			{
				my_window->ViscaCommand(instance, PTZ_ZOOM_OUT);
				zooming = 1;
				flag = 1;
			}
			if((key_table[KEY_DOWN] == 1) && (key_table[KEY_RIGHT] == 1))
			{
				my_window->ViscaCommand(instance, PTZ_DOWN_RIGHT);
				dir = 1;
			}
			else if((key_table[KEY_DOWN] == 1) && (key_table[KEY_LEFT] == 1))
			{
				my_window->ViscaCommand(instance, PTZ_DOWN_LEFT);
				dir = 1;
			}
			else if((key_table[KEY_UP] == 1) && (key_table[KEY_RIGHT] == 1))
			{
				my_window->ViscaCommand(instance, PTZ_UP_RIGHT);
				dir = 1;
			}
			else if((key_table[KEY_UP] == 1) && (key_table[KEY_LEFT] == 1))
			{
				my_window->ViscaCommand(instance, PTZ_UP_LEFT);
				dir = 1;
			}
			else if(key_table[KEY_DOWN] == 1)
			{
				my_window->ViscaCommand(instance, PTZ_DOWN);
				dir = 1;
			}
			else if(key_table[KEY_UP] == 1)
			{
				my_window->ViscaCommand(instance, PTZ_UP);
				dir = 1;
			}
			else if(key_table[KEY_RIGHT] == 1)
			{
				my_window->ViscaCommand(instance, PTZ_RIGHT);
				dir = 1;
			}
			else if(key_table[KEY_LEFT] == 1)
			{
				my_window->ViscaCommand(instance, PTZ_LEFT);
				dir = 1;
			}
		}
	}
	else if(event == FL_KEYUP)
	{
		if(hovering == 1)
		{
			int dir = 0;
			int key = Fl::event_key();
			if(key == FL_Down)
			{
				key_table[KEY_DOWN] = 0;
				flag = 1;
			}
			else if(key == FL_Up)
			{
				key_table[KEY_UP] = 0;
				flag = 1;
			}
			else if(key == FL_Right)
			{
				key_table[KEY_RIGHT] = 0;
				flag = 1;
			}
			else if(key == FL_Left)
			{
				key_table[KEY_LEFT] = 0;
				flag = 1;
			}
			if(zooming == 1)
			{
				my_window->ViscaCommand(instance, PTZ_ZOOM_STOP);
				zooming = 0;
				flag = 1;
			}
			if(focusing == 1)
			{
				my_window->ViscaCommand(instance, PTZ_FOCUS_STOP);
				focusing = 0;
				flag = 1;
			}
			if(dir == 1)
			{
				if((key_table[KEY_DOWN] == 0)
				&& (key_table[KEY_UP] == 0)
				&& (key_table[KEY_RIGHT] == 0)
				&& (key_table[KEY_LEFT] == 0))
				{
					my_window->ViscaCommand(instance, PTZ_PAN_STOP);
				}
				dir = 0;
			}
		}
	}
	if(flag == 0)
	{
		flag = SlidingElement::handle(event);
	}
	return(flag);
}

void	PTZ_Window::draw()
{
	SlidingElement::draw();
	if(bound_camera != NULL)
	{
		if(bound_camera == my_window->DisplayedCamera())
		{
			fl_color(YELLOW);
			fl_rect(x(), y(), w(), h());
		}
	}
}

void	PTZ_Window::UpdatePTZButtons()
{
static time_t last_here = 0;

	time_t nn = time(0);
	int diff = nn - last_here;
	if(diff > 2)
	{
		if(instance == 0)
		{
			int rr = my_window->LockedCameraStatus();
			if(rr == 1)
			{
				ptz_lock_to_camera_button->value(1);
			}
			else
			{
				ptz_lock_to_camera_button->value(0);
			}
		}
		if(bound_camera != NULL)
		{
			ptz_bind_camera_button->value(1);
		}
		else
		{
			ptz_bind_camera_button->value(0);
		}
		int rr = AutoFocusStatus();
		if(rr == 1)
		{
			ptz_auto_focus->activate();
			ptz_auto_focus->value(1);
		}
		else if(rr == 0)
		{
			ptz_auto_focus->activate();
			ptz_auto_focus->value(0);
		}
		else
		{
			ptz_auto_focus->deactivate();
		}
		rr = AutoExposureStatus();
		if(rr == 1)
		{
			ptz_auto_exp->activate();
			ptz_auto_exp->value(1);
		}
		else if(rr == 0)
		{
			ptz_auto_exp->activate();
			ptz_auto_exp->value(0);
		}
		else
		{
			ptz_auto_exp->deactivate();
		}
		rr = DigitalZoomStatus();
		if(rr == 1)
		{
			ptz_dzoom_button->activate();
			ptz_dzoom_button->value(1);
		}
		else if(rr == 0)
		{
			ptz_dzoom_button->activate();
			ptz_dzoom_button->value(0);
		}
		else
		{
			ptz_dzoom_button->deactivate();
		}
		rr = BacklightStatus();
		if(rr == 1)
		{
			ptz_backlight->activate();
			ptz_backlight->value(1);
		}
		else if(rr == 0)
		{
			ptz_backlight->activate();
			ptz_backlight->value(0);
		}
		else
		{
			ptz_backlight->deactivate();
		}
		ptz_follow_button->value(my_window->ptz_follow);
		ptz_soft_memory_button->value(ptz_soft_memory[ptz_interface_index][ptz_current_camera_idx]);
		last_here = time(0);
	}
}

void	PTZ_Window::UpdatePresets()
{
int	loop;

	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(ptz_position[ptz_interface_index][ptz_current_camera_idx][loop]->set == 1)
		{
			ptz_camera_set_button[loop]->value(1);
			ptz_camera_set_button[loop]->box(FL_FRAME_BOX);
		}
		else
		{
			ptz_camera_set_button[loop]->value(0);
			ptz_camera_set_button[loop]->box(FL_FRAME);
		}
		ptz_camera_set_button[loop]->redraw();
	}
}

int		PTZ_Window::AutoFocusStatus()
{
	int rr = 0;
	uint8_t auto_val = 0;
	if(ptz_current_interface != NULL)
	{
		int nn = VISCA_get_focus_auto(ptz_current_interface, ptz_current_camera, &auto_val);
		if(nn == VISCA_SUCCESS)
		{
			if(auto_val == VISCA_FOCUS_AUTO_ON)
			{
				rr = 1;
			}
			else if(auto_val == VISCA_FOCUS_AUTO_OFF)
			{
				rr = 0;
			}
		}
		else
		{
			Camera *cam = my_window->DisplayedCamera();
			if(cam != NULL)
			{
				if((cam->ptz_lock_interface == ptz_interface_index) 
				&& ((cam->ptz_lock_camera == ptz_current_camera_idx) || (cam->ptz_lock_camera == -1)))
				{
					if(cam->cap != NULL)
					{
						int val = cam->cap->get(CAP_PROP_AUTOFOCUS);
						if(val != 0)
						{
							rr = 1;
						}
						else
						{
							rr = 0;
						}
					}
					else
					{
						rr = -1;
					}
				}
				else
				{
					rr = -1;
				}
			}
			else
			{
				rr = -1;
			}
		}
	}
	else
	{
		rr = -1;
	}
	return(rr);
}

int		PTZ_Window::AutoExposureStatus()
{
	int rr = 0;
	uint8_t auto_val = 0;
	if(ptz_current_interface != NULL)
	{
		int nn = VISCA_get_auto_exp_mode(ptz_current_interface, ptz_current_camera, &auto_val);
		if(nn == VISCA_SUCCESS)
		{
			if(auto_val == VISCA_AUTO_EXP_FULL_AUTO)
			{
				rr = 1;
			}
			else if(auto_val == VISCA_AUTO_EXP_MANUAL)
			{
				rr = 0;
			}
		}
		else
		{
			Camera *cam = my_window->DisplayedCamera();
			if(cam != NULL)
			{
				if((cam->ptz_lock_interface == ptz_interface_index) 
				&& ((cam->ptz_lock_camera == ptz_current_camera_idx) || (cam->ptz_lock_camera == -1)))
				{
					if(cam->cap != NULL)
					{
						int val = cam->cap->get(V4L2_EXPOSURE_AUTO);
						if(val != 0)
						{
							rr = 1;
						}
						else
						{
							rr = 0;
						}
					}
					else
					{
						rr = -1;
					}
				}
				else
				{
					rr = -1;
				}
			}
			else
			{
				rr = -1;
			}
		}
	}
	else
	{
		rr = -1;
	}
	return(rr);
}

int		PTZ_Window::DigitalZoomStatus()
{
	int rr = 0;
	uint8_t auto_val = 0;
	if(ptz_current_interface != NULL)
	{
		int nn = VISCA_get_dzoom(ptz_current_interface, ptz_current_camera, &auto_val);
		if(nn == VISCA_SUCCESS)
		{
			if(auto_val == VISCA_DZOOM_ON)
			{
				rr = 1;
			}
			else if(auto_val == VISCA_DZOOM_OFF)
			{
				rr = 0;
			}
		}
		else
		{
			rr = -1;
		}
	}
	else
	{
		rr = -1;
	}
	return(rr);
}

int		PTZ_Window::BacklightStatus()
{
	int rr = 0;
	uint8_t auto_val = 0;
	if(ptz_current_interface != NULL)
	{
		int nn = VISCA_get_backlight_comp(ptz_current_interface, ptz_current_camera, &auto_val);
		if(nn == VISCA_SUCCESS)
		{
			if(auto_val == VISCA_FOCUS_AUTO_ON)
			{
				rr = 1;
			}
			else if(auto_val == VISCA_FOCUS_AUTO_OFF)
			{
				rr = 0;
			}
		}
		else
		{
			rr = -1;
		}
	}
	else
	{
		rr = -1;
	}
	return(rr);
}

struct	PTZ_Info
{
	PTZ_Window	*ptz_window;
	int			state;
	MyButton	*button;
};

void	release_shortcut(void *v)
{
	struct PTZ_Info *info = (PTZ_Info *)v;
	info->ptz_window->ViscaButtonCommands(info->button, info->state);
	free(info);
}

void	PTZ_Window::ViscaButtonCommands(MyButton *b, int state)
{
	if(state == FL_PUSH)
	{
		int b_type = (long int)b->user_data();
		my_window->ViscaCommand(instance, b_type);
	}
	else if(state == FL_SHORTCUT)
	{
		int key = Fl::event_key();
		int state = Fl::event_state();
		if((state & FL_ALT) == FL_ALT)
		{
			key += FL_ALT;
		}
		if((state & FL_SHIFT) == FL_SHIFT)
		{
			key += FL_SHIFT;
		}
		if((state & FL_CTRL) == FL_CTRL)
		{
			key += FL_CTRL;
		}
		if(b->shortcut() == key)
		{
			int b_type = (long int)b->user_data();
			my_window->ViscaCommand(instance, b_type);
			struct PTZ_Info *info = (struct PTZ_Info *)malloc(sizeof(PTZ_Info));
			info->ptz_window = this;
			info->state = FL_RELEASE;
			info->button = b;
			Fl::add_timeout(0.1, release_shortcut, info);
		}
	}
	else if(state == FL_RELEASE)
	{
		int b_type = (long int)b->user_data();
		if((b_type == PTZ_UP)
		|| (b_type == PTZ_UP_RIGHT)
		|| (b_type == PTZ_UP_LEFT)
		|| (b_type == PTZ_DOWN)
		|| (b_type == PTZ_DOWN_RIGHT)
		|| (b_type == PTZ_DOWN_LEFT)
		|| (b_type == PTZ_LEFT)
		|| (b_type == PTZ_RIGHT))
		{
			my_window->ViscaCommand(instance, PTZ_PAN_STOP);
		}
		else if((b_type == PTZ_ZOOM_IN) || (b_type == PTZ_ZOOM_OUT))
		{
			my_window->ViscaCommand(instance, PTZ_ZOOM_STOP);
		}
		else if((b_type == PTZ_FOCUS_FAR) || (b_type == PTZ_FOCUS_NEAR))
		{
			my_window->ViscaCommand(instance, PTZ_FOCUS_STOP);
		}
	}
}

void	PTZ_Window::PTZ_RememberPosition(int num)
{
	MyWin *win = my_window;
	PTZ_Position *pos = ptz_position[ptz_interface_index][ptz_current_camera_idx][num];
	if(pos != NULL)
	{
		pos->Set(win->ptz_pan_reading, win->ptz_tilt_reading, win->ptz_zoom_reading, win->ptz_focus_reading);
	}
	if(ptz_current_interface != NULL)
	{
		if(ptz_soft_memory[ptz_interface_index][ptz_current_camera_idx] == 0)
		{
			VISCA_memory_set(ptz_current_interface, ptz_current_camera, num);
		}
	}
}

void	PTZ_Window::PTZ_UnRememberPosition(int num)
{
	PTZ_Position *pos = ptz_position[ptz_interface_index][ptz_current_camera_idx][num];
	if(pos != NULL)
	{
		pos->UnSet();
	}
	if(ptz_current_interface != NULL)
	{
		if(ptz_soft_memory[ptz_interface_index][ptz_current_camera_idx] == 0)
		{
			VISCA_memory_reset(ptz_current_interface, ptz_current_camera, num);
		}
	}
}

int	PTZ_Window::PTZ_RecallPosition(int speed, int num)
{
	int r = 0;
	if(ptz_soft_memory[ptz_interface_index][ptz_current_camera_idx] == 1)
	{
		if((num > -1) && (num < NUMBER_OF_PRESETS))
		{
			PTZ_Position *pos = ptz_position[ptz_interface_index][ptz_current_camera_idx][num];
			if(pos->set == 1)
			{
				GoToPTZPosition(speed, pos->pan, pos->tilt, pos->zoom, pos->focus);
				r = 1;
			}
		}
	}
	else
	{
		if(ptz_current_interface != NULL)
		{
			VISCA_memory_recall(ptz_current_interface, ptz_current_camera, num);
			r = 1;
		}
	}
	return(r);
}

void	PTZ_Window::GoToPTZPosition(int speed, int in_pan, int in_tilt, int in_zoom, int in_focus)
{
	int done = 0;
	int attempts = 0;
	while((done == 0) && (attempts < 10))
	{
		int target_pan = in_pan;
		int target_tilt = in_tilt;
		my_window->ViscaCommand(instance, PTZ_ABSOLUTE_POSITION, 4, speed, speed, target_pan, target_tilt);
		while(my_window->visca_command != 0)
		{
			Fl::check();
			usleep(10000);
		}
		int r_pan = my_window->ptz_pan_reading / 16;
		int r_tilt = my_window->ptz_tilt_reading / 16;
		int d_pan = abs(r_pan - target_pan);
		int d_tilt = abs(r_tilt - target_tilt);
		if((d_pan < 100) && (d_tilt < 100))
		{
			done = 1;
		}
		attempts++;
	}
	my_window->ViscaCommand(instance, PTZ_ZOOM_AND_FOCUS, 2, in_zoom, in_focus);
	while(my_window->visca_command != 0)
	{
		Fl::check();
		usleep(10000);
	}
	Fl::check();
}

void	PTZ_Window::LoadPTZPositions(int fd)
{
int	aa, ab, ac;

	if(fd != -1)
	{
		for(aa = 0;aa < NUMBER_OF_INTERFACES;aa++)
		{
			for(ab = 0;ab < NUMBER_OF_CAMERAS;ab++)
			{
				for(ac = 0;ac < NUMBER_OF_PRESETS;ac++)
				{
					if(ptz_position[aa][ab][ac] != NULL)
					{
						read(fd, ptz_position[aa][ab][ac], sizeof(PTZ_Position));
					}
				}
			}
		}
	}
}

void	PTZ_Window::AutoFocus(int on)
{
	if(ptz_current_interface != NULL)
	{
		if(on == 1)
		{
			VISCA_set_focus_auto(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_FOCUS_AUTO_ON);
			if(bound_camera != NULL)
			{
				if(bound_camera->ndi_ptz == 1)
				{
					NDILib->recv_ptz_auto_focus(bound_camera->ndi_recv);
				}
			}
		}
		else
		{
			VISCA_set_focus_auto(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_FOCUS_AUTO_OFF);
		}
	}
	ptz_auto_focus->value(on);
}

void	PTZ_Window::DigitalZoom(int on)
{
	if(ptz_current_interface != NULL)
	{
		if(on == 1)
		{
			VISCA_set_dzoom(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_DZOOM_ON);
		}
		else
		{
			VISCA_set_dzoom(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_DZOOM_OFF);
		}
	}
}

void	PTZ_Window::AutoExposure(int on)
{
	if(ptz_current_interface != NULL)
	{
		if(on == 1)
		{
			VISCA_set_auto_exp_mode(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_AUTO_EXP_FULL_AUTO);
		}
		else
		{
			VISCA_set_auto_exp_mode(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_AUTO_EXP_MANUAL);
		}
	}
}

void	PTZ_Window::BacklightCompensation(int on)
{
	if(ptz_current_interface != NULL)
	{
		if(on == 1)
		{
			VISCA_set_backlight_comp(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_ON);
		}
		else
		{
			VISCA_set_backlight_comp(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_OFF);
		}
	}
}

// SECTION *********************************** CODEC SELECTION WINDOW AND LIST MENU *******************************************

void	codec_selection_window_cb(Fl_Widget *in_csw, void *v)
{
	CodecSelectionWindow *csw = (CodecSelectionWindow *)in_csw;
	strcpy(csw->container_selected, "");
	strcpy(csw->extension_selected, "");
	strcpy(csw->video_codec_selected, "");
	strcpy(csw->audio_codec_selected, "");
	csw->hide();
}

void	csw_outcome_cancel_cb(Fl_Widget *w, void *v)
{
	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	strcpy(csw->container_selected, "");
	strcpy(csw->extension_selected, "");
	strcpy(csw->video_codec_selected, "");
	strcpy(csw->audio_codec_selected, "");
	csw->hide();
}

void	clear_window_cb(Fl_Widget *w, void *v)
{
	Fl_Window *win = (Fl_Window *)v;
	win->hide();
	Fl::delete_widget(win);
}

void	csw_outcome_accept_cb(Fl_Widget *w, void *v)
{
void		reset_button_cb(Fl_Widget *w, void *v);
int			my_find_codec_by_name(int type, char *format_name, char *in_name);
char		buf[256];

	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	MyWin *win = csw->my_window;
	int video_id = my_find_codec_by_name(0, csw->container_selected, csw->video_codec_selected);
	int audio_id = my_find_codec_by_name(1, csw->container_selected, csw->audio_codec_selected);
	if((video_id != 0) && (audio_id != 0))
	{
		csw->video_codec_id = (AVCodecID)video_id;
		csw->audio_codec_id = (AVCodecID)audio_id;
		strcpy(buf, csw->extension_selected);
		char *cp = buf;
		while((*cp != '\0') && (*cp != ','))
		{
			cp++;
		}
		if(*cp == ',')
		{
			*cp = '\0';
		}
		strcpy(csw->extension_selected, buf);
		strcpy(win->use_extension, buf);
		strcpy(win->use_container, csw->container_selected);
		win->use_video_codec = (AVCodecID)video_id;
		win->use_audio_codec = (AVCodecID)audio_id;
		int	video_found = my_find_codec_by_id(0, win->use_video_codec, win->video_codec_name);
		int	audio_found = my_find_codec_by_id(1, win->use_audio_codec, win->audio_codec_name);
		csw->hide();
		win->SaveCodecs();
		reset_button_cb(NULL, win);
	}
	else
	{
		static char buf[1024];
		Fl_Window *win = new Fl_Window(csw->x() + (csw->w() / 2) - 150, csw->y() + (csw->h() / 2) - 30, 300, 60);
		win->box(FL_FLAT_BOX);
		win->color(WHITE);
		win->border(0);
		if((strlen(csw->video_codec_selected) > 0)
		&& (strlen(csw->audio_codec_selected) > 0))
		{
			if((strlen(csw->video_codec_selected) > 0) && (strlen(csw->audio_codec_selected) > 0))
			{
				if((video_id == 0) && (audio_id == 0))
				{
					sprintf(buf, "%s and %s are not valid codecs.", csw->video_codec_selected, csw->audio_codec_selected);
				}
				else if(video_id == 0)
				{
					sprintf(buf, "%s is not a valid video codec.", csw->video_codec_selected);
				}
				else if(audio_id == 0)
				{
					sprintf(buf, "%s is not a valid audio codec.", csw->audio_codec_selected);
				}
			}
			else
			{
				sprintf(buf, "Invalid codecs selected.");
			}
		}
		else
		{
			sprintf(buf, "Invalid codecs selected.");
		}
		MyButton *button = new MyButton(1, 1, 298, 58);
		button->copy_label(buf);
		button->color(DARK_RED);
		button->box(FL_FLAT_BOX);
		button->labelcolor(WHITE);
		button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		button->callback(clear_window_cb, win);
		win->end();
		win->set_modal();
		win->show();
	}
}

ListMenu::ListMenu(void *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Window(xx, yy, ww, hh)
{
	my_window = in_win;
	item_cnt = 0;
	current_item = -1;
	box(FL_FRAME_BOX);
	color(BLACK);
	border(0);
		scroll = new Fl_Scroll(2, 24, ww - 4, h() - 26, lbl);
		scroll->align(FL_ALIGN_TOP);
		scroll->labelcolor(WHITE);
		scroll->box(FL_FLAT_BOX);
		scroll->color(BLACK);
		scroll->type(Fl_Scroll::VERTICAL);
		scroll->end();
		scroll->hscrollbar.hide();
	end();
}

ListMenu::~ListMenu()
{
}

void	ListMenu::ScrollToItem(Fl_Widget *wid)
{
	int extent = wid->y() + wid->h();
	if(extent > scroll->y() + scroll->h())
	{
		scroll->scroll_to(0, scroll->yposition() + wid->h());
	}
	if(wid->y() < scroll->y())
	{
		scroll->scroll_to(0, scroll->yposition() - wid->h());
	}
}

int	ListMenu::handle(int event)
{
int	loop;

	int flag = 0;
	switch(event)
	{
		case(FL_FOCUS):
		{
			color(DARK_RED);
			if(item_cnt > 0)
			{
				if(current_item < 0)
				{
					current_item = 0;
				}
				if(current_item > -1)
				{
					if(item[current_item]->color() != DARK_GRAY)
					{
						item[current_item]->color(DARK_GRAY);
						item[current_item]->do_callback(item[current_item], my_window);
					}
				}
			}
			redraw();
			flag = 1;
		}
		break;
		case(FL_UNFOCUS):
		{
			color(BLACK);
			redraw();
			flag = 1;
		}
		break;
		case(FL_KEYBOARD):
		{
			int key = Fl::event_key();
			if(key == FL_Down)
			{
				if(current_item < (item_cnt - 1))
				{
					item[current_item]->color(BLACK);
					current_item++;
					item[current_item]->color(DARK_GRAY);
					ScrollToItem(item[current_item]);
					item[current_item]->do_callback(item[current_item], my_window);
					redraw();
				}
				flag = 1;
			}
			else if(key == FL_Up)
			{
				if(current_item > 0)
				{
					item[current_item]->color(BLACK);
					current_item--;
					item[current_item]->color(DARK_GRAY);
					ScrollToItem(item[current_item]);
					item[current_item]->do_callback(item[current_item], my_window);
					redraw();
				}
				flag = 1;
			}
		}
		break;
		case(FL_PUSH):
		{
			for(loop = 0;loop < item_cnt;loop++)
			{
				item[loop]->color(BLACK);
				if(Fl::event_inside(item[loop]))
				{
					current_item = loop;
					item[current_item]->color(DARK_GRAY);
					item[current_item]->do_callback(item[current_item], my_window);
					redraw();
					take_focus();
				}
			}
			flag = 1;
		}
		break;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	ListMenu::Add(Fl_Widget *wid)
{
	scroll->add(wid);
	item[item_cnt] = wid;
	item_cnt++;
	current_item = 0;
}

void	ListMenu::Clear()
{
	scroll->clear();
	current_item = -1;
	item_cnt = 0;
}

void	select_audio_codec_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyButton *b = (MyButton *)w;
	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	strcpy(csw->audio_codec_selected, b->label());
}

void	select_video_codec_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	strcpy(csw->video_codec_selected, b->label());
}

void	codecs_menu_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyButton *b = (MyButton *)w;
	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	if(csw != NULL)
	{
		MyWin *win = csw->my_window;
		char *format_name = (char *)b->label();
		int done = -1;
		MyFormat *mf = NULL;
		for(loop = 0;((loop < global_my_format_cnt) && (done == -1));loop++)
		{
			MyFormat *test_mf = global_my_format[loop];
			if(strcmp(format_name, test_mf->name) == 0)
			{
				done = loop;
				mf = test_mf;
			}
		}
		if(mf != NULL)
		{
			strcpy(csw->container_selected, mf->name);
			strcpy(csw->extension_selected, mf->extensions);
			strcpy(csw->video_codec_selected, "");
			strcpy(csw->audio_codec_selected, "");
			int yy = 26;
			csw->video_codec->Clear();
			for(loop = 0;loop < mf->video_codec_cnt;loop++)
			{
				if(mf->video_id[loop] != 0)
				{
					MyToggleButton *video_button = new MyToggleButton(4, yy, 192, 20, mf->video_codec[loop]);
					video_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					video_button->box(FL_FLAT_BOX);
					video_button->color(BLACK);
					video_button->down_color(DARK_GRAY);
					video_button->labelcolor(YELLOW);
					video_button->type(FL_RADIO_BUTTON);
					video_button->clear_visible_focus();
					video_button->callback(select_video_codec_cb, csw);
					csw->video_codec->Add(video_button);
					if(strcmp(mf->video_codec[loop], win->video_codec_name) == 0)
					{
						csw->video_codec->current_item = loop;
						video_button->color(DARK_GRAY);
						select_video_codec_cb(video_button, csw);
					}
					else
					{
						if(mf->video_codec_cnt == 1)
						{
							video_button->color(DARK_GRAY);
							select_video_codec_cb(video_button, csw);
						}
					}
					yy += 20;
				}
			}
			csw->video_codec->redraw();
			csw->video_codec->show();
			yy = 26;
			csw->audio_codec->Clear();
			for(loop = 0;loop < mf->audio_codec_cnt;loop++)
			{
				if(mf->audio_id[loop] != 0)
				{
					MyToggleButton *audio_button = new MyToggleButton(4, yy, 192, 20, mf->audio_codec[loop]);
					audio_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					audio_button->box(FL_FLAT_BOX);
					audio_button->color(BLACK);
					audio_button->labelcolor(YELLOW);
					audio_button->down_color(GRAY);
					audio_button->type(FL_RADIO_BUTTON);
					audio_button->clear_visible_focus();
					audio_button->callback(select_audio_codec_cb, csw);
					csw->audio_codec->Add(audio_button);
					if(strcmp(mf->audio_codec[loop], win->audio_codec_name) == 0)
					{
						csw->audio_codec->current_item = loop;
						audio_button->color(DARK_GRAY);
						select_audio_codec_cb(audio_button, csw);
					}
					else
					{
						if(mf->audio_codec_cnt == 1)
						{
							audio_button->color(DARK_GRAY);
							select_audio_codec_cb(audio_button, csw);
						}
					}
					yy += 20;
				}
			}
			csw->audio_codec->redraw();
			csw->audio_codec->show();
		}
	}
}

void	container_menu_cb(Fl_Widget *w, void *v)
{
int		loop;

	MyWin *win = (MyWin *)v;
	if(win->codec_selection_window == NULL)
	{
		win->codec_selection_window = new CodecSelectionWindow(win);
	}
	if(win->codec_selection_window->visible())
	{
		CodecSelectionWindow *cs = win->codec_selection_window;
		strcpy(cs->container_selected, "");
		strcpy(cs->extension_selected, "");
		strcpy(cs->video_codec_selected, "");
		strcpy(cs->audio_codec_selected, "");
		cs->hide();
	}
	else
	{
		CodecSelectionWindow *cs = win->codec_selection_window;
		strcpy(cs->container_selected, "");
		strcpy(cs->extension_selected, "");
		strcpy(cs->audio_codec_selected, "");
		strcpy(cs->video_codec_selected, "");

		cs->container->Clear();
		int yy = 26;
		int found = -1;
		for(loop = 0;loop < global_my_format_cnt;loop++)
		{
			MyFormat *mf = global_my_format[loop];
			if(mf->invalid == 0)
			{
				MyToggleButton *button = new MyToggleButton(4, yy, 176, 20, mf->name);
				button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
				button->box(FL_FLAT_BOX);
				button->color(BLACK);
				button->down_color(GRAY);
				button->labelcolor(YELLOW);
				button->type(FL_RADIO_BUTTON);
				button->clear_visible_focus();
				button->value(0);
				button->callback(codecs_menu_cb, cs);
				button->redraw();
				cs->container->Add(button);
				if(strcmp(mf->name, win->use_container) == 0)
				{
					found = loop;
				}
				yy += 20;
			}
		}
		cs->show();
		if(found > -1)
		{
			cs->container->current_item = found;
			cs->container->take_focus();
		}
	}
}

CodecSelectionWindow::CodecSelectionWindow(MyWin *in_win) : Dialog(630, 815, "Codec Selection")
{
	my_window = in_win;

	strcpy(container_selected, "");
	strcpy(extension_selected, "");
	strcpy(audio_codec_selected, "");
	strcpy(video_codec_selected, "");

	audio_codec_id = (AVCodecID)0;
	video_codec_id = (AVCodecID)0;

	int new_yp = 20;

	container = new ListMenu(this, 10, new_yp + 10, 200, 745, "Container Format");
	video_codec = new ListMenu(this, 215, new_yp + 10, 200, 745, "Video Codec");
	audio_codec = new ListMenu(this, 420, new_yp + 10, 200, 745, "Audio Codec");

	Fl_Box *warning = new Fl_Box(10, new_yp + 776, 380, 34);
	warning->box(FL_FLAT_BOX);
	warning->color(color());
	warning->labelcolor(WHITE);
	warning->labelsize(8);
	warning->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
	warning->copy_label("Warning: Reseting the codecs will\nreset recording. A new file will be made.");

	accept = new MyButton(420, new_yp + 784, 80, 20, "Accept");
	accept->box(FL_FLAT_BOX);
	accept->labelcolor(YELLOW);
	accept->color(BLACK);
	accept->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	accept->callback(csw_outcome_accept_cb, this);
	accept->show();

	cancel = new MyButton(530, new_yp + 784, 80, 20, "Cancel");
	cancel->box(FL_FLAT_BOX);
	cancel->labelcolor(YELLOW);
	cancel->color(BLACK);
	cancel->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	cancel->callback(csw_outcome_cancel_cb, this);
	cancel->show();
	end();

	set_non_modal();
	callback(codec_selection_window_cb, this);
}

CodecSelectionWindow::~CodecSelectionWindow()
{
}

// SECTION ************************************** ENCODE SPEED WINDOW **********************************************

void	encode_speed_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	MyButton *b = (MyButton *)w;
	char *lbl = (char *)b->label();
	if(lbl != NULL)
	{
		int nn = atoi(lbl);
		for(loop = 0;loop < 128;loop++)
		{
			if(win->my_muxer[loop] != NULL)
			{
				win->my_muxer[loop]->realtime_factor = nn;
			}
		}
	}
}

EncodeSpeedWindow::EncodeSpeedWindow(MyWin *in_win, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
int	loop;

	box(FL_NO_BOX);
	my_window = in_win;
	int px = xx;
	int val = -32;
	for(loop = 0;loop < 11;loop++)
	{
		if(val == 0) val = 1;
		sprintf(label_buf[loop], "%d", val);
		button[loop] = new MyButton(px, yy, 16, 16, label_buf[loop]);
		button[loop]->labelsize(8);
		button[loop]->color(DARK_GRAY);
		button[loop]->labelcolor(WHITE);
		button[loop]->down_color(GRAY);
		button[loop]->box(FL_FLAT_BOX);
		button[loop]->type(FL_RADIO_BUTTON);
		button[loop]->clear_visible_focus();
		button[loop]->callback(encode_speed_cb, my_window);
		if(val == 1)
		{
			button[loop]->value(1);
		}
		px += 15;
		if(val < 0)
		{
			val += abs(val) / 2;
			if(val == -1) val = 0;
		}
		else
		{
			val += abs(val);
		}
	}
	end();
	hide();
}

EncodeSpeedWindow::~EncodeSpeedWindow()
{
}

void	EncodeSpeedWindow::Reset()
{
int	loop;

	for(loop = 0;loop < 11;loop++)
	{
		button[loop]->value(0);
	}
	button[5]->value(1);
	for(loop = 0;loop < 128;loop++)
	{
		if(my_window->my_muxer[loop] != NULL)
		{
			my_window->my_muxer[loop]->realtime_factor = 1;
		}
	}
}

// SECTION ************************************** COMMAND KEY **********************************************

void	command_key_value_button_cb(Fl_Widget *w, void *v)
{
	CommandKeyGroup *ckg = (CommandKeyGroup *)v;
	ckg->my_window->CloseAll();
	ckg->value_button->hide();
	ckg->value_input->show();
	ckg->value_menu->show();
	ckg->redraw();
}

void	command_key_input_cb(Fl_Widget *w, void *v)
{
	CommandKeyGroup *ckg = (CommandKeyGroup *)v;
	ckg->my_window->CloseAll();
	ckg->value_button->copy_label(ckg->value_input->value());
	ckg->value_menu->value(-1);
	ckg->redraw();
}

void	command_key_menu_cb(Fl_Widget *w, void *v)
{
	CommandKeyGroup *ckg = (CommandKeyGroup *)v;
	ckg->my_window->CloseAll();
	ckg->value_button->copy_label(ckg->value_menu->text(ckg->value_menu->value()));
	ckg->value_input->value("");
	ckg->redraw();
}

CommandKeyGroup::CommandKeyGroup(CommandKeySettingsWindow *in_win, int xx, int yy, int in_ww, int in_hh, char *lbl, char *val) : MyGroup(xx, yy, in_ww, in_hh)
{
	my_window = in_win;
	if(val == NULL) val = "";
	int ww = in_ww - 40;
	int hh = in_hh;
	lbl_box = new Fl_Box(xx + 20, yy, ww / 2, hh, lbl);
	lbl_box->labelsize(9);
	lbl_box->labelcolor(WHITE);
	lbl_box->align(FL_ALIGN_INSIDE | FL_ALIGN_RIGHT);

	value_input = new Fl_Input(xx + ((ww / 2) + 25), yy + 1, 50 - 2, hh - 2);
	value_input->textsize(9);
	value_input->box(FL_FLAT_BOX);
	value_input->callback(command_key_input_cb, this);
	value_input->hide();
	if(strlen(val) == 1)
	{
		value_input->value(val);
	}
	value_menu = new MyMenuButton(xx + ((ww / 2) + 75), yy + 1, (ww / 4) - 2, hh - 2, "");
	value_menu->textsize(9);
	value_menu->box(FL_FLAT_BOX);
	value_menu->callback(command_key_menu_cb, this);
	value_menu->hide();

	// Cover both of the other widgets until it is pressed
	value_button = new MyButton(xx + ((ww / 2) + 25) + 1, yy + 1, 50 + (ww / 4) - 2, hh - 2);
	value_button->labelsize(11);
	value_button->box(FL_FLAT_BOX);
	value_button->color(WHITE);
	value_button->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	value_button->copy_label(val);
	value_button->callback(command_key_value_button_cb, this);

	int cnt = 0;
	int done = 0;
	while(done == 0)
	{
		if(named_key[cnt].val != 0)
		{
			char *str = named_key[cnt].name;
			value_menu->add(str);
		}
		else
		{
			done = 1;
		}
		cnt++;
	}
	if(strlen(val) > 1)
	{
		int nn = value_menu->find_index(val);
		if(nn > -1)
		{
			value_menu->value(nn);
		}
		value_input->value(val);
	}
	end();
}

CommandKeyGroup::~CommandKeyGroup()
{
}

void	CommandKeyGroup::value(char *val)
{
	if(strlen(val) == 1)
	{
		value_input->value(val);
	}
	if(strlen(val) > 1)
	{
		int nn = value_menu->find_index(val);
		if(nn > -1)
		{
			value_menu->value(nn);
		}
	}
	value_button->copy_label(val);
	value_button->show();
	value_input->hide();
	value_menu->hide();
}

void	CommandKeyGroup::Close()
{
	value_button->show();
	value_input->hide();
	value_menu->hide();
}

void	command_key_window_accept(Fl_Widget *w, void *v)
{
	CommandKeySettingsWindow *cksw = (CommandKeySettingsWindow *)v;
	cksw->hide();
}

void	command_key_window_cancel(Fl_Widget *w, void *v)
{
	CommandKeySettingsWindow *cksw = (CommandKeySettingsWindow *)v;
	cksw->hide();
}

void	command_key_window_reset(Fl_Widget *w, void *v)
{
int	loop;

	CommandKeySettingsWindow *cksw = (CommandKeySettingsWindow *)v;
	for(loop = 0;loop < cksw->command_key_cnt;loop++)
	{
		char *str = cksw->my_window->CommandKeyName(cksw->my_window->command_key[loop]);
		if(str != NULL)
		{
			cksw->command_key_group[loop]->value(str);
			cksw->command_key_group[loop]->redraw();
		}
	}
	cksw->redraw();
}

CommandKeySettingsWindow::CommandKeySettingsWindow(MyWin *in_win, int ww, int hh) : Dialog(ww, hh, "Key Bindings")
{
	my_window = in_win;
	int cnt = 0;

	int new_yp = 20;

	int y_pos = 20 + new_yp;
	box(FL_FRAME_BOX);
	color(BLACK);
	char *str = NULL;
	ww = 280;

	Fl_Scroll *scroll = new Fl_Scroll(10, y_pos, 260, 760);
	scroll->color(FL_BLACK);
	scroll->type(Fl_Scroll::VERTICAL);

	str = my_window->CommandKeyName(my_window->command_key[KEY_TOGGLE_RECORD]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "TOGGLE RECORD", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DELETE_IMMEDIATE]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DELETE IMMEDIATE", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_TOGGLE_PTZ_JOYSTICK]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "TOGGLE PTZ JOYSTICK", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_INCREASE_PTZ_LITTLE_SPEED]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "INCREASE PTZ LITTLE SPEED", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DECREASE_PTZ_LITTLE_SPEED]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DECREASE PTZ LITTLE SPEED", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_CYCLE_PTZ_LITTLE_MODE]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "CYCLE PTZ LITTLE MODE", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_PTZ_HOME]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "PTZ HOME", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_CYCLE_DOWN_THUMBGROUP]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "CYCLE DOWN THUMBGROUP", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_CYCLE_UP_THUMBGROUP]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "CYCLE UP THUMBGROUP", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_0]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 0", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_1]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 1", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_2]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 2", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_3]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 3", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_4]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 4", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_5]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 5", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_6]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 6", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_7]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 7", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_8]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 8", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_9]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 9", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_1]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 1", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_2]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 2", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_3]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 3", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_4]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 4", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_5]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 5", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_6]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 6", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_7]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 7", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_8]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 8", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_1]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 1", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_2]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 2", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_3]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 3", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_4]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 4", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_5]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 5", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_6]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 6", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_7]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 7", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_8]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 8", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LOCAL_ZOOM_IN]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LOCAL ZOOM IN", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LOCAL_ZOOM_OUT]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LOCAL ZOOM OUT", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_REVIEW]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "REVIEW", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_TOGGLE_FROZEN]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "TOGGLE FROZEN", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SNAPSHOT]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SNAPSHOT", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SNAPSHOT_OTHER]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SNAPSHOT OTHER", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SCALE_VIDEO_RESET]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SCALE VIDEO RESET", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SCALE_VIDEO_UP]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SCALE VIDEO UP", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SCALE_VIDEO_DOWN]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SCALE VIDEO DOWN", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_0]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 0", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_1]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 1", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_2]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 2", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_3]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 3", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_4]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 4", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_5]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 5", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_6]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 6", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_7]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 7", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_8]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 8", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_9]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 9", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_ELEMENTS]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "TOGGLE DISPLAY ELEMENTS", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_EXIT]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "EXIT", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_OPEN_MENU]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "OPEN MENU", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_OPEN_CAMERAS]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "OPEN CAMERAS", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_OPEN_AUDIO]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "OPEN AUDIO", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_OPEN_PTZ]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "OPEN PTZ", str); cnt++; y_pos += 18;

	scroll->end();

	command_key_cnt = cnt;

	int ny_pos = 21 + new_yp;
	accept = new MyButton(280, ny_pos, 80, 16, "Accept");
	accept->box(FL_FLAT_BOX);
	accept->color(YELLOW);
	accept->labelsize(11);
	accept->callback(command_key_window_accept, this);
	ny_pos += 18;
	
	cancel = new MyButton(280, ny_pos, 80, 16, "Cancel");
	cancel->box(FL_FLAT_BOX);
	cancel->color(YELLOW);
	cancel->labelsize(11);
	cancel->callback(command_key_window_cancel, this);
	ny_pos += 18;

	reset = new MyButton(280, ny_pos, 80, 16, "Reset");
	reset->box(FL_FLAT_BOX);
	reset->color(YELLOW);
	reset->labelsize(11);
	reset->callback(command_key_window_reset, this);

	end();
}

CommandKeySettingsWindow::~CommandKeySettingsWindow()
{
}

void	CommandKeySettingsWindow::CloseAll()
{
int	loop;

	for(loop = 0;loop < command_key_cnt;loop++)
	{
		command_key_group[loop]->Close();
	}
}

// SECTION ************************************** MENU BUTTON **********************************************

MenuButton::MenuButton(MainMenu *in_menu, int font_sz, int xx, int yy, int ww, int hh, char *lbl) : MyButton(xx, yy, ww, hh, lbl)
{
	my_menu = in_menu;
	hover = 0;
	box(FL_NO_BOX);
	labelcolor(YELLOW);
	labelsize(font_sz);
	align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	my_menu->AddButton(this);
}

MenuButton::~MenuButton()
{
}

int		MenuButton::handle(int event)
{
	int flag = 0;
	if(event == FL_ENTER)
	{
		my_menu->Select(this);
		redraw();
		window()->redraw();
		flag = 1;
	}
	else if(event == FL_LEAVE)
	{
		my_menu->Select(NULL);
		redraw();
		window()->redraw();
		flag = 1;
	}
	else if(event == FL_PUSH)
	{
		my_menu->Select(this);
		redraw();
		window()->redraw();
	}
	if(flag == 0)
	{
		flag = MyButton::handle(event);
	}
	return(flag);
}

void	MenuButton::draw()
{
	if(hover == 1)
	{
		labelcolor(CYAN);
	}
	else
	{
		labelcolor(YELLOW);
	}
	MyButton::draw();
}

void	MenuButton::show()
{
	MyButton::show();
	hover = 0;
}

void	MenuButton::hide()
{
	MyButton::hide();
	hover = 0;
}

// SECTION ************************************** MY GROUP AND RESIZE GROUP **********************************************

MyGroup::MyGroup(int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
}

MyGroup::MyGroup(int xx, int yy, int ww, int hh, char *lbl) : Fl_Group(xx, yy, ww, hh, lbl)
{
}

ResizeGroup::ResizeGroup(MyWin *in_win, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	my_window = in_win;
}

int	ResizeGroup::handle(int event)
{
char	buf[4096];

	Camera *cam = my_window->DisplayedCamera();
	int flag = 0;
	switch(event)
	{
		case(FL_FOCUS):
		case(FL_UNFOCUS):
		case(FL_DND_ENTER):
		case(FL_DND_LEAVE):
		case(FL_DND_DRAG):
		case(FL_DND_RELEASE):
		{
			flag = 1;
		}
		break;
		case(FL_PASTE):
		{
			char *path = (char *)Fl::event_text();
			if(path != NULL)
			{
				strncpy(buf, path, 4096);
				int nn = my_window->SetupCamera(buf, "Pasted", my_window->requested_w, my_window->requested_h, 32);
				if(nn == -1)
				{
					my_window->SetErrorMessage("Cannot Open Camera");
				}
			}
			flag = 1;
		}
		break;
	}
	if(flag == 0)
	{
		flag = MyGroup::handle(event);
	}
	return(flag);
}

// SECTION ************************************** MONITOR WINDOW *****************************************

void	monitor_window_popup_cb(Fl_Widget *w, void *v)
{
	Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
	MonitorWindow *mw = (MonitorWindow *)v;
	char *str = (char *)browser->text(browser->value());
	if(str != NULL)
	{
		if(strcmp(str, "Full Size") == 0)
		{
			mw->size = 1;
		}
		else if(strcmp(str, "Half Size") == 0)
		{
			mw->size = 2;
		}
		else if(strcmp(str, "Quarter Size") == 0)
		{
			mw->size = 4;
		}
		else if(strcmp(str, "Hide") == 0)
		{
			mw->hide();
		}
		mw->redraw();
	}
}

MonitorWindow::MonitorWindow(MyWin *in_win, int ww, int hh, char *lbl) : Dialog(ww, hh, lbl)
{
	my_window = in_win;
	depth = 0;
	popup = NULL;
	size = 1;
	int new_yp = 20;
	vertical_offset = new_yp;

	end();
	set_non_modal();
}

MonitorWindow::~MonitorWindow()
{
}

void	MonitorWindow::hide()
{
	my_window->monitor_video_button->copy_label("Monitor Video");
	Dialog::hide();
}

void	MonitorWindow::draw()
{
	Dialog::draw();
	if(depth > 0)
	{
		int ww = mat.cols / size;
		int hh = mat.rows / size;
		cv::resize(mat, mat, cv::Size(ww, hh));
		unsigned char *data_ptr = mat.ptr();
		fl_draw_image(data_ptr, 0, vertical_offset, w(), h(), depth);
	}
	else
	{
		fl_color(BLACK);
		fl_rectf(0, vertical_offset, w(), h());
	}
	fl_color(WHITE);
	fl_rect(0, 0, w(), h());
	depth = 0;
}

int		MonitorWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		if(Fl::event_button() == 3)
		{
			ShowPopup();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	MonitorWindow::ShowPopup()
{
	if(popup == NULL)
	{
		popup = new PopupMenu(Fl::event_x_root() - 10, Fl::event_y_root() - 10, 160, 170);
		popup->browser->callback(monitor_window_popup_cb, this);
	}
	else
	{
		popup->resize(Fl::event_x_root() - 10, Fl::event_y_root() - 10, popup->w(), popup->h());
	}
	if(popup != NULL)
	{
		popup->browser->clear();
		popup->browser->add("Full Size");
		popup->browser->add("Half Size");
		popup->browser->add("Quarter Size");
		popup->browser->add("Hide");
		popup->set_non_modal();
		popup->Fit();
		popup->show();
	}
}

// SECTION ************************************** MAIN MENU **********************************************

MainMenu::MainMenu(MyWin *in_win, int xx, int yy, int ww, int hh) : SlidingElement(in_win, OPEN_LEFT, xx, yy, ww, hh)
{
int	loop;

	my_window = in_win;
	hovering = 0;
	selected = 0;
	menu_button_cnt = 0;
	for(loop = 0;loop < 1024;loop++)
	{
		menu_button[loop] = NULL;
	}
}

MainMenu::~MainMenu()
{
}

void	MainMenu::show()
{
	Fl::focus(this);
	SlidingElement::show();
}

void	MainMenu::hide()
{
	SlidingElement::hide();
}

int	MainMenu::handle(int event)
{
	int flag = 0;
	if(event == FL_FOCUS)
	{
		flag = 1;
	}
	else if(event == FL_UNFOCUS)
	{
		flag = 1;
	}
	else if(event == FL_ENTER)
	{
		Fl::focus(this);
		hovering = 1;
	}
	else if(event == FL_LEAVE)
	{
		Fl::focus(my_window);
		hovering = 0;
	}
	else if(event == FL_KEYBOARD)
	{
		if((hovering == 1) || (my_window->buttons_shown == 1))
		{
			int key = Fl::event_key();
			if(key == FL_Down)
			{
				Advance();
				flag = 1;
			}
			else if(key == FL_Up)
			{
				Retreat();
				flag = 1;
			}
			else if((key == ' ') || (key == FL_Enter))
			{
				Do();
				flag = 1;
			}
			else if(key == FL_Tab)
			{
				Fl::focus(my_window);
				flag = my_window->handle(event);
			}
		}
	}
	if(flag == 0)
	{
		flag = SlidingElement::handle(event);
	}
	return(flag);
}

void	MainMenu::draw()
{
int	loop;

	int done = -1;
	for(loop = 0;((loop < menu_button_cnt) && (done == -1));loop++)
	{
		if(menu_button[loop] != NULL)
		{
			if(menu_button[loop]->hover == 1)
			{
				done = loop;
			}
		}
	}
	if(done == -1)
	{
		done = -1;
		for(loop = 0;((loop < menu_button_cnt) && (done == -1));loop++)
		{
			if(menu_button[loop] != NULL)
			{
				if(menu_button[loop]->visible())
				{
					menu_button[loop]->hover = 1;
					selected = loop;
					done = loop;
				}
			}
		}
	}
	SlidingElement::draw();
}

void	MainMenu::ClearSelection()
{
int	loop;

	selected = -1;
	for(loop = 0;loop < menu_button_cnt;loop++)
	{
		if(menu_button[loop] != NULL)
		{
			menu_button[loop]->hover = 0;
		}
	}
}

void	MainMenu::Select(MenuButton *in)
{
int	loop;

	ClearSelection();
	if(in != NULL)
	{
		int done = 0;
		for(loop = 0;((loop < menu_button_cnt) && (done == 0));loop++)
		{
			if(menu_button[loop] == in)
			{
				selected = loop;
				menu_button[loop]->hover = 1;
				done = 1;
			}
		}
	}
}

void	MainMenu::Do()
{
int	loop;

	int done = 0;
	for(loop = 0;((loop < menu_button_cnt) && (done == 0));loop++)
	{
		if(menu_button[loop] != NULL)
		{
			if(menu_button[loop]->hover == 1)
			{
				menu_button[loop]->do_callback();
				done = 1;
			}
		}
	}
}

void	MainMenu::Advance()
{
int	loop;
int	inner;

	int done = 0;
	if(selected > -1)
	{
		if(menu_button[selected] != NULL)
		{
			if(selected < (menu_button_cnt - 1))
			{
				for(inner = selected + 1;((inner < menu_button_cnt) && (done == 0));inner++)
				{
					if(menu_button[inner]->visible())
					{
						Select(menu_button[inner]);
						done = 1;
					}
				}
			}
		}
	}
}

void	MainMenu::Retreat()
{
int	loop;
int	inner;

	int done = 0;
	if(selected < (menu_button_cnt - 1))
	{
		if(menu_button[selected] != NULL)
		{
			for(inner = selected - 1;((inner >= 0) && (done == 0));inner--)
			{
				if(menu_button[inner]->visible())
				{
					Select(menu_button[inner]);
					done = 1;
				}
			}
		}
	}
}

void	MainMenu::AddButton(MenuButton *in_button)
{
	if(menu_button_cnt < 1024)
	{
		menu_button[menu_button_cnt] = in_button;
		menu_button_cnt++;
	}
}

// SECTION ************************************** GUIDELINE **********************************************

Guideline::Guideline(MyWin *in_win, int in_type, int in_pos)
{
	my_window = in_win;
	type = in_type;
	pos = in_pos;
	hide = 0;
}

Guideline::~Guideline()
{
}

// SECTION ************************************** AUDIO SETTINGS WINDOW  *********************************

MyMenuButton::MyMenuButton(int xx, int yy, int ww, int hh, char *lbl) : Fl_Menu_Button(xx, yy, ww, hh, lbl)
{
	labelsize(9);
	labelcolor(WHITE);
	textsize(9);
	color(DARK_GRAY);
	textcolor(WHITE);
	box(FL_FLAT_BOX);
	align(FL_ALIGN_LEFT);
}

MyMenuButton::~MyMenuButton()
{
}

void	MyMenuButton::draw()
{
	Fl_Menu_Button::draw();
	fl_color(labelcolor());
	fl_font(FL_HELVETICA, labelsize());
	int nn = value();
	if(nn > -1)
	{
		char *str = (char *)text(nn);
		if(str != NULL)
		{
			fl_draw(str, x(), y(), w(), h(), FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		}
	}
}

void	audio_settings_window_accept_cb(Fl_Widget *w, void *v)
{
	AudioSettingsWindow *asw = (AudioSettingsWindow *)v;
	MyWin *win = asw->my_window;

	int reset_needed = 0;
	int nn = asw->sample_rate->value();
	if(nn > -1)
	{
		char *str = (char *)asw->sample_rate->text(nn);
		if(str != NULL)
		{
			int val = atoi(str);
			if(win->audio_sample_rate != val)
			{
				win->audio_sample_rate = val;
				reset_needed = 1;
			}
		}
	}
	nn = asw->channels->value();
	if(nn > -1)
	{
		char *str = (char *)asw->channels->text(nn);
		if(str != NULL)
		{
			if(strcmp(str, "Mono") == 0)
			{
				if(win->audio_channels != 1)
				{
					win->audio_channels = 1;
					reset_needed = 1;
				}
			}
			if(strcmp(str, "Stereo") == 0)
			{
				if(win->audio_channels != 2)
				{
					win->audio_channels = 2;
					reset_needed = 1;
				}
			}
		}
	}
	nn = asw->display->value();
	if(nn > -1)
	{
		char *str = (char *)asw->display->text(nn);
		if(str != NULL)
		{
			if(strcmp(str, "None") == 0)
			{
				win->audio_display = 0;
			}
			else if(strcmp(str, "Amplitude") == 0)
			{
				win->audio_display = AUDIO_DISPLAY_AMPLITUDE;
			}
			else if(strcmp(str, "Frequency") == 0)
			{
				win->audio_display = AUDIO_DISPLAY_FREQUENCY;
			}
			else if(strcmp(str, "Both") == 0)
			{
				win->audio_display = AUDIO_DISPLAY_AMPLITUDE | AUDIO_DISPLAY_FREQUENCY;
			}
		}
	}
	win->audio_direct_mix = asw->direct_mix->value();
	win->audio_incidental_volume = asw->incidental_volume_slider->value();
	if(reset_needed == 1)
	{
		win->ResetAudio();
	}
	win->SaveAudioSettings("audio_settings.json");
	asw->hide();
}

AudioSettingsWindow::AudioSettingsWindow(MyWin *in_win) : Dialog(230, 174, "Audio Settings Window")
{
int	loop;

	my_window = in_win;

	int new_yp = 20;
	int yp = new_yp + 20;
	
	sample_rate = new MyMenuButton(100, yp, 100, 16, "Sample Rate");
	sample_rate->add("8000");
	sample_rate->add("9600");
	sample_rate->add("11025");
	sample_rate->add("12000");
	sample_rate->add("16000");
	sample_rate->add("22050");
	sample_rate->add("24000");
	sample_rate->add("32000");
	sample_rate->add("44100");
	sample_rate->add("48000");
	sample_rate->add("88200");
	sample_rate->add("192000");
	sample_rate->value(8);
	yp += 18;
	channels = new MyMenuButton(100, yp, 100, 16, "Channels");
	channels->add("Mono");
	channels->add("Stereo");
	channels->value(1);
	yp += 18;
	display = new MyMenuButton(100, yp, 100, 16, "Display");
	display->add("None");
	display->add("Amplitude");
	display->add("Frequency");
	display->add("Both");
	display->value(2);
	yp += 26;
	direct_mix = new MyLightButton(20, yp, 200, 18, "Direct Mix Incendentals");
	direct_mix->box(FL_FLAT_BOX);
	direct_mix->color(BLACK);
	direct_mix->labelcolor(YELLOW);
	direct_mix->labelsize(9);
	direct_mix->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	direct_mix->value(my_window->audio_direct_mix);
	yp += 24;
	incidental_volume_slider = new MySlider(100, yp, 100, 16, "Incidental Volume");
	incidental_volume_slider->color(BLACK);
	incidental_volume_slider->box(FL_FRAME_BOX);
	incidental_volume_slider->range(0.0, 1.0);
	incidental_volume_slider->value(my_window->audio_incidental_volume);
	incidental_volume_slider->initial_value = my_window->audio_incidental_volume;
	incidental_volume_slider->step(0.1);
	incidental_volume_slider->labelcolor(YELLOW);
	incidental_volume_slider->labelsize(9);
	incidental_volume_slider->align(FL_ALIGN_LEFT);
	yp += 26;

	MyButton *accept = new MyButton(20, yp, 80, 20, "Accept");
	accept->box(FL_NO_BOX);
	accept->color(WHITE);
	accept->labelcolor(YELLOW);
	accept->labelsize(12);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->callback(audio_settings_window_accept_cb, this);

	MyButton *cancel = new MyButton(120, yp, 80, 20, "Cancel");
	cancel->box(FL_NO_BOX);
	cancel->color(WHITE);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(12);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->callback(hide_window_cb, this);

	end();

	SetToMyWin();
}

AudioSettingsWindow::~AudioSettingsWindow()
{
}

void	AudioSettingsWindow::show()
{
	SetToMyWin();
	set_non_modal();
	Dialog::show();
}

void	AudioSettingsWindow::SetToMyWin()
{
int	loop;

	for(loop = 0;loop < sample_rate->size();loop++)
	{
		char *str = (char *)sample_rate->text(loop);
		if(str != NULL)
		{
			int nn = atoi(str);
			if(nn == my_window->audio_sample_rate)
			{
				sample_rate->value(loop);
			}
		}
	}
	if(my_window->audio_channels == 1)
	{
		channels->value(0);
	}
	else if(my_window->audio_channels == 2)
	{
		channels->value(1);
	}
	if(my_window->audio_display == AUDIO_DISPLAY_NONE)
	{
		display->value(0);
	}
	if(my_window->audio_display == AUDIO_DISPLAY_AMPLITUDE)
	{
		display->value(1);
	}
	if(my_window->audio_display == AUDIO_DISPLAY_FREQUENCY)
	{
		display->value(2);
	}
	if(((my_window->audio_display & AUDIO_DISPLAY_AMPLITUDE) == AUDIO_DISPLAY_AMPLITUDE)
	&& ((my_window->audio_display & AUDIO_DISPLAY_FREQUENCY) == AUDIO_DISPLAY_FREQUENCY))
	{
		display->value(3);
	}
	if(my_window->recorded_frames > 0)
	{
		sample_rate->deactivate();
		channels->deactivate();
	}
	else
	{
		sample_rate->activate();
		channels->activate();
	}
}

// SECTION ************************************** NDI SOURCE LIST WINDOW **********************************************

void	ndi_source_list(char *list[256], int& final_total)
{
int	loop;

	NDIlib_find_instance_t ndi_find;
	const NDIlib_source_t *sources = NULL;
	int cnt = 0;
	if(NDILib != NULL)
	{
		uint32_t num_sources = 0;
		const NDIlib_find_create_t NDI_find_create_desc;
		NDIlib_find_instance_t ndi_find = NDILib->NDIlib_find_create_v2(&NDI_find_create_desc);
		NDILib->NDIlib_find_wait_for_sources(ndi_find, 1000);
		sources = NDILib->NDIlib_find_get_current_sources(ndi_find, &num_sources);
		if((num_sources > 0) && (num_sources < 33))
		{
			for(loop = 0;loop < num_sources;loop++)
			{
				char source_name[256];
				sprintf(source_name, "ndi://%s", sources[loop].p_ndi_name);
				list[cnt] = strdup(source_name);
				cnt++;
				sprintf(source_name, "ndi_uyvy://%s", sources[loop].p_ndi_name);
				list[cnt] = strdup(source_name);
				cnt++;
				sprintf(source_name, "ndi_p216://%s", sources[loop].p_ndi_name);
				list[cnt] = strdup(source_name);
				cnt++;
				sprintf(source_name, "ndi_rgbx://%s", sources[loop].p_ndi_name);
				list[cnt] = strdup(source_name);
				cnt++;
				sprintf(source_name, "ndi_bgrx://%s", sources[loop].p_ndi_name);
				list[cnt] = strdup(source_name);
				cnt++;
			}
		}
		NDILib->NDIlib_find_destroy(ndi_find);
	}
	final_total = cnt;
}

void	select_ndi_source_cb(Fl_Widget *w, void *v)
{
int		loop;
char	buf[256];

	NDISourceListWindow *ndi_win = (NDISourceListWindow *)v;
	MyButton *b = (MyButton *)w;
	char *lbl = (char *)b->label();
	if(lbl != NULL)
	{
		strcpy(buf, lbl);
		char *cp = buf;
		int flag = 0;
		if(strncmp(buf, "[fastest] ", strlen("[fastest] ")) == 0)
		{
			cp += strlen("[fastest] ");
			flag = 1;
		}
		else if(strncmp(buf, "[best] ", strlen("[best] ")) == 0)
		{
			cp += strlen("[best] ");
			flag = 2;
		}
		else if(strncmp(buf, "[rgbx] ", strlen("[rgbx] ")) == 0)
		{
			cp += strlen("[rgbx] ");
			flag = 3;
		}
		else if(strncmp(buf, "[bgrx] ", strlen("[bgrx] ")) == 0)
		{
			cp += strlen("[bgrx] ");
			flag = 4;
		}
		for(loop = 0;loop < ndi_win->num_sources;loop++)
		{
			if(strcmp(cp, ndi_win->sources[loop].p_ndi_name) == 0)
			{
				if(ndi_win->my_window->new_source_window != NULL)
				{
					char use[256];
					if(flag == 0)
					{
						sprintf(use, "ndi://%s", ndi_win->sources[loop].p_ndi_name);
					}
					else if(flag == 1)
					{
						sprintf(use, "ndi_uyvy://%s", ndi_win->sources[loop].p_ndi_name);
					}
					else if(flag == 2)
					{
						sprintf(use, "ndi_p216://%s", ndi_win->sources[loop].p_ndi_name);
					}
					else if(flag == 3)
					{
						sprintf(use, "ndi_rgbx://%s", ndi_win->sources[loop].p_ndi_name);
					}
					else if(flag == 4)
					{
						sprintf(use, "ndi_bgrx://%s", ndi_win->sources[loop].p_ndi_name);
					}
					ndi_win->my_window->new_source_window->source->value(use);
					ndi_win->my_window->new_source_window->redraw();
				}
			}
		}
	}
	ndi_win->hide();
}

NDISourceListWindow::NDISourceListWindow(MyWin *in_win) : Dialog(300, 400, "NDI Source")
{
	my_window = in_win;
	end();
	ndi_find = NULL;

	int new_yp = 20;
	vertical_offset = new_yp;
	ndi_source_button_cnt = 0;
}

NDISourceListWindow::~NDISourceListWindow()
{
	if(ndi_find != NULL)
	{
		NDILib->NDIlib_find_destroy(ndi_find);
		ndi_find = NULL;
	}
}

void	NDISourceListWindow::clear()
{
int	loop;

	for(loop = 0;loop < ndi_source_button_cnt;loop++)
	{
		if(ndi_source_button[loop] != NULL)
		{
			remove(ndi_source_button[loop]);
			Fl::delete_widget(ndi_source_button[loop]);
			ndi_source_button[loop] = NULL;
		}
	}
	ndi_source_button_cnt = 0;
}

void	NDISourceListWindow::Update()
{
int	loop;
int	inner;

	if(NDILib != NULL)
	{
		if(ndi_find != NULL)
		{
			NDILib->NDIlib_find_destroy(ndi_find);
			ndi_find = NULL;
		}
		clear();
		num_sources = 0;
		sources = NULL;
		const NDIlib_find_create_t NDI_find_create_desc;
		NDIlib_find_instance_t ndi_find = NDILib->NDIlib_find_create_v2(&NDI_find_create_desc);
		NDILib->NDIlib_find_wait_for_sources(ndi_find, 1000);
		sources = NDILib->NDIlib_find_get_current_sources(ndi_find, &num_sources);
		int yp = 10 + vertical_offset;
		int cnt = 0;
		if((num_sources > 0) && (num_sources < 33))
		{
			resize(x(), y(), w(), ((num_sources * 5) * 18) + 42 + vertical_offset);
			for(loop = 0;loop < num_sources;loop++)
			{
				for(inner = 0;inner < 5;inner++)
				{
					char source_name[256];
					if(inner == 0)
					{
						sprintf(source_name, "%s", sources[loop].p_ndi_name);
					}
					if(inner == 1)
					{
						sprintf(source_name, "[fastest] %s", sources[loop].p_ndi_name);
					}
					if(inner == 2)
					{
						sprintf(source_name, "[best] %s", sources[loop].p_ndi_name);
					}
					if(inner == 3)
					{
						sprintf(source_name, "[rgbx] %s", sources[loop].p_ndi_name);
					}
					if(inner == 4)
					{
						sprintf(source_name, "[bgrx] %s", sources[loop].p_ndi_name);
					}
					ndi_source_button[cnt] = new MyButton(10, yp, w() - 20, 18, strdup(source_name));
					ndi_source_button[cnt]->box(FL_FLAT_BOX);
					ndi_source_button[cnt]->color(BLACK);
					ndi_source_button[cnt]->labelcolor(WHITE);
					ndi_source_button[cnt]->labelsize(9);
					ndi_source_button[cnt]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					ndi_source_button[cnt]->callback(select_ndi_source_cb, this);
					add(ndi_source_button[cnt]);
					cnt++;
					yp += 18;
				}
			}
		}
		else
		{
			resize(x(), y(), w(), 42 + vertical_offset);
		}
		ndi_source_button[cnt] = new MyButton(10, yp, w() - 20, 20, "Close");
		ndi_source_button[cnt]->box(FL_FLAT_BOX);
		ndi_source_button[cnt]->color(BLACK);
		ndi_source_button[cnt]->labelcolor(YELLOW);
		ndi_source_button[cnt]->labelsize(11);
		ndi_source_button[cnt]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		ndi_source_button[cnt]->callback(hide_window_cb, this);
		add(ndi_source_button[cnt]);
		cnt++;
		ndi_source_button_cnt = cnt;
	}
}

// SECTION ************************************** SOURCE SELECT WINDOW **********************************************

void	source_select_accept_cb(Fl_Widget *w, void *v)
{
int		loop;
char	buf[32768];

	SourceSelectWindow *ssw = (SourceSelectWindow *)v;
	NewSourceWindow *nsw = ssw->my_window->new_source_window;
	sprintf(buf, "split://%d,%d", ssw->cols_nn, ssw->rows_nn);
	int nn = ssw->cols_nn * ssw->rows_nn;
	if(nn > 0)
	{
		strcat(buf, ";");
	}
	for(loop = 0;loop < nn;loop++)
	{
		if(loop < 128)
		{
			if(ssw->list[loop] == NULL)
			{
				strcat(buf, "[blank]");
				if(loop < nn - 1)
				{
					strcat(buf, ",");
				}
			}
			else
			{
				strcat(buf, ssw->list[loop]);
				if(loop < nn - 1)
				{
					strcat(buf, ",");
				}
			}
		}
	}
	nsw->source->value(buf);
	ssw->hide();
}

void	source_select_image_button_cb(Fl_Widget *w, void *v)
{
	SourceSelectWindow *ssw = (SourceSelectWindow *)v;
	Fl_Button *tb = (Fl_Button *)w;
	ssw->Set((char *)tb->label());
	ssw->Update();
}

void	source_select_cols_and_rows_cb(Fl_Widget *w, void *v)
{
	SourceSelectWindow *ssw = (SourceSelectWindow *)v;
	Fl_Int_Input *in = (Fl_Int_Input *)w;
	char *val = (char *)in->value();
	int nn = atoi(val);
	if(nn > 0)
	{
		if(in == ssw->cols)
		{
			ssw->cols_nn = nn;
		}
		else
		{
			ssw->rows_nn = nn;
		}
		ssw->Update();
	}
}

SourceSelectWindow::SourceSelectWindow(MyWin *win, int ww, int hh, char *lbl) : Dialog(ww, hh, lbl)
{
int	loop;

	my_window = win;
	cols_nn = 2;
	rows_nn = 2;
	cur_row = 0;
	cur_col = 0;
	int new_yp = 20;
	vertical_offset = new_yp;

	for(loop = 0;loop < 128;loop++)
	{
		list[loop] = NULL;
	}
	cols = new Fl_Int_Input(100, new_yp + 14, 60, 20, "Columns");
	cols->color(BLACK);
	cols->textcolor(WHITE);
	cols->textsize(11);
	cols->cursor_color(WHITE);
	cols->labelcolor(YELLOW);
	cols->labelsize(9);
	cols->box(FL_FRAME_BOX);
	cols->value("2");
	cols->callback(source_select_cols_and_rows_cb, this);

	rows = new Fl_Int_Input(280, new_yp + 14, 60, 20, "Rows");
	rows->color(BLACK);
	rows->textcolor(WHITE);
	rows->textsize(11);
	rows->cursor_color(WHITE);
	rows->labelcolor(YELLOW);
	rows->labelsize(9);
	rows->box(FL_FRAME_BOX);
	rows->value("2");
	rows->callback(source_select_cols_and_rows_cb, this);

	scroll = new Fl_Scroll((w() / 2) - 150, new_yp + 182, 300, 550);
	scroll->box(FL_FRAME_BOX);
	scroll->color(BLACK);
	scroll->type(Fl_Scroll::VERTICAL);
	pack = new Fl_Pack((w() / 2) - 150, new_yp + 182, 300, 100);
	pack->box(FL_NO_BOX);
	pack->type(Fl_Pack::VERTICAL);
	scroll->scrollbar.hide();
	pack->end();
	scroll->end();

	MyButton *accept = new MyButton(100, h() - 40, 80, 20, "Accept");
	accept->box(FL_FLAT_BOX);
	accept->color(BLACK);
	accept->labelcolor(YELLOW);
	accept->labelsize(12);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->copy_tooltip("Accept the currently selected sources and close");
	accept->callback(source_select_accept_cb, this);

	MyButton *cancel = new MyButton(240, h() - 40, 80, 20, "Cancel");
	cancel->box(FL_FLAT_BOX);
	cancel->color(BLACK);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(12);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->copy_tooltip("Cancel changes and close");
	cancel->callback(hide_window_cb, this);
	end();
}

SourceSelectWindow::~SourceSelectWindow()
{
}

void	SourceSelectWindow::draw()
{
int	outer, inner;

	Dialog::draw();
	if((cols_nn > 0) && (rows_nn > 0))
	{
		fl_color(WHITE);
		int xx = (w() / 2) - 50;
		int yy = 60 + vertical_offset;
		fl_rect(xx, yy, 100, 100);
		int x_sz = 100 / cols_nn;
		int y_sz = 100 / rows_nn;
		int y_inc = 0;
		for(outer = 0;outer < rows_nn;outer++)
		{
			int x_inc = 0;
			for(inner = 0;inner < cols_nn;inner++)
			{
				int nn = (outer * cols_nn) + inner;
				if(nn < 128)
				{
					fl_color(BLACK);
					if(list[nn] != NULL)
					{
						fl_color(GRAY);
					}
					if((outer == cur_row) && (inner == cur_col))
					{
						fl_color(WHITE);
					}
					fl_rectf(xx + x_inc, yy + y_inc, x_sz, y_sz);
					fl_color(WHITE);
					fl_rect(xx + x_inc, yy + y_inc, x_sz, y_sz);
				}
				x_inc += x_sz;
			}
			y_inc += y_sz;
		}
	}
}

int		SourceSelectWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		int ex = Fl::event_x();
		int ey = Fl::event_y();
		int xx = (w() / 2) - 50;
		int yy = 60;
		if((ex > xx) && (ey > yy)
		&& (ex < xx + 100) && (ey < yy + 100))
		{
			int nx = ex - xx;
			int ny = ey - yy;
			int sel_col = (double)nx / (100.0 / (double)cols_nn);
			int sel_row = (double)ny / (100.0 / (double)rows_nn);
			if((sel_col < cols_nn) && (sel_row < rows_nn))
			{
				cur_col = sel_col;
				cur_row = sel_row;
				Update();
				redraw();
			}
			flag = 1;
		}
	}
	else if((event == FL_RELEASE) || (event == FL_DRAG))
	{
		int ex = Fl::event_x();
		int ey = Fl::event_y();
		int xx = (w() / 2) - 50;
		int yy = 60;
		if((ex > xx) && (ey > yy)
		&& (ex < xx + 100) && (ey < yy + 100))
		{
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	SourceSelectWindow::Update()
{
int	loop;

	int yy = 0;
	pack->clear();

	cv::Mat local_mat(168, 300, CV_8UC4, cv::Scalar(0, 0, 0, 0));
	int nw = local_mat.cols;
	int nh = local_mat.rows;
	MyImageButton *image_button = new MyImageButton(local_mat, pack->x(), pack->y() + yy, local_mat.cols, local_mat.rows, "[blank]");
	image_button->callback(source_select_image_button_cb, this);
	pack->add(image_button);

	for(loop = 0;loop < my_window->source_cnt;loop++)
	{
		Camera *cam = my_window->camera[loop];
		cam->Capture();
		Mat local_mat = cam->mat;
		if(!local_mat.empty())
		{
			Mat new_mat;
			int nw = local_mat.cols;
			int nh = local_mat.rows;
			double scale = 300.0 / (double)nw;
			nw = (int)((double)nw * scale);
			nh = (int)((double)nh * scale);
			cv::resize(local_mat, new_mat, cv::Size(nw, nh));

			MyImageButton *image_button = new MyImageButton(new_mat, pack->x(), pack->y() + yy, new_mat.cols, new_mat.rows, cam->alias);
			image_button->callback(source_select_image_button_cb, this);
			pack->add(image_button);
			yy += nh;
		}
	}
	redraw();
}

void	SourceSelectWindow::Set(char *val)
{
	if((cur_col < cols_nn) && (cur_row < rows_nn))
	{
		int nn = (cur_row * cols_nn) + cur_col;
		if(nn < 128)
		{
			list[nn] = val;
			cur_col++;
			if(cur_col >= cols_nn)
			{
				cur_col = 0;
				cur_row++;
				if(cur_row >= rows_nn)
				{
					cur_row = 0;
				}
			}
		}
	}
}

// SECTION ************************************** MY WINDOW **********************************************

void	clipboard_notify(int source, void *v)
{
	MyWin *win = (MyWin *)v;
	win->clipboard_changed = 1;
}

void	record_on_start_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	char *alias = win->record_on_start_alias;
	Camera *cam = NULL;
	if(alias != NULL)
	{
		cam = win->FindCameraByAlias(alias);
		if(cam != win->DisplayedCamera())
		{
			win->DisplayCamera(cam);
		}
	}
	if(cam == NULL)
	{
		cam = win->DisplayedCamera();
	}
	if(cam != NULL)
	{
		win->RecordOn(cam);
	}
}

void	my_window_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	win->redraw();
	if(win->record_all == 1)
	{
		win->RecordAll();
	}
	win->Scheduled();
	if(win->button_refresh == 0)
	{
		win->ShowButtons();
		win->button_refresh = 1;
	}
	if((win->record_on_start > 0) && (win->recording_on_start == 0))
	{
		Fl::add_timeout(1.0, record_on_start_cb, win);
		win->recording_on_start = 1;
	}
	Fl::repeat_timeout(win->forced_interval, my_window_cb, win);
}

void	audio_library_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->audio_library_window->visible())
	{
		win->audio_library_window->hide();
	}
	else
	{
		win->audio_library_window->show();
	}
}

void	audio_library_list_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->audio_library_list->visible())
	{
		win->audio_library_list->hide();
	}
	else
	{
		win->audio_library_list->show();
	}
}

void	stop_playing_audio_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->pulse_mixer != NULL)
	{
		for(loop = 0;loop < 10;loop++)
		{
			if(win->pulse_mixer->pa_monitor[loop] != NULL)
			{
				win->pulse_mixer->pa_monitor[loop]->Pause();
				win->pulse_mixer->pa_monitor[loop]->Stop();
			}
		}
	}
}

void	pause_playing_audio_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->pulse_mixer != NULL)
	{
		for(loop = 0;loop < 10;loop++)
		{
			if(win->pulse_mixer->pa_monitor[loop] != NULL)
			{
				if(win->pulse_mixer->pa_monitor[loop]->mini_pause == 0)
				{
					w->copy_label("Resume Playing");
					win->pulse_mixer->pa_monitor[loop]->mini_pause = 1;
				}
				else
				{
					w->copy_label("Pause Playing");
					win->pulse_mixer->pa_monitor[loop]->mini_pause = 0;
				}
			}
		}
	}
}

void	play_audio_file_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	char path[4096];
	strcpy(path, "");
	int nn = my_file_chooser("Select an audio file", "*.{wav,mp3,flac}", "./AudioLibrary", path);
	if(nn > 0)
	{
		if(access(path, 0) == 0)
		{
			play_audio_file(win, path);
		}
	}
}

void	monitor_audio_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->pulse_mixer->monitor == 1)
	{
		win->pulse_mixer->monitor = 0;
		win->monitor_audio_button->copy_label("Monitor Audio");
	}
	else
	{
		win->pulse_mixer->monitor = 1;
		win->monitor_audio_button->copy_label("Stop Monitoring Audio");
	}
}

void	audio_settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->audio_settings_window->visible())
	{
		win->audio_settings_window->hide();
	}
	else
	{
		win->audio_settings_window->show();
	}
}

void	audio_save_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->SaveMicrophones();
}

void	audio_load_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->LoadMicrophones();
}

void	audio_mute_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->mute_audio == 1)
	{
		win->mute_audio = 0;
		if(win->muxing == 1)
		{
			for(loop = 0;loop < 128;loop++)
			{
				if(win->my_muxer[loop] != NULL)
				{
					win->my_muxer[loop]->mute = 0;
				}
			}
		}
		if(win->pulse_mixer != NULL)
		{
			win->pulse_mixer->Unmute();
		}
		win->audio_mute_button->copy_label("Mute Audio");
	}
	else
	{
		win->mute_audio = 1;
		if(win->muxing == 1)
		{
			for(loop = 0;loop < 128;loop++)
			{
				if(win->my_muxer[loop] != NULL)
				{
					win->my_muxer[loop]->mute = 1;
				}
			}
		}
		if(win->pulse_mixer != NULL)
		{
			win->pulse_mixer->Mute();
		}
		win->audio_mute_button->copy_label("Unmute Audio");
	}
}

void	toggle_objects_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->object_menu->visible())
	{
		win->HideObjects();
	}
	else
	{
		win->ShowObjects();
	}
}

void	jpeg_streaming_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->transmitting == 0)
	{
		win->jpeg_streaming_button->copy_label("Ceace Streaming");
		win->image_memory.done = 0;
		win->SendToNetwork();
		win->transmitting = 1;
	}
	else
	{
		win->jpeg_streaming_button->copy_label("JPEG Streaming");
		win->transmitting = 0;
		win->image_memory.done = 1;
	}
}

void	test_recognition_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->test_recognition == 0)
	{
		w->copy_label("Stop Testing Recognition");
		win->test_recognition = 1;
	}
	else
	{
		w->copy_label("Test Recognition");
		win->test_recognition = 0;
	}
}

void	show_debug_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->visible_debug == 0)
	{
		w->copy_label("Stop Recording Recognition");
		win->visible_debug = 1;
	}
	else
	{
		w->copy_label("Record Recognition");
		win->visible_debug = 0;
	}
}

void	show_motion_debug_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->motion_debug == 0)
	{
		w->copy_label("Hide Motion Debug");
		win->motion_debug = 1;
	}
	else
	{
		w->copy_label("Show Motion Debug");
		win->motion_debug = 0;
	}
}

void	clear_interest_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->interest_cnt = 0;
}

void	set_interest_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->mark_interest == 0)
	{
		win->HideButtons();
		w->show();
		w->copy_label("Done Setting Interest");
		win->mark_interest = 1;
	}
	else
	{
		win->mark_interest = 0;
		win->ShowButtons();
		w->copy_label("Set Interest");
	}
}

void	snapshot_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		cam->TriggerSnapshot();
	}
}

void	review_muxed_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->review_muxed == NULL)
	{
		if(win->last_muxed_list[0] != NULL)
		{
			win->review_muxed = new MuxPreviewWindow(win, win->requested_w, win->requested_h, "Muxed Preview");
			win->review_muxed->show();
		}
	}
}

void	review_button_cb(Fl_Widget *w, void *v)
{
int		extract_audio(int *prg, char *in_filename, char *out_filename, int hz, int channels);
int		extract_video(int *prg, char *in_filename, char *out_filename, int in_sequence);
void	review_win_cb(void *v);
char	buf[4092];

	MyWin *win = (MyWin *)v;
	if(win->review == NULL)
	{
		if(win->muxing == 1)
		{
			if(win->last_muxed_list[0] != NULL)
			{
				win->extracting = -1;
				int nn = extract_audio(&win->extracting, win->last_muxed_list[0], "audio.bin", win->audio_sample_rate, 1);
				if(nn >= 0)
				{
					win->FlushMuxerArray();
					win->extracting = 1;
					nn = extract_video(&win->extracting, win->last_muxed_list[0], "video.bin", 0);
					if(nn >= 0)
					{
						int n_ww = win->camera[win->displayed_source]->width;
						int n_hh = win->camera[win->displayed_source]->height;
						win->review = new ReviewWin(win, n_ww, n_hh, 24, "Review", "video.bin");
						cv::Mat local_mat(n_hh, n_ww, CV_8UC3, cv::Scalar(55, 100, 150));
						memcpy(win->review->frame, local_mat.ptr(), (n_ww * n_hh * 3));
						win->review->end();
						win->review->show();
						win->review->main = win;
						Fl::add_timeout(0.1, review_win_cb, win->review);
					}
				}
				win->extracting = 0;
			}
		}
		else
		{
			Camera *cam = win->camera[win->displayed_source];
			if(cam != NULL)
			{
				if(win->single_stream == 0)
				{
					sprintf(buf, "main_%02d.bin", win->displayed_source);
				}
				else
				{
					sprintf(buf, "single_stream.bin");
				}
				int n_ww = win->camera[win->displayed_source]->width;
				int n_hh = win->camera[win->displayed_source]->height;
				win->review = new ReviewWin(win, n_ww, n_hh, (int)cam->fps, "Review", buf);
				memcpy(win->review->frame, cam->mat.ptr(), (n_ww * n_hh * 3));
				win->review->end();
				win->review->show();
				win->review->main = win;
				Fl::add_timeout(0.1, review_win_cb, win->review);
			}
		}
	}
}

void	image_sequence_button_cb(Fl_Widget *w, void *v)
{
int	extract_audio(int *prg, char *in_filename, char *out_filename, int hz, int channels);
int	extract_video(int *prg, char *in_filename, char *out_filename, int in_sequence);

	MyWin *win = (MyWin *)v;
	if((win->muxing == 1) && (win->stream_only == 1))
	{
		if(win->last_muxed_list[0] != NULL)
		{
			win->extracting = -1;
			int nn = extract_audio(&win->extracting, win->last_muxed_list[0], "Frames/audio.bin", win->audio_sample_rate, 1);
			if(nn >= 0)
			{
				win->extracting = 1;
				nn = extract_video(&win->extracting, win->last_muxed_list[0], "Frames", 1);
			}
			win->extracting = 0;
		}
	}
}

void	reset_button_cb(Fl_Widget *w, void *v)
{
void	record_button_cb(Fl_Widget *w, void *v);
int		loop;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		int restart = 0;
		if(cam->triggers_requested == 1)
		{
			record_button_cb(NULL, win);
			restart = 1;
		}
		if(win->pulse_mixer != NULL)
		{
			win->pulse_mixer->Stop();
		}
		if(cam->fd > -1)
		{
			close(cam->fd);
			cam->fd = -1;
		}
		cam->total_frames = 0;
		cam->ever_opened = 0;
		cam->starting_time = 0;
		cam->running_time = 0;

		win->current_fps_window->starting_time = 0;
		win->current_fps_window->running_time = 0;
		for(loop = 0;loop < 128;loop++)
		{
			if(win->my_muxer[loop] != NULL)
			{
				win->my_muxer[loop]->current_frame = 0;
			}
		}
		pthread_mutex_lock(&win->muxer_mutex);
		for(loop = 0;loop < 128;loop++)
		{
			if(win->my_muxer[loop] != NULL)
			{
				win->my_muxer[loop]->Pause();
				win->my_muxer[loop]->Stop();
				win->my_muxer[loop]->FinishMux();
				delete win->my_muxer[loop];
				win->my_muxer[loop] = NULL;
			}
		}
		pthread_mutex_unlock(&win->muxer_mutex);
		win->recorded_frames = 0;
		if(restart == 1)
		{
			record_button_cb(NULL, win);
		}
	}
}

void	reset_cameras_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->RecordingFullStop();
	Fl::remove_timeout(my_window_cb);
	win->ResetCameras(1, win->source, win->source_cnt);
	Fl::add_timeout(0.1, my_window_cb, win);
}

void	trigger_camera_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->trigger_select_mode == 0)
	{
		win->trigger_select_mode = 1;
		win->trigger_window->set_non_modal();
		win->trigger_window->take_focus();
		win->trigger_window->show();
	}
	else
	{
		win->trigger_select_mode = 0;
		win->trigger_window->hide();
	}
}

void	resize_capture_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->resize_capture == 0)
	{
		win->resize_capture = 1;
		reset_button_cb(NULL, win);
		win->resize_capture_button->copy_label("Zoom");
	}
	else
	{
		win->resize_capture = 0;
		win->resize_capture_button->copy_label("Resize Capture (reset)");
	}
}

void	quit_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->Done();
	if(win->review != NULL)
	{
		win->review->hide();
	}
	if(win->immediate_drawing_window != NULL)
	{
		win->immediate_drawing_window->hide();
	}
	if(win->anim_timeline != NULL)
	{
		win->anim_timeline->hide();
	}
	win->hide();
	delete win;
}

void	open_standalone_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *now_cam = win->DisplayedCamera();
	if(now_cam != NULL)
	{
		if(now_cam->standalone_display == NULL)
		{
			StandaloneDisplay *sd = new StandaloneDisplay(now_cam, now_cam->width, now_cam->height, "Standalone");
			sd->end();
			now_cam->standalone_display = sd;
			sd->show();
		}
		else
		{
			if(now_cam->standalone_display->visible())
			{
				now_cam->standalone_display->hide();
			}
			else
			{
				now_cam->standalone_display->show();
			}
		}
	}
}

void	monitor_video_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->monitor_window->visible())
	{
		w->copy_label("Monitor Video");
		win->monitor_window->hide();
	}
	else
	{
		w->copy_label("Close Monitor");
		win->monitor_window->show();
	}
}

void	split_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->split == 0)
	{
		win->current_fps_window->showing = 0;
		for(loop = 0;loop < 128;loop++)
		{
			win->thumbnail[loop]->hide();
		}
		win->split = 1;
	}
	else
	{
		win->split = 0;
	}
}

void	edit_output_button_cb(Fl_Widget *w, void *v)
{
	MyWin *my_win = (MyWin *)v;
	if(!my_win->edit_output_window->visible())
	{
		my_win->edit_output_window->set_non_modal();
		my_win->edit_output_window->take_focus();
		my_win->edit_output_window->show();
	}
	else
	{
		my_win->edit_output_window->hide();
	}
}

void	select_output_button_cb(Fl_Widget *w, void *v)
{
	MyWin *my_win = (MyWin *)v;
	if(!my_win->select_output_window->visible())
	{
		my_win->select_output_window->show();
		my_win->select_output_window->set_non_modal();
		my_win->select_output_window->Populate();
	}
	else
	{
		my_win->select_output_window->hide();
	}
}

void	new_source_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->new_source_window->visible())
	{
		win->new_source_window->set_non_modal();
		win->new_source_window->Show(0);
		win->new_source_window->take_focus();
	}
	else
	{
		win->new_source_window->hide();
	}
}

void	edit_source_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->new_source_window->visible())
	{
		win->new_source_window->set_non_modal();
		win->new_source_window->Show(1);
		win->new_source_window->take_focus();
	}
	else
	{
		win->new_source_window->hide();
	}
}

void	reset_camera_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		win->ResetCamera(cam);
	}
}

void	alias_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->alias_window->visible())
	{
		win->showing_alias_window = 1;
		win->alias_window->take_focus();
		win->alias_window->set_non_modal();
		win->alias_window->show();
	}
	else
	{
		win->showing_alias_window = 0;
		win->alias_window->hide();
	}
}

void	ptz_lock_window_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->ptz_lock_window->visible())
	{
		win->ptz_lock_window->set_non_modal();
		win->ptz_lock_window->show();
	}
	else
	{
		win->ptz_lock_window->hide();
	}
}

void	video_settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->video_settings_window->visible())
	{
		win->video_settings_window->Update();
		win->video_settings_window->set_non_modal();
		win->video_settings_window->show();
		win->video_settings_window->take_focus();
	}
	else
	{
		win->video_settings_window->hide();
	}
}

void	camera_settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->camera_settings_window->visible())
	{
		win->camera_settings_window->Update();
		win->camera_settings_window->take_focus();
		win->camera_settings_window->set_non_modal();
		win->camera_settings_window->show();
	}
	else
	{
		win->camera_settings_window->hide();
	}
}

void	snapshot_settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->snapshot_settings_window->visible())
	{
		win->snapshot_settings_window->Update();
		win->snapshot_settings_window->take_focus();
		win->snapshot_settings_window->set_non_modal();
		win->snapshot_settings_window->show();
	}
	else
	{
		win->snapshot_settings_window->hide();
	}
}

void	keyboard_settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->command_key_settings->visible())
	{
		win->command_key_settings->take_focus();
		win->command_key_settings->set_non_modal();
		win->command_key_settings->show();
	}
	else
	{
		win->command_key_settings->hide();
	}
}

void	gui_settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->gui_settings_window->visible())
	{
		win->gui_settings_window->show();
		win->gui_settings_window->take_focus();
		win->gui_settings_window->set_non_modal();
	}
	else
	{
		win->gui_settings_window->hide();
	}
}

void	transitions_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->transitions_window->visible())
	{
		win->transitions_window->Update();
		win->transitions_window->set_non_modal();
		win->transitions_window->show();
		win->transitions_window->take_focus();
	}
	else
	{
		win->transitions_window->hide();
	}
}

void	filter_built_in_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->filter_built_in_window->visible())
	{
		win->filter_built_in_window->set_non_modal();
		win->filter_built_in_window->show();
		win->filter_built_in_window->take_focus();
	}
	else
	{
		win->filter_built_in_window->hide();
	}
}

void	filter_plugins_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->filter_plugins_window->visible())
	{
		win->filter_plugins_window->set_non_modal();
		win->filter_plugins_window->show();
		win->filter_plugins_window->take_focus();
	}
	else
	{
		win->filter_plugins_window->hide();
	}
}

void	audio_filter_plugins_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->audio_filter_plugins_window->visible())
	{
		win->audio_filter_plugins_window->set_non_modal();
		win->audio_filter_plugins_window->show();
		win->audio_filter_plugins_window->take_focus();
	}
	else
	{
		win->audio_filter_plugins_window->hide();
	}
}

void	audio_bind_to_camera_button_cb(Fl_Widget *w, void *v)
{
	MenuButton *b = (MenuButton *)w;
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->bound_mic_cnt == -1)
		{
			b->copy_label("Unbind Camera");
			b->copy_tooltip("Remove audio source binding from displayed camera.");
			cam->BindMics();
		}
		else
		{
			b->copy_label("Bind to Camera");
			b->copy_tooltip("Bind currently selected audio sources to displayed camera.");
			cam->UnBindMics();
		}
	}
}


void	external_pgm_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->embed_app_settings->visible())
	{
		win->embed_app_settings->set_non_modal();
		win->embed_app_settings->show();
	}
	else
	{
		win->embed_app_settings->hide();
	}
}

void	fltk_plugin_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->fltk_plugin_window->visible())
	{
		win->fltk_plugin_window->Reset();
		win->fltk_plugin_window->set_non_modal();
		win->fltk_plugin_window->show();
	}
	else
	{
		win->fltk_plugin_window->hide();
	}
}

void	immediate_drawing_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->immediate_drawing_window->visible())
	{
		win->im_drawing_mode = 1;
		win->immediate_drawing_window->set_non_modal();
		win->immediate_drawing_window->show();
		win->immediate_drawing_window->take_focus();
		if(win->anim_timeline != NULL)
		{
			win->anim_timeline->show();
		}
	}
	else
	{
		win->im_drawing_mode = 0;
		win->immediate_drawing_window->hide();
		if(win->anim_timeline != NULL)
		{
			win->anim_timeline->hide();
		}
	}
}

void	dynamic_coloring_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->color_it_window->visible())
	{
		win->color_it_window->set_non_modal();
		win->color_it_window->take_focus();
		win->color_it_window->show();
	}
	else
	{
		win->color_it_window->hide();
	}
}

void	toggle_camera_effects_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->capture_effects == 1)
		{
			cam->capture_effects = 0;
			win->toggle_camera_effects_button->copy_label("Turn On Effects");
		}
		else
		{
			cam->capture_effects = 1;
			win->toggle_camera_effects_button->copy_label("Turn Off Effects");
		}
	}
}

void	save_camera_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(access("./Cameras", 0) != 0)
		{
			mkdir("./Cameras", 0755);
		}
		char filename[4096];
		int r = my_file_chooser("Select a camera file", "*.json", "./Cameras", filename, 0, 1);
		if(r > 0)
		{
			if(strlen(filename) > 0)
			{
				FILE *fp = fopen(filename, "w");
				if(fp != NULL)
				{
					cam->SaveAsJSON(fp);
					fclose(fp);
				}
				else
				{
					win->SetErrorMessage("Error: File did not open.");
				}
			}
		}
	}
}

void	load_camera_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	char filename[4096];
	int restore = 0;
	int nn = my_file_chooser("Select a camera file", "*.json", "./Cameras", filename);
	if(nn > 0)
	{
		win->LoadJSONCamera(filename);
	}
}

void	encode_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(win->encoding == 0)
	{
		win->record_button->copy_label("Record");
		win->encode_speed_window->Reset();
		win->encode_speed_window->hide();
		win->Encode();
		win->UpdateThumbButtons();

		win->encode_button->hide();
	}
}

void	override_button_cb(Fl_Widget *w, void *v)
{
void	reset_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	Camera *cam = NULL;
	if(win->follow_mode != FOLLOW_MODE_RECORDING_FOLLOWS_DISPLAY)
	{
		cam = win->RecordingCamera();
	}
	if(cam == NULL)
	{
		cam = win->DisplayedCamera();
	}
	if(cam->trigger_override == 0)
	{
		win->override_button->copy_label("Stop Override");
		cam->trigger_override = 1;
	}
	else
	{
		win->override_button->copy_label("Override");
		cam->trigger_override = 0;
	}
}

void	MyWin::RecordOn(Camera *cam)
{
	record_button->copy_label("Stop");
	if(cam->record_trigger != 0)
	{
		override_button->copy_label("Override");
		override_button->show();
	}
	Camera *recording_now = RecordingCamera();
	if((recording_now != NULL) && (single_stream == 1))
	{
		recording_now->triggers_requested = 0;
	}
	cam->triggers_requested = 1;
	encode_speed_window->Reset();
	encode_speed_window->show();
	if(encoding == 0)
	{
		if(muxing == 0)
		{
			encode_button->show();
		}
	}
	UpdateThumbButtons();
	ShowButtons();
}

void	MyWin::SaveAudioSettings(char *filename)
{
	FILE *fp = fopen(filename, "w");
	if(fp != NULL)
	{
		fprintf(fp, "{\n");
		fprintf(fp, "\t\"audio sample rate\": %d,\n", audio_sample_rate);
		fprintf(fp, "\t\"audio channels\": %d,\n", audio_channels);
		fprintf(fp, "\t\"audio display\": %d,\n", audio_display);
		fprintf(fp, "\t\"audio direct mix\": %d,\n", audio_direct_mix);
		fprintf(fp, "\t\"audio incidental volume\": %f\n", audio_incidental_volume);
		fprintf(fp, "}\n");

		fclose(fp);
	}
}

void	MyWin::LoadAudioSettings(char *filename)
{
	char *buf = ReadWholeFile(filename);
	if(buf != NULL)
	{
		cJSON *json = cJSON_Parse(buf);
		if(json == NULL)
		{
			const char *error_ptr = cJSON_GetErrorPtr();
			if(error_ptr != NULL)
			{
				fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
			}
		}
		else
		{
			int success = json_parse_int(json, "audio sample rate", audio_sample_rate);
			success = json_parse_int(json, "audio channels", audio_channels);
			success = json_parse_int(json, "audio display", audio_display);
			success = json_parse_int(json, "audio direct mix", audio_direct_mix);
			success = json_parse_double(json, "audio incidental volume", audio_incidental_volume);
			cJSON_Delete(json);
		}
		free(buf);
	}
}

void	MyWin::RecordOff(Camera *cam)
{
	record_button->copy_label("Record");
	cam->triggers_requested = 0;
	cam->recording = 0;
	cam->trigger_override = 0;
	encode_speed_window->Reset();
	encode_speed_window->hide();
	override_button->hide();
	if(pulse_mixer != NULL)
	{
		pulse_mixer->Stop();
	}
	int err = cam->Record();
	if(cam != NULL)
	{
		if(cam->total_frames == 0)
		{
			encode_button->hide();
		}
		else if(encoding == 0)
		{
			if(muxing == 0)
			{
				encode_button->show();
			}
		}
	}
	cam->resuming = 1;
	RecordOff();
	SetAllCamerasToStop();
	if(streaming == STREAMING_NET)
	{
		reset_button_cb(NULL, this);
	}
	ShowButtons();
}

void	record_button_cb(Fl_Widget *w, void *v)
{
void	reset_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	Camera *cam = NULL;
	cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->triggers_requested == 0)
		{
			win->RecordOn(cam);
		}
		else
		{
			win->RecordOff(cam);
		}
	}
}

void	freeze_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->freeze_video == 0)
	{
		w->copy_label("Defrost");
		cam->freeze_video = 1;
	}
	else
	{
		w->copy_label("Freeze");
		cam->freeze_video = 0;
	}
}

void	mute_video_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->mute_video == 0)
	{
		w->copy_label("Unmute Video");
		cam->mute_video = 1;
	}
	else
	{
		w->copy_label("Mute Video");
		cam->mute_video = 0;
	}
}

void	power_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->power == 0)
	{
		w->copy_label("Turn Off");
		cam->power = 1;
	}
	else
	{
		w->copy_label("Turn On");
		cam->power = 0;
	}
	win->HideButtons();
	win->ShowButtons();
}

void	save_setup_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(access("./Setups", 0) != 0)
	{
		mkdir("./Setups", 0755);
	}
	chdir("./Setups");
	char filename[4096];
	int r = my_file_chooser("Select a setup file", "*.json", "./Setups", filename, 0, 1);
	if(r > 0)
	{
		if(strlen(filename) > 0)
		{
			FILE *fp = fopen(filename, "w");
			if(fp != NULL)
			{
				win->SaveAsJSON(fp);
				fclose(fp);
			}
			else
			{
				win->SetErrorMessage("Error: Unable to open file.");
			}
		}
	}
	chdir("..");
}

void	load_setup_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	char filename[4096];
	int r = my_file_chooser("Select a setup file", "*.json", "./Setups", filename);
	if(r > 0)
	{
		if(strlen(filename) > 0)
		{
			win->LoadJSON(filename);
		}
	}
}

void	hide_video_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->display_video == 1)
	{
		win->display_video = 0;
		win->hide_video_button->copy_label("Display Video");
	}
	else
	{
		win->display_video = 1;
		win->hide_video_button->copy_label("Hide Video");
	}
}

void	timestamp_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(win->timestamp == 0)
	{
		w->copy_label("No Timestamp");
		win->timestamp = 1;
		if(win->video_settings_window != NULL)
		{
			win->video_settings_window->timestamp_default->value(1);
		}
	}
	else
	{
		w->copy_label("Timestamp");
		win->timestamp = 0;
		if(win->video_settings_window != NULL)
		{
			win->video_settings_window->timestamp_default->value(0);
		}
	}
}

void	dump_button_cb(Fl_Widget *w, void *v)
{
void	read_video_header(int fdx, int *uw, int *uh, int *depth, int *ufps);
char	buf[4096];
char	directory[4096];
char	filename[8192];
struct tm	*tm;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(win->muxing == 0)
	{
		if(win->single_stream == 0)
		{
			sprintf(buf, "main_%02d.bin", win->displayed_source);
		}
		else
		{
			sprintf(buf, "single_stream.bin");
		}
		if(access(buf, 0) == 0)
		{
			int fdi = open(buf, O_RDONLY);
			if(fdi > -1)
			{
				int uw = 0;
				int uh = 0;
				int depth = 0;
				int ufps = 0;
				long int length = filelength(fdi);
				read_video_header(fdi, &uw, &uh, &depth, &ufps);
				int in_frame = 0;
				int sz = uw * uh * depth;
				length -= (sizeof(int) * 4);
				int dumped_frame_cnt = length / sz;
				if(dumped_frame_cnt > 0)
				{
					void *ptr = malloc(sz);
					if(ptr != NULL)
					{
						time_t t_num = time(0);
						tm = localtime((const time_t *)&t_num);
						sprintf(directory, "FrameDump_%04d_%02d_%02d_%02d_%02d_%02d", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
						mkdir(directory, 0777);
						int cnt = 0;
						int done = 0;
						while((done == 0) && (cnt < dumped_frame_cnt))
						{
							long int ts = 0;
							int nn = read_frame(fdi, ptr, sz, &ts);
							if(nn == sz)
							{
								sprintf(filename, "%s/frame_%06d.png", directory, cnt);
								Mat src = Mat(uh, uw, CV_8UC3, ptr);
								cvtColor(src, src, COLOR_RGB2BGR);
								imwrite(filename, src);
								cnt++;
							}
							else
							{
								done = 1;
							}
						}
						free(ptr);
					}
				}
				close(fdi);
			}
		}
	}
	else
	{
		image_sequence_button_cb(NULL, win);
	}
}


void	flip_horizontal_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->flip_horizontal == 0)
		{
			cam->flip_horizontal = 1;
			win->flip_horizontal_button->copy_label("Restore Horizontal");
		}
		else
		{
			cam->flip_horizontal = 0;
			win->flip_horizontal_button->copy_label("Flip Horizontal");
		}
	}
}

void	flip_vertical_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->flip_vertical == 0)
		{
			cam->flip_vertical = 1;
			win->flip_vertical_button->copy_label("Restore Vertical");
		}
		else
		{
			cam->flip_vertical = 0;
			win->flip_vertical_button->copy_label("Flip Vertical");
		}
	}
}

void	save_interest_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->SaveInterest();
}

void	load_interest_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->LoadInterest();
}

void	zoom_box_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->zoom_box_display == 0)
		{
			win->zoom_boxing = 1;
			win->drag_start_x = -1;
			win->drag_start_y = -1;
		}
		else
		{
			cam->zoom_box_display = 0;
			win->zoom_box_button->copy_label("Box Zoom");
		}
	}
}

MyWin::MyWin(
	int in_w
	, int in_h
	, int in_source_cnt
	, char **in_source
	, int in_audio_source_cnt
	, char **in_audio_source
	, int ww
	, int hh
	, int output_ww
	, int output_hh
	, int display_ww
	, int display_hh
	, int in_fps
	, double in_interval
	, int in_split
	, int in_muxing
	, int in_flip
	, int use_audio
	, char *in_mux_format
	, int in_use_old
	, int in_no_scan
	, int in_no_audio_scan
	, int in_record_all
	, int in_record_desktop
	, int in_desktop_x
	, int in_desktop_y
	, int in_desktop_w
	, int in_desktop_h
	, int in_single_stream
	, int in_follow_mode
	, int in_transition
	, char *in_transition_plugin
	, int in_ptz_device_path_cnt
	, char *in_ptz_device_path[NUMBER_OF_INTERFACES]
	, char *in_ptz_lock_alias[NUMBER_OF_INTERFACES][NUMBER_OF_CAMERAS]
	, char *in_ptz_bind_alias[NUMBER_OF_INTERFACES]
	, int in_ptz_prefer_ndi[NUMBER_OF_INTERFACES]
	, int in_ptz_prefer_v4l[NUMBER_OF_INTERFACES]
	, char *in_ptz_alias[NUMBER_OF_INTERFACES]
	, int in_ptz_home_on_launch
	, int in_use_yolo_model
	, char *in_yolo_cfg
	, char *in_yolo_weights
	, char *in_yolo_names
	, char *in_jpeg_streaming
	, int in_streaming
	, char *in_stream_url
	, int in_stream_only
	, int in_streaming_audio_quality
	, int in_embed_pip
	, double in_pip_x_position
	, double in_pip_y_position
	, int in_pip_red
	, int in_pip_green
	, int in_pip_blue
	, double in_pip_size
	, int in_multipip
	, int in_grid_size
	, char *use_desktop_monitor
	, int use_detect
	, int use_timestamp
	, int use_frame_scaling
	, int use_retain_commands
	, int use_retain_cameras
	, int use_retain_audio
	, int use_retain_ptz
	, int use_hide_status
	, int use_auto_scale
	, int in_crop_output
	, int crop_display
	, int use_disregard_settings
	, int use_transparent_interface
	, int use_animate_panels
	, int use_exclude_directories
	, char *lbl)
	: Fl_Double_Window(in_w, in_h, lbl)
{
int	loop;
int	inner;
int	outer;

	resizable(this);
	resize_grp = new ResizeGroup(this, 0, 0, w(), h());
	resize_grp->resizable(0);
	size_range(w() / 4, h() / 4, 0, 0, 0, 0, 1);
	original_w = w();
	original_h = h();
	auto_scale = use_auto_scale;
	error_message = NULL;
	for(loop = 0;loop < 128;loop++)
	{
		camera[loop] = NULL;
	}
	disregard_settings = use_disregard_settings;
	transparent_interface = use_transparent_interface;
	muxer_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
	ndi_send_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

	video_count = 0;
	strcpy(last_used_filename, "");
	strcpy(mux_format, "mov");
	if(in_mux_format != NULL)
	{
		if(strlen(in_mux_format) < 255)
		{
			strcpy(mux_format, in_mux_format);
		}
	}
	current_source = 0;
	displayed_source = 0;
	alt_displayed_source = -1;
	split = in_split;
	for(loop = 0;loop < 1024;loop++)
	{
		source[loop] = NULL;
	}
	for(loop = 0;loop < in_source_cnt;loop++)
	{
		source[loop] = in_source[loop];
	}
	source_cnt = in_source_cnt;
	audio_source = in_audio_source;
	audio_source_cnt = in_audio_source_cnt;
	requested_w = ww;
	requested_h = hh;
	display_video = 1;
	last_cam = NULL;
	im_drawing_mode = 0;
	mouse_moving = 0;
	exit_timer = 0;
	actively_exiting = 0;
	animate_panels = use_animate_panels;
	use_tooltips = 1;
	Fl_Tooltip::enable();
	recording_camera = NULL;

	audio_display = AUDIO_DISPLAY_FREQUENCY;
	audio_display_timer = 200;
	audio_channels = 2;

	audio_direct_mix = 1;
	active_audio_playback = 0;

	audio_incidental_volume = 0.5;
	LoadAudioSettings("audio_settings.json");

	ndi_send = NULL;
	ndi_streaming = 0;
	strcpy(ndi_stream_name, "");
	ndi_send_video_format = NDI_SEND_VIDEO_FORMAT_RGBX;
	ndi_initialized = 0;

	if(output_ww > -1)
	{
		output_width = output_ww;
	}
	else
	{
		output_width = ww;
	}
	if(output_hh > -1)
	{
		output_height = output_hh;
	}
	else
	{
		output_height = hh;
	}
	if(display_ww > -1)
	{
		display_width = display_ww;
	}
	else
	{
		display_width = ww;
	}
	if(display_hh > -1)
	{
		display_height = display_hh;
	}
	else
	{
		display_height = hh;
	}
	for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
	{
		ptz_window[loop] = NULL;
	}
	initial_button_group_x = -1;
	initial_button_group_y = -1;
	initial_thumbnail_group_x = -1;
	initial_thumbnail_group_y = -1;
	initial_audio_thumbnail_group_x = -1;
	initial_audio_thumbnail_group_y = -1;
	initial_current_fps_x = -1;
	initial_current_fps_y = -1;
	initial_video_out_x = -1000000;
	initial_video_out_y = -1000000;
	for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
	{
		initial_ptz_x[loop] = -1;
		initial_ptz_y[loop] = -1;
	}
	highlight_image_windows = 0;
	html_background = 0;
	init_detect = use_detect;
	recording = 0;
	use_mousewheel = 1;
	refreshed = 0;
	mute_audio = 0;
	muxing = in_muxing;
	recorded_frames = 0;
	forced_fps = in_fps;
	forced_interval = in_interval;
	restore_forced_interval = in_interval;
	record_all_cnt = 0;
	record_all_start = 0;
	clipboard_changed = 1;
	resize_capture = 0;
	no_scan = in_no_scan;
	no_audio_scan = in_no_audio_scan;
	use_old = in_use_old;
	video_settings_window = NULL;
	misc_video_settings_window = NULL;
	camera_settings_window = NULL;
	snapshot_settings_window = NULL;
	gui_settings_window = NULL;
	transitions_window = NULL;
	immediate_drawing_window = NULL;
	new_source_window = NULL;
	alias_window = NULL;
	trigger_window = NULL;
	dumped_frames = 0;
	dumped_limit = -1;
	zoom_boxing = 0;
	dump_type = NULL;
	follow_mode = FOLLOW_MODE_NONE;
	button_group_side = SIDE_RIGHT;
	file_selector_layout = MY_SCROLL_LAYOUT_LIST;
	file_selector_exclude_directories = use_exclude_directories;
	record_on_start = 0;
	recording_on_start = 0;
	record_on_start_alias = NULL;
	text_edit_window = NULL;

	Fl::get_color(WHITE, status_color_r, status_color_g, status_color_b);
	status_color_a = 0;

	strcpy(mux_format, in_mux_format);
	pthread_mutex_lock(&muxer_mutex);
	for(loop = 0;loop < 128;loop++)
	{
		my_muxer[loop] = NULL;
	}
	muxer_cnt = 0;
	pthread_mutex_unlock(&muxer_mutex);
	for(loop = 0;loop < 1024;loop++)
	{
		guideline[loop] = NULL;
	}
	guideline_cnt = 0;
	extracting = 0;
	speed_factor = 1.0;
	minimum_fps = 20.0;
	all_fd = -1;
	actively_loading = 0;
	record_all = in_record_all;
	image_window_button = 0;
	grid_size = in_grid_size;
	mux_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
	desktop_monitor = use_desktop_monitor;
	last_resize_drag_x = -1;
	last_resize_drag_y = -1;
	last_push_x = -1;
	last_push_y = -1;
	embedded_app_cnt = 0;
	evaluate_focus = 0;
	retain_commands = use_retain_commands;
	retain_cameras = use_retain_cameras;
	retain_audio = use_retain_audio;
	retain_ptz = use_retain_ptz;
	hide_status = use_hide_status;
	image_origin_x = 0;
	image_origin_y = 0;
	selecting_colors = 0;
	ptz_lock_window = NULL;

	if(disregard_settings == 0)
	{
		ReadGUISettings();
	}
	rubberband_mode = SCROLL_MODE;
	rubberband_x = -1;
	rubberband_y = -1;
	rubberband_w = -1;
	rubberband_h = -1;
	guideline_mode = HORIZONTAL_GUIDELINE;

	popup = NULL;
	misc_copy = NULL;
	misc_copy_cnt = 0;
	editing_misc_outer = -1;
	editing_misc_inner = -1;
	editing_misc_mode = -1;

	shape = NULL;
	shape_cnt = 0;

	button_refresh = 0;

	for(loop = 0;loop < 128;loop++)
	{
		output_name[loop] = NULL;
		output_path[loop] = NULL;
		output_active[loop] = 0;
	}
	output_path_cnt = 0;
	for(loop = 0;loop < 10;loop++)
	{
		embedded_app[loop] = NULL;
	}
	for(loop = 0;loop < 64;loop++)
	{
		last_muxed_list[loop] = NULL;
	}
	for(loop = 0;loop < 128;loop++)
	{
		audio_thumbnail[loop] = NULL;
		thumbnail[loop] = NULL;
	}
	audio_thumbnail_cnt = 0;
	if(in_record_all == 1)
	{
		start_win->Update("Opening record all file");
		record_all_start = time(0);
		all_fd = open("global.bin", O_CREAT | O_WRONLY | O_TRUNC, 0777);
		int uw = original_w;
		int uh = original_h;
		int depth = 4;
		int ufps = 25;
		write(all_fd, &uw, sizeof(int));
		write(all_fd, &uh, sizeof(int));
		write(all_fd, &depth, sizeof(int));
		write(all_fd, &ufps, sizeof(int));
	}
	record_desktop = in_record_desktop;
	desktop_x = in_desktop_x;
	desktop_y = in_desktop_y;
	desktop_w = in_desktop_w;
	desktop_h = in_desktop_h;
	codec_selection_window = NULL;

	dragging_thumb = NULL;
	dragging_thumb_x = -1;
	dragging_thumb_y = -1;

	single_stream = in_single_stream;
	follow_mode = in_follow_mode;

	for(loop = 0;loop < 128;loop++)
	{
		pulse_microphone[loop] = NULL;
	}
	pulse_microphone_cnt = 0;
	for(loop = 0;loop < 10;loop++)
	{
		split_bx[loop] = -1;
		split_by[loop] = -1;
		split_rx[loop] = -1;
		split_ry[loop] = -1;
	}
	tag_recognized = 0;
	tag_fp = NULL;
	for(loop = 0;loop < 1024;loop++)
	{
		recognize_class_name[loop] = NULL;
	}
	if(in_use_yolo_model == USE_YOLO_MODEL_OPEN_IMAGES)
	{
		strcpy(yolo_cfg_filename, YOLO_CFG_FILENAME);
		strcpy(yolo_weights_filename, YOLO_WEIGHTS_FILENAME);
		strcpy(yolo_names_filename, YOLO_NAMES_FILENAME);
	}
	else
	{
		strcpy(yolo_cfg_filename, YOLO_ALT_CFG_FILENAME);
		strcpy(yolo_weights_filename, YOLO_ALT_WEIGHTS_FILENAME);
		strcpy(yolo_names_filename, YOLO_ALT_NAMES_FILENAME);
	}
	if((in_yolo_cfg != NULL) && (in_yolo_weights != NULL) && (in_yolo_names != NULL))
	{
		strcpy(yolo_cfg_filename, in_yolo_cfg);
		strcpy(yolo_weights_filename, in_yolo_weights);
		strcpy(yolo_names_filename, in_yolo_names);
	}
	jpeg_streaming = in_jpeg_streaming;
	jpeg_streaming_port = 20000;
	if(jpeg_streaming != NULL)
	{
		char *cp = jpeg_streaming;
		while(*cp != '\0')
		{
			if(*cp == ':')
			{
				*cp = '\0';
				jpeg_streaming_port = atoi(cp + 1);
			}
			cp++;
		}
	}
	immediate_list = NULL;
	immediate_cnt = 0;

	streaming = in_streaming;
	stream_only = in_stream_only;
	streaming_audio_quality = in_streaming_audio_quality;
	strcpy(stream_url, "");
	if(in_stream_url != NULL)
	{
		strcpy(stream_url, in_stream_url);
	}
	else
	{
		streaming = 0;
	}
	embed_pip = in_embed_pip;
	pip_x_position = in_pip_x_position;
	pip_y_position = in_pip_y_position;
	pip_red = in_pip_red;
	pip_green = in_pip_green;
	pip_blue = in_pip_blue;
	pip_size = in_pip_size;
	multipip = in_multipip;
	recognize_class_cnt = 0;
	ReadClasses();
	if(init_detect == 1)
	{
		start_win->Update("Setup object detection");
		SetupObjectDetection();
	}
	pulse_mixer = NULL;
	review_muxed = NULL;

	start_win->Update("Open cameras");
	ResetCameras(0, in_source, in_source_cnt);

	timestamp = use_timestamp;
	strcpy(timestamp_format, "%Y/%M/%D %h:%m:%s (%frame) [%source]");
	timestamp_rr = 255;
	timestamp_gg = 240;
	timestamp_bb = 128;
	timestamp_aa = 255;
	timestamp_background_rr = 0;
	timestamp_background_gg = 0;
	timestamp_background_bb = 0;
	timestamp_background_aa = 0;
	timestamp_font_sz = 24;
	timestamp_position_x = 10;
	timestamp_position_y = 32;

	test_recognition = 0;

	frame_scaling = use_frame_scaling;
	crop_scaling = crop_display;
	crop_output = in_crop_output;
	if((output_width > -1) && (output_height > -1))
	{
		if((output_width < display_width) && (output_height < display_height))
		{
			crop_output_x = (display_width / 2) - (output_width / 2);
			crop_output_y = (display_height / 2) - (output_height / 2);
		}
		else
		{
			crop_output_x = 0;
			crop_output_y = 0;
			crop_output = 0;
		}
	}
	else
	{
		crop_output_x = 0;
		crop_output_y = 0;
	}
	image_display_scale = 1.0;
	start_time = 0;
	encoding = 0;
	force_center_x = w() / 2;
	force_center_y = h() / 2;
	visible_debug = 0;
	nominal_interest_x = -1;
	nominal_interest_y = -1;
	interest_cnt = 0;
	mark_interest = 0;
	review = NULL;
	buttons_shown = 0;
	all_frames = 0;
	ready_to_average = 0;
	grid_sz = 1;
	drag_start_x = -1;
	drag_start_y = -1;
	offset_x = 0;
	offset_y = 0;
	start_offset_x = -1;
	start_offset_y = -1;
	save_offset_x = 0;
	save_offset_y = 0;
	dragging = 0;
	motion_debug = 0;
	showing_alias_window = 0;
	redraw_cnt = 0;
	encoding_frame_cnt = 0;
	transition_cnt = 0.0;
	transition = in_transition;
	strcpy(transition_plugin, in_transition_plugin);
	ptz_mode = 0;
	for(loop = 0;loop < NUMBER_OF_INTERFACES;loop++)
	{
		for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
		{
			ptz_lock_alias[loop][inner] = NULL;
		}
		ptz_device_path[loop] = NULL;
		ptz_alias[loop] = NULL;
		ptz_bind_alias[loop] = NULL;
		ptz_interface_type[loop] = VISCA_INTERFACE_TYPE_SERIAL;
		ptz_prefer_ndi[loop] = 0;
		ptz_prefer_v4l[loop] = 0;
	}
	ptz_device_cnt = in_ptz_device_path_cnt;
	for(loop = 0;loop < ptz_device_cnt;loop++)
	{
		for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
		{
			ptz_lock_alias[loop][inner] = in_ptz_lock_alias[loop][inner];
		}
		ptz_device_path[loop] = in_ptz_device_path[loop];
		ptz_alias[loop] = in_ptz_alias[loop];
		ptz_bind_alias[loop] = in_ptz_bind_alias[loop];
		ptz_prefer_ndi[loop] = in_ptz_prefer_ndi[loop];
		ptz_prefer_v4l[loop] = in_ptz_prefer_v4l[loop];
	}
	ptz_zoom = 0;
	ptz_panning = 0;
	ptz_zooming = 0;
	ptz_focusing = 0;
	old_ptz_zoom = 1;
	start_ptz_drag_x = 0;
	start_ptz_drag_y = 0;
	ptz_middle_mouse = 0;
	ptz_focus_reading = 0;
	ptz_zoom_reading = -1;
	ptz_pan_reading = 0;
	ptz_tilt_reading = 0;
	ptz_dragged = 0;
	use_pan_speed = 0;
	use_tilt_speed = 0;
	ptz_window_index = 0;
	visca_command = 0;
	visca_arg_cnt = 0;
	ptz_travel_x = 0.294355;
	ptz_travel_y = 0.290323;
	ptz_follow = 0;
	ptz_follow_home_pan = 0;
	ptz_follow_home_tilt = 0;
	ptz_little_speed = 10;
	ptz_little_mode = 0;
	center_message_timer = 0;
	ptz_reverse_horizontal = 0;
	ptz_reverse_vertical = 0;
	ptz_zoomer = 0;
	ptz_joystick = 0;
	ptz_joystick_x = 0;
	ptz_joystick_y = 0;
	ptz_last_joystick_x = 0;
	ptz_last_joystick_y = 0;
	magic_x = -1;
	magic_y = -1;
	transmitting = 0;
	move_corner = 0;
	resize_corner = 0;
	restore_corner = 0;
	camera_caps_cnt = 0;

	start_win->image_mat_cnt = 0;
	start_win->Update("Initialize command keys");
	ResetCommandKeys();
	if(access("./Setups/key_definitions.txt", 0) == 0)
	{
		ReadCommandKeyDefinitions("./Setups/key_definitions.txt");
	}
	render_mouse = 1;
	tutorial_mode = 1;

	image_memory.ptr = NULL;
	image_memory.size = 0;
	image_memory.ready = 0;
	image_memory.done = 0;
	image_memory.ptz = 0;

	trigger_select_mode = 0;
	buttonized_visible = 0;

	use_video_codec = (AVCodecID)AV_CODEC_ID_H264,
	use_audio_codec = (AVCodecID)AV_CODEC_ID_AAC,
	strcpy(use_extension, "flv");
	strcpy(use_container, "flv");

	LoadCodecs();
	LoadTransition();

	box(FL_NO_BOX);
	current_fps_window = new CurrentFPSWindow(this, 10, 10, 475, 24);
	current_fps_window->end();
	current_fps_window->showing = 0;

	if((initial_current_fps_x > -1) && (initial_current_fps_y > -1))
	{
		current_fps_window->resize(initial_current_fps_x, initial_current_fps_y, current_fps_window->w(), current_fps_window->h());
	}
	int at_xx = (w() / 2) - 500;
	int at_yy = (h() - 120);
	anim_timeline = new AnimTimeline(this, at_xx, at_yy, 1000, 50);
	anim_timeline->hide();

	start_win->Update("Initialize audio thumbnails");
	audio_thumbnail_group = new SlidingElement(this, OPEN_DOWN, 0, 0, w() - 600, 180);
	audio_thumbnail_group->resizable(0);
	audio_thumbnail_group->box(FL_NO_BOX);
	for(loop = 0;loop < 3;loop++)
	{
		audio_thumbnail_pack[loop] = new Fl_Pack(0, (60 * loop), w() - 600, 60);
		audio_thumbnail_pack[loop]->box(FL_NO_BOX);
		audio_thumbnail_pack[loop]->type(Fl_Pack::HORIZONTAL);
		audio_thumbnail_pack[loop]->spacing(10);
		audio_thumbnail_pack[loop]->end();
	}
	audio_thumbnail_group->end();
	audio_thumbnail_group->resize(600, 0, w() - 600, 210);
	if((initial_audio_thumbnail_group_x > -1) && (initial_audio_thumbnail_group_y > -1))
	{
		audio_thumbnail_group->resize(initial_audio_thumbnail_group_x, initial_audio_thumbnail_group_y, audio_thumbnail_group->w(), audio_thumbnail_group->h());
	}
	audio_thumbnail_group->hide();
	if(use_audio == 1)
	{
		start_win->Update("Initialize audio");
		if(no_audio_scan == 0)
		{
			ScanPulse(0);
		}
		else
		{
			OpenNamedPulse();
		}
		audio = 1;
	}
	BuildMainMenu();

	start_win->Update("Initialize video thumbnails");
	int nxx = 0;
	int nyy = 0;
	video_thumbnail_group = new VideoThumbnailGroup(this, 0, 0, 258, 112 * DISPLAYED_THUMB_CNT);
	video_thumbnail_group->box(FL_NO_BOX);
	int cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		thumbnail[loop] = new ThumbGroup(this, loop, 0, 0, 257, 112);
		thumbnail[loop]->resize(nxx, nyy, 257, 112);
		nyy += 112;
		cnt++;
		if(cnt >= DISPLAYED_THUMB_CNT)
		{
			cnt = 0;
			nyy = 0;
		}
	}
	video_thumbnail_group->end();
	if((initial_thumbnail_group_x > -1) && (initial_thumbnail_group_y > -1))
	{
		video_thumbnail_group->resize(initial_thumbnail_group_x, initial_thumbnail_group_y, video_thumbnail_group->w(), video_thumbnail_group->h());
	}
	else
	{
		if(button_group_side == SIDE_RIGHT)
		{
			video_thumbnail_group->resize(0, 75, 258, 112 * DISPLAYED_THUMB_CNT);
			video_thumbnail_group->direction = OPEN_RIGHT;
		}
		else
		{
			video_thumbnail_group->resize(w() - 258, 45, 258, 112 * DISPLAYED_THUMB_CNT);
			video_thumbnail_group->direction = OPEN_LEFT;
		}
	}
	start_win->Update("Initialize PTZ window");
	if(ptz_device_cnt > 0)
	{
		ptz_home_on_launch = in_ptz_home_on_launch;
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			SetupPTZWindow(loop);
		}
		LoadAllPTZPositions();
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			PTZ_DoCommand(loop, 0);
		}
	}
	progress_scrubber = new ProgressScrubber(this, NULL, 0, 0, Fl::w(), Fl::h());
	progress_scrubber->end();

	number_of_fonts = Fl::set_fonts(NULL);

	Fl::add_clipboard_notify(clipboard_notify, this);
	start_win->Update("Read external programs");
	ReadInExternalPrograms();
	resize_grp->end();
	monitor_window = new MonitorWindow(this, output_width, output_height, "Monitor Window");
	monitor_window->hide();
	timer_window = new TimerWindow(this, 230, 255);
	timer_window->hide();
	alert_window = new AlertWindow(this, 520, 255);
	alert_window->hide();
	start_win->Update("Initialize Source Select Window");
	source_select_window = new SourceSelectWindow(this, 420, 800, "Source Select");
	source_select_window->hide();
	DisplayCamera(0);
}

MyWin::~MyWin()
{
	Shutdown();
	if(anim_timeline != NULL)
	{
		anim_timeline->hide();
		Fl::delete_widget(anim_timeline);
		anim_timeline = NULL;
	}
	if(record_on_start_alias != NULL)
	{
		free(record_on_start_alias);
		record_on_start_alias = NULL;
	}
	if(shape != NULL)
	{
		free(shape);
		shape = NULL;
	}
	shape_cnt = 0;
	if(text_edit_window != NULL)
	{
		text_edit_window->hide();
		Fl::delete_widget(text_edit_window);
		text_edit_window = NULL;
	}
	if(pulse_audio_filter_window != NULL)
	{
		pulse_audio_filter_window->hide();
		Fl::delete_widget(pulse_audio_filter_window);
		pulse_audio_filter_window = NULL;
	}
	if(embed_app_settings != NULL)
	{
		embed_app_settings->hide();
		Fl::delete_widget(embed_app_settings);
		embed_app_settings = NULL;
	}
	if(command_key_settings != NULL)
	{
		command_key_settings->hide();
		Fl::delete_widget(command_key_settings);
		command_key_settings = NULL;
	}
	if(video_settings_window != NULL)
	{
		video_settings_window->hide();
		Fl::delete_widget(video_settings_window);
		video_settings_window = NULL;
	}
	if(misc_video_settings_window != NULL)
	{
		misc_video_settings_window->hide();
		Fl::delete_widget(misc_video_settings_window);
		misc_video_settings_window = NULL;
	}
	if(audio_settings_window != NULL)
	{
		audio_settings_window->hide();
		Fl::delete_widget(audio_settings_window);
		audio_settings_window = NULL;
	}
	if(object_menu != NULL)
	{
		object_menu->hide();
		Fl::delete_widget(object_menu);
		object_menu = NULL;
	}
	if(fltk_plugin_window != NULL)
	{
		fltk_plugin_window->hide();
		Fl::delete_widget(fltk_plugin_window);
		fltk_plugin_window = NULL;
	}
	if(filter_plugins_window != NULL)
	{
		filter_plugins_window->hide();
		Fl::delete_widget(filter_plugins_window);
		filter_plugins_window = NULL;
	}
	if(filter_built_in_window != NULL)
	{
		filter_built_in_window->hide();
		Fl::delete_widget(filter_built_in_window);
		filter_built_in_window = NULL;
	}
	if(alias_window != NULL)
	{
		alias_window->hide();
		Fl::delete_widget(alias_window);
		alias_window = NULL;
	}
	if(snapshot_settings_window != NULL)
	{
		snapshot_settings_window->hide();
		Fl::delete_widget(snapshot_settings_window);
		snapshot_settings_window = NULL;
	}
	if(trigger_window != NULL)
	{
		trigger_window->hide();
		Fl::delete_widget(trigger_window);
		trigger_window = NULL;
	}
	if(pseudo_camera_window != NULL)
	{
		pseudo_camera_window->hide();
		Fl::delete_widget(pseudo_camera_window);
		pseudo_camera_window = NULL;
	}
	if(source_select_window != NULL)
	{
		source_select_window->hide();
		Fl::delete_widget(source_select_window);
		source_select_window = NULL;
	}
	if(alert_window != NULL)
	{
		alert_window->hide();
		Fl::delete_widget(alert_window);
		alert_window = NULL;
	}
	if(timer_window != NULL)
	{
		timer_window->hide();
		Fl::delete_widget(timer_window);
		timer_window = NULL;
	}
	if(specify_irc_window != NULL)
	{
		specify_irc_window->hide();
		Fl::delete_widget(specify_irc_window);
		specify_irc_window = NULL;
	}
	if(ndi_source_window != NULL)
	{
		ndi_source_window->hide();
		Fl::delete_widget(ndi_source_window);
		ndi_source_window = NULL;
	}
	if(specify_url_window != NULL)
	{
		specify_url_window->hide();
		Fl::delete_widget(specify_url_window);
		specify_url_window = NULL;
	}
	if(new_source_window != NULL)
	{
		new_source_window->hide();
		Fl::delete_widget(new_source_window);
		new_source_window = NULL;
	}
	if(camera_settings_window != NULL)
	{
		camera_settings_window->hide();
		Fl::delete_widget(camera_settings_window);
		camera_settings_window = NULL;
	}
	if(color_it_window != NULL)
	{
		color_it_window->hide();
		Fl::delete_widget(color_it_window);
		color_it_window = NULL;
	}
	if(transitions_window != NULL)
	{
		transitions_window->hide();
		Fl::delete_widget(transitions_window);
		transitions_window = NULL;
	}
	if(immediate_drawing_window != NULL)
	{
		immediate_drawing_window->hide();
		Fl::delete_widget(immediate_drawing_window);
		immediate_drawing_window = NULL;
	}
	if(filter_plugins_window != NULL)
	{
		filter_plugins_window->hide();
		Fl::delete_widget(filter_plugins_window);
		filter_plugins_window = NULL;
	}
	if(audio_filter_plugins_window != NULL)
	{
		audio_filter_plugins_window->hide();
		Fl::delete_widget(audio_filter_plugins_window);
		audio_filter_plugins_window = NULL;
	}
	if(resize_frame != NULL)
	{
		resize_frame->hide();
		remove(resize_frame);
		Fl::delete_widget(resize_frame);
		resize_frame = NULL;
	}
}

void	MyWin::LoadPluginTransition(char *name)
{
char	buf[256];
int		inner;

	if(strncmp(name, "transition_", strlen("transition_")) != 0)
	{
		sprintf(buf, "transition_%s", name);
	}
	else
	{
		strcpy(buf, name);
	}
	for(inner = 0;inner < global_potential_transition_cnt;inner++)
	{
		if((global_potential_transition[inner] != NULL) && (global_potential_transition_handle[inner] != NULL))
		{
			if(strcmp(buf, global_potential_transition[inner]) == 0)
			{
				void_transition_plugin = (void *)dlsym(global_potential_transition_handle[inner], global_potential_transition[inner]);
				strcpy(transition_plugin, buf);
			}
		}
	}
}

Camera	*MyWin::FindCameraByAlias(char *tst)
{
int	loop;

	Camera *match = NULL;
	for(loop = 0;((loop < source_cnt) && (match == NULL));loop++)
	{
		Camera *compare_cam = camera[loop];
		if(strcmp(tst, compare_cam->alias) == 0)
		{
			match = compare_cam;
		}
	}
	return(match);
}

void	MyWin::LoadJSON(char *filename)
{
	char *buf = ReadWholeFile(filename);
	if(buf != NULL)
	{
		ParseJSON(buf);
		free(buf);
	}
	else
	{
		fprintf(stderr, "Error: Cannor load JSON file: %s\n", filename);
	}
}

void	MyWin::SaveAsJSON(FILE *fp)
{
int	loop;
int	inner;

	fprintf(fp, "{\n");
	fprintf(fp, "\t\"source cnt\": %d,\n", source_cnt);
	if(source_cnt > 0)
	{
		int nn = source_cnt - 1;
		fprintf(fp, "\t\"source\": [");
		for(loop = 0;loop < source_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", source[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"audio source cnt\": %d,\n", audio_source_cnt);
	if(audio_source_cnt > 0)
	{
		int nn = audio_source_cnt - 1;
		fprintf(fp, "\t\t\"audio source\": [");
		for(loop = 0;loop < audio_source_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", audio_source[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"init detect\": %d,\n", init_detect);
	fprintf(fp, "\t\"original w\": %d,\n", original_w);
	fprintf(fp, "\t\"original h\": %d,\n", original_h);
	fprintf(fp, "\t\"disregard settings\": %d,\n", disregard_settings);
	fprintf(fp, "\t\"exit timer\": %ld,\n", exit_timer);
	fprintf(fp, "\t\"highlight image windows\": %d,\n", highlight_image_windows);
	fprintf(fp, "\t\"audio display\": %d,\n", audio_display);
	fprintf(fp, "\t\"audio display timer\": %d,\n", audio_display_timer);
	fprintf(fp, "\t\"audio sample rate\": %d,\n", audio_sample_rate);
	fprintf(fp, "\t\"audio channels\": %d,\n", audio_channels);
	fprintf(fp, "\t\"requested w\": %d,\n", requested_w);
	fprintf(fp, "\t\"requested h\": %d,\n", requested_h);
	fprintf(fp, "\t\"output width\": %d,\n", output_width);
	fprintf(fp, "\t\"output height\": %d,\n", output_height);
	fprintf(fp, "\t\"display width\": %f,\n", display_width);
	fprintf(fp, "\t\"display height\": %f,\n", display_height);
	fprintf(fp, "\t\"display video\": %d,\n", display_video);
	fprintf(fp, "\t\"record on start\": %d,\n", record_on_start);
	if(record_on_start_alias != NULL)
	{
		fprintf(fp, "\t\"record on start alias\": \"%s\",\n", record_on_start_alias);
	}
	fprintf(fp, "\t\"hour\": %d,\n", hour);
	fprintf(fp, "\t\"minute\": %d,\n", minute);
	fprintf(fp, "\t\"second\": %d,\n", second);
	fprintf(fp, "\t\"year\": %d,\n", year);
	fprintf(fp, "\t\"month\": %d,\n", month);
	fprintf(fp, "\t\"day\": %d,\n", day);
	fprintf(fp, "\t\"animate panels\": %d,\n", animate_panels);
	fprintf(fp, "\t\"exclude directories\": %d,\n", file_selector_exclude_directories);
	fprintf(fp, "\t\"use tooltips\": %d,\n", use_tooltips);
	fprintf(fp, "\t\"last used filename\": \"%s\",\n", last_used_filename);
	fprintf(fp, "\t\"transparent interface\": %d,\n", transparent_interface);
	fprintf(fp, "\t\"status color r\": %d,\n", status_color_r);
	fprintf(fp, "\t\"status color g\": %d,\n", status_color_g);
	fprintf(fp, "\t\"status color b\": %d,\n", status_color_b);
	fprintf(fp, "\t\"status color a\": %d,\n", status_color_a);
	fprintf(fp, "\t\"ndi stream name\": \"%s\",\n", ndi_stream_name);
	fprintf(fp, "\t\"ndi streaming\": %d,\n", ndi_streaming);
	fprintf(fp, "\t\"ndi send video format\": %d,\n", ndi_send_video_format);
	fprintf(fp, "\t\"recognize class cnt\": %d,\n", recognize_class_cnt);
	if(recognize_class_cnt > 0)
	{
		int nn = recognize_class_cnt - 1;
		fprintf(fp, "\t\"recognize class name\": [");
		for(loop = 0;loop < recognize_class_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", recognize_class_name[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"yolo cfg filename\": \"%s\",\n", yolo_cfg_filename);
	fprintf(fp, "\t\"yolo weights filename\": \"%s\",\n", yolo_weights_filename);
	fprintf(fp, "\t\"yolo names filename\": \"%s\",\n", yolo_names_filename);
	fprintf(fp, "\t\"forced fps\": %d,\n", forced_fps);
	fprintf(fp, "\t\"forced interval\": %f,\n", forced_interval);
	fprintf(fp, "\t\"speed factor\": %f,\n", speed_factor);
	fprintf(fp, "\t\"minimum fps\": %f,\n", minimum_fps);
	if(jpeg_streaming != NULL)
	{
		fprintf(fp, "\t\"jpeg streaming\": \"%s\",\n", jpeg_streaming);
	}
	fprintf(fp, "\t\"jpeg streaming port\": %d,\n", jpeg_streaming_port);
	fprintf(fp, "\t\"streaming\": %d,\n", streaming);
	fprintf(fp, "\t\"stream url\": \"%s\",\n", stream_url);
	fprintf(fp, "\t\"stream only\": %d,\n", stream_only);
	fprintf(fp, "\t\"streaming audio quality\": %d,\n", streaming_audio_quality);
	fprintf(fp, "\t\"image origin x\": %d,\n", image_origin_x);
	fprintf(fp, "\t\"image origin y\": %d,\n", image_origin_y);
	fprintf(fp, "\t\"embedded app cnt\": %d,\n", embedded_app_cnt);
	fprintf(fp, "\t\"embed pip\": %d,\n", embed_pip);
	fprintf(fp, "\t\"pip x position\": %f,\n", pip_x_position);
	fprintf(fp, "\t\"pip y position\": %f,\n", pip_y_position);
	fprintf(fp, "\t\"pip red\": %d,\n", pip_red);
	fprintf(fp, "\t\"pip green\": %d,\n", pip_green);
	fprintf(fp, "\t\"pip blue\": %d,\n", pip_blue);
	fprintf(fp, "\t\"pip size\": %f,\n", pip_size);
	fprintf(fp, "\t\"number of fonts\": %d,\n", number_of_fonts);
	fprintf(fp, "\t\"image window button\": %d,\n", image_window_button);
	fprintf(fp, "\t\"buttonized visible\": %d,\n", buttonized_visible);
	fprintf(fp, "\t\"command key\": [");
	for(loop = 0;loop < 128;loop++)
	{
		fprintf(fp, "%d", command_key[loop]);
		if(loop != 127)
		{
			fprintf(fp, ",");
		}
		else
		{
			fprintf(fp, "],\n");
		}
	}
	fprintf(fp, "\t\"button panel sz\": %d,\n", button_panel_sz);
	fprintf(fp, "\t\"gui scale factor\": %f,\n", gui_scale_factor);
	fprintf(fp, "\t\"image display scale\": %f,\n", image_display_scale);
	fprintf(fp, "\t\"retain commands\": %d,\n", retain_commands);
	fprintf(fp, "\t\"retain cameras\": %d,\n", retain_cameras);
	fprintf(fp, "\t\"retain audio\": %d,\n", retain_audio);
	fprintf(fp, "\t\"retain ptz\": %d,\n", retain_ptz);
	fprintf(fp, "\t\"hide status\": %d,\n", hide_status);
	fprintf(fp, "\t\"auto scale\": %d,\n", auto_scale);
	fprintf(fp, "\t\"ptz home on launch\": %d,\n", ptz_home_on_launch);
	fprintf(fp, "\t\"output path cnt\": %d,\n", output_path_cnt);
	if(output_path_cnt > 0)
	{
		int nn = output_path_cnt - 1;
		fprintf(fp, "\t\"output name\": [");
		for(loop = 0;loop < output_path_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", output_name[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"output path\": [");
		for(loop = 0;loop < output_path_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", output_path[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"output active\": [");
		for(loop = 0;loop < output_path_cnt;loop++)
		{
			fprintf(fp, "%d", output_active[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"immediate cnt\": %d,\n", immediate_cnt);
	if(immediate_cnt > 0)
	{
		fprintf(fp, "\t\"Immediate\": [\n");
		for(loop = 0;loop < immediate_cnt;loop++)
		{
			if(immediate_list[loop] != NULL)
			{
				Immediate *im = immediate_list[loop];
				fprintf(fp, "\t\t{\n");
				im->SaveAsJSON(fp);
				if(loop == immediate_cnt - 1)
				{
					fprintf(fp, "\t\t}\n");
				}
				else
				{
					fprintf(fp, "\t\t},\n");
				}
			}
		}
		fprintf(fp, "\t],\n");
	}
	fprintf(fp, "\t\"pulse microphone cnt\": %d,\n", pulse_microphone_cnt);
	SaveMicrophonesAsJSON(fp);
	fprintf(fp, ",\n");
	fprintf(fp, "\t\"audio\": %d,\n", audio);
	fprintf(fp, "\t\"mute audio\": %d,\n", mute_audio);
	fprintf(fp, "\t\"audio direct mix\": %d,\n", audio_direct_mix);
	fprintf(fp, "\t\"audio incidental volume\": %f,\n", audio_incidental_volume);
	fprintf(fp, "\t\"active audio playback\": %d,\n", active_audio_playback);
	fprintf(fp, "\t\"shape cnt\": %d,\n", shape_cnt);
	if(shape_cnt > 0)
	{
		fprintf(fp, "\t\"Shape\": [\n");
		for(loop = 0;loop < shape_cnt;loop++)
		{
			if(shape[loop] != NULL)
			{
				Shape *local_shape = shape[loop];
				fprintf(fp, "\t\t\"type\": %d,\n", local_shape->type);
				fprintf(fp, "\t\t\"xx\": %d,\n", local_shape->xx);
				fprintf(fp, "\t\t\"yy\": %d,\n", local_shape->yy);
				fprintf(fp, "\t\t\"ww\": %d,\n", local_shape->ww);
				fprintf(fp, "\t\t\"hh\": %d,\n", local_shape->hh);
				fprintf(fp, "\t\t\"mode\": %d,\n", local_shape->mode);
				fprintf(fp, "\t\t\"layer\": %d,\n", local_shape->layer);
				fprintf(fp, "\t\t\"hidden\": %d,\n", local_shape->hidden);
				fprintf(fp, "\t\t\"highlight\": %d,\n", local_shape->highlight);
				fprintf(fp, "\t\t\"thickness\": %d,\n", local_shape->thickness);
				fprintf(fp, "\t\t\"filled\": %d,\n", local_shape->filled);
				fprintf(fp, "\t\t\"square\": %d,\n", local_shape->square);
				fprintf(fp, "\t\t\"erase\": %d,\n", local_shape->erase);
				fprintf(fp, "\t\t\"background r\": %d,\n", local_shape->background_r);
				fprintf(fp, "\t\t\"background g\": %d,\n", local_shape->background_g);
				fprintf(fp, "\t\t\"background b\": %d,\n", local_shape->background_b);
				fprintf(fp, "\t\t\"background a\": %d,\n", local_shape->background_a);
				fprintf(fp, "\t\t\"foreground r\": %d,\n", local_shape->foreground_r);
				fprintf(fp, "\t\t\"foreground g\": %d,\n", local_shape->foreground_g);
				fprintf(fp, "\t\t\"foreground b\": %d,\n", local_shape->foreground_b);
				fprintf(fp, "\t\t\"foreground a\": %d,\n", local_shape->foreground_a);
				fprintf(fp, "\t\t\"font\": %d,\n", local_shape->font);
				fprintf(fp, "\t\t\"style\": %d,\n", local_shape->style);
				fprintf(fp, "\t\t\"font sz\": %d,\n", local_shape->font_sz);
			}
		}
	}
	if(dump_type != NULL)
	{
		fprintf(fp, "\t\"dump type\": \"%s\",\n", dump_type);
	}
	fprintf(fp, "\t\"mux format\": \"%s\",\n", mux_format);
	fprintf(fp, "\t\"audio thumbnail cnt\": %d,\n", audio_thumbnail_cnt);
	fprintf(fp, "\t\"visible debug\": %d,\n", visible_debug);
	fprintf(fp, "\t\"filename\": \"%s\",\n", filename);
	fprintf(fp, "\t\"interest cnt\": %d,\n", interest_cnt);
	if(interest_cnt > 0)
	{
		int nn = interest_cnt - 1;
		fprintf(fp, "\t\"interest x\": [");
		for(loop = 0;loop < output_path_cnt;loop++)
		{
			fprintf(fp, "%d", interest_x[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
		fprintf(fp, "\t\"interest y\": [");
		for(loop = 0;loop < output_path_cnt;loop++)
		{
			fprintf(fp, "%d", interest_y[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
			else
			{
				fprintf(fp, "],\n");
			}
		}
	}
	fprintf(fp, "\t\"zoom boxing\": %d,\n", zoom_boxing);
	fprintf(fp, "\t\"timestamp\": %d,\n", timestamp);
	fprintf(fp, "\t\"timestamp format\": \"%s\",\n", timestamp_format);
	fprintf(fp, "\t\"timestamp rr\": %d,\n", timestamp_rr);
	fprintf(fp, "\t\"timestamp gg\": %d,\n", timestamp_gg);
	fprintf(fp, "\t\"timestamp bb\": %d,\n", timestamp_bb);
	fprintf(fp, "\t\"timestamp aa\": %d,\n", timestamp_aa);
	fprintf(fp, "\t\"timestamp background rr\": %d,\n", timestamp_background_rr);
	fprintf(fp, "\t\"timestamp background gg\": %d,\n", timestamp_background_gg);
	fprintf(fp, "\t\"timestamp background bb\": %d,\n", timestamp_background_bb);
	fprintf(fp, "\t\"timestamp background aa\": %d,\n", timestamp_background_aa);
	fprintf(fp, "\t\"timestamp font sz\": %d,\n", timestamp_font_sz);
	fprintf(fp, "\t\"timestamp position x\": %d,\n", timestamp_position_x);
	fprintf(fp, "\t\"timestamp position y\": %d,\n", timestamp_position_y);
	fprintf(fp, "\t\"frame scaling\": %d,\n", frame_scaling);
	fprintf(fp, "\t\"crop scaling\": %d,\n", crop_scaling);
	fprintf(fp, "\t\"crop output\": %d,\n", crop_output);
	fprintf(fp, "\t\"crop output x\": %d,\n", crop_output_x);
	fprintf(fp, "\t\"crop output y\": %d,\n", crop_output_y);
	fprintf(fp, "\t\"resizing detail\": %d,\n", resizing_detail);
	fprintf(fp, "\t\"grid sz\": %d,\n", grid_sz);
	fprintf(fp, "\t\"detail x\": %d,\n", detail_x);
	fprintf(fp, "\t\"detail y\": %d,\n", detail_y);
	fprintf(fp, "\t\"detail width\": %d,\n", detail_width);
	fprintf(fp, "\t\"detail height\": %d,\n", detail_height);
	fprintf(fp, "\t\"motion debug\": %d,\n", motion_debug);
	fprintf(fp, "\t\"split\": %d,\n", split);
	fprintf(fp, "\t\"trigger select mode\": %d,\n", trigger_select_mode);
	fprintf(fp, "\t\"record all\": %d,\n", record_all);
	fprintf(fp, "\t\"record desktop\": %d,\n", record_desktop);
	fprintf(fp, "\t\"desktop x\": %d,\n", desktop_x);
	fprintf(fp, "\t\"desktop y\": %d,\n", desktop_y);
	fprintf(fp, "\t\"desktop w\": %d,\n", desktop_w);
	fprintf(fp, "\t\"desktop h\": %d,\n", desktop_h);
	fprintf(fp, "\t\"single stream\": %d,\n", single_stream);
	fprintf(fp, "\t\"follow mode\": %d,\n", follow_mode);
	fprintf(fp, "\t\"transition\": %d,\n", transition);
	fprintf(fp, "\t\"ptz mode\": %d,\n", ptz_mode);
	fprintf(fp, "\t\"ptz device cnt\": %d,\n", ptz_device_cnt);
	if(ptz_device_cnt > 0)
	{
		int nn = ptz_device_cnt - 1;
		fprintf(fp, "\t\"ptz device path\": [");
		for(loop = 0;loop < ptz_device_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", ptz_device_path[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
		}
		fprintf(fp, "],\n");
		fprintf(fp, "\t\"ptz lock alias\": [");
		for(loop = 0;loop < ptz_device_cnt;loop++)
		{
			for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
			{
				fprintf(fp, "\"%s\"", ptz_lock_alias[loop][inner]);
				if(inner < NUMBER_OF_CAMERAS - 1)
				{
					fprintf(fp, ",");
				}
			}
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
		}
		fprintf(fp, "],\n");
		fprintf(fp, "\t\"ptz alias\": [");
		for(loop = 0;loop < ptz_device_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", ptz_alias[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
		}
		fprintf(fp, "],\n");
		fprintf(fp, "\t\"ptz bind alias\": [");
		for(loop = 0;loop < ptz_device_cnt;loop++)
		{
			fprintf(fp, "\"%s\"", ptz_bind_alias[loop]);
			if(loop != nn)
			{
				fprintf(fp, ",");
			}
		}
		fprintf(fp, "],\n");
	}
	fprintf(fp, "\t\"use pan speed\": %d,\n", use_pan_speed);
	fprintf(fp, "\t\"use tilt speed\": %d,\n", use_tilt_speed);
	fprintf(fp, "\t\"ptz follow\": %d,\n", ptz_follow);
	fprintf(fp, "\t\"ptz little speed\": %d,\n", ptz_little_speed);
	fprintf(fp, "\t\"ptz little mode\": %d,\n", ptz_little_mode);
	fprintf(fp, "\t\"ptz reverse horizontal\": %d,\n", ptz_reverse_horizontal);
	fprintf(fp, "\t\"ptz reverse vertical\": %d,\n", ptz_reverse_vertical);
	fprintf(fp, "\t\"ptz zoomer\": %d,\n", ptz_zoomer);
	fprintf(fp, "\t\"ptz joystick\": %d,\n", ptz_joystick);
	fprintf(fp, "\t\"center message timer\": %d,\n", center_message_timer);
	fprintf(fp, "\t\"transmitting\": %d,\n", transmitting);
	fprintf(fp, "\t\"move corner\": %d,\n", move_corner);
	fprintf(fp, "\t\"resize corner\": %d,\n", resize_corner);
	fprintf(fp, "\t\"use extension\": \"%s\",\n", use_extension);
	fprintf(fp, "\t\"use container\": \"%s\",\n", use_container);
	fprintf(fp, "\t\"video codec name\": \"%s\",\n", video_codec_name);
	fprintf(fp, "\t\"audio codec name\": \"%s\",\n", audio_codec_name);
	fprintf(fp, "\t\"render mouse\": %d,\n", render_mouse);
	fprintf(fp, "\t\"tutorial mode\": %d,\n", tutorial_mode);
	SaveCamerasAsJSON(fp);
	fprintf(fp, "}");
}

void	MyWin::SaveMicrophonesAsJSON(FILE *fp)
{
int	loop;

	fprintf(fp, "\"Microphones\": [\n");
	for(loop = 0;loop < pulse_microphone_cnt;loop++)
	{
		if(pulse_microphone[loop] != NULL)
		{
			pulse_microphone[loop]->SaveAsJSON(fp);
			if(loop < pulse_microphone_cnt - 1)
			{
				fprintf(fp, ",\n");
			}
			else
			{
				fprintf(fp, "\n");
			}
		}
	}
	fprintf(fp, "]\n");
}

void	MyWin::SaveCamerasAsJSON(FILE *fp)
{
int	loop;

	fprintf(fp, "\"Cameras\": [\n");
	for(loop = 0;loop < source_cnt;loop++)
	{
		if(camera[loop] != NULL)
		{
			camera[loop]->SaveAsJSON(fp);
			if(loop < source_cnt - 1)
			{
				fprintf(fp, ",\n");
			}
			else
			{
				fprintf(fp, "\n");
			}
		}
	}
	fprintf(fp, "]\n");
}

int	MyWin::ParseJSON(char *str)
{
void	my_window_cb(void *v);
int		loop;

	int status = 1;
	cJSON *json = cJSON_Parse(str);
	if(json == NULL)
	{
		const char *error_ptr = cJSON_GetErrorPtr();
		if(error_ptr != NULL)
		{
			fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
		}
		status = 0;
	}
	else
	{
		Cleanup();
		ParseJSONSystem(json);
		cJSON_Delete(json);
		recognize_class_cnt = 0;
		ReadClasses();
		if(init_detect == 1)
		{
			 SetupObjectDetection();
		}
		if((audio == 1) && (audio_thumbnail_cnt == 0))
		{
			pulse_mixer = NULL;
			if(no_audio_scan == 0)
			{
				ScanPulse(0);
			}
			else
			{
				OpenNamedPulse();
			}
		}
		else if(audio == 1)
		{
			OpenNamedPulse();
		}
		ptz_mode = 0;
		if(ptz_device_cnt > 0)
		{
			for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
			{
				SetupPTZWindow(loop);
				add(ptz_window[loop]);
			}
		}
		HideButtons();
		ShowButtons();
		Fl::remove_timeout(my_window_cb, this);
		Fl::add_timeout(0.1, my_window_cb, this);
	}
	return(status);
}

void	MyWin::ParseJSONSystem(cJSON *json)
{
int	loop;
int	inner;

	if(start_win != NULL)
	{
		start_win->Update("Reading Setup");
	}
	for(loop = 0;loop < source_cnt;loop++)
	{
		if(source[loop] != NULL)
		{
			free(source[loop]);
			source[loop] = NULL;
		}
	}
	source_cnt = 0;
	int local_source_cnt = 0;
	int success = json_parse_int(json, "source cnt", local_source_cnt);

	cJSON *source_item = NULL;
	cJSON *source_items = json_parse_array(json, "source");
	if(source_items != NULL)
	{
		int cnt = 0;
		cJSON_ArrayForEach(source_item, source_items)
		{
			if(source_item->valuestring != NULL)
			{
				source[cnt] = strdup(source_item->valuestring);
				cnt++;
			}
		}
		local_source_cnt = cnt;
	}
	for(loop = 0;loop < audio_source_cnt;loop++)
	{
		if(audio_source[loop] != NULL)
		{
			free(audio_source[loop]);
			audio_source[loop] = NULL;
		}
	}
	int local_audio_source_cnt = 0;
	audio_source_cnt = 0;
	success = json_parse_int(json, "audio source cnt", local_audio_source_cnt);
	cJSON *audio_source_item = NULL;
	cJSON *audio_source_items = json_parse_array(json, "audio source");
	if(audio_source_items != NULL)
	{
		int cnt = 0;
		cJSON_ArrayForEach(audio_source_item, audio_source_items)
		{
			if(cnt < 128)
			{
				if(audio_source_item->valuestring != NULL)
				{
					audio_source[cnt] = strdup(audio_source_item->valuestring);
					cnt++;
				}
			}
		}
		local_audio_source_cnt = cnt;
	}
	success = json_parse_int(json, "init detect", init_detect);
	success = json_parse_int(json, "original w", original_w);
	success = json_parse_int(json, "original h", original_h);
	success = json_parse_int(json, "disregard settings", disregard_settings);
	success = json_parse_int(json, "exit timer", exit_timer);
	success = json_parse_int(json, "highlight image windows", highlight_image_windows);
	success = json_parse_int(json, "audio display", audio_display);
	success = json_parse_int(json, "audio display timer", audio_display_timer);
	success = json_parse_int(json, "audio sample rate", audio_sample_rate);
	success = json_parse_int(json, "audio channels", audio_channels);
	success = json_parse_int(json, "requested w", requested_w);
	success = json_parse_int(json, "requested h", requested_h);
	success = json_parse_int(json, "output width", output_width);
	success = json_parse_int(json, "output height", output_height);
	success = json_parse_double(json, "display width", display_width);
	success = json_parse_double(json, "display height", display_height);
	success = json_parse_int(json, "display video", display_video);
	success = json_parse_int(json, "record on start", record_on_start);
	char *str = json_parse_string(json, "record on start alias");
	if(str != NULL)
	{
		record_on_start_alias = strdup(str);
	}
	success = json_parse_int(json, "hour", hour);
	success = json_parse_int(json, "minute", minute);
	success = json_parse_int(json, "second", second);
	success = json_parse_int(json, "year", year);
	success = json_parse_int(json, "month", month);
	success = json_parse_int(json, "day", day);
	success = json_parse_int(json, "animate panels", animate_panels);
	success = json_parse_int(json, "exclude directories", file_selector_exclude_directories);
	success = json_parse_int(json, "use tooltips", use_tooltips);
	strcpy(last_used_filename, "");
	str = json_parse_string(json, "last used filename");
	if(str != NULL)
	{
		strcpy(last_used_filename, str);
	}
	success = json_parse_int(json, "transparent interface", transparent_interface);
	success = json_parse_int(json, "status color r", status_color_r);
	success = json_parse_int(json, "status color g", status_color_g);
	success = json_parse_int(json, "status color b", status_color_b);
	success = json_parse_int(json, "status color a", status_color_a);
	strcpy(ndi_stream_name, "");
	str = json_parse_string(json, "ndi stream name");
	if(str != NULL)
	{
		strcpy(ndi_stream_name, str);
	}
	success = json_parse_int(json, "ndi streaming", ndi_streaming);
	success = json_parse_int(json, "ndi send video format", ndi_send_video_format);
	for(loop = 0;loop < recognize_class_cnt;loop++)
	{
		if(recognize_class_name[loop] != NULL)
		{
			free(recognize_class_name[loop]);
			recognize_class_name[loop] = NULL;
		}
	}
	success = json_parse_int(json, "recognize class cnt", recognize_class_cnt);
	cJSON *recognize_class_item = NULL;
	cJSON *recognize_class_items = json_parse_array(json, "recognize class name");
	if(recognize_class_items != NULL)
	{
		int cnt = 0;
		cJSON_ArrayForEach(recognize_class_item, recognize_class_items)
		{
			if(cnt < 128)
			{
				if(recognize_class_item->valuestring != NULL)
				{
					recognize_class_name[cnt] = strdup(recognize_class_item->valuestring);
					cnt++;
				}
			}
		}
		recognize_class_cnt = cnt;
	}
	strcpy(yolo_cfg_filename, "");
	str = json_parse_string(json, "yolo cfg filename");
	if(str != NULL)
	{
		strcpy(yolo_cfg_filename, str);
	}
	strcpy(yolo_weights_filename, "");
	str = json_parse_string(json, "yolo weights filename");
	if(str != NULL)
	{
		strcpy(yolo_weights_filename, str);
	}
	strcpy(yolo_names_filename, "");
	str = json_parse_string(json, "yolo names filename");
	if(str != NULL)
	{
		strcpy(yolo_names_filename, str);
	}
	success = json_parse_int(json, "forced fps", forced_fps);
	success = json_parse_double(json, "forced interval", forced_interval);
	success = json_parse_double(json, "speed factor", speed_factor);
	success = json_parse_double(json, "minimum fps", minimum_fps);
	if(jpeg_streaming != NULL)
	{
		free(jpeg_streaming);
		jpeg_streaming = NULL;
	}
	str = json_parse_string(json, "jpeg streaming");
	if(str != NULL)
	{
		jpeg_streaming = strdup(str);
	}
	success = json_parse_int(json, "jpeg streaming port", jpeg_streaming_port);
	success = json_parse_int(json, "streaming", streaming);
	strcpy(stream_url, "");
	str = json_parse_string(json, "stream url");
	if(str != NULL)
	{
		strcpy(stream_url, str);
	}
	success = json_parse_int(json, "stream only", stream_only);
	success = json_parse_int(json, "streaming audio quality", streaming_audio_quality);
	success = json_parse_int(json, "image origin x", image_origin_x);
	success = json_parse_int(json, "image origin y", image_origin_y);
	success = json_parse_int(json, "embedded app cnt", embedded_app_cnt);
	success = json_parse_int(json, "embed pip", embed_pip);
	success = json_parse_double(json, "pip x position", pip_x_position);
	success = json_parse_double(json, "pip y position", pip_y_position);
	success = json_parse_int(json, "pip red", pip_red);
	success = json_parse_int(json, "pip green", pip_green);
	success = json_parse_int(json, "pip blue", pip_blue);
	success = json_parse_double(json, "pip size", pip_size);
	success = json_parse_int(json, "number of fonts", number_of_fonts);
	success = json_parse_int(json, "image window button", image_window_button);
	success = json_parse_int(json, "buttonized visible", buttonized_visible);
	cJSON *command_key_item = NULL;
	cJSON *command_key_items = json_parse_array(json, "command key");
	if(command_key_items != NULL)
	{
		int cnt = 0;
		cJSON_ArrayForEach(command_key_item, command_key_items)
		{
			command_key[cnt] = command_key_item->valueint;
			cnt++;
		}
	}
	success = json_parse_int(json, "button panel sz", button_panel_sz);
	success = json_parse_double(json, "gui scale factor", gui_scale_factor);
	success = json_parse_double(json, "image display scale", image_display_scale);
	success = json_parse_int(json, "retain commands", retain_commands);
	success = json_parse_int(json, "retain cameras", retain_cameras);
	success = json_parse_int(json, "retain audio", retain_audio);
	success = json_parse_int(json, "retain ptz", retain_ptz);
	success = json_parse_int(json, "hide status", hide_status);
	success = json_parse_int(json, "auto scale", auto_scale);
	success = json_parse_int(json, "ptz home on launch", ptz_home_on_launch);
	for(loop = 0;loop < output_path_cnt;loop++)
	{
		if(output_name[loop] != NULL)
		{
			free(output_name[loop]);
			output_name[loop] = NULL;
		}
		if(output_path[loop] != NULL)
		{
			free(output_path[loop]);
			output_path[loop] = NULL;
		}
		output_active[loop] = 0;
	}
	success = json_parse_int(json, "output path cnt", output_path_cnt);
	cJSON *item = NULL;
	cJSON *items = json_parse_array(json, "output name");
	if(items != NULL)
	{
		int cnt = 0;
		cJSON_ArrayForEach(item, items)
		{
			if(item->valuestring != NULL)
			{
				output_name[cnt] = strdup(item->valuestring);
				cnt++;
			}
		}
	}
	item = NULL;
	items = json_parse_array(json, "output path");
	if(items != NULL)
	{
		int cnt = 0;
		cJSON_ArrayForEach(item, items)
		{
			if(item->valuestring != NULL)
			{
				output_path[cnt] = strdup(item->valuestring);
				cnt++;
			}
		}
	}
	item = NULL;
	items = json_parse_array(json, "output active");
	if(items != NULL)
	{
		int cnt = 0;
		cJSON_ArrayForEach(item, items)
		{
			output_active[cnt] = item->valueint;
			cnt++;
		}
	}
	if(start_win != NULL)
	{
		start_win->Update("Reading Immediate Drawings");
	}
	ClearImmediate();
	success = json_parse_int(json, "immediate cnt", immediate_cnt);
	if(immediate_cnt > 0)
	{
		cJSON *immediate = NULL;
		cJSON *immediates = json_parse_array(json, "Immediate");
		if(immediates != NULL)
		{
			int cnt = 0;
			cJSON_ArrayForEach(immediate, immediates)
			{
				Immediate *im_use = ParseJSONImmediate(immediate, NULL);
				AddImmediate(im_use);
				add(im_use);
				cnt++;
			}
			immediate_cnt = cnt;
		}
	}
	if(start_win != NULL)
	{
		start_win->Update("Reading Audio Sources");
	}
	success = json_parse_int(json, "pulse microphone cnt", pulse_microphone_cnt);
	ParseJSONMicrophones(json);
	success = json_parse_int(json, "audio", audio);
	success = json_parse_int(json, "mute audio", mute_audio);
	success = json_parse_int(json, "audio direct mix", audio_direct_mix);
	success = json_parse_double(json, "audio incidental volume", audio_incidental_volume);
	success = json_parse_int(json, "active audio playback", active_audio_playback);
	for(loop = 0;loop < shape_cnt;loop++)
	{
		if(shape[loop] != NULL)
		{
			delete shape[loop];
			shape[loop] = NULL;
		}
	}
	if(start_win != NULL)
	{
		start_win->Update("Reading Shapes");
	}
	success = json_parse_int(json, "shape cnt", shape_cnt);
	if(shape_cnt > 0)
	{
		item = NULL;
		items = json_parse_array(json, "Shape");
		if(items != NULL)
		{
			int cnt = 0;
			cJSON_ArrayForEach(item, items)
			{
				int xx;
				int yy;
				int ww;
				int hh;
				success = json_parse_int(item, "xx", xx);
				success = json_parse_int(item, "yy", yy);
				success = json_parse_int(item, "ww", ww);
				success = json_parse_int(item, "hh", hh);
				shape[cnt] = new Shape(this, xx, yy, ww, hh);
				success = json_parse_int(item, "type", shape[cnt]->type);
				success = json_parse_int(item, "mode", shape[cnt]->mode);
				success = json_parse_int(item, "layer", shape[cnt]->layer);
				success = json_parse_int(item, "hidden", shape[cnt]->hidden);
				success = json_parse_int(item, "highlight", shape[cnt]->highlight);
				success = json_parse_int(item, "thickness", shape[cnt]->thickness);
				success = json_parse_int(item, "filled", shape[cnt]->filled);
				success = json_parse_int(item, "square", shape[cnt]->square);
				success = json_parse_int(item, "erase", shape[cnt]->erase);
				success = json_parse_int(item, "background r", shape[cnt]->background_r);
				success = json_parse_int(item, "background g", shape[cnt]->background_g);
				success = json_parse_int(item, "background g", shape[cnt]->background_b);
				success = json_parse_int(item, "background a", shape[cnt]->background_a);
				success = json_parse_int(item, "foreground r", shape[cnt]->foreground_r);
				success = json_parse_int(item, "foreground g", shape[cnt]->foreground_g);
				success = json_parse_int(item, "foreground b", shape[cnt]->foreground_b);
				success = json_parse_int(item, "foreground a", shape[cnt]->foreground_a);
				success = json_parse_int(item, "font", shape[cnt]->font);
				success = json_parse_int(item, "style", shape[cnt]->style);
				success = json_parse_int(item, "font sz", shape[cnt]->font_sz);
				cnt++;
			}
			shape_cnt = cnt;
		}
	}
	if(dump_type != NULL)
	{
		free(dump_type);
		dump_type = NULL;
	}
	str = json_parse_string(json, "dump type");
	if(str != NULL)
	{
		dump_type = strdup(str);
	}
	str = json_parse_string(json, "mux format");
	if(str != NULL)
	{
		strcpy(mux_format, str);
	}
	success = json_parse_int(json, "audio thumbnail cnt", audio_thumbnail_cnt);
	success = json_parse_int(json, "visible debug", visible_debug);
	strcpy(filename, "");
	str = json_parse_string(json, "filename");
	if(str != NULL)
	{
		strcpy(filename, str);
	}
	success = json_parse_int(json, "interest cnt", interest_cnt);
	if(interest_cnt > 0)
	{
		item = NULL;
		items = json_parse_array(json, "interest x");
		if(items != NULL)
		{
			int cnt = 0;
			cJSON_ArrayForEach(item, items)
			{
				interest_x[cnt] = item->valueint;
				cnt++;
			}
		}
		item = NULL;
		items = json_parse_array(json, "interest y");
		if(items != NULL)
		{
			int cnt = 0;
			cJSON_ArrayForEach(item, items)
			{
				interest_y[cnt] = item->valueint;
				cnt++;
			}
		}
	}
	if(start_win != NULL)
	{
		start_win->Update("Reading PTZ Settings");
	}
	success = json_parse_int(json, "zoom boxing", zoom_boxing);
	success = json_parse_int(json, "timestamp", timestamp);
	strcpy(timestamp_format, "");
	str = json_parse_string(json, "timestamp format");
	if(str != NULL)
	{
		strcpy(timestamp_format, str);
	}
	success = json_parse_int(json, "timestamp rr", timestamp_rr);
	success = json_parse_int(json, "timestamp gg", timestamp_gg);
	success = json_parse_int(json, "timestamp bb", timestamp_bb);
	success = json_parse_int(json, "timestamp aa", timestamp_aa);
	success = json_parse_int(json, "timestamp background rr", timestamp_background_rr);
	success = json_parse_int(json, "timestamp background gg", timestamp_background_gg);
	success = json_parse_int(json, "timestamp background bb", timestamp_background_bb);
	success = json_parse_int(json, "timestamp background aa", timestamp_background_aa);
	success = json_parse_int(json, "timestamp font sz", timestamp_font_sz);
	success = json_parse_int(json, "timestamp position x", timestamp_position_x);
	success = json_parse_int(json, "timestamp position y", timestamp_position_y);
	success = json_parse_int(json, "frame scaling", frame_scaling);
	success = json_parse_int(json, "crop scaling", crop_scaling);
	success = json_parse_int(json, "crop output", crop_output);
	success = json_parse_int(json, "crop output x", crop_output_x);
	success = json_parse_int(json, "crop output y", crop_output_y);
	success = json_parse_int(json, "resizing detail", resizing_detail);
	success = json_parse_int(json, "grid sz", grid_sz);
	success = json_parse_int(json, "detail x", detail_x);
	success = json_parse_int(json, "detail y", detail_y);
	success = json_parse_int(json, "detail width", detail_width);
	success = json_parse_int(json, "detail height", detail_height);
	success = json_parse_int(json, "motion debug", motion_debug);
	success = json_parse_int(json, "split", split);
	success = json_parse_int(json, "trigger select mode", trigger_select_mode);
	success = json_parse_int(json, "record all", record_all);
	success = json_parse_int(json, "record desktop", record_desktop);
	success = json_parse_int(json, "desktop x", desktop_x);
	success = json_parse_int(json, "desktop y", desktop_y);
	success = json_parse_int(json, "desktop w", desktop_w);
	success = json_parse_int(json, "desktop h", desktop_h);
	success = json_parse_int(json, "single stream", single_stream);
	success = json_parse_int(json, "follow mode", follow_mode);
	success = json_parse_int(json, "transition", transition);
	success = json_parse_int(json, "ptz mode", ptz_mode);
	for(loop = 0;loop < ptz_device_cnt;loop++)
	{
		if(ptz_device_path[loop] != NULL)
		{
			free(ptz_device_path[loop]);
			ptz_device_path[loop] = NULL;
		}
		for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
		{
			if(ptz_lock_alias[loop][inner] != NULL)
			{
				free(ptz_lock_alias[loop][inner]);
				ptz_lock_alias[loop][inner] = NULL;
			}
		}
		if(ptz_alias[loop] != NULL)
		{
			free(ptz_alias[loop]);
			ptz_alias[loop] = NULL;
		}
		if(ptz_bind_alias[loop] != NULL)
		{
			free(ptz_bind_alias[loop]);
			ptz_bind_alias[loop] = NULL;
		}
	}
	success = json_parse_int(json, "ptz device cnt", ptz_device_cnt);
	if(ptz_device_cnt > 0)
	{
		item = NULL;
		items = json_parse_array(json, "ptz device path");
		if(items != NULL)
		{
			int cnt = 0;
			cJSON_ArrayForEach(item, items)
			{
				if(item->valuestring != NULL)
				{
					ptz_device_path[cnt] = strdup(item->valuestring);
					cnt++;
				}
			}
		}
		item = NULL;
		items = json_parse_array(json, "ptz lock alias");
		if(items != NULL)
		{
			int cnt = 0;
			int inner = 0;
			cJSON_ArrayForEach(item, items)
			{
				if(item->valuestring != NULL)
				{
					ptz_lock_alias[cnt][inner] = strdup(item->valuestring);
					inner++;
					if(inner == NUMBER_OF_CAMERAS - 1)
					{
						inner = 0;
						cnt++;
					}
				}
			}
		}
		item = NULL;
		items = json_parse_array(json, "ptz alias");
		if(items != NULL)
		{
			int cnt = 0;
			cJSON_ArrayForEach(item, items)
			{
				if(item->valuestring != NULL)
				{
					ptz_alias[cnt] = strdup(item->valuestring);
					cnt++;
				}
			}
		}
		item = NULL;
		items = json_parse_array(json, "ptz bind alias");
		if(items != NULL)
		{
			int cnt = 0;
			cJSON_ArrayForEach(item, items)
			{
				if(item->valuestring != NULL)
				{
					ptz_bind_alias[cnt] = strdup(item->valuestring);
					cnt++;
				}
			}
		}
	}
	success = json_parse_int(json, "use pan speed", use_pan_speed);
	success = json_parse_int(json, "use tilt speed", use_tilt_speed);
	success = json_parse_int(json, "ptz follow", ptz_follow);
	success = json_parse_int(json, "ptz little speed", ptz_little_speed);
	success = json_parse_int(json, "ptz little mode", ptz_little_mode);
	success = json_parse_int(json, "ptz reverse horizontal", ptz_reverse_horizontal);
	success = json_parse_int(json, "ptz reverse vertical", ptz_reverse_vertical);
	success = json_parse_int(json, "ptz zoomer", ptz_zoomer);
	success = json_parse_int(json, "ptz joystick", ptz_joystick);
	success = json_parse_int(json, "center message timer", center_message_timer);
	success = json_parse_int(json, "transmitting", transmitting);
	success = json_parse_int(json, "move corner", move_corner);
	success = json_parse_int(json, "resize corner", resize_corner);
	strcpy(use_extension, "");
	if(start_win != NULL)
	{
		start_win->Update("Reading Codecs");
	}
	str = json_parse_string(json, "use extension");
	if(str != NULL)
	{
		strcpy(use_extension, str);
	}
	strcpy(use_container, "");
	str = json_parse_string(json, "use container");
	if(str != NULL)
	{
		strcpy(use_container, str);
	}
	strcpy(video_codec_name, "");
	str = json_parse_string(json, "video codec name");
	if(str != NULL)
	{
		strcpy(video_codec_name, str);
	}
	strcpy(audio_codec_name, "");
	str = json_parse_string(json, "audio codec name");
	if(str != NULL)
	{
		strcpy(audio_codec_name, str);
	}
	success = json_parse_int(json, "render mouse", render_mouse);
	success = json_parse_int(json, "tutorial mode", tutorial_mode);
	if(start_win != NULL)
	{
		start_win->Update("Reading Video Sources");
	}
	ParseJSONCameras(json);
}

void	MyWin::ParseJSONCameras(cJSON *json)
{
	cJSON *mic = NULL;
	cJSON *mics = json_parse_array(json, "Cameras");
	if(mics != NULL)
	{
		cJSON_ArrayForEach(mic, mics)
		{
			ParseJSONCamera(mic);
		}
	}
}

void	MyWin::ParseJSONMicrophones(cJSON *json)
{
	cJSON *mic = NULL;
	cJSON *mics = json_parse_array(json, "Microphones");
	if(mics != NULL)
	{
		cJSON_ArrayForEach(mic, mics)
		{
			ParseJSONMicrophone(mic);
		}
	}
}

PulseAudioButton	*MyWin::ParseJSONMicrophone(cJSON *json)
{
	PulseAudioButton *out = NULL;
	if(json != NULL)
	{
		char *name = json_parse_string(json, "name");
		PulseAudioButton *b = AddAudioSource(0, strdup(name), strdup(name));
		out = b;
	}
	return(out);
}

void	MyWin::LoadJSONCamera(char *filename, Camera *cam)
{
	char *buf = ReadWholeFile(filename);
	if(buf != NULL)
	{
		cJSON *json = cJSON_Parse(buf);
		if(json == NULL)
		{
			const char *error_ptr = cJSON_GetErrorPtr();
			if(error_ptr != NULL)
			{
				fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
			}
		}
		else
		{
			ParseJSONCamera(json, cam);
			cJSON_Delete(json);
		}
		free(buf);
	}
	else
	{
		fprintf(stderr, "Error: Cannot read JSON file: %s\n", filename);
	}
}

Camera	*MyWin::ParseJSONCamera(cJSON *name, Camera *in_cam)
{
int	loop;

	Camera *out = NULL;
	if(name != NULL)
	{
		int width;
		int height;
		int font_sz;
		int immediate_cnt;
		int	color_it_cnt;
		int matrix_state_cnt;
		int trigger_cnt;
		int image_window_cnt;
		int filter_cnt;
		int filter_plugin_cnt;
		int bound_mic_cnt;
		int split_src_cnt;
		int recognize_object_cnt;

		int success = 0;
		char *path = json_parse_string(name, "path");
		char *original_path = json_parse_string(name, "original path");
		char *alias = json_parse_string(name, "alias");
		success = json_parse_int(name, "width", width);
		success = json_parse_int(name, "height", height);
		success = json_parse_int(name, "font sz", font_sz);
		char *use_path = original_path;
		if(use_path == NULL)
		{
			use_path = path;
		}
		Camera *cam = NULL;
		int cam_num = -1;
		if(in_cam == NULL)
		{
			cam_num = SetupCamera(use_path, alias, width, height, font_sz);
			cam = camera[cam_num];
		}
		else
		{
			cam = in_cam;
			if((width != cam->width) || (height != cam->height))
			{
				RemoveSource(cam->id);
				cam_num = SetupCamera(path, cam->alias, width, height, font_sz);
				cam = camera[cam_num];
			}
		}
		if(cam != NULL)
		{
			out = cam;
			success = json_parse_int(name, "triggers requested", cam->triggers_requested);
			success = json_parse_int(name, "requested x", cam->requested_x);
			success = json_parse_int(name, "requested y", cam->requested_y);
			success = json_parse_int(name, "requested w", cam->requested_w);
			success = json_parse_int(name, "requested h", cam->requested_h);
			success = json_parse_double(name, "darkness trigger", cam->darkness_trigger);
			success = json_parse_int(name, "grab interval", cam->grab_interval);
			success = json_parse_double(name, "capture interval", cam->capture_interval);
			success = json_parse_int(name, "cap fourcc", cam->cap_fourcc);
			success = json_parse_int(name, "cap format", cam->cap_format);
			success = json_parse_double(name, "zoom", cam->zoom);
			success = json_parse_int(name, "orig width", cam->orig_width);
			success = json_parse_int(name, "orig height", cam->orig_height);
			success = json_parse_int(name, "capture effects", cam->capture_effects);
			char *font_name = json_parse_string(name, "font name");
			if(font_name != NULL)
			{
				strcpy(cam->font_name, font_name);
			}
			success = json_parse_double(name, "capture scaling", cam->capture_scaling);
			success = json_parse_double(name, "fps", cam->fps);
			success = json_parse_int(name, "timer format", cam->timer_format);
			success = json_parse_int(name, "military clock", cam->military_clock);
			char *format_code = json_parse_string(name, "format code");
			if(format_code != NULL)
			{
				strcpy(cam->format_code, format_code);
			}
			char *extra_url = json_parse_string(name, "extra url");
			if(extra_url != NULL)
			{
				cam->extra_url = strdup(extra_url);
			}
			char *extra_css = json_parse_string(name, "extra css");
			if(extra_css != NULL)
			{
				cam->extra_css = strdup(extra_css);
			}
			char *extra_js_once = json_parse_string(name, "extra js once");
			if(extra_js_once != NULL)
			{
				cam->extra_js_once = strdup(extra_js_once);
			}
			char *extra_js_always = json_parse_string(name, "extra js always");
			if(extra_js_always != NULL)
			{
				cam->extra_js_always = strdup(extra_js_always);
			}
			success = json_parse_int(name, "chroma color", cam->chroma_color);
			success = json_parse_int(name, "crop start x", cam->crop_start_x);
			success = json_parse_int(name, "crop start y", cam->crop_start_y);
			success = json_parse_int(name, "use crop start", cam->use_crop_start);
			success = json_parse_int(name, "flip horizontal", cam->flip_horizontal);
			success = json_parse_int(name, "flip vertical", cam->flip_vertical);
			success = json_parse_double(name, "brightness", cam->brightness);
			success = json_parse_double(name, "saturation", cam->saturation);
			success = json_parse_double(name, "hue", cam->hue);
			success = json_parse_double(name, "intensity", cam->intensity);
			success = json_parse_double(name, "contrast", cam->contrast);
			success = json_parse_double(name, "red intensity", cam->red_intensity);
			success = json_parse_double(name, "green intensity", cam->green_intensity);
			success = json_parse_double(name, "blue intensity", cam->blue_intensity);
			success = json_parse_double(name, "alpha intensity", cam->alpha_intensity);
			success = json_parse_int(name, "motion threshold", cam->motion_threshold);
			success = json_parse_double(name, "recognition threshold", cam->recognition_threshold);
			success = json_parse_int(name, "recognize interval", cam->recognize_interval);
			success = json_parse_double(name, "forced aspect x", cam->forced_aspect_x);
			success = json_parse_double(name, "forced aspect y", cam->forced_aspect_y);
			success = json_parse_int(name, "zoom box display", cam->zoom_box_display);
			success = json_parse_int(name, "zoom box x", cam->zoom_box_x);
			success = json_parse_int(name, "zoom box y", cam->zoom_box_y);
			success = json_parse_int(name, "zoom box w", cam->zoom_box_w);
			success = json_parse_int(name, "zoom box h", cam->zoom_box_h);
			success = json_parse_int(name, "image sx", cam->image_sx);
			success = json_parse_int(name, "image sy", cam->image_sy);
			success = json_parse_double(name, "display width", cam->display_width);
			success = json_parse_double(name, "display height", cam->display_height);
			success = json_parse_int(name, "red", cam->red);
			success = json_parse_int(name, "green", cam->green);
			success = json_parse_int(name, "blue", cam->blue);
			success = json_parse_int(name, "alpha", cam->alpha);
			success = json_parse_int(name, "text red", cam->text_red);
			success = json_parse_int(name, "text green", cam->text_green);
			success = json_parse_int(name, "text blue", cam->text_blue);
			success = json_parse_int(name, "text alpha", cam->text_alpha);
			char *snapshot_filename_format = json_parse_string(name, "snapshot filename format");
			if(snapshot_filename_format != NULL)
			{
				strcpy(cam->snapshot_filename_format, snapshot_filename_format);
			}
			success = json_parse_int(name, "snapshot initial delay", cam->snapshot_initial_delay);
			success = json_parse_int(name, "snapshot repeat delay", cam->snapshot_repeat_delay);
			success = json_parse_int(name, "snapshot trigger condition", cam->snapshot_trigger_condition);
			success = json_parse_double(name, "snapshot scale", cam->snapshot_scale);
			success = json_parse_int(name, "snapshot", cam->snapshot);
			success = json_parse_int(name, "ptz lock interface", cam->ptz_lock_interface);
			success = json_parse_int(name, "ptz lock camera", cam->ptz_lock_camera);
			char *pseudo_camera_name = json_parse_string(name, "pseudo camera name");
			if(pseudo_camera_name != NULL)
			{
				strcpy(cam->pseudo_camera_name, pseudo_camera_name);
			}
			success = json_parse_int(name, "immediate cnt", immediate_cnt);
			if(immediate_cnt > 0)
			{
				cJSON *immediate = NULL;
				cJSON *immediates = json_parse_array(name, "Immediate");
				if(immediates != NULL)
				{
					int cnt = 0;
					cJSON_ArrayForEach(immediate, immediates)
					{
						if(cnt < 128)
						{
							Immediate *im_use = ParseJSONImmediate(immediate, cam);
							cam->AddImmediate(im_use);
							add(im_use);
							cnt++;
						}
					}
					cam->immediate_cnt = cnt;
				}
			}
			success = json_parse_int(name, "color it cnt", color_it_cnt);
			if(color_it_cnt > 0)
			{
				ParseJSONColorIt(name, cam);
				cam->color_it_cnt = color_it_cnt;
			}
			success = json_parse_int(name, "matrix state cnt", matrix_state_cnt);
			if(matrix_state_cnt > 0)
			{
				cJSON *matrix_state = NULL;
				cJSON *matrix_states = json_parse_array(name, "Matrix State");
				if(matrix_states != NULL)
				{
					int cnt = 0;
					cJSON_ArrayForEach(matrix_state, matrix_states)
					{
						if(cnt < 128)
						{
							MatrixState *ms = ParseJSONMatrixState(matrix_state);
							cam->matrix_state[cnt] = ms;
							cnt++;
						}
					}
					cam->matrix_state_cnt = cnt;
				}
			}
			success = json_parse_int(name, "trigger cnt", trigger_cnt);
			if(trigger_cnt > 0)
			{
				cJSON *trigger = NULL;
				cJSON *triggers = json_parse_array(name, "trigger");
				int cnt = 0;
				cJSON_ArrayForEach(trigger, triggers)
				{
					if(cnt < 128)
					{
						cam->trigger[cnt] = trigger->valueint;
						cnt++;
					}
					cam->trigger_cnt = cnt;
				}
			}
			success = json_parse_int(name, "image window cnt", image_window_cnt);
			if(image_window_cnt > 0)
			{
				cJSON *image_window = NULL;
				cJSON *image_windows = json_parse_array(name, "Image Window");
				if(image_windows != NULL)
				{
					int cnt = 0;
					cJSON_ArrayForEach(image_window, image_windows)
					{
						if(cnt < 128)
						{
							ImageWindow *iw = ParseJSONImageWindow(image_window, cam, cnt);
							if(iw != NULL)
							{
								cam->image_window[cnt] = iw;
								if(iw->buttonize == 0)
								{
									iw->show();
								}
								else
								{
									iw->hide();
								}
								add(iw);
								cnt++;
							}
						}
					}
				}
			}
			success = json_parse_int(name, "filter cnt", filter_cnt);
			if(filter_cnt > 0)
			{
				cJSON *filter = NULL;
				cJSON *filters = json_parse_array(name, "filter name");
				char *filter_name[128];
				int cnt = 0;
				cJSON_ArrayForEach(filter, filters)
				{
					if(cnt < 128)
					{
						if(filter->valuestring != NULL)
						{
							cam->filter_name[cnt] = strdup(filter->valuestring);
							cnt++;
						}
					}
				}
				cam->filter_cnt = cnt;
			}
			success = json_parse_int(name, "filter plugin cnt", filter_plugin_cnt);
			if(filter_plugin_cnt > 0)
			{
				cJSON *filter_plugin = NULL;
				cJSON *filter_plugins = json_parse_array(name, "filter plugin name");
				char *filter_plugin_name[128];
				int cnt = 0;
				cJSON_ArrayForEach(filter_plugin, filter_plugins)
				{
					if(cnt < 128)
					{
						if(filter_plugin->valuestring != NULL)
						{
							cam->filter_plugin_name[cnt] = strdup(filter_plugin->valuestring);
							cnt++;
						}
					}
				}
				cam->filter_plugin_cnt = cnt;
			}
			success = json_parse_int(name, "bound mic cnt", bound_mic_cnt);
			if(bound_mic_cnt > 0)
			{
				cJSON *bound_mic = NULL;
				cJSON *bound_mics = json_parse_array(name, "bound mic");
				int cnt = 0;
				cJSON_ArrayForEach(bound_mic, bound_mics)
				{
					if(cnt < 128)
					{
						if(bound_mic->valuestring != NULL)
						{
							cam->bound_mic[cnt] = strdup(bound_mic->valuestring);
							cnt++;
						}
					}
				}
				cam->bound_mic_cnt = cnt;
			}
			success = json_parse_int(name, "split source cnt", split_src_cnt);
			if(split_src_cnt > 0)
			{
				cJSON *split_src = NULL;
				cJSON *split_srcs = json_parse_array(name, "split source");
				int cnt = 0;
				cJSON_ArrayForEach(split_src, split_srcs)
				{
					if(cnt < 128)
					{
						if(split_src->valuestring != NULL)
						{
							cam->split_source[cnt] = strdup(split_src->valuestring);
							cnt++;
						}
					}
				}
				cam->split_source_cnt = cnt;
			}
			success = json_parse_int(name, "recognize object cnt", recognize_object_cnt);
			if(recognize_object_cnt > 0)
			{
				cJSON *object = NULL;
				cJSON *objects = json_parse_array(name, "recognize object");
				int cnt = 0;
				cJSON_ArrayForEach(object, objects)
				{
					if(object->valuestring != NULL)
					{
						for(loop = 0;loop < recognize_class_cnt;loop++)
						{
							if(strcasecmp(object->valuestring, recognize_class_name[loop]) == 0)
							{
								cam->object_index[loop] = 1;
							}
						}
					}
				}
			}
		}
	}
	return(out);
}

Immediate	*MyWin::ParseJSONImmediate(cJSON *immediate, Camera *cam)
{
int im_type;
int immediate_type;
int sx;
int sy;
int sw;
int sh;

	Immediate *out = NULL;
	int success = json_parse_int(immediate, "im type", im_type);
	success = json_parse_int(immediate, "immediate_type", immediate_type);
	success = json_parse_int(immediate, "sx", sx);
	success = json_parse_int(immediate, "sy", sy);
	success = json_parse_int(immediate, "sw", sw);
	success = json_parse_int(immediate, "sh", sh);

	ImmediateDrawingWindow *idw = immediate_drawing_window;
	Immediate *im = new Immediate(this, cam, sx, sy, sw, sh);
	out = im;

	im->idw = idw;
	ImDefault *def = NULL;
	if(im_type == IM_RECTANGLE)
	{
		im->rectangle = new ImRectangle(this, im, sx, sy, sw, sh);
		im->add(im->rectangle);
		def = (ImDefault *)im->rectangle;
	}
	else if(im_type == IM_PIXELATE)
	{
		im->pixelate = new ImPixelate(this, im, sx, sy, sw, sh);
		im->add(im->pixelate);
		def = (ImDefault *)im->pixelate;
	}
	else if(im_type == IM_RECTANGLE_PASSTHRU)
	{
		im->rectangle_passthru = new ImRectanglePassThru(this, im, sx, sy, sw, sh);
		im->add(im->rectangle_passthru);
		def = (ImDefault *)im->pixelate;
	}
	else if(im_type == IM_IMAGE)
	{
		im->image_im = new ImImage(this, im, sx, sy, sw, sh);
		im->add(im->image_im);
		def = (ImDefault *)im->image_im;
	}
	else if(im_type == IM_ELLIPSE)
	{
		im->ellipse = new ImEllipse(this, im, sx, sy, sw, sh);
		im->add(im->ellipse);
		def = (ImDefault *)im->ellipse;
	}
	else if(im_type == IM_ELLIPSE_PASSTHRU)
	{
		im->ellipse_passthru = new ImEllipsePassThru(this, im, sx, sy, sw, sh);
		im->add(im->ellipse_passthru);
		def = (ImDefault *)im->ellipse_passthru;
	}
	else if(im_type == IM_FREEHAND)
	{
		im->freehand = new ImFreehand(this, im, sx, sy, sw, sh);
		im->add(im->freehand);
		def = (ImDefault *)im->freehand;
	}
	else if(im_type == IM_LINE)
	{
		im->line = new ImLine(this, im, immediate_type, sx, sy, sw, sh);
		im->add(im->line);
		def = (ImDefault *)im->line;
	}
	else if(im_type == IM_TEXT)
	{
		im->text = new ImText(this, im, sx, sy, sw, sh);
		im->add(im->text);
		def = (ImDefault *)im->text;
	}
	success = json_parse_int(immediate, "draw it", im->draw_it);
	success = json_parse_int(immediate, "immediate type", im->immediate_type);
	success = json_parse_int(immediate, "initial x", im->initial_x);
	success = json_parse_int(immediate, "initial y", im->initial_y);
	success = json_parse_int(immediate, "layer", im->layer);
	success = json_parse_int(immediate, "crop x", im->crop_x);
	success = json_parse_int(immediate, "crop y", im->crop_y);
	success = json_parse_int(immediate, "crop w", im->crop_w);
	success = json_parse_int(immediate, "crop h", im->crop_h);
	success = json_parse_double(immediate, "overall alpha", im->overall_alpha);
	success = json_parse_int(immediate, "use as mask", im->use_as_mask);
	if(im->text != NULL)
	{
		char *text_value = json_parse_string(immediate, "text value");
		if(text_value != NULL)
		{
			im->text->value(text_value);
		}
	}
	int anim_cnt = 0;
	cJSON *anim = NULL;
	cJSON *anims = json_parse_array(immediate, "Anim");
	if(anims != NULL)
	{
		cJSON_ArrayForEach(anim, anims)
		{
			if(anim_cnt < 1024)
			{
				im->anim[anim_cnt] = new ImAnim();
				success = json_parse_int(anim, "frame", im->anim[anim_cnt]->frame);
				success = json_parse_double(anim, "xx", im->anim[anim_cnt]->xx);
				success = json_parse_double(anim, "yy", im->anim[anim_cnt]->yy);
				success = json_parse_double(anim, "ww", im->anim[anim_cnt]->ww);
				success = json_parse_double(anim, "hh", im->anim[anim_cnt]->hh);
				success = json_parse_double(anim, "angle", im->anim[anim_cnt]->angle);
				success = json_parse_double(anim, "red", im->anim[anim_cnt]->red);
				success = json_parse_double(anim, "green", im->anim[anim_cnt]->green);
				success = json_parse_double(anim, "blue", im->anim[anim_cnt]->blue);
				success = json_parse_double(anim, "alpha", im->anim[anim_cnt]->alpha);
				anim_cnt++;
			}
		}
	}
	im->anim_cnt = anim_cnt;
	if(def != NULL)
	{
		char *text_font_name = json_parse_string(immediate, "text font name");
		if(text_font_name != NULL)
		{
			strcpy(def->font_name, text_font_name);
		}
		char *image_file_path = json_parse_string(immediate, "image file path");
		if(image_file_path != NULL)
		{
			strcpy(def->image_file_path, image_file_path);
		}
		char *freehand_filename = json_parse_string(immediate, "freehand filename");
		if(freehand_filename != NULL)
		{
			strcpy(def->freehand_filename, freehand_filename);
		}
		success = json_parse_int(immediate, "width", def->width);
		success = json_parse_int(immediate, "red", def->red);
		success = json_parse_int(immediate, "green", def->green);
		success = json_parse_int(immediate, "blue", def->blue);
		success = json_parse_int(immediate, "alpha", def->alpha);
		success = json_parse_int(immediate, "style", def->style);
		success = json_parse_int(immediate, "shape", def->shape);
		success = json_parse_int(immediate, "use size", def->use_size);
		success = json_parse_int(immediate, "filled", def->filled);
		success = json_parse_int(immediate, "square", def->square);
		success = json_parse_int(immediate, "box type", def->box_type);
		success = json_parse_int(immediate, "point cnt", def->cnt);

		im->anim_red = def->red;
		im->anim_green = def->green;
		im->anim_blue = def->blue;
		im->anim_alpha = def->alpha;

		cJSON *point = NULL;
		cJSON *points = json_parse_array(immediate, "Point");
		if(points != NULL)
		{
			int pt_cnt = 0;
			def->xx = (int *)malloc(sizeof(int) * def->cnt);
			def->yy = (int *)malloc(sizeof(int) * def->cnt);
			def->pt_type = (int *)malloc(sizeof(int) * def->cnt);
			cJSON_ArrayForEach(point, points)
			{
				if(pt_cnt < 128)
				{
					success = json_parse_int(point, "xx", def->xx[pt_cnt]);
					success = json_parse_int(point, "yy", def->yy[pt_cnt]);
					success = json_parse_int(point, "pt type", def->pt_type[pt_cnt]);
					pt_cnt++;
				}
			}
		}
		int key;
		success = json_parse_int(immediate, "key", key);
		def->key = (char)key;
		success = json_parse_int(immediate, "italic", def->italic);
		success = json_parse_int(immediate, "bold", def->bold);
		success = json_parse_int(immediate, "outline", def->outline);
		success = json_parse_int(immediate, "font alpha", def->font_alpha);
		success = json_parse_int(immediate, "background red", def->background_red);
		success = json_parse_int(immediate, "background green", def->background_green);
		success = json_parse_int(immediate, "background blue", def->background_blue);
		success = json_parse_int(immediate, "background alpha", def->background_alpha);
		success = json_parse_int(immediate, "outline alpha", def->outline_alpha);
	}
	return(out);
}

void	MyWin::ParseJSONColorIt(cJSON *name, Camera *cam)
{
	cJSON *color_it = NULL;
	cJSON *color_its = json_parse_array(name, "color it r");
	int cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_r[cnt] = color_it->valueint;
			cnt++;
		}
	}
	color_it = NULL;
	color_its = json_parse_array(name, "color it g");
	cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_g[cnt] = color_it->valueint;
			cnt++;
		}
	}
	color_it = NULL;
	color_its = json_parse_array(name, "color it b");
	cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_b[cnt] = color_it->valueint;
			cnt++;
		}
	}
	color_it = NULL;
	color_its = json_parse_array(name, "color it tolerance r");
	cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_tolerance_r[cnt] = color_it->valueint;
			cnt++;
		}
	}
	color_it = NULL;
	color_its = json_parse_array(name, "color it tolerance g");
	cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_tolerance_g[cnt] = color_it->valueint;
			cnt++;
		}
	}
	color_it = NULL;
	color_its = json_parse_array(name, "color it tolerance b");
	cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_tolerance_b[cnt] = color_it->valueint;
			cnt++;
		}
	}
	color_it = NULL;
	color_its = json_parse_array(name, "color it replace r");
	cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_replace_r[cnt] = color_it->valueint;
			cnt++;
		}
	}
	color_it = NULL;
	color_its = json_parse_array(name, "color it replace g");
	cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_replace_g[cnt] = color_it->valueint;
			cnt++;
		}
	}
	color_it = NULL;
	color_its = json_parse_array(name, "color it replace b");
	cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_replace_b[cnt] = color_it->valueint;
			cnt++;
		}
	}
	color_it = NULL;
	color_its = json_parse_array(name, "color it replace a");
	cnt = 0;
	cJSON_ArrayForEach(color_it, color_its)
	{
		if(cnt < 128)
		{
			cam->color_it_replace_a[cnt] = color_it->valueint;
			cnt++;
		}
	}
}

MatrixState	*MyWin::ParseJSONMatrixState(cJSON *matrix_state)
{
	MatrixState *ms = new MatrixState();
	char *name = json_parse_string(matrix_state, "name");
	if(name != NULL)
	{
		strcpy(ms->name, name);
	}
	int success = json_parse_int(matrix_state, "type", ms->type);
	success = json_parse_int(matrix_state, "command", ms->command);
	success = json_parse_int(matrix_state, "frames", ms->frames);
	success = json_parse_double(matrix_state, "start x", ms->start_x);
	success = json_parse_double(matrix_state, "start y", ms->start_y);
	success = json_parse_double(matrix_state, "start z", ms->start_z);
	success = json_parse_double(matrix_state, "end x", ms->end_x);
	success = json_parse_double(matrix_state, "end y", ms->end_y);
	success = json_parse_double(matrix_state, "end z", ms->end_z);
	return(ms);
}

ImageWindow	*MyWin::ParseJSONImageWindow(cJSON *image_window, Camera *cam, int cnt)
{
	ImageWindow *out = NULL;
	char *source_path = json_parse_string(image_window, "source path");
	char *source_orig_path = json_parse_string(image_window, "source orig path");
	if(source_path != NULL)
	{
		Camera *source_cam = FindCameraByPath(source_path);
		if(source_cam == NULL)
		{
			char use_path[4096];
			strcpy(use_path, source_path);
			if(strlen(source_orig_path) > 0)
			{
				strcpy(use_path, source_orig_path);
			}
			int cam_num = SetupCamera(use_path, NULL, requested_w, requested_h, 32);
			if(cam_num > -1)
			{
				source_cam = camera[cam_num];
			}
			else
			{
				SetErrorMessage("Cannot Open Camera");
			}
		}
		if(source_cam != NULL)
		{
			double dx;
			double dy;
			double dw;
			double dh;

			int success = json_parse_double(image_window, "dx", dx);
			success = json_parse_double(image_window, "dy", dy);
			success = json_parse_double(image_window, "dw", dw);
			success = json_parse_double(image_window, "dh", dh);
			ImageWindow *iw = new ImageWindow(cnt, this, source_cam, cam, dx, dy, dw, dh);
			out = iw;
			iw->camera = source_cam;
			iw->dest_camera = cam;

			success = json_parse_int(image_window, "layer", iw->layer);
			success = json_parse_int(image_window, "transform", iw->transform);
			success = json_parse_double(image_window, "width", iw->width);
			success = json_parse_double(image_window, "height", iw->height);
			success = json_parse_double(image_window, "orig w", iw->orig_w);
			success = json_parse_double(image_window, "orig h", iw->orig_h);
			success = json_parse_int(image_window, "buttonize", iw->buttonize);
			success = json_parse_int(image_window, "buttonized x", iw->buttonized_x);
			success = json_parse_int(image_window, "buttonized y", iw->buttonized_y);
			success = json_parse_int(image_window, "buttonized w", iw->buttonized_w);
			success = json_parse_int(image_window, "buttonized h", iw->buttonized_h);
			success = json_parse_int(image_window, "crop x", iw->crop_x);
			success = json_parse_int(image_window, "crop y", iw->crop_y);
			success = json_parse_int(image_window, "crop w", iw->crop_w);
			success = json_parse_int(image_window, "crop h", iw->crop_h);
			success = json_parse_int(image_window, "trim x", iw->trim_x);
			success = json_parse_int(image_window, "trim y", iw->trim_y);
			success = json_parse_double(image_window, "overall alpha", iw->overall_alpha);
			success = json_parse_int(image_window, "use as mask", iw->use_as_mask);
			success = json_parse_double(image_window, "angle", iw->angle);
			success = json_parse_int(image_window, "frame", iw->frame);
			success = json_parse_int(image_window, "flip horizontal", iw->flip_horizontal);
			success = json_parse_int(image_window, "flip vertical", iw->flip_vertical);
		}
	}
	return(out);
}


void	MyWin::Shutdown()
{
int	loop;
int	aa, ab, ac;
void	my_window_cb(void *v);
void	sliding_element_close_cb(void *v);

	Fl::remove_timeout(sliding_element_close_cb);
	Fl::remove_timeout(my_window_cb);
	ndi_streaming = 0;
	ndi_initialized = 0;
	if(ptz_mode == 1)
	{
		ViscaCommand(0, VISCA_QUIT);
	}
	if(ndi_send != NULL)
	{
		if(NDILib != NULL)
		{
			pthread_mutex_lock(&ndi_send_mutex);
			NDILib->NDIlib_send_destroy(ndi_send);
			pthread_mutex_unlock(&ndi_send_mutex);
		}
		ndi_send = NULL;
	}
	if(audio_library_window != NULL)
	{
		audio_library_window->hide();
		delete audio_library_window;
		audio_library_window = NULL;
	}
	if(audio_library_list != NULL)
	{
		audio_library_list->hide();
		delete audio_library_list;
		audio_library_list = NULL;
	}
	if(monitor_window != NULL)
	{
		monitor_window->hide();
		delete monitor_window;
		monitor_window = NULL;
	}
	if(select_output_window != NULL)
	{
		select_output_window->hide();
		delete select_output_window;
		select_output_window = NULL;
	}
	if(edit_output_window != NULL)
	{
		edit_output_window->hide();
		delete edit_output_window;
		edit_output_window = NULL;
	}
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			Fl::delete_widget(immediate_list[loop]);
		}
	}
	for(loop = 0;loop < guideline_cnt;loop++)
	{
		if(guideline[loop] != NULL)
		{
			delete guideline[loop];
			guideline[loop] = NULL;
		}
	}
	guideline_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		if(output_name[loop] != NULL)
		{
			free(output_name[loop]);
			output_name[loop] = NULL;
		}
		if(output_path[loop] != NULL)
		{
			free(output_path[loop]);
			output_path[loop] = NULL;
		}
	}
	output_path_cnt = 0;
	for(loop = 0;loop < 64;loop++)
	{
		if(last_muxed_list[loop] != NULL)
		{
			free(last_muxed_list[loop]);
			last_muxed_list[loop] = NULL;
		}
	}
	if(pulse_mixer != NULL)
	{
		pulse_mixer->done = 1;
		usleep(1000000);
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(audio_thumbnail[loop] != NULL)
		{
			audio_thumbnail[loop]->hide();
			audio_thumbnail[loop] = NULL;
		}
	}
	if(codec_selection_window != NULL)
	{
		codec_selection_window->hide();
		delete codec_selection_window;
		codec_selection_window = NULL;
	}
	if(ptz_mode == 1)
	{
		for(loop = 0;loop < ptz_device_cnt;loop++)
		{
			VISCA_close(&iface[loop]);
		}
	}
	int have_audio = 0;
	if(pulse_mixer != NULL)
	{
		pulse_mixer->Stop();
	}
	if(pulse_mixer != NULL)
	{
		if(pulse_mixer->done != -1)
		{
			pulse_mixer->done = 1;
			int cnt = 0;
			while((pulse_mixer->done == 1) && (cnt < 1000))
			{
				usleep(10000);
				cnt++;
			}
		}
		delete pulse_mixer;
		pulse_mixer = NULL;
	}
	ClearMuxerArray();
	muxer_cnt = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			if(cam->fd > -1)
			{
				close(cam->fd);
			}
		}
	}
	for(loop = 0;loop < recognize_class_cnt;loop++)
	{
		if(recognize_class_name[loop] != NULL)
		{
			free(recognize_class_name[loop]);
			recognize_class_name[loop] = NULL;
		}
	}
	recognize_class_cnt = 0;
	for(loop = 0;loop < 3;loop++)
	{
		Fl_Pack *pack = audio_thumbnail_pack[loop];
		if(pack != NULL)
		{
			pack->clear();
		}
	}
	audio_thumbnail_cnt = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		if(camera[loop] != NULL)
		{
			delete camera[loop];
			camera[loop] = NULL;
		}
	}
	SaveAllPTZPositions();
	if(record_all == 1)
	{
		if(all_fd > -1)
		{
			SetCodec();
			close(all_fd);
			double fps = 25.0;
			int total_time = (int)(time(0) - record_all_start);
			if(total_time > 0)
			{
				fps = (double)record_all_cnt / (double)total_time;
			}
			char out_filename[4096];
			sprintf(out_filename, "global.%s", use_extension);
			Muxer *use_muxer = new Muxer(this, NULL, 1);
			int mux_err = use_muxer->InitMux(audio, use_video_codec, use_audio_codec, "global.bin", NULL, out_filename, NULL, desktop_monitor, pulse_mixer, -1, original_w, original_h, fps, audio_sample_rate, audio_channels, -1, NULL, NULL);
			if(mux_err == 0)
			{
				AddLastMuxed(out_filename);
			}
			else
			{
				SetErrorMessage("Encoding Error: Not recording.");
			}
			delete use_muxer;
		}
	}
	ClearCameraCaps();
}

void	MyWin::PartialShutdown()
{
int	loop;
int	aa, ab, ac;

	Fl::remove_timeout(my_window_cb);
	ndi_streaming = 0;
	ndi_initialized = 0;
	if(ptz_mode == 1)
	{
		ViscaCommand(0, VISCA_QUIT);
	}
	if(ndi_send != NULL)
	{
		if(NDILib != NULL)
		{
			pthread_mutex_lock(&ndi_send_mutex);
			NDILib->NDIlib_send_destroy(ndi_send);
			pthread_mutex_unlock(&ndi_send_mutex);
		}
		ndi_send = NULL;
	}
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			Fl::delete_widget(immediate_list[loop]);
		}
	}
	for(loop = 0;loop < guideline_cnt;loop++)
	{
		if(guideline[loop] != NULL)
		{
			delete guideline[loop];
			guideline[loop] = NULL;
		}
	}
	guideline_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		if(output_name[loop] != NULL)
		{
			free(output_name[loop]);
			output_name[loop] = NULL;
		}
		if(output_path[loop] != NULL)
		{
			free(output_path[loop]);
			output_path[loop] = NULL;
		}
	}
	output_path_cnt = 0;
	for(loop = 0;loop < 64;loop++)
	{
		if(last_muxed_list[loop] != NULL)
		{
			free(last_muxed_list[loop]);
			last_muxed_list[loop] = NULL;
		}
	}
	if(pulse_mixer != NULL)
	{
		pulse_mixer->done = 1;
		usleep(1000000);
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(audio_thumbnail[loop] != NULL)
		{
			audio_thumbnail[loop]->hide();
			audio_thumbnail[loop] = NULL;
		}
	}
	for(loop = 0;loop < ptz_device_cnt;loop++)
	{
		VISCA_close(&iface[loop]);
	}
	int have_audio = 0;
	if(pulse_mixer != NULL)
	{
		pulse_mixer->Stop();
	}
	if(pulse_mixer != NULL)
	{
		if(pulse_mixer->done != -1)
		{
			pulse_mixer->done = 1;
			int cnt = 0;
			while((pulse_mixer->done == 1) && (cnt < 1000))
			{
				usleep(10000);
				cnt++;
			}
		}
		delete pulse_mixer;
		pulse_mixer = NULL;
	}
	ClearMuxerArray();
	muxer_cnt = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			if(cam->fd > -1)
			{
				close(cam->fd);
			}
		}
	}
	for(loop = 0;loop < recognize_class_cnt;loop++)
	{
		if(recognize_class_name[loop] != NULL)
		{
			free(recognize_class_name[loop]);
			recognize_class_name[loop] = NULL;
		}
	}
	recognize_class_cnt = 0;
	for(loop = 0;loop < 3;loop++)
	{
		Fl_Pack *pack = audio_thumbnail_pack[loop];
		if(pack != NULL)
		{
			pack->clear();
		}
	}
	audio_thumbnail_cnt = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		if(camera[loop] != NULL)
		{
			delete camera[loop];
			camera[loop] = NULL;
		}
	}
	ClearCameraCaps();
}

void	MyWin::ResetAudio()
{
int	loop;

	if(pulse_mixer != NULL)
	{
		pulse_mixer->done = 1;
		usleep(100000);
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(audio_thumbnail[loop] != NULL)
		{
			audio_thumbnail[loop]->hide();
			remove(audio_thumbnail[loop]);
			Fl::delete_widget(audio_thumbnail[loop]);
			audio_thumbnail[loop] = NULL;
		}
	}
	if(pulse_mixer != NULL)
	{
		pulse_mixer->Stop();
	}
	if(pulse_mixer != NULL)
	{
		if(pulse_mixer->done != -1)
		{
			pulse_mixer->done = 1;
			int cnt = 0;
			while((pulse_mixer->done == 1) && (cnt < 1000))
			{
				usleep(10000);
				cnt++;
			}
		}
		delete pulse_mixer;
		pulse_mixer = NULL;
	}
	pulse_microphone_cnt = 0;
	if(no_audio_scan == 0)
	{
		ScanPulse(0);
	}
	else
	{
		OpenNamedPulse();
	}
}

void	MyWin::SaveTransition()
{
	FILE *fp = fopen("transition.ini", "w");
	if(fp != NULL)
	{
		if(transition == TRANSITION_NONE)
		{
			fprintf(fp, "NONE\n");
		}
		else if(transition == TRANSITION_BLEND)
		{
			fprintf(fp, "BLEND\n");
		}
		else if(transition == TRANSITION_FADE_TO_BLACK)
		{
			fprintf(fp, "FADE TO BLACK\n");
		}
		else if(transition == TRANSITION_L2R_WIPE)
		{
			fprintf(fp, "L2R WIPE\n");
		}
		else if(transition == TRANSITION_R2L_WIPE)
		{
			fprintf(fp, "R2L WIPE\n");
		}
		else if(transition == TRANSITION_T2B_WIPE)
		{
			fprintf(fp, "T2B WIPE\n");
		}
		else if(transition == TRANSITION_B2T_WIPE)
		{
			fprintf(fp, "B2T WIPE\n");
		}
		else if(transition == TRANSITION_PLUGIN)
		{
			fprintf(fp, "%s\n", transition_plugin);
		}
		fclose(fp);
	}
}

void	MyWin::LoadTransition()
{
char	buf[256];

	FILE *fp = fopen("transition.ini", "r");
	if(fp != NULL)
	{
		strcpy(buf, "");
		fgets(buf, 255, fp);
		strip_lf(buf);
		if(strcmp(buf, "NONE") == 0)
		{
			transition = TRANSITION_NONE;
		}
		else if(strcmp(buf, "BLEND") == 0)
		{
			transition = TRANSITION_BLEND;
		}
		else if(strcmp(buf, "FADE TO BLACK") == 0)
		{
			transition = TRANSITION_FADE_TO_BLACK;
		}
		else if(strcmp(buf, "L2R WIPE") == 0)
		{
			transition = TRANSITION_L2R_WIPE;
		}
		else if(strcmp(buf, "R2L WIPE") == 0)
		{
			transition = TRANSITION_R2L_WIPE;
		}
		else if(strcmp(buf, "T2B WIPE") == 0)
		{
			transition = TRANSITION_T2B_WIPE;
		}
		else if(strcmp(buf, "B2T WIPE") == 0)
		{
			transition = TRANSITION_B2T_WIPE;
		}
		else
		{
			transition = TRANSITION_PLUGIN;
			strcpy(transition_plugin, buf);
			LoadPluginTransition(buf);
		}
		fclose(fp);
	}
}

void	MyWin::SaveCodecs()
{
	FILE *fp = fopen("codec.ini", "w");
	if(fp != NULL)
	{
		fprintf(fp, "%s\n", use_container);
		fprintf(fp, "%s\n", use_extension);
		fprintf(fp, "%d\n", use_video_codec);
		fprintf(fp, "%d\n", use_audio_codec);
		fclose(fp);
	}
}

void	MyWin::LoadCodecs()
{
	FILE *fp = fopen("codec.ini", "r");
	if(fp != NULL)
	{
		fscanf(fp, "%s\n", use_container);
		fscanf(fp, "%s\n", use_extension);
		fscanf(fp, "%d\n", (int *)&use_video_codec);
		fscanf(fp, "%d\n", (int *)&use_audio_codec);
		fclose(fp);
	}
}

void	MyWin::SaveAllPTZPositions()
{
int	loop;
int	aa, ab, ac;

	FILE *fp = fopen("ptz_positions.json", "w");
	if(fp != NULL)
	{
		int nn = 0;
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				for(aa = 0;aa < NUMBER_OF_INTERFACES;aa++)
				{
					for(ab = 0;ab < NUMBER_OF_CAMERAS;ab++)
					{
						for(ac = 0;ac < NUMBER_OF_PRESETS;ac++)
						{
							if(ptz_window[loop]->ptz_position[aa][ab][ac] != NULL)
							{
								nn++;
							}
						}
					}
				}
			}
		}
		fprintf(fp, "{\n");
		fprintf(fp, "\t\"ptz positions\": [\n");
		int cnt = 0;
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				for(aa = 0;aa < NUMBER_OF_INTERFACES;aa++)
				{
					for(ab = 0;ab < NUMBER_OF_CAMERAS;ab++)
					{
						for(ac = 0;ac < NUMBER_OF_PRESETS;ac++)
						{
							if(ptz_window[loop]->ptz_position[aa][ab][ac] != NULL)
							{
								ptz_window[loop]->ptz_position[aa][ab][ac]->Save(fp);
								if(cnt < (nn - 1))
								{
									fprintf(fp, ",\n");
								}
								else
								{
									fprintf(fp, "\n");
								}
							}
							cnt++;
						}
					}
				}
			}
		}
		fprintf(fp, "\t]\n");
		fprintf(fp, "}\n");
		fclose(fp);
	}
}

void	MyWin::LoadAllPTZPositions()
{
	char *buf = ReadWholeFile("ptz_positions.json");
	if(buf != NULL)
	{
		cJSON *json = cJSON_Parse(buf);
		if(json == NULL)
		{
			const char *error_ptr = cJSON_GetErrorPtr();
			if(error_ptr != NULL)
			{
				fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
			}
		}
		else
		{
			int win_n = 0;
			int aa = 0;
			int ab = 0;
			int ac = 0;
			cJSON *outer = NULL;
			cJSON *outers = json_parse_array(json, "ptz positions");
			cJSON_ArrayForEach(outer, outers)
			{
				if(ptz_window[win_n] != NULL)
				{
					if(ptz_window[win_n]->ptz_position[aa][ab][ac] != NULL)
					{
						int success = json_parse_int(outer, "set", ptz_window[win_n]->ptz_position[aa][ab][ac]->set);
						success = json_parse_int(outer, "pan", ptz_window[win_n]->ptz_position[aa][ab][ac]->pan);
						success = json_parse_int(outer, "tilt", ptz_window[win_n]->ptz_position[aa][ab][ac]->tilt);
						success = json_parse_int(outer, "zoom", ptz_window[win_n]->ptz_position[aa][ab][ac]->zoom);
						success = json_parse_int(outer, "focus", ptz_window[win_n]->ptz_position[aa][ab][ac]->focus);
					}
				}
				ac++;
				if(ac >= NUMBER_OF_PRESETS)
				{
					ac = 0;
					ab++;
					if(ab >= NUMBER_OF_CAMERAS)
					{
						ab = 0;
						aa++;
						if(aa >= NUMBER_OF_INTERFACES)
						{
							aa = 0;
							win_n++;
							if(win_n >= PTZ_WINDOW_LIMIT)
							{
							}
						}
					}
				}
			}
			cJSON_Delete(json);
		}
		free(buf);
	}
}

void	MyWin::LoadOutputPathList(char *filename)
{
char	buf[4096];
int		loop;

	int cnt = 0;
	FILE *fp = fopen(filename, "r");
	if(fp != NULL)
	{
		while(fgets(buf, 4096, fp) != NULL)
		{
			strip_lf(buf);
			if(buf[0] == '*')
			{
				output_active[cnt] = 1;
			}
			char *cp = buf;
			while((*cp != '[') && (*cp != '\0'))
			{
				cp++;
			}
			if(*cp == '[')
			{
				cp++;
				output_name[cnt] = strdup(cp);
				char *cp2 = output_name[cnt];
				while((*cp2 != ']') && (*cp2 != '\0'))
				{
					cp2++;
				}
				*cp2 = '\0';
				while((*cp != ']') && (*cp != '\0'))
				{
					cp++;
				}
				if(*cp == ']')
				{
					*cp = '\0';
					cp++;
					output_path[cnt] = strdup(cp);
					cnt++;
				}
			}
		}
		fclose(fp);
	}
	output_path_cnt = cnt;
}

void	MyWin::SaveOutputPathList(char *filename)
{
int	loop;

	FILE *fp = fopen(filename, "w");
	if(fp != NULL)
	{
		for(loop = 0;loop < output_path_cnt;loop++)
		{
			char cc = ' ';
			if(output_active[loop] == 1)
			{
				cc = '*';
			}
			fprintf(fp, "%c[%s]%s\n", cc, output_name[loop], output_path[loop]);
		}
		fclose(fp);
	}
}

void	set_output_select_cb(Fl_Widget *w, void *v)
{
int	loop;

	EditOutputWindow *win = (EditOutputWindow *)v;
	win->NDI_Exclusive(w);
	win->redraw();
}

void	set_output_accept_cb(Fl_Widget *w, void *v)
{
	EditOutputWindow *win = (EditOutputWindow *)v;
	win->Debrief();
	win->my_window->SaveOutputPathList("outputs.txt");
	win->hide();
	reset_button_cb(NULL, win->my_window);
}

void	set_output_cancel_cb(Fl_Widget *w, void *v)
{
	EditOutputWindow *win = (EditOutputWindow *)v;
	win->hide();
	win->Populate();
}

void	set_output_rescan_cb(Fl_Widget *w, void *v)
{
	EditOutputWindow *win = (EditOutputWindow *)v;
	MyWin *my_win = win->my_window;
	Fl_Input *in = (Fl_Input *)w;
	char *val = (char *)in->value();
	if(strlen(val) < 1)
	{
		in->parent()->hide();
	}
	else
	{
		char out[4096];
		int	streaming = interpret_output_path(my_win, val, out, NULL);
		if(streaming == STREAMING_NET)
		{
			in->color(DARK_RED);
			in->copy_label("URL:");
		}
		else if(streaming == STREAMING_NDI)
		{
			in->color(DARK_BLUE);
			in->copy_label("NDI:");
		}
		else
		{
			in->copy_label("File:");
		}
		in->redraw();
		in->parent()->redraw();
	}
}

void	set_output_add_cb(Fl_Widget *w, void *v)
{
	EditOutputWindow *win = (EditOutputWindow *)v;
	int num = win->pack->children();
	int y_pos = 5 + (num * 22);
	MyGroup *grp = new MyGroup(0, y_pos, win->w(), 20);
	grp->box(FL_FLAT_BOX);
	grp->color(BLACK);
		win->button[num] = new MyLightButton(15, y_pos, 20, 20);
		win->button[num]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		win->button[num]->box(FL_FLAT_BOX);
		win->button[num]->color(BLACK);
		win->button[num]->down_color(YELLOW);
		win->button[num]->labelcolor(YELLOW);
		win->button[num]->value(0);

		win->name[num] = new Fl_Input(60, y_pos, 120, 20);
		win->name[num]->color(BLACK);
		win->name[num]->textcolor(WHITE);
		win->name[num]->textsize(11);
		win->name[num]->cursor_color(WHITE);
		win->name[num]->labelcolor(YELLOW);
		win->name[num]->labelsize(9);
		win->name[num]->box(FL_FRAME_BOX);

		win->preset[num] = new Fl_Input(181, y_pos, 520, 20);
		win->preset[num]->color(BLACK);
		win->preset[num]->textcolor(WHITE);
		win->preset[num]->textsize(11);
		win->preset[num]->cursor_color(WHITE);
		win->preset[num]->labelcolor(YELLOW);
		win->preset[num]->labelsize(9);
		win->preset[num]->box(FL_FRAME_BOX);
		win->preset[num]->callback(set_output_rescan_cb, win);
	grp->end();
	win->pack->add(grp);
	win->redraw();
}

void	MyWin::ClearMuxerArray()
{
int	loop;

	pthread_mutex_lock(&muxer_mutex);
	for(loop = 0;loop < 128;loop++)
	{
		if(my_muxer[loop] != NULL)
		{
			my_muxer[loop]->Pause();
			my_muxer[loop]->Stop();
			my_muxer[loop]->FinishMux();
			delete my_muxer[loop];
			my_muxer[loop] = NULL;
		}
	}
	pthread_mutex_unlock(&muxer_mutex);
	reset_button_cb(NULL, this);
}

void	MyWin::FlushMuxerArray()
{
int	loop;

	reset_button_cb(NULL, this);
	pthread_mutex_lock(&muxer_mutex);
	for(loop = 0;loop < 128;loop++)
	{
		if(my_muxer[loop] != NULL)
		{
			my_muxer[loop]->Pause();
			my_muxer[loop]->Stop();
			my_muxer[loop]->Flush();
		}
	}
	pthread_mutex_unlock(&muxer_mutex);
}

void	MyWin::BuildEditOutputWindow()
{
	edit_output_window = new EditOutputWindow(this, 400, 240, 720, 530);
	edit_output_window->hide();
	edit_output_window->set_non_modal();
}

void	MyWin::BuildSelectOutputWindow()
{
	select_output_window = new SelectOutputWindow(this, 400, 240, 130, 40);
	select_output_window->hide();
	select_output_window->set_non_modal();
}

void	MyWin::ReadInExternalPrograms()
{
int	loop;

	FILE *fp = fopen("external_programs.txt", "r");
	if(fp != NULL)
	{
		char buf[4096];
		char *path[10];
		int width[10];
		int height[10];
		char *arg[10][10];
		int entry = -1;
		int arg_cnt = 0;
		int inner;
		while((fgets(buf, 4096, fp) != NULL) && (entry < 9))
		{
			strip_lf(buf);
			if(strncasecmp(buf, "PATH=", strlen("PATH=")) == 0)
			{
				entry++;
				arg_cnt = 0;
				for(inner = 0;inner < 10;inner++)
				{
					arg[entry][inner] = NULL;
				}
				char *cp = buf + strlen("PATH=");
				path[entry] = strdup(cp);
			}
			if(strncasecmp(buf, "WIDTH=", strlen("WIDTH=")) == 0)
			{
				char *cp = buf + strlen("WIDTH=");
				width[entry] = atoi(cp);;
			}
			if(strncasecmp(buf, "HEIGHT=", strlen("HEIGHT=")) == 0)
			{
				char *cp = buf + strlen("HEIGHT=");
				height[entry] = atoi(cp);;
			}
			if(strncasecmp(buf, "ARG=", strlen("ARG=")) == 0)
			{
				char *cp = buf + strlen("ARG=");
				arg[entry][arg_cnt] = strdup(cp);
				if(arg_cnt < 10)
				{
					arg_cnt++;
				}
			}
		}
		fclose(fp);
		for(loop = 0;loop <= entry;loop++)
		{
			printf("%02d PATH: [%s]\n", loop, path[loop]);
			printf("%02d WIDTH: [%d]\n", loop, width[loop]);
			printf("%02d HEIGHT: [%d]\n", loop, height[loop]);
			for(inner = 0;inner < 10;inner++)
			{
				printf("%02d|%02d ARG: [%s]\n", loop, inner, arg[loop][inner]);
			}
			int x_pos = 0;
			int y_pos = 0;
			CalcEmbeddedWindowPosition(width[loop], height[loop], x_pos, y_pos);
			EmbedAppWindow *embed = new EmbedAppWindow(this, x_pos, y_pos, width[loop], height[loop]);
			AddEmbeddedWindow(embed);
			embed->set_non_modal();
			embed->show();
			int fw = 0;
			int fh = 0;
			int succeed = embed->EmbedApp(path[loop], arg[loop], fw, fh);
			if(succeed != 1)
			{
				RemoveEmbeddedWindow(embed);
				SetErrorMessage("Command failed to embed.");
			}
		}
	}
}

void	MyWin::Cleanup()
{
int	loop;

	PartialShutdown();
	pulse_microphone_cnt = 0;
	for(loop = 0;loop < 10;loop++)
	{
		split_bx[loop] = -1;
		split_by[loop] = -1;
		split_rx[loop] = -1;
		split_ry[loop] = -1;
	}
	for(loop = 0;loop < 1024;loop++)
	{
		recognize_class_name[loop] = NULL;
	}
	for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
	{
		if(ptz_window[loop] != NULL)
		{
			ptz_window[loop]->hide();
			remove(ptz_window[loop]);
			delete ptz_window[loop];
			ptz_window[loop] = NULL;
		}
	}
}

int	MyWin::SetCodec()
{
	int rr = 0;
	use_video_codec = (AVCodecID)AV_CODEC_ID_H264,
	use_audio_codec = (AVCodecID)AV_CODEC_ID_AAC,

	strcpy(use_extension, mux_format);
	if(codec_selection_window != NULL)
	{
		if(codec_selection_window->video_codec_id != 0)
		{
			use_video_codec = codec_selection_window->video_codec_id;
			rr = 1;
		}
		if(codec_selection_window->audio_codec_id != 0)
		{
			use_audio_codec = codec_selection_window->audio_codec_id;
			rr = 2;
		}
		if(strlen(codec_selection_window->extension_selected) > 0)
		{
			strcpy(use_extension, codec_selection_window->extension_selected);
			rr = 4;
		}
		if(strlen(codec_selection_window->container_selected) > 0)
		{
			strcpy(use_container, codec_selection_window->container_selected);
			rr = 8;
		}
	}
	int	video_found = my_find_codec_by_id(0, use_video_codec, video_codec_name);
	int	audio_found = my_find_codec_by_id(1, use_audio_codec, audio_codec_name);
	return(rr);
}

void	MyWin::RemoveCamera(Camera *cam)
{
int	loop;
int	inner;

	for(loop = 0;loop < 128;loop++)
	{
		if(camera[loop] != NULL)
		{
			for(inner = 0;inner < camera[loop]->image_window_cnt;inner++)
			{
				if(camera[loop]->image_window[inner] != NULL)
				{
					ImageWindow *iw = camera[loop]->image_window[inner];
					if(iw->camera == cam)
					{
						iw->hide();
						remove(iw);
						camera[loop]->image_window[inner] = NULL;
						Fl::delete_widget(iw);
					}
				}
			}
			camera[loop]->CompressImageWindowList();
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(cam == camera[loop])
		{
			camera[loop] = NULL;
			delete cam;
		}
		if(camera[loop] != NULL)
		{
			if(camera[loop]->source_camera == cam)
			{
				delete camera[loop];
				camera[loop] = NULL;
			}
		}
	}
	CompressCameraList();
	UpdateThumbButtons();
}

void	MyWin::CompressCameraList()
{
Camera	*list[128];
int		loop;

	int cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		list[loop] = NULL;
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(camera[loop] != NULL)
		{
			list[cnt] = camera[loop];
			cnt++;
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		camera[loop] = list[loop];
		if(camera[loop] != NULL)
		{
			camera[loop]->id = loop;
		}
	}
	source_cnt = cnt;
}

int	MyWin::ScanForDuplicateCameras(char *in_path)
{
int	inner;

	int rr = 0;
	char path1[PATH_MAX];
	char path2[PATH_MAX];
	realpath(in_path, path1);
	for(inner = 0;((inner < 128) && (rr == 0));inner++)
	{
		if(camera[inner] != NULL)
		{
			char path2[PATH_MAX];
			realpath(camera[inner]->path, path2);
			if(strcmp(path1, path2) == 0)
			{
				rr = 1;
			}
		}
	}
	return(rr);
}

void	MyWin::ResetCameras(int reset_existing, char **in_source, int in_source_cnt)
{
int	loop;
int	inner;

	char n_path[4096];
	if(reset_existing == 1)
	{
		for(loop = 0;loop < 128;loop++)
		{
			if(camera[loop] != NULL)
			{
				delete camera[loop];
				camera[loop] = NULL;
			}
		}
		start_time = 0;
	}
	for(loop = 0;loop < 128;loop++)
	{
		camera[loop] = NULL;
	}
	source_cnt = 0;
	if(in_source != NULL)
	{
		for(loop = 0;loop < in_source_cnt;loop++)
		{
			if(in_source[loop] != NULL)
			{
				if(atoi(in_source[loop]) == 0)
				{
					if(strlen(in_source[loop]) > 0)
					{
						if(strncmp(in_source[loop], "json://", strlen("json://")) == 0)
						{
							char *filename = in_source[loop] + strlen("json://");
							LoadJSONCamera(filename);
						}
						else
						{
							int nn = SetupCamera(in_source[loop], NULL, requested_w, requested_h, 32);
							if(nn == -1)
							{
								SetErrorMessage("Cannot Open Camera");
							}
						}
					}
				}
			}
		}
		if(record_desktop == 1)
		{
			int nn = SetupCamera("desktop://", "Desktop", requested_w, requested_h, 32);
			if(nn == -1)
			{
				SetErrorMessage("Cannot Open Camera");
			}
		}
	}
	if(no_scan == 0)
	{
		ScanForCameras();
	}
}

void	MyWin::ResetCamera(Camera *cam)
{
int	loop;
int	inner;

	RecordingFullStop();
	Fl::remove_timeout(my_window_cb);
	char n_path[4096];
	char n_alias[4096];
	strcpy(n_path, cam->path);
	strcpy(n_alias, cam->alias);
	for(loop = 0;loop < 128;loop++)
	{
		if(camera[loop] == cam)
		{
			delete camera[loop];
			camera[loop] = NULL;
		}
	}
	int nn = SetupCamera(n_path, n_alias, requested_w, requested_h, 32);
	if(nn == -1)
	{
		SetErrorMessage("Cannot Open Camera");
	}
	Fl::add_timeout(0.1, my_window_cb, this);
}

Camera	*MyWin::RecordingCamera()
{
	Camera *cam = recording_camera;
	return(cam);
}

Camera	*MyWin::DisplayedCamera()
{
	Camera *cam = NULL;
	if(displayed_source > -1)
	{
		cam = camera[displayed_source];
	}
	return(cam);
}

void	MyWin::HideObjects()
{
	object_menu->hide();
}

void	MyWin::ShowObjects()
{
int		loop;
int		inner;
char	*sorted_list[1024];

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		object_menu->set_non_modal();
		object_menu->take_focus();
		object_menu->show();
		int cnt = 0;
		for(loop = 0;loop < recognize_class_cnt;loop++)
		{
			sorted_list[loop] = recognize_class_name[loop];
		}
		object_page = 0;
		qsort(sorted_list, recognize_class_cnt, sizeof(char *), cmpstringp);
		for(loop = 0;loop < recognize_class_cnt;loop++)
		{
			int start = 123 * object_page;
			int end = 123 * (object_page + 1);
			if((cnt >= start) && (cnt < end))
			{
				object_menu->object_name_button[loop]->copy_label(sorted_list[loop]);
				object_menu->object_name_button[loop]->show();
				object_menu->object_name_button[loop]->redraw();
				for(inner = 0;inner < recognize_class_cnt;inner++)
				{
					if(strcmp(recognize_class_name[inner], object_menu->object_name_button[loop]->label()) == 0)
					{
						if(cam->object_index[inner] == 1)
						{
							object_menu->object_name_button[loop]->labelcolor(WHITE);
						}
						else
						{
							object_menu->object_name_button[loop]->labelcolor(YELLOW);
						}
					}
				}
			}
			else
			{
				object_menu->object_name_button[loop]->hide();
			}
			cnt++;
		}
		object_menu->object_clear_button->show();
		object_menu->object_all_button->show();
		object_menu->object_done_button->show();
		object_menu->object_apply_all_button->show();
		if(recognize_class_cnt > 123)
		{
			if((recognize_class_cnt / 123) > object_page)
			{
				object_menu->object_next_button->show();
			}
			else
			{
				object_menu->object_next_button->hide();
			}
			if(object_page > 0)
			{
				object_menu->object_prev_button->show();
			}
			else
			{
				object_menu->object_prev_button->hide();
			}
		}
		redraw();
	}
}

void	MyWin::ScanForCameras()
{
int	loop;

	for(loop = 0;loop < 10;loop++)
	{
		int success = 0;
		Camera *cam = new Camera(this, source_cnt, NULL, loop, forced_fps, requested_w, requested_h);
		if(cam->cap != NULL)
		{
			if(cam->cap->isOpened())
			{
				camera[source_cnt] = cam;
				source_cnt++;
				success = 1;
			}
		}
		if(success == 0)
		{
			delete cam;
		}
	}
}

int	MyWin::SetupCamera(char *source, char *in_alias, int r_ww, int r_hh, int fz, char *font_name, int irr, int igg, int ibb, int iaa, int t_rr, int t_gg, int t_bb, int t_aa, int use_chroma)
{
	int rr = -1;
	Camera *cam = new Camera(this, source_cnt, source, -1, forced_fps, r_ww, r_hh, irr, igg, ibb, iaa, t_rr, t_gg, t_bb, t_aa, use_chroma);
	if(cam != NULL)
	{
		cam->font_sz = fz;
		if(font_name != NULL)
		{
			strcpy(cam->font_name, font_name);
		}
		else
		{
			strcpy(cam->font_name, "Sans");
		}
		int success = 0;
		if(cam->cap != NULL)
		{
			if((cam->cap->isOpened()) || (cam->ndi_capture == 1))
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else 
			{
				if((cam->type == CAMERA_TYPE_TEXT)
				|| (cam->type == CAMERA_TYPE_DYNAMIC_TEXT)
				|| (cam->type == CAMERA_TYPE_ALERT)
				|| (cam->type == CAMERA_TYPE_PIPED)
				|| (cam->type == CAMERA_TYPE_TIMER)
				|| (cam->type == CAMERA_TYPE_CLOCK)
				|| (cam->type == CAMERA_TYPE_VECTOR)
				|| (cam->type == CAMERA_TYPE_SINGLE_FRAME_FILE)
				|| (cam->type == CAMERA_TYPE_OSG)
				|| (cam->type == CAMERA_TYPE_DESKTOP)
				|| (cam->type == CAMERA_TYPE_WINDOW)
				|| (cam->type == CAMERA_TYPE_SLIDESHOW)
				|| (cam->type == CAMERA_TYPE_PSEUDO)
				|| (cam->type == CAMERA_TYPE_PLUGIN)
				|| (cam->type == CAMERA_TYPE_BLANK)
				|| (cam->type == CAMERA_TYPE_AV)
				|| (cam->type == CAMERA_TYPE_HTML)
				|| (cam->type == CAMERA_TYPE_SOURCED)
				|| (cam->type == CAMERA_TYPE_EDGE_DETECT)
				|| (cam->type == CAMERA_TYPE_CHROMAKEY)
				|| (cam->type == CAMERA_TYPE_ALTERNATING)
				|| (cam->type == CAMERA_TYPE_SPLIT)
				|| (cam->type == CAMERA_TYPE_ALL))
				{
					camera[source_cnt] = cam;
					rr = source_cnt;
					source_cnt++;
					success = 1;
				}
			}
		}
		else if(cam->type == CAMERA_TYPE_IMAGE)
		{
			camera[source_cnt] = cam;
			rr = source_cnt;
			source_cnt++;
			success = 1;
		}
		if(success == 0)
		{
			delete cam;
		}
		else
		{
			if(in_alias != NULL)
			{
				strcpy(cam->alias, in_alias);
			}
			else
			{
				if(strlen(cam->alias) < 1)
				{
					strcpy(cam->alias, source);
				}
			}
		}
		UpdateThumbButtons();
	}
	return(rr);
}

void	review_win_cb(void *v)
{
	ReviewWin *rw = (ReviewWin *)v;
	rw->redraw();
	if(rw->playing == 1)
	{
		Fl::repeat_timeout(rw->delay, review_win_cb, rw);
	}
}


int	MyWin::LockedCameraStatus()
{
int	loop;

	int rr = 0;
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				if(ptz_window[loop]->visible())
				{
					if((cam->ptz_lock_interface == ptz_window[loop]->ptz_interface_index) 
					&& ((cam->ptz_lock_camera == ptz_window[loop]->ptz_current_camera_idx) || (cam->ptz_lock_camera == -1)))
					{
						rr = 1;
					}
				}
			}
		}
	}
	return(rr);
}

void	MyWin::PTZ_DoCommand(int index, int button, int arg_cnt, int arg0, int arg1, int arg2, int arg3, int arg4)
{
static char	buf1[256];
static char	buf2[256];

	PTZ_Window *win = ptz_window[index];
	int zoom_factor = 0;
	use_pan_speed = -1;
	use_tilt_speed = -1;

	Camera *bound_cam = DisplayedCamera();
	if(win != NULL)
	{
		if(win->bound_camera != NULL)
		{
			bound_cam = win->bound_camera;
		}
	}
	if((button < 20) && (arg_cnt > 1))
	{
		use_pan_speed = arg0;
		use_tilt_speed = arg1;
	}
	else
	{
		if(ptz_zoom_reading < 0)
		{
			ptz_zoom_reading = 0;
			if(win->ptz_current_interface != NULL)
			{
				VISCA_get_zoom_value(win->ptz_current_interface, win->ptz_current_camera, (uint16_t *)&ptz_zoom_reading);
			}
			sprintf(buf2, "%05d", ptz_zoom_reading);
			win->ptz_zoom_value_label->copy_label(buf2);
		}
		ptz_set_speed_cb(win->ptz_speed_slider, this);

		double use = (double)1.0;
		if(win->ptz_adjust_speed_for_zoom == 1)
		{
			zoom_factor = ptz_zoom_reading;
			if(zoom_factor < 1) zoom_factor = 1;
			if(zoom_factor > 16384) zoom_factor = 16384;
			use = (double)(16384 - zoom_factor) / 16384.0;
		}
		use_tilt_speed = (int)(win->ptz_tilt_speed * use);
		use_pan_speed = (int)(win->ptz_pan_speed * use);
		if(use_tilt_speed < 0) use_tilt_speed = 0;
		if(use_pan_speed < 0) use_pan_speed = 0;
	}
	int acquire_position = 0;
	int acquire_zoom = 0;
	int acquire_focus = 0;

	float ps = ((1.0 / 20.0) * (float)use_pan_speed);
	float ts = ((1.0 / 20.0) * (float)use_tilt_speed);
	float zs = ((1.0 / 40.0) * (float)win->ptz_zoom_speed);
	float fs = ((1.0 / 4.0) * (float)win->ptz_focus_speed);

	if(ptz_reverse_horizontal == 1)
	{
		if(button == PTZ_RIGHT) button = PTZ_LEFT;
		else if(button == PTZ_LEFT) button = PTZ_RIGHT;
		else if(button == PTZ_DOWN_RIGHT) button = PTZ_DOWN_LEFT;
		else if(button == PTZ_DOWN_LEFT) button = PTZ_DOWN_RIGHT;
		else if(button == PTZ_UP_RIGHT) button = PTZ_UP_LEFT;
		else if(button == PTZ_UP_LEFT) button = PTZ_UP_RIGHT;
	}
	if(ptz_reverse_vertical == 1)
	{
		if(button == PTZ_UP) button = PTZ_DOWN;
		else if(button == PTZ_DOWN) button = PTZ_UP;
		else if(button == PTZ_DOWN_RIGHT) button = PTZ_UP_RIGHT;
		else if(button == PTZ_DOWN_LEFT) button = PTZ_UP_LEFT;
		else if(button == PTZ_UP_RIGHT) button = PTZ_DOWN_RIGHT;
		else if(button == PTZ_UP_LEFT) button = PTZ_DOWN_LEFT;
	}
	if(button == PTZ_UP_LEFT)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt_speed(bound_cam->ndi_recv, ps, ts);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_Motion(V4L_UP | V4L_LEFT);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_pantilt_upleft(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_Motion(V4L_UP | V4L_LEFT);
						}
					}
				}
			}
		}
		ptz_panning = button;
	}
	else if(button == PTZ_UP_RIGHT)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt_speed(bound_cam->ndi_recv, -ps, ts);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_Motion(V4L_UP | V4L_RIGHT);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_pantilt_upright(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_Motion(V4L_UP | V4L_RIGHT);
						}
					}
				}
			}
		}
		ptz_panning = button;
	}
	else if(button == PTZ_DOWN_RIGHT)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt_speed(bound_cam->ndi_recv, -ps, -ts);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_Motion(V4L_DOWN | V4L_RIGHT);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_pantilt_downright(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_Motion(V4L_DOWN | V4L_RIGHT);
						}
					}
				}
			}
		}
		ptz_panning = button;
	}
	else if(button == PTZ_DOWN_LEFT)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt_speed(bound_cam->ndi_recv, ps, -ts);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_Motion(V4L_DOWN | V4L_LEFT);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_pantilt_downleft(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_Motion(V4L_DOWN | V4L_LEFT);
						}
					}
				}
			}
		}
		ptz_panning = button;
	}
	else if(button == PTZ_UP)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt_speed(bound_cam->ndi_recv, 0.0, ts);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_Command(V4L_UP);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_pantilt_up(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_Command(V4L_UP);
						}
					}
				}
			}
		}
		ptz_panning = button;
	}
	else if(button == PTZ_DOWN)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt_speed(bound_cam->ndi_recv, 0.0, -ts);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_Command(V4L_DOWN);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_pantilt_down(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_Command(V4L_DOWN);
						}
					}
				}
			}
		}
		ptz_panning = button;
	}
	else if(button == PTZ_RIGHT)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt_speed(bound_cam->ndi_recv, -ps, 0.0);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_Command(V4L_RIGHT);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_pantilt_right(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_Command(V4L_RIGHT);
						}
					}
				}
			}
		}
		ptz_panning = button;
	}
	else if(button == PTZ_LEFT)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt_speed(bound_cam->ndi_recv, ps, 0.0);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_Command(V4L_LEFT);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_pantilt_left(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_Command(V4L_LEFT);
						}
					}
				}
			}
		}
		ptz_panning = button;
	}
	else if(button == PTZ_ZOOM_IN)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_zoom_speed(bound_cam->ndi_recv, zs);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_RepeatCommand(V4L_ZOOM_IN);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_zoom_tele_speed(win->ptz_current_interface, win->ptz_current_camera, win->ptz_zoom_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_RepeatCommand(V4L_ZOOM_IN);
						}
					}
				}
			}
		}
		ptz_zooming = 1;
	}
	else if(button == PTZ_ZOOM_OUT)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_zoom_speed(bound_cam->ndi_recv, -zs);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_RepeatCommand(V4L_ZOOM_OUT);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_zoom_wide_speed(win->ptz_current_interface, win->ptz_current_camera, win->ptz_zoom_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_RepeatCommand(V4L_ZOOM_OUT);
						}
					}
				}
			}
		}
		ptz_zooming = -1;
	}
	else if(button == PTZ_ZOOM)
	{
		if(win->ptz_current_interface != NULL)
		{
			VISCA_set_zoom_value(win->ptz_current_interface, win->ptz_current_camera, arg0);
			ptz_zooming = -1;
		}
	}
	else if(button == PTZ_FOCUS)
	{
		if(win->ptz_current_interface != NULL)
		{
			VISCA_set_focus_value(win->ptz_current_interface, win->ptz_current_camera, arg0);
			ptz_focusing = 1;
		}
	}
	else if(button == PTZ_ZOOM_AND_FOCUS)
	{
		if(win->ptz_current_interface != NULL)
		{
			VISCA_set_zoom_and_focus_value(win->ptz_current_interface, win->ptz_current_camera, arg0, arg1);
			ptz_zooming = 1;
			ptz_focusing = 1;
			acquire_zoom = 1;
			acquire_focus = 1;
		}
	}
	else if(button == PTZ_FOCUS_FAR)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_focus_speed(bound_cam->ndi_recv, fs);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_RepeatCommand(V4L_FOCUS_FAR);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_focus_far_speed(win->ptz_current_interface, win->ptz_current_camera, win->ptz_focus_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_RepeatCommand(V4L_FOCUS_FAR);
						}
					}
				}
			}
		}
		ptz_focusing = 1;
	}
	else if(button == PTZ_FOCUS_NEAR)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_focus_speed(bound_cam->ndi_recv, -fs);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->V4L_RepeatCommand(V4L_FOCUS_NEAR);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_focus_near_speed(win->ptz_current_interface, win->ptz_current_camera, win->ptz_focus_speed);
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->V4L_RepeatCommand(V4L_FOCUS_NEAR);
						}
					}
				}
			}
		}
		ptz_focusing = -1;
	}
	else if(button == PTZ_APERTURE_OPEN)
	{
		if(win->ptz_current_interface != NULL)
		{
			VISCA_set_iris_up(win->ptz_current_interface, win->ptz_current_camera);
			ptz_focusing = 1;
		}
	}
	else if(button == PTZ_APERTURE_CLOSE)
	{
		if(win->ptz_current_interface != NULL)
		{
			VISCA_set_iris_down(win->ptz_current_interface, win->ptz_current_camera);
			ptz_focusing = -1;
		}
	}
	else if(button == PTZ_HOME)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt(bound_cam->ndi_recv, 0.0, 0.0);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				VISCA_set_pantilt_home(win->ptz_current_interface, win->ptz_current_camera);
				VISCA_set_zoom_value(win->ptz_current_interface, win->ptz_current_camera, 0);
				VISCA_set_focus_value(win->ptz_current_interface, win->ptz_current_camera, 20000);
			}
		}
		acquire_position = 1;
		acquire_zoom = 1;
		acquire_focus = 1;
	}
	else if(button == PTZ_PAN_STOP)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_pan_tilt_speed(bound_cam->ndi_recv, 0.0, 0.0);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->v4l_pending_command = 0;
			bound_cam->V4L_Command(V4L_STOP);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_pantilt_stop(win->ptz_current_interface, win->ptz_current_camera, 0, 0);
				ptz_panning = 0;
				acquire_position = 1;
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->v4l_pending_command = 0;
							cam->V4L_Command(V4L_STOP);
						}
					}
				}
			}
		}
	}
	else if(button == PTZ_ZOOM_STOP)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_zoom_speed(bound_cam->ndi_recv, 0.0);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->v4l_pending_command = 0;
			bound_cam->V4L_Command(V4L_STOP);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_zoom_stop(win->ptz_current_interface, win->ptz_current_camera);
				ptz_zooming = 0;
				acquire_zoom = 1;
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->v4l_pending_command = 0;
							cam->V4L_Command(V4L_STOP);
						}
					}
				}
			}
		}
	}
	else if(button == PTZ_FOCUS_STOP)
	{
		if(bound_cam->ndi_ptz == 1)
		{
			NDILib->recv_ptz_focus_speed(bound_cam->ndi_recv, 0.0);
		}
		else if(bound_cam->prefer_v4l == 1)
		{
			bound_cam->v4l_pending_command = 0;
			bound_cam->V4L_Command(V4L_STOP);
		}
		else
		{
			if(win->ptz_current_interface != NULL)
			{
				int err = VISCA_set_focus_stop(win->ptz_current_interface, win->ptz_current_camera);
				ptz_focusing = 0;
				acquire_focus = 1;
				if(err != 0)
				{
					if(win != NULL)
					{
						if(win->bound_camera != NULL)
						{
							Camera *cam = win->bound_camera;
							cam->v4l_pending_command = 0;
							cam->V4L_Command(V4L_STOP);
						}
					}
				}
			}
		}
	}
	else if(button == PTZ_RELATIVE_POSITION)
	{
		if(win->ptz_current_interface != NULL)
		{
			int err = VISCA_set_pantilt_relative_position(win->ptz_current_interface, win->ptz_current_camera, arg0, arg1, arg2, arg3);
			if(err != 0)
			{
				if((arg2 == 0) && (arg3 == 10))
				{
					VISCA_set_pantilt_up(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
					usleep(10000);
					VISCA_set_pantilt_stop(win->ptz_current_interface, win->ptz_current_camera, 0, 0);
				}
				else if((arg2 == 10) && (arg3 == 10))
				{
					VISCA_set_pantilt_upright(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
					usleep(10000);
					VISCA_set_pantilt_stop(win->ptz_current_interface, win->ptz_current_camera, 0, 0);
				}
				else if((arg2 == 10) && (arg3 == 0))
				{
					VISCA_set_pantilt_right(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
					usleep(10000);
					VISCA_set_pantilt_stop(win->ptz_current_interface, win->ptz_current_camera, 0, 0);
				}
				else if((arg2 == 10) && (arg3 == -10))
				{
					VISCA_set_pantilt_downright(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
					usleep(10000);
					VISCA_set_pantilt_stop(win->ptz_current_interface, win->ptz_current_camera, 0, 0);
				}
				else if((arg2 == 0) && (arg3 == -10))
				{
					VISCA_set_pantilt_down(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
					usleep(10000);
					VISCA_set_pantilt_stop(win->ptz_current_interface, win->ptz_current_camera, 0, 0);
				}
				else if((arg2 == -10) && (arg3 == -10))
				{
					VISCA_set_pantilt_downleft(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
					usleep(10000);
					VISCA_set_pantilt_stop(win->ptz_current_interface, win->ptz_current_camera, 0, 0);
				}
				else if((arg2 == -10) && (arg3 == 0))
				{
					VISCA_set_pantilt_left(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
					usleep(10000);
					VISCA_set_pantilt_stop(win->ptz_current_interface, win->ptz_current_camera, 0, 0);
				}
				else if((arg2 == -10) && (arg3 == 10))
				{
					VISCA_set_pantilt_upleft(win->ptz_current_interface, win->ptz_current_camera, use_pan_speed, use_tilt_speed);
					usleep(10000);
					VISCA_set_pantilt_stop(win->ptz_current_interface, win->ptz_current_camera, 0, 0);
				}
			}
			acquire_position = 1;
		}
	}
	else if(button == PTZ_ABSOLUTE_POSITION)
	{
		if(win->ptz_current_interface != NULL)
		{
			VISCA_set_pantilt_absolute_position(win->ptz_current_interface, win->ptz_current_camera, arg0, arg1, arg2, arg3);
			acquire_position = 1;
		}
	}
	else
	{
		acquire_position = 1;
		acquire_zoom = 1;
		acquire_focus = 1;
	}
	if(acquire_focus == 1)
	{
		if(win->ptz_current_interface != NULL)
		{
			ptz_focus_reading = 0;
			char nn = -1;
			int cnt = 0;
			while((nn == -1) && (cnt < 10))
			{
				nn = VISCA_get_focus_value(win->ptz_current_interface, win->ptz_current_camera, (uint16_t *)&ptz_focus_reading);
				cnt++;
			}
			sprintf(buf1, "%05d", ptz_focus_reading);
			win->ptz_focus_value_label->copy_label(buf1);
		}
	}
	if(acquire_zoom == 1)
	{
		if(win->ptz_current_interface != NULL)
		{
			ptz_zoom_reading = 0;
			char nn = -1;
			int cnt = 0;
			while((nn == -1) && (cnt < 10))
			{
				nn = VISCA_get_zoom_value(win->ptz_current_interface, win->ptz_current_camera, (uint16_t *)&ptz_zoom_reading);
				cnt++;
			}
			sprintf(buf2, "%05d", ptz_zoom_reading);
			win->ptz_zoom_value_label->copy_label(buf2);
		}
	}
	if(acquire_position == 1)
	{
		if(win->ptz_current_interface != NULL)
		{
			ptz_pan_reading = 0;
			ptz_tilt_reading = 0;
			char nn = -1;
			int cnt = 0;
			while((nn == -1) && (cnt < 10))
			{
				nn = (char)VISCA_get_pantilt_position(win->ptz_current_interface, win->ptz_current_camera, &ptz_pan_reading, &ptz_tilt_reading);
				cnt++;
			}
		}
	}
	ptz_window[index]->UpdatePTZButtons();
}

void	ptz_zoom_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->ptz_lock_interface != -1)
	{
		int instance = -1;
		if(win->ptz_window[cam->ptz_lock_interface] != NULL)
		{
			instance = win->ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
		}
		if(instance != -1)
		{
			win->ViscaCommand(instance, PTZ_ZOOM_STOP);
		}
	}
}

void	ptz_focus_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->ptz_lock_interface != -1)
	{
		int instance = -1;
		if(win->ptz_window[cam->ptz_lock_interface] != NULL)
		{
			instance = win->ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
		}
		if(instance != -1)
		{
			win->ViscaCommand(instance, PTZ_FOCUS_STOP);
		}
	}
}

void	ptz_drag_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->ptz_lock_interface != -1)
	{
		int instance = -1;
		if(win->ptz_window[cam->ptz_lock_interface] != NULL)
		{
			instance = win->ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
		}
		if(instance != -1)
		{
			win->ViscaCommand(instance, PTZ_PAN_STOP);
		}
	}
}

void	MyWin::PTZ_MoveTo(int instance, int spd_x, int spd_y, int xx, int yy)
{
	int dx = ((w() / 2) - xx) * -1;
	int dy = (h() / 2) - yy;
	dx *= 3;
	dy *= 3;
	int zoom_factor = ptz_zoom_reading;
	if(zoom_factor < 1) zoom_factor = 1;
	if(zoom_factor > 15000) zoom_factor = 15000;
	double use = (double)(16384 - zoom_factor) / 16384.0;
	double ddx = (double)dx * use;
	double ddy = (double)dy * use;
	dx = (int)ddx;
	dy = (int)ddy;
	ViscaCommand(instance, PTZ_RELATIVE_POSITION, 4, spd_x, spd_y, dx, dy);
}

void	ptz_tour_presets_cb(void *v)
{
int	loop;

	PTZ_Window *win = (PTZ_Window *)v;
	int cnt = 0;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(win->ptz_position[win->ptz_interface_index][win->ptz_current_camera_idx][loop]->set == 1)
		{
			cnt++;
		}
	}
	if(cnt > 1)
	{
		int r = 0;
		double val = win->ptz_speed_slider->value();
		if(win->ptz_position[win->ptz_interface_index][win->ptz_current_camera_idx][win->ptz_tour_index]->set == 1)
		{
			r = win->PTZ_RecallPosition((int)(20.0 * val), win->ptz_tour_index);
		}
		win->ptz_tour_index++;
		if(win->ptz_tour_index > 20)
		{
			win->ptz_tour_index = 0;
		}
		if(r == 1)
		{
			Fl::repeat_timeout(10.0 * (1.0 - val), ptz_tour_presets_cb, win);
		}
		else
		{
			Fl::repeat_timeout(0.01, ptz_tour_presets_cb, win);
		}
	}
}

void	MyWin::ZoomALittle(int instance, int key)
{
	if(visca_command == 0)
	{
		if(ptz_window[instance]->ptz_current_interface != NULL)
		{
			int zoom_reading = 0;
			VISCA_get_zoom_value(ptz_window[instance]->ptz_current_interface, ptz_window[instance]->ptz_current_camera, (uint16_t *)&zoom_reading);
			if((key == 'w') || (key == FL_KP + '8'))
			{
				ViscaCommand(instance, PTZ_ZOOM, 1, zoom_reading + ptz_little_speed);
			}
			else if((key == 's') || (key == FL_KP + '2'))
			{
				if(zoom_reading > ptz_little_speed)
				{
					ViscaCommand(instance, PTZ_ZOOM, 1, zoom_reading - ptz_little_speed);
				}
			}
		}
	}
}

void	MyWin::FocusALittle(int instance, int key)
{
	if(visca_command == 0)
	{
		if(ptz_window[instance]->ptz_current_interface != NULL)
		{
			int focus_reading = 0;
			VISCA_get_focus_value(ptz_window[instance]->ptz_current_interface, ptz_window[instance]->ptz_current_camera, (uint16_t *)&focus_reading);
			if((key == 'w') || (key == FL_KP + '8'))
			{
				ViscaCommand(instance, PTZ_FOCUS, 1, focus_reading + ptz_little_speed);
			}
			else if((key == 's') || (key == FL_KP + '2'))
			{
				if(focus_reading > ptz_little_speed)
				{
					ViscaCommand(instance, PTZ_FOCUS, 1, focus_reading - ptz_little_speed);
				}
			}
		}
	}
}

void	MyWin::ZoomAndFocusALittle(int instance, int key)
{
	if(visca_command == 0)
	{
		if(ptz_window[instance]->ptz_current_interface != NULL)
		{
			int zoom_reading = 0;
			int focus_reading = 0;
			VISCA_get_zoom_value(ptz_window[instance]->ptz_current_interface, ptz_window[instance]->ptz_current_camera, (uint16_t *)&zoom_reading);
			VISCA_get_focus_value(ptz_window[instance]->ptz_current_interface, ptz_window[instance]->ptz_current_camera, (uint16_t *)&focus_reading);
			if((key == 'w') || (key == FL_KP + '8'))
			{
				ViscaCommand(instance, PTZ_ZOOM_AND_FOCUS, 2, zoom_reading + ptz_little_speed, focus_reading + ptz_little_speed);
			}
			else if((key == 's') || (key == FL_KP + '2'))
			{
				if((zoom_reading > ptz_little_speed)
				&& (focus_reading > ptz_little_speed))
				{
					ViscaCommand(instance, PTZ_ZOOM_AND_FOCUS, 2, zoom_reading - ptz_little_speed, focus_reading - ptz_little_speed);
				}
			}
		}
	}
}

void	MyWin::CenterMessage(char *str, int timer)
{
	strcpy(center_message, str);
	center_message_timer = timer;
}

void	MyWin::MoveALittle(int instance, int key)
{
	if((key == 'w') || (key == FL_KP + '8'))
	{
		ViscaCommand(instance, PTZ_RELATIVE_POSITION, 4, 1, 1, 0, ptz_little_speed);
	}
	else if((key == 'a') || (key == FL_KP + '4'))
	{
		ViscaCommand(instance, PTZ_RELATIVE_POSITION, 4, 1, 1, -ptz_little_speed, 0);
	}
	else if((key == 's') || (key == FL_KP + '2'))
	{
		ViscaCommand(instance, PTZ_RELATIVE_POSITION, 4, 1, 1, 0, -ptz_little_speed);
	}
	else if((key == 'd') || (key == FL_KP + '6'))
	{
		ViscaCommand(instance, PTZ_RELATIVE_POSITION, 4, 1, 1, ptz_little_speed, 0);
	}
	else if((key == 'q') || (key == FL_KP + '7'))
	{
		ViscaCommand(instance, PTZ_RELATIVE_POSITION, 4, 1, 1, -ptz_little_speed, ptz_little_speed);
	}
	else if((key == 'e') || (key == FL_KP + '9'))
	{
		ViscaCommand(instance, PTZ_RELATIVE_POSITION, 4, 1, 1, ptz_little_speed, ptz_little_speed);
	}
	else if((key == 'z') || (key == FL_KP + '1'))
	{
		ViscaCommand(instance, PTZ_RELATIVE_POSITION, 4, 1, 1, -ptz_little_speed, -ptz_little_speed);
	}
	else if((key == 'x') || (key == FL_KP + '3'))
	{
		ViscaCommand(instance, PTZ_RELATIVE_POSITION, 4, 1, 1, ptz_little_speed, -ptz_little_speed);
	}
}

void	ptz_joystick_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	int r = win->ptz_joystick_handler();
	if(r == 1)
	{
		Fl::repeat_timeout(0.01, ptz_joystick_cb, win);
	}
}

int	MyWin::ptz_joystick_handler()
{
	int r = 0;
	Camera *cam = DisplayedCamera();
	if(cam->ptz_lock_interface != -1)
	{
		int instance = -1;
		if(ptz_window[cam->ptz_lock_interface] != NULL)
		{
			instance = ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
		}
		if(instance != -1)
		{
			if((ptz_joystick_x != ptz_last_joystick_x)
			|| (ptz_joystick_y != ptz_last_joystick_y))
			{
				int test_x = ptz_joystick_x / 10;
				int test_y = ptz_joystick_y / 10;
				ptz_last_joystick_x = ptz_joystick_x;
				ptz_last_joystick_y = ptz_joystick_y;
				int x_speed = abs(test_x);
				int y_speed = abs(test_y);
				if(x_speed > 20) x_speed = 20;
				if(y_speed > 20) y_speed = 20;
				if((x_speed > 0) || (y_speed > 0))
				{
					if((test_x > 0) && (test_y > 0))
					{
						ViscaCommand(instance, PTZ_DOWN_RIGHT, 2, x_speed, y_speed);
					}
					else if((test_x > 0) && (test_y < 0))
					{
						ViscaCommand(instance, PTZ_UP_RIGHT, 2, x_speed, y_speed);
					}
					else if((test_x < 0) && (test_y > 0))
					{
						ViscaCommand(instance, PTZ_DOWN_LEFT, 2, x_speed, y_speed);
					}
					else if((test_x < 0) && (test_y < 0))
					{
						ViscaCommand(instance, PTZ_UP_LEFT, 2, x_speed, y_speed);
					}
					else if(test_x > 0)
					{
						ViscaCommand(instance, PTZ_RIGHT, 2, x_speed, y_speed);
					}
					else if(test_x < 0)
					{
						ViscaCommand(instance, PTZ_LEFT, 2, x_speed, y_speed);
					}
					else if(test_y > 0)
					{
						ViscaCommand(instance, PTZ_DOWN, 2, x_speed, y_speed);
					}
					else if(test_y < 0)
					{
						ViscaCommand(instance, PTZ_UP, 2, x_speed, y_speed);
					}
				}
				r = 1;
			}
		}
	}
	return(r);
}

void	iconize_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	char *raw = (char *)grab_raw_desktop_image();
	if(raw != NULL)
	{
		FakeWindow *fake = new FakeWindow(win, raw);
		fake->show();
		win->hide();
		while(fake->visible())
		{
			Fl::wait(1);
		}
		win->show();
		win->new_source_window->show();
		win->new_source_window->set_non_modal();
		Fl::delete_widget(fake);
	}
}

int	MyWin::ImageWindowButtonHit(int xx, int yy)
{
int	loop;

	int done = 0;
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;((loop < cam->image_window_cnt) && (done == 0));loop++)
		{
			if(cam->image_window[loop] != NULL)
			{
				if(cam->image_window[loop]->buttonize == 1)
				{
					if(cam->image_window[loop]->AsButton(xx, yy) == 1)
					{
						done = 1;
					}
				}
			}
		}
	}
	return(done);
}

void	MyWin::DeleteImmediate()
{
int	loop;

	Fl_Widget *foc = Fl::focus();
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->immediate_list != NULL)
		{
			for(loop = 0;loop < cam->immediate_cnt;loop++)
			{
				Immediate *wid = cam->immediate_list[loop];
				if(wid != NULL)
				{
					if(wid != foc)
					{
						if((xx > wid->x())
						&& (yy > wid->y())
						&& (xx < (wid->x() + wid->w()))
						&& (yy < (wid->y() + wid->h())))
						{
							immediate_drawing_window->ClearSelectedWidget();
							cam->RemoveImmediate(wid);
							Fl::delete_widget(wid);
						}
					}
				}
			}
		}
	}
}

void	MyWin::ToggleRecord(Camera *cam)
{
	if(cam->record == 0)
	{
		cam->RecordOn();
	}
	else
	{
		cam->RecordOff();
	}
}

int	MyWin::DoDeleteImmediate()
{
	int flag = 0;
	if(im_drawing_mode == 1)
	{
		DeleteImmediate();
	}
	return(flag);
}

int	MyWin::TogglePTZJoystick()
{
int	loop;

	int flag = 0;
	if(ptz_mode == 1)
	{
		if(ptz_joystick == 0)
		{
			ptz_joystick = 1;
			ptz_window[0]->ptz_joystick_button->value(1);
		}
		else
		{
			ptz_joystick = 0;
			ptz_window[0]->ptz_joystick_button->value(0);
		}
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				ptz_window[loop]->ptz_joystick_button->value(ptz_joystick);
			}
		}
		flag = 1;
	}
	return(flag);
}

int	MyWin::IncreasePTZLittleSpeed()
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		ptz_little_speed++;
		char buf[256];
		sprintf(buf, "Speed: %d", ptz_little_speed);
		CenterMessage(buf, 100);
		flag = 1;
	}
	return(flag);
}

int	MyWin::DecreasePTZLittleSpeed()
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		if(ptz_little_speed > 1)
		{
			ptz_little_speed--;
			char buf[256];
			sprintf(buf, "Speed: %d", ptz_little_speed);
			CenterMessage(buf, 100);
			flag = 1;
		}
	}
	return(flag);
}

int	MyWin::CyclePTZLittleMode()
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		ptz_little_mode++;
		if(ptz_little_mode > PTZ_LITTLE_ZOOM_AND_FOCUS_MODE)
		{
			ptz_little_mode = PTZ_LITTLE_MOTION_MODE;
		}
		if(ptz_little_mode == PTZ_LITTLE_MOTION_MODE)
		{
			CenterMessage("Motion", 100);
		}
		else if(ptz_little_mode == PTZ_LITTLE_ZOOM_MODE)
		{
			CenterMessage("Zoom", 100);
		}
		else if(ptz_little_mode == PTZ_LITTLE_FOCUS_MODE)
		{
			CenterMessage("Focus", 100);
		}
		else if(ptz_little_mode == PTZ_LITTLE_ZOOM_AND_FOCUS_MODE)
		{
			CenterMessage("Zoom and Focus", 100);
		}
		flag = 1;	
	}
	return(flag);
}

int	MyWin::PTZHome()
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		Camera *cam = DisplayedCamera();
		if(cam->ptz_lock_interface != -1)
		{
			int instance = -1;
			if(ptz_window[cam->ptz_lock_interface] != NULL)
			{
				instance = ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
			}
			if(instance != -1)
			{
				ViscaCommand(instance, PTZ_HOME);
				flag = 1;
			}
		}
	}
	return(flag);
}

int	MyWin::LittleMotion(int key)
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		Camera *cam = DisplayedCamera();
		if(cam->ptz_lock_interface != -1)
		{
			int instance = -1;
			if(ptz_window[cam->ptz_lock_interface] != NULL)
			{
				instance = ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
			}
			if(instance != -1)
			{
				if(ptz_little_mode == PTZ_LITTLE_MOTION_MODE)
				{
					MoveALittle(instance, key);
				}
				else if(ptz_little_mode == PTZ_LITTLE_ZOOM_MODE)
				{
					ZoomALittle(instance, key);
				}
				else if(ptz_little_mode == PTZ_LITTLE_FOCUS_MODE)
				{
					FocusALittle(instance, key);
				}
				else if(ptz_little_mode == PTZ_LITTLE_ZOOM_AND_FOCUS_MODE)
				{
					ZoomAndFocusALittle(instance, key);
				}
				flag = 1;	
			}
		}
	}
	return(flag);
}

void	MyWin::Review()
{
	review_button_cb(NULL, this);
}

void	MyWin::LocalZoomIn(Camera *cam)
{
	cam->zoom += 0.01;
	if(cam->zoom > 4.0)
	{
		cam->zoom = 4.0;
	}
}

void	MyWin::LocalZoomOut(Camera *cam)
{
	cam->zoom -= 0.01;
	if(cam->zoom <= 1.0)
	{
		cam->zoom = 1.0;
		offset_x = 0;
		offset_y = 0;
	}
}

void	MyWin::ToggleFrozen()
{
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->freeze_video == 0)
		{
			cam->freeze_video = 1;
		}
		else
		{
			cam->freeze_video = 0;
		}
	}
}

void	MyWin::DoSnapshot()
{
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		cam->snapshot = 1;
	}
}

void	MyWin::ScaleVideoReset()
{
	image_display_scale = 1.0;
}

void	MyWin::ScaleVideoUp()
{
	if(image_display_scale < 10.0)
	{
		image_display_scale += 0.01;
	}
}

void	MyWin::ScaleVideoDown()
{
	if(image_display_scale > 0.01)
	{
		image_display_scale -= 0.01;
	}
}

int	MyWin::DisplaySplitSelection(int nn)
{
	int flag = 0;
	if((nn >= 0) && (nn < source_cnt))
	{
		current_fps_window->showing = 1;
		DisplayCamera(nn);
		split = 0;
		flag = 1;
	}
	return(flag);
}

void	MyWin::HideAllElements()
{
int	loop;

	HideButtons();
	button_group->hide();
	buttons_shown = 0;
	video_thumbnail_group->hide();
	if(audio == 1)
	{
		audio_thumbnail_group->hide();
	}
	if(ptz_mode == 1)
	{
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				ptz_window[loop]->hide();
			}
		}
	}
}

void	MyWin::ShowAllElements()
{
int	loop;

	ShowButtons();
	button_group->show();
	buttons_shown = 1;
	video_thumbnail_group->show();
	if(audio == 1)
	{
		audio_thumbnail_group->show();
	}
	if(ptz_mode == 1)
	{
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				if(ptz_window[loop]->showing == 1)
				{
					ptz_window[loop]->show();
				}
			}
		}
	}
}

void	show_all_elements_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	win->ShowAllElements();
}

void	hide_all_elements_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	win->HideAllElements();
}

void	exit_timer_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	time_t now = time(0);
	if(now < win->exit_timer)
	{
		Fl::repeat_timeout(1.0, exit_timer_cb, win);
	}
	else
	{
		win->exit_timer = 0;
	}
}

void	MyWin::InitiateExit()
{
	exit_timer = time(0) + 10;
	Fl::add_timeout(1.0, exit_timer_cb, this);
}

int	MyWin::HandleKeyboard(int event, Camera *cam)
{
	int flag = 0;
	int key = Fl::event_key();
	int ctrl = Fl::event_state(FL_CTRL);
	int alt = Fl::event_state(FL_ALT);
	int shift = Fl::event_state(FL_SHIFT);
	if(split == 0)
	{
		if((key == command_key[KEY_TOGGLE_RECORD]) && (!ctrl) && (!alt) && (!shift))
		{
			record_button_cb(record_button, this);
			flag = 1;
		}
		else if((key == command_key[KEY_DELETE_IMMEDIATE]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DoDeleteImmediate();
		}
		else if((key == command_key[KEY_TOGGLE_PTZ_JOYSTICK]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = TogglePTZJoystick();
		}
		else if((key == command_key[KEY_INCREASE_PTZ_LITTLE_SPEED]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = IncreasePTZLittleSpeed();
		}
		else if((key == command_key[KEY_DECREASE_PTZ_LITTLE_SPEED]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DecreasePTZLittleSpeed();
		}
		else if((key == command_key[KEY_CYCLE_PTZ_LITTLE_MODE]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = CyclePTZLittleMode();
		}
		else if((key == command_key[KEY_PTZ_HOME]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = PTZHome();
		}
		else if((key == command_key[KEY_CYCLE_DOWN_THUMBGROUP]) && (!ctrl) && (!alt) && (!shift))
		{
			video_thumbnail_group->CycleDownThumbgroup();
			flag = 1;
		}
		else if((key == command_key[KEY_CYCLE_UP_THUMBGROUP]) && (!ctrl) && (!alt) && (!shift))
		{
			video_thumbnail_group->CycleUpThumbgroup();
			flag = 1;
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_0]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(0);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_1]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(1);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_2]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(2);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_3]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(3);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_4]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(4);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_5]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(5);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_6]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(6);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_7]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(7);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_8]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(8);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_9]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = video_thumbnail_group->DisplayThumbgroup(9);
		}
		else if((key == command_key[KEY_DISPLAY_ELEMENTS]) && (ctrl) && (!alt) && (!shift))
		{
			if((retain_commands == 0) || (retain_cameras == 0) || (retain_audio == 0) || (retain_ptz == 0))
			{
				retain_commands = 1;
				retain_cameras = 1;
				retain_audio = 1;
				retain_ptz = 1;
				Fl::add_timeout(0.0, show_all_elements_cb, this);
			}
			else
			{
				retain_commands = 0;
				retain_cameras = 0;
				retain_audio = 0;
				retain_ptz = 0;
				Fl::add_timeout(0.0, hide_all_elements_cb, this);
			}
			flag = 1;
		}
		else if((key == command_key[KEY_DISPLAY_ELEMENTS]) && (!ctrl) && (!alt) && (!shift))
		{
			HideButtons();
			ShowButtons();
			if(!button_group->visible())
			{
				if(button_group->in_motion == 0)
				{
					button_group->show();
				}
				buttons_shown = 1;
			}
			else
			{
				if(button_group->in_motion == 0)
				{
					button_group->hide();
				}
				buttons_shown = 0;
			}
		}
		else if(((key == command_key[KEY_LITTLE_MOTION_1]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_1]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_2]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_2]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_3]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_3]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_4]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_4]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_5]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_5]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_6]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_6]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_7]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_7]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_8]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_8]) && (!ctrl) && (!alt) && (!shift)))
		{
			flag = LittleMotion(key);
		}
		else if((key == command_key[KEY_REVIEW]) && (!ctrl) && (!alt) && (!shift))
		{
			Review();
			flag = 1;
		}
		else if((key == command_key[KEY_LOCAL_ZOOM_IN]) && (!ctrl) && (!alt) && (shift))
		{
			LocalZoomIn(cam);
			flag = 1;
		}
		else if((key == command_key[KEY_LOCAL_ZOOM_OUT]) && (!ctrl) && (!alt) && (!shift))
		{
			LocalZoomOut(cam);
			flag = 1;
		}
		else if((key == command_key[KEY_TOGGLE_FROZEN]) && (!ctrl) && (!alt) && (!shift))
		{
			ToggleFrozen();
			flag = 1;
		}
		else if((key == command_key[KEY_SCALE_VIDEO_RESET]) && (!ctrl) && (!alt) && (!shift))
		{
			ScaleVideoReset();
			flag = 1;
		}
		else if((key == command_key[KEY_SCALE_VIDEO_UP]) && (!ctrl) && (!alt) && (!shift))
		{
			ScaleVideoUp();
			flag = 1;
		}
		else if((key == command_key[KEY_SCALE_VIDEO_DOWN]) && (!ctrl) && (!alt) && (!shift))
		{
			ScaleVideoDown();
			flag = 1;
		}
		else if(((key == command_key[KEY_SNAPSHOT]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_SNAPSHOT_OTHER]) && (!ctrl) && (!alt) && (!shift)))
		{
			DoSnapshot();
			flag = 1;
		}
		else if((key == command_key[KEY_EXIT]) && (!ctrl) && (!alt) && (!shift))
		{
			if(exit_timer == 0)
			{
				InitiateExit();
			}
			else
			{
				actively_exiting = 1;
				redraw();
				Fl::check();
				quit_cb(NULL, this);
			}
			flag = 1;
		}
		else if((key == command_key[KEY_OPEN_MENU]) && (!ctrl) && (!alt) && (!shift))
		{
			ReallyToggleButtonPanel();
			flag = 1;
		}
		else if((key == command_key[KEY_OPEN_CAMERAS]) && (!ctrl) && (!alt) && (!shift))
		{
			ReallyToggleCameras();
			flag = 1;
		}
		else if((key == command_key[KEY_OPEN_AUDIO]) && (!ctrl) && (!alt) && (!shift))
		{
			ReallyToggleAudio();
			flag = 1;
		}
		else if((key == command_key[KEY_OPEN_PTZ]) && (!ctrl) && (!alt) && (!shift))
		{
			ReallyTogglePTZ();
			flag = 1;
		}
	}
	else
	{
		if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_0]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(0);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_1]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(1);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_2]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(2);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_3]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(3);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_4]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(4);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_5]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(5);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_6]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(6);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_7]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(7);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_8]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(8);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_9]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(9);
		}
	}
	return(flag);
}

int	MyWin::HandlePushForEmbedded(int xx, int yy)
{
int	loop;

	int flag = 0;
	if(embedded_app_cnt > 0)
	{
		if(Fl::event_button() == FL_LEFT_MOUSE)
		{
			for(loop = 0;loop < 10;loop++)
			{
				EmbedAppWindow *eaw = embedded_app[loop];
				if(eaw != NULL)
				{
					int nx1 = (eaw->my_x + eaw->my_w) - 20;
					int ny1 = h() - 20;
					int nx2 = (eaw->my_x + eaw->my_w) - 10;
					int ny2 = (h() - 20) + 10; 

					if((xx > nx1)
					&& (yy > ny1)
					&& (xx < nx2)
					&& (yy < ny2))
					{
						RemoveEmbeddedWindow(eaw);
						flag = 1;
					}
				}
			}
		}
	}
	return(flag);
}

int	MyWin::HandleReleaseForSplit()
{
	int flag = 0;
	int sz_w = w();
	int sz_h = h();
	int cols = 1;
	if(source_cnt == 1)
	{
		sz_w = w();
		sz_h = h();
		cols = 1;
	}
	else if(source_cnt < 5)
	{
		sz_w = w() / 2;
		sz_h = h() / 2;
		cols = 2;
	}
	else if(source_cnt < 10)
	{
		sz_w = w() / 3;
		sz_h = h() / 3;
		cols = 3;
	}
	int actual_x = Fl::event_x();
	int actual_y = Fl::event_y();
	int xx = actual_x / sz_w;
	int yy = actual_y / sz_h;
	int position = (yy * cols) + xx;
	if((position > -1) && (position < source_cnt))
	{
		if((actual_x > split_bx[position]) && (actual_x < split_bx[position] + 20)
		&& (actual_y > split_by[position]) && (actual_y < split_by[position] + 20))
		{
			RemoveSource(position);
		}
		if((actual_x > split_rx[position]) && (actual_x < split_rx[position] + 14)
		&& (actual_y > split_ry[position]) && (actual_y < split_ry[position] + 14))
		{
			ToggleRecord(position);
		}
		else
		{
			DisplayCamera(position);
			split = 0;
		}
		flag = 1;
	}
	return(flag);
}

int	MyWin::HandlePushToSelectImmediate(Camera *cam)
{
int	loop;

	int newly_selected = 0;
	if(Fl::event_button() == FL_LEFT_MOUSE)
	{
		if((immediate_drawing_window->selected_widget == NULL)
		|| (((immediate_drawing_window->mode != DRAWING_MODE_LINE))
			&& (immediate_drawing_window->mode != DRAWING_MODE_POLYGON)
			&& (immediate_drawing_window->mode != DRAWING_MODE_POLYGON_PASSTHRU)
			&& (immediate_drawing_window->mode != DRAWING_MODE_RECTANGLE_PASSTHRU)
			&& (immediate_drawing_window->mode != DRAWING_MODE_LOOP)))
		{
			int xx = Fl::event_x();
			int yy = Fl::event_y();
			if(cam->immediate_list != NULL)
			{
				Immediate *s_wid = NULL;
				for(loop = 0;loop < cam->immediate_cnt;loop++)
				{
					Immediate *wid = cam->immediate_list[loop];
					if(wid != NULL)
					{
						if(wid->layer == cam->edit_layer)
						{
							if((xx > wid->x())
							&& (yy > wid->y())
							&& (xx < (wid->x() + wid->w()))
							&& (yy < (wid->y() + wid->h())))
							{
								if(((immediate_drawing_window->mode == wid->immediate_type))
								|| (immediate_drawing_window->mode == DRAWING_MODE_DELETE)
								|| (immediate_drawing_window->mode == DRAWING_MODE_HIDE))
								{
									if(wid->draw_it == 1)
									{
										s_wid = wid;
									}
								}
							}
						}
					}
				}
				if((immediate_drawing_window->selected_widget == NULL) && (s_wid != NULL))
				{
					newly_selected = 1;
				}
				immediate_drawing_window->selected_widget = s_wid;
			}
		}
	}
	return(newly_selected);
}

int	MyWin::HandlePushToEditImmediate(Camera *cam)
{
	int flag = 0;
	immediate_drawing_window->redraw();
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	if((xx > cam->image_sx)
	&& (yy > cam->image_sy)
	&& (xx < cam->image_sx + cam->width)
	&& (yy < cam->image_sy + cam->height))
	{
		int grid_sz = immediate_drawing_window->grid_size;
		xx = force_to_grid(grid_sz, xx - cam->image_sx);
		yy = force_to_grid(grid_sz, yy - cam->image_sy);
		xx += cam->image_sx;
		yy += cam->image_sy;
		if((immediate_drawing_window->mode == DRAWING_MODE_LINE)
		|| (immediate_drawing_window->mode == DRAWING_MODE_POLYGON)
		|| (immediate_drawing_window->mode == DRAWING_MODE_POLYGON_PASSTHRU)
		|| (immediate_drawing_window->mode == DRAWING_MODE_FREEHAND)
		|| (immediate_drawing_window->mode == DRAWING_MODE_LOOP))
		{
			if(Fl::event_button() == FL_RIGHT_MOUSE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					immediate_drawing_window->selected_widget->actively_drawing = 0;
					Immediate *im = (Immediate *)immediate_drawing_window->selected_widget;
					im->orig_w = im->w();
					im->orig_h = im->h();
				}
				immediate_drawing_window->selected_widget = NULL;
				flag = 1;
			}
			else 
			{
				if(immediate_drawing_window->selected_widget == NULL)
				{
					Immediate *im = cam->EventInImmediate();
					if(im == NULL)
					{
						ImmediateDrawingWindow *idw = immediate_drawing_window;
						Immediate *im = new Immediate(this, cam, idw, cam->image_sx, cam->image_sy, cam->width, cam->height);
						immediate_drawing_window->selected_widget = im;
						cam->AddImmediate(im);
						add(im);
						im->actively_drawing = 1;
						im->line->width = idw->line_size;
						im->line->red = idw->line_color_red;
						im->line->green = idw->line_color_green;
						im->line->blue = idw->line_color_blue;
						im->line->alpha = idw->line_color_alpha;
						im->line->style = idw->line_style;
						im->line->key = idw->freehand_key;
						im->line->freehand_mat = idw->freehand_mat.clone();
						im->line->AddPoint(xx, yy);
						flag = 1;
					}
				}
				else
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->layer == cam->edit_layer)
					{
						if(im->line != NULL)
						{
							if(im->actively_drawing == 1)
							{
								im->line->width = idw->line_size;
								im->line->red = idw->line_color_red;
								im->line->green = idw->line_color_green;
								im->line->blue = idw->line_color_blue;
								im->line->alpha = idw->line_color_alpha;
								im->line->style = idw->line_style;
								im->line->key = idw->freehand_key;
								if(immediate_drawing_window->mode != DRAWING_MODE_FREEHAND)
								{
									im->line->AddPoint(xx, yy);
								}
								flag = 1;
							}
						}
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_TEXT)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				if(immediate_drawing_window->selected_widget == NULL)
				{
					if((xx > cam->image_sx)
					&& (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width)
					&& (yy < cam->image_sy + cam->height))
					{
						Immediate *im = cam->EventInImmediate();
						if(im == NULL)
						{
							ImmediateDrawingWindow *idw = immediate_drawing_window;
							int dist_w = cam->width - (xx - cam->image_sx);
							int dist_h = cam->height - (yy - cam->image_sy);
							Immediate *im = new Immediate(this, cam, idw, xx, yy, dist_w, dist_h);
							immediate_drawing_window->selected_widget = im;
							im->orig_w = im->w();
							im->orig_h = im->h();
							cam->AddImmediate(im);
							add(im);
							flag = 1;
						}
					}
				}
				else
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->layer == cam->edit_layer)
					{
						if(im->text != NULL)
						{
							im->text->italic = idw->text_italic_button->value();
							im->text->bold = idw->text_bold_button->value();
							im->text->outline = idw->text_outline_button->value();
							im->text->font_alpha = idw->font_color_alpha;
							im->text->background_alpha = idw->back_color_alpha;
							im->text->outline_alpha = idw->outline_color_alpha;

							im->text->textfont(idw->font_num);
							im->text->textsize(idw->font_size);
							im->text->textcolor(fl_rgb_color(idw->font_color_red, idw->font_color_green, idw->font_color_blue));
							im->text->color(fl_rgb_color(idw->back_color_red, idw->back_color_green, idw->back_color_blue));
							im->text->box(idw->text_box_type);
							im->text->box_type = idw->text_box_type;
							im->text->take_focus();
						}
						im->redraw();
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				ImmediateDrawingWindow *idw = immediate_drawing_window;
				if(idw->selected_widget == NULL)
				{
					if((xx > cam->image_sx)
					&& (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width)
					&& (yy < cam->image_sy + cam->height))
					{
						Immediate *im = cam->EventInImmediate();
						if(im == NULL)
						{
							Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
							immediate_drawing_window->selected_widget = im;
							cam->AddImmediate(im);
							add(im);
							flag = 1;
						}
					}
				}
				else
				{
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->layer == cam->edit_layer)
					{
						if(im->rectangle != NULL)
						{
							im->rectangle->width = idw->rectangle_size;
							im->rectangle->red = idw->rectangle_color_red;
							im->rectangle->green = idw->rectangle_color_green;
							im->rectangle->blue = idw->rectangle_color_blue;
							im->rectangle->alpha = idw->rectangle_color_alpha;
							im->rectangle->style = idw->rectangle_style;
							im->rectangle->filled = idw->rectangle_filled;
							im->rectangle->square = idw->rectangle_square;
							im->rectangle->erase = idw->rectangle_erase;
						}
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE_PASSTHRU)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				ImmediateDrawingWindow *idw = immediate_drawing_window;
				if(idw->selected_widget == NULL)
				{
					if((xx > cam->image_sx)
					&& (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width)
					&& (yy < cam->image_sy + cam->height))
					{
						Immediate *im = cam->EventInImmediate();
						if(im == NULL)
						{
							Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
							immediate_drawing_window->selected_widget = im;
							cam->AddImmediate(im);
							add(im);
							flag = 1;
						}
					}
				}
				else
				{
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->layer == cam->edit_layer)
					{
						if(im->rectangle != NULL)
						{
							im->rectangle->width = 1;
							im->rectangle->red = 255;
							im->rectangle->green = 255;
							im->rectangle->blue = 255;
							im->rectangle->alpha = 255;
							im->rectangle->style = FL_SOLID;
							im->rectangle->filled = 0;
							im->rectangle->square = 0;
							im->rectangle->erase = 0;
						}
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_ELLIPSE)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				ImmediateDrawingWindow *idw = immediate_drawing_window;
				if(idw->selected_widget == NULL)
				{
					if((xx > cam->image_sx)
					&& (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width)
					&& (yy < cam->image_sy + cam->height))
					{
						Immediate *im = cam->EventInImmediate();
						if(im == NULL)
						{
							Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
							immediate_drawing_window->selected_widget = im;
							cam->AddImmediate(im);
							add(im);
							flag = 1;
						}
					}
				}
				else
				{
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->layer == cam->edit_layer)
					{
						if(im->ellipse != NULL)
						{
							im->ellipse->width = idw->rectangle_size;
							im->ellipse->red = idw->rectangle_color_red;
							im->ellipse->green = idw->rectangle_color_green;
							im->ellipse->blue = idw->rectangle_color_blue;
							im->ellipse->alpha = idw->rectangle_color_alpha;
							im->ellipse->style = idw->rectangle_style;
							im->ellipse->filled = idw->rectangle_filled;
							im->ellipse->square = idw->rectangle_square;
							im->ellipse->erase = idw->rectangle_erase;
						}
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_ELLIPSE_PASSTHRU)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				ImmediateDrawingWindow *idw = immediate_drawing_window;
				if(idw->selected_widget == NULL)
				{
					if((xx > cam->image_sx)
					&& (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width)
					&& (yy < cam->image_sy + cam->height))
					{
						Immediate *im = cam->EventInImmediate();
						if(im == NULL)
						{
							Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
							immediate_drawing_window->selected_widget = im;
							cam->AddImmediate(im);
							add(im);
							flag = 1;
						}
					}
				}
				else
				{
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->layer == cam->edit_layer)
					{
						if(im->ellipse_passthru != NULL)
						{
							im->ellipse_passthru->width = idw->rectangle_size;
							im->ellipse_passthru->red = idw->rectangle_color_red;
							im->ellipse_passthru->green = idw->rectangle_color_green;
							im->ellipse_passthru->blue = idw->rectangle_color_blue;
							im->ellipse_passthru->alpha = idw->rectangle_color_alpha;
							im->ellipse_passthru->style = idw->rectangle_style;
							im->ellipse_passthru->filled = idw->rectangle_filled;
							im->ellipse_passthru->square = idw->rectangle_square;
							im->ellipse_passthru->erase = idw->rectangle_erase;
						}
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_IMAGE)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				ImmediateDrawingWindow *idw = immediate_drawing_window;
				if(idw->selected_widget == NULL)
				{
					if((xx > cam->image_sx)
					&& (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width)
					&& (yy < cam->image_sy + cam->height))
					{
						Immediate *im = cam->EventInImmediate();
						if(im == NULL)
						{
							Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
							immediate_drawing_window->selected_widget = im;
							cam->AddImmediate(im);
							add(im);
							flag = 1;
						}
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_PIXELATE)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				ImmediateDrawingWindow *idw = immediate_drawing_window;
				if(idw->selected_widget == NULL)
				{
					if((xx > cam->image_sx)
					&& (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width)
					&& (yy < cam->image_sy + cam->height))
					{
						Immediate *im = cam->EventInImmediate();
						if(im == NULL)
						{
							Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
							immediate_drawing_window->selected_widget = im;
							cam->AddImmediate(im);
							add(im);
							flag = 1;
						}
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_DELETE)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					Immediate *wid = immediate_drawing_window->selected_widget;
					if(wid->layer == cam->edit_layer)
					{
						immediate_drawing_window->ClearSelectedWidget();
						cam->RemoveImmediate(wid);
						Fl::delete_widget(wid);
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_HIDE)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					Immediate *wid = immediate_drawing_window->selected_widget;
					if(wid->layer == cam->edit_layer)
					{
						immediate_drawing_window->ClearSelectedWidget();
						wid->Hide();
						wid->redraw();
					}
				}
			}
		}
	}
	return(flag);
}

void	MyWin::ImmediateNewlySelectedHighlight()
{
	immediate_drawing_window->redraw();
}

int	MyWin::DoMarkInterest()
{
int	loop;

	int flag = 0;
	if(interest_cnt < 100)
	{
		int off_x = (w() / 2) - (camera[current_source]->width / 2);
		int off_y = (h() / 2) - (camera[current_source]->height / 2);
		int xx = Fl::event_x();
		int yy = Fl::event_y();

		if((xx > off_x)
		&& (yy > off_y)
		&& (xx < off_x + camera[current_source]->width)
		&& (yy < off_y + camera[current_source]->height))
		{
			int nx = (10.0 / (double)camera[current_source]->width) * (double)(xx - off_x);
			int ny = (10.0 / (double)camera[current_source]->height) * (double)(yy - off_y);
			int no_go = 0;
			for(loop = 0;loop < interest_cnt;loop++)
			{
				if((interest_x[loop] == nx)
				&& (interest_y[loop] == ny))
				{
					no_go = 1;
				}
			}
			if(no_go == 0)
			{
				interest_x[interest_cnt] = nx;
				interest_y[interest_cnt] = ny;
				interest_cnt++;
			}
			flag = 1;
		}
	}
	return(flag);
}

int	MyWin::HandlePushForPTZ(Camera *cam)
{
int	loop;

	int flag = 0;
	int no_go = 0;
	if(use_mousewheel == 0)
	{
		no_go = 1;
	}
	if(no_go == 0)
	{
		Camera *cam = DisplayedCamera();
		if(cam->ptz_lock_interface != -1)
		{
			int instance = -1;
			if(ptz_window[cam->ptz_lock_interface] != NULL)
			{
				instance = ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
			}
			if(instance != -1)
			{
				if(Fl::event_button() == FL_LEFT_MOUSE)
				{
					if(ImageWindowButtonHit(Fl::event_x(), Fl::event_y()) == 0)
					{
						if(ptz_joystick == 1)
						{
							int xx = Fl::event_x() - (w() / 2);
							int yy = Fl::event_y() - (h() / 2);
							if((xx > -100) && (yy > -100)
							&& (xx < 100) && (yy < 100))
							{
								ptz_joystick_x = xx;
								ptz_joystick_y = yy;
								Fl::add_timeout(0.01, ptz_joystick_cb, this);
								flag = 1;
							}
						}
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						start_ptz_drag_x = xx;
						start_ptz_drag_y = yy;
						ptz_dragged = 0;
					}
					else
					{
						image_window_button = 1;
					}
				}
				else if(Fl::event_button() == FL_MIDDLE_MOUSE)
				{
					ptz_middle_mouse++;
					if(ptz_middle_mouse > 4)
					{
						ptz_middle_mouse = 0;
					}
					if(ptz_middle_mouse == 1)
					{
						CenterMessage("Zoom", 100);
						ptz_window[instance]->zoom_label->labelcolor(CYAN);
						ptz_window[instance]->focus_label->labelcolor(YELLOW);
						ptz_zoomer = 0;
						ptz_window[instance]->ptz_zoomer_speed = 0;
						ViscaCommand(instance, PTZ_ZOOM_STOP);
					}
					else if(ptz_middle_mouse == 2)
					{
						CenterMessage("Focus", 100);
						ptz_window[instance]->zoom_label->labelcolor(YELLOW);
						ptz_window[instance]->focus_label->labelcolor(CYAN);
						ptz_zoomer = 0;
						ptz_window[instance]->ptz_zoomer_speed = 0;
						ViscaCommand(instance, PTZ_ZOOM_STOP);
					}
					else if(ptz_middle_mouse == 3)
					{
						CenterMessage("Zoom with speed control", 100);
						ptz_window[instance]->zoom_label->labelcolor(CYAN);
						ptz_window[instance]->focus_label->labelcolor(YELLOW);
					}
					else if(ptz_middle_mouse == 4)
					{
						CenterMessage("Interface Transparency", 100);
					}
					else
					{
						CenterMessage("Digital Scaling", 100);
					}
					flag = 1;
				}
			}
		}
	}
	return(flag);
}

int	MyWin::HandleReleaseForImmediate(Camera *cam)
{
	int flag = 0;
	if(im_drawing_mode == 1)
	{
		if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->rectangle != NULL)
					{
						im->CompleteRectangle(xx, yy);
						idw->ClearSelectedWidget();
					}
					im->redraw();
				}
				flag = 1;
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE_PASSTHRU)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->rectangle_passthru != NULL)
					{
						im->CompleteRectangle(xx, yy);
						im->rectangle_passthru->selecting = 0;
						idw->ClearSelectedWidget();
					}
					im->redraw();
				}
				flag = 1;
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_ELLIPSE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->ellipse != NULL)
					{
						im->CompleteRectangle(xx, yy);
						idw->ClearSelectedWidget();
					}
					im->redraw();
					flag = 1;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_ELLIPSE_PASSTHRU)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->ellipse_passthru != NULL)
					{
						im->CompleteRectangle(xx, yy);
						idw->ClearSelectedWidget();
					}
					im->redraw();
					flag = 1;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_IMAGE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->image_im != NULL)
					{
						im->CompleteRectangle(xx, yy);
						idw->ClearSelectedWidget();
					}
					im->redraw();
					flag = 1;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_PIXELATE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->pixelate != NULL)
					{
						im->CompleteRectangle(xx, yy);
						idw->ClearSelectedWidget();
					}
					im->redraw();
					flag = 1;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_FREEHAND)
		{
			ImmediateDrawingWindow *idw = immediate_drawing_window;
			Immediate *im = (Immediate *)idw->selected_widget;
			if(im != NULL)
			{
				im->orig_w = im->w();
				im->orig_h = im->h();
			}
			idw->ClearSelectedWidget();
			flag = 1;
		}
	}
	return(flag);
}

int	MyWin::HandleRelease(Camera *cam)
{
	int flag = 0;
	if((zoom_boxing == 1)
	&& (drag_start_x > -1)
	&& (drag_start_y > -1)
	&& (move_corner == 0)
	&& (resize_corner == 0)
	&& (restore_corner == 0))
	{
		reset_button_cb(NULL, this);
		int drag_stop_x = Fl::event_x();
		int drag_stop_y = Fl::event_y();
		if(drag_stop_x < drag_start_x)
		{
			int tmp = drag_stop_x;
			drag_stop_x = drag_start_x;
			drag_start_x = tmp;
		}
		if(drag_stop_y < drag_start_y)
		{
			int tmp = drag_stop_y;
			drag_stop_y = drag_start_y;
			drag_start_y = tmp;
		}
		int diff_x = abs(drag_stop_x - drag_start_x);
		int diff_y = abs(drag_stop_y - drag_start_y);
		while((diff_x % 16) != 0)
		{
			diff_x++;
		}
		while((diff_y % 16) != 0)
		{
			diff_y++;
		}
		if(diff_x < 320) diff_x = 320;
		if(diff_x > w()) diff_x = w();
		if(diff_y < 240) diff_y = 240;
		if(diff_y > h()) diff_y = h();
		if(zoom_boxing == 1)
		{
			zoom_boxing = 0;
			if((drag_start_x >= cam->image_sx)
			&& (drag_start_y >= cam->image_sy))
			{
				double aspect = (double)output_height / (double)output_width;
				diff_y = (int)((double)diff_x * aspect);
				if((drag_start_x + diff_x <= cam->image_sx + camera[current_source]->width)
				&& (drag_start_y + diff_y <= cam->image_sy + camera[current_source]->height))
				{
					cam->zoom_box_display = 1;
					cam->zoom_box_x = drag_start_x;
					cam->zoom_box_y = drag_start_y;
					cam->zoom_box_w = diff_x;
					cam->zoom_box_h = diff_y;
					zoom_box_button->copy_label("Cease Box Zoom");
				}
			}
		}
		flag = 1;
	}
	dragging = 0;
	save_offset_x += offset_x;
	save_offset_y += offset_y;
	offset_x = 0;
	offset_y = 0;
	fl_cursor(FL_CURSOR_DEFAULT);
	return(flag);
}

int	MyWin::HandleReleaseForPTZ(Camera *cam)
{
	int flag = 0;
	if((mark_interest == 0) && (move_corner == 0) && (resize_corner == 0) && (restore_corner == 0))
	{
		if(cam->ptz_lock_interface != -1)
		{
			int instance = -1;
			if(ptz_window[cam->ptz_lock_interface] != NULL)
			{
				instance = ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
			}
			if(instance != -1)
			{
				if(ptz_joystick == 1)
				{
					if(ptz_window[instance]->ptz_current_interface != NULL)
					{
						VISCA_set_pantilt_stop(ptz_window[instance]->ptz_current_interface, ptz_window[instance]->ptz_current_camera, 0, 0);
						ptz_joystick_x = 0;
						ptz_joystick_y = 0;
					}
				}
				else
				{
					if(Fl::event_button() == FL_LEFT_MOUSE)
					{
						if((ptz_dragged == 0) && (image_window_button == 0))
						{
							int xx = Fl::event_x();
							int yy = Fl::event_y();
							if((xx >= cam->image_sx)
							&& (yy >= cam->image_sy)
							&& (xx <= (cam->image_sx + cam->width))
							&& (yy <= (cam->image_sy + cam->height)))
							{
								PTZ_MoveTo(instance, 20, 20, xx, yy);
							}
						}
						image_window_button = 0;
					}
				}
				flag = 1;
			}
		}
	}
	return(flag);
}

void	MyWin::ShowPTZ(Camera *cam, int xx, int yy)
{
int	loop;

	if(ptz_mode == 1)
	{
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				if(retain_ptz == 0)
				{
					if(ptz_window[loop]->in_motion == 0)
					{
						int show_m = 0;
						int ny = ptz_window[loop]->y();
						if(ny < 0) ny = 0;
						if(ny > h()) ny = h();
						if((xx > ptz_window[loop]->x()) && (yy >= ny)
						&& (xx < ptz_window[loop]->x() + ptz_window[loop]->w())
						&& (yy < ny + ptz_window[loop]->h()))
						{
							show_m = 1;
						}
						ReallyTogglePTZ(loop, show_m);
					}
				}
				else
				{
					if(ptz_window[loop]->showing == 1)
					{
						ptz_window[loop]->TrueShow();
					}
				}
			}
		}
	}
}

void	MyWin::ReallyTogglePTZ(int idx, int show_m)
{
	if(ptz_mode == 1)
	{
		if(ptz_window[idx] != NULL)
		{
			if(show_m == 1)
			{
				if(ptz_window[idx]->showing == 1)
				{
					if(!ptz_window[idx]->visible())
					{
						ptz_window[idx]->show();
					}
				}
			}
			else
			{
				if(ptz_window[idx]->pinned == 0)
				{
					if(ptz_window[idx]->visible())
					{
						ptz_window[idx]->hide();
					}
				}
			}
		}
	}
}

void	MyWin::ReallyTogglePTZ()
{
int	loop;

	if(ptz_mode == 1)
	{
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				if(!ptz_window[loop]->visible())
				{
					if(ptz_window[loop]->showing == 1)
					{
						ptz_window[loop]->show();
						retain_ptz = 1;
					}
				}
				else
				{
					if(ptz_window[loop]->pinned == 0)
					{
						if(ptz_window[loop]->visible())
						{
							ptz_window[loop]->hide();
							retain_ptz = 0;
						}
					}
				}
			}
		}
	}
}

void	MyWin::ShowAudio(int xx, int yy)
{
	if(audio == 1)
	{
		if(retain_audio == 0)
		{
			int bars = (audio_thumbnail_cnt / 7) + 1;
			int lower_edge = 10 + (bars * 70);
			int show_m = 0;
			int ny = audio_thumbnail_group->y();
			if(ny < 0) ny = 0;
			if(ny > h()) ny = h();
			if((xx > audio_thumbnail_group->x()) && (yy >= ny)
			&& (xx < audio_thumbnail_group->x() + audio_thumbnail_group->w())
			&& (yy < ny + audio_thumbnail_group->h()))
			{
				show_m = 1;
			}
			ReallyToggleAudio(show_m);
		}
		else
		{
			audio_thumbnail_group->TrueShow();
		}
	}
}

void	MyWin::ReallyToggleAudio(int show_m)
{
int	loop;

	if(audio == 1)
	{
		if(show_m == 1)
		{
			if(audio_thumbnail_group->in_motion == 0)
			{
				if(!audio_thumbnail_group->visible())
				{
					audio_thumbnail_group->show();
				}
			}
		}
		else
		{
			audio_thumbnail_group->hide();
			for(loop = 0;loop < audio_thumbnail_cnt;loop++)
			{
				PulseAudioButton *pat = audio_thumbnail[loop];
				if(pat != NULL)
				{
					if(pat->alias_in->visible())
					{
						pulse_audio_edit_alias(NULL, pat);
					}
				}
			}
		}
	}
}

void	MyWin::ReallyToggleAudio()
{
int	loop;

	if(audio == 1)
	{
		if(!audio_thumbnail_group->visible())
		{
			if(audio_thumbnail_group->in_motion == 0)
			{
				audio_thumbnail_group->show();
				retain_audio = 1;
			}
		}
		else
		{
			audio_thumbnail_group->hide();
			for(loop = 0;loop < audio_thumbnail_cnt;loop++)
			{
				PulseAudioButton *pat = audio_thumbnail[loop];
				if(pat != NULL)
				{
					if(pat->alias_in->visible())
					{
						pulse_audio_edit_alias(NULL, pat);
					}
				}
			}
			retain_audio = 0;
		}
	}
}

void	MyWin::ShowVideoThumbs(int xx, int yy)
{
	if(retain_cameras == 0)
	{
		if(video_thumbnail_group->in_motion == 0)
		{
			int show_m = 0;
			int nx = video_thumbnail_group->x();
			if(nx < 0) nx = 0;
			if(nx > w()) nx = w();
			if((xx >= nx) && (yy >= video_thumbnail_group->y())
			&& (xx < nx + video_thumbnail_group->w())
			&& (yy < video_thumbnail_group->y() + video_thumbnail_group->h()))
			{
				show_m = 1;
			}
			ReallyToggleCameras(show_m);
		}
	}
	else
	{
		video_thumbnail_group->TrueShow();
	}
}

void	MyWin::ReallyToggleCameras(int show_m)
{
	if(show_m == 1)
	{
		if(!video_thumbnail_group->visible())
		{
			video_thumbnail_group->show();
		}
	}
	else
	{
		if(video_thumbnail_group->visible())
		{
			video_thumbnail_group->hide();
		}
	}
}

void	MyWin::ReallyToggleCameras()
{
	if(!video_thumbnail_group->visible())
	{
		video_thumbnail_group->show();
		retain_cameras = 1;
	}
	else
	{
		video_thumbnail_group->hide();
		retain_cameras = 0;
	}
}

void	MyWin::PlaceButtonGroup(int side)
{
int	loop;

	button_group_side = side;
	if(side == SIDE_RIGHT)
	{
		button_group->resize(w() - button_group->w(), button_group->y(), button_group->w(), button_group->h());
		button_group->direction = OPEN_LEFT;
		video_thumbnail_group->resize(10 , video_thumbnail_group->y() , video_thumbnail_group->w() , video_thumbnail_group->h());
		video_thumbnail_group->direction = OPEN_RIGHT;
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				ptz_window[loop]->resize(10 + (loop * 300), ptz_window[loop]->y(), ptz_window[loop]->w(), ptz_window[loop]->h());
			}
		}
	}
	else if(side == SIDE_LEFT)
	{
		button_group->resize(0, button_group->y(), button_group->w(), button_group->h());
		button_group->direction = OPEN_RIGHT;
		video_thumbnail_group->resize(w() - video_thumbnail_group->w(), video_thumbnail_group->y(), video_thumbnail_group->w(), video_thumbnail_group->h());
		video_thumbnail_group->direction = OPEN_LEFT;
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				ptz_window[loop]->resize(((w() - 10) - ptz_window[loop]->w()) - (300 * loop), ptz_window[loop]->y(), ptz_window[loop]->w(), ptz_window[loop]->h());
			}
		}
	}
}

int	MyWin::HandleMove(Camera *cam)
{
int	loop;

	int flag = 0;
	if(split == 0)
	{
		mouse_moving = 100;
		move_corner = 0;
		resize_corner = 0;
		restore_corner = 0;
		highlight_image_windows = 0;
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		if(mark_interest == 1)
		{
			int off_x = image_origin_x;
			int off_y = image_origin_y;

			if((xx > off_x)
			&& (yy > off_y)
			&& (xx < off_x + camera[current_source]->width)
			&& (yy < off_y + camera[current_source]->height))
			{
				int nx = (10.0 / (double)camera[current_source]->width) * (double)(xx - off_x);
				int ny = (10.0 / (double)camera[current_source]->height) * (double)(yy - off_y);
				nominal_interest_x = nx;
				nominal_interest_y = ny;
			}
			else
			{
				nominal_interest_x = -1;
				nominal_interest_y = -1;
			}
		}
		if((xx < cam->image_sx) || (xx > (cam->image_sx + cam->display_width))
		|| (yy < cam->image_sy) || (yy > (cam->image_sy + cam->display_height)))
		{
			fl_cursor(FL_CURSOR_DEFAULT);
			highlight_image_windows = 0;
		}
		else
		{
			highlight_image_windows = 1;
			if(resize_frame != NULL)
			{
				if(resize_frame->visible())
				{
					flag = resize_frame->handle(FL_MOVE);
				}
			}
		}
		if(cam->fps > 0.0)
		{
			buttonized_visible = 0;
			int show_m = 0;
			int nx = button_group->x();
			if(nx < 0) nx = 0;
			if(nx > w()) nx = w();
			if((xx >= nx) && (yy >= button_group->y())
			&& (xx < nx + button_group->w())
			&& (yy < button_group->y() + button_group->h()))
			{
				show_m = 1;
			}
			if(show_m == 1)
			{
				if(buttons_shown == 0)
				{
					if(!button_group->visible())
					{
						if(button_group->in_motion == 0)
						{
							button_group->show();
						}
					}
					buttons_shown = 1;
				}
			}
			else
			{
				if(retain_commands == 1)
				{
					if(buttons_shown == 0)
					{
						if(button_group->in_motion == 0)
						{
							button_group->show();
						}
						buttons_shown = 1;
					}
				}
				if((xx > 280) && (yy > (Fl::h() - 180)))
				{
					buttonized_visible = 1;
				}
				if(buttons_shown == 1)
				{
					if(retain_commands == 0)
					{
						if(button_group->visible())
						{
							if(button_group->in_motion == 0)
							{
								button_group->hide();
							}
						}
						buttons_shown = 0;
					}
				}
				ShowVideoThumbs(xx, yy);
				ShowPTZ(cam, xx, yy);
				ShowAudio(xx, yy);
				if(embedded_app_cnt > 0)
				{
					for(loop = 0;loop < 10;loop++)
					{
						EmbedAppWindow *eaw = embedded_app[loop];
						if(eaw != NULL)
						{
							int alive = eaw->TestWindow();
							if(alive == 1)
							{
								if(eaw->viz == 1)
								{
									if((xx > eaw->my_x)
									&& (yy > eaw->my_y)
									&& (xx < (eaw->my_x + eaw->my_w)))
									{
										eaw->my_show();
										eaw->show();
										eaw->redraw();
									}
									else
									{
										eaw->my_hide();
									}
								}
								else
								{
									if((xx > eaw->my_x)
									&& (yy > h() - 25)
									&& (xx < (eaw->my_x + eaw->my_w)))
									{
										eaw->my_show();
										eaw->show();
										eaw->redraw();
									}
								}
							}
							else
							{
								RemoveEmbeddedWindow(eaw);
								SetErrorMessage("Command is no longer providing a window.");
							}
						}
					}
				}
				if((cam->image_sx > 0) && (cam->image_sy > 0))
				{
					int diff_x = xx - cam->image_sx;
					int diff_y = yy - cam->image_sy;
					if((diff_x < 25) && (diff_y < 25)
					&& (diff_x >= 0) && (diff_y >= 0))
					{
						move_corner = 1;
					}
				}
				if((cam->display_width < w()) && (cam->display_height < h()))
				{
					int diff_x = (cam->image_sx + cam->display_width) - xx;
					int diff_y = (cam->image_sy + cam->display_height) - yy;
					if((diff_x < 25) && (diff_y < 25)
					&& (diff_x >= 0) && (diff_y >= 0))
					{
						resize_corner = 1;
					}
				}
				if((cam->display_width != cam->width) && (cam->display_height != cam->height))
				{
					int diff_x = xx - cam->image_sx;
					int diff_y = (cam->image_sy + cam->display_height) - yy;
					if((diff_x < 25) && (diff_y < 25)
					&& (diff_x >= 0) && (diff_y >= 0))
					{
						restore_corner = 1;
					}
				}
			}
		}
	}
	else
	{
		if(buttons_shown == 1)
		{
			button_group->hide();
			buttons_shown = 0;
		}
	}
	return(flag);
}

int	MyWin::HandleImmediateDrag(Camera *cam)
{
	int flag = 0;
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	if((xx > cam->image_sx)
	&& (yy > cam->image_sy)
	&& (xx < cam->image_sx + cam->width)
	&& (yy < cam->image_sy + cam->height))
	{
		if(im_drawing_mode == 1)
		{
			if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->rectangle != NULL)
					{
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE_PASSTHRU)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->rectangle_passthru != NULL)
					{
						im->rectangle_passthru->selecting = 1;
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_ELLIPSE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->ellipse != NULL)
					{
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_ELLIPSE_PASSTHRU)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->ellipse_passthru != NULL)
					{
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_IMAGE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->image_im != NULL)
					{
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_PIXELATE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->pixelate != NULL)
					{
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_FREEHAND)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->line != NULL)
					{
						im->actively_drawing = 1;
						im->line->width = idw->line_size;
						im->line->red = idw->line_color_red;
						im->line->green = idw->line_color_green;
						im->line->blue = idw->line_color_blue;
						im->line->style = idw->line_style;
						im->line->key = idw->freehand_key;
						im->line->AddPoint(xx, yy);
						flag = 1;
					}
				}
			}
		}
	}
	return(flag);
}

int	MyWin::HandlePTZDrag()
{
	int flag = 0;
	int xx = Fl::event_x() - (w() / 2);
	int yy = Fl::event_y() - (h() / 2);
	if((xx > -100) && (yy > -100)
	&& (xx < 100) && (yy < 100))
	{
		ptz_joystick_x = xx;
		ptz_joystick_y = yy;
		Fl::add_timeout(0.01, ptz_joystick_cb, this);
		flag = 1;
	}
	return(flag);
}

int	MyWin::HandleDrag(Camera *cam)
{
	int flag = 0;
	if(move_corner == 1)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		int off_x = xx - cam->image_sx;
		int off_y = yy - cam->image_sy;
		cam->OffsetPositionImageWindows(off_x, off_y);
		cam->image_sx = xx;
		cam->image_sy = yy;
		flag = 1;
	}
	else if(resize_corner == 1)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		if((last_resize_drag_x > -1) && (last_resize_drag_y > -1))
		{
			int diff_x = xx - last_resize_drag_x;
			double factor = (double)(cam->display_width + diff_x) / (double)cam->display_width;
			double use_x = (double)cam->display_width * factor;
			double use_y = (double)cam->display_height * factor;
			if((use_x > 50) && (use_y > 50))
			{
				double factor_w = use_x / cam->display_width;
				double factor_h = use_y / cam->display_height;
				cam->display_width = use_x;
				cam->display_height = use_y;
			}
		}
		last_resize_drag_x = xx;
		last_resize_drag_y = yy;
	}
	else
	{
		if(cam->zoom > 1.0)
		{
			if((start_offset_x > -1) && (start_offset_y > -1))
			{
				int off_x = (start_offset_x - Fl::event_x());
				int off_y = (start_offset_y - Fl::event_y());
				offset_x += off_x;
				offset_y += off_y;
				start_offset_x = Fl::event_x();
				start_offset_y = Fl::event_y();
				dragging = 1;
			}
			flag = 1;
			fl_cursor(FL_CURSOR_MOVE);
		}
		else if(rubberband_mode == RUBBERBAND_MODE)
		{
			int x1 = last_push_x;
			int y1 = last_push_y;
			int x2 = Fl::event_x();
			int y2 = Fl::event_y();
			if(editing_misc_mode == EDITING_MISC_MOVE)
			{
				if(editing_misc_outer > -1)
				{
					if(misc_copy[editing_misc_outer] != NULL)
					{
						int ddx = x2 - last_push_x;
						int ddy = y2 - last_push_y;
						if(editing_misc_inner == -1)
						{
							misc_copy[editing_misc_outer]->xx += ddx;
							misc_copy[editing_misc_outer]->yy += ddy;
							if(misc_copy[editing_misc_outer]->type == MISC_COPY_TEXT)
							{
								int use_x = misc_copy[editing_misc_outer]->xx + cam->image_sx;
								int use_y = misc_copy[editing_misc_outer]->yy + cam->image_sy;
								int use_w = misc_copy[editing_misc_outer]->quick_text->w();
								int use_h = misc_copy[editing_misc_outer]->quick_text->h();
								misc_copy[editing_misc_outer]->quick_text->resize(use_x, use_y, use_w, use_h);
							}
						}
						else if(editing_misc_inner > -1)
						{
							misc_copy[editing_misc_outer]->dest_x[editing_misc_inner] += ddx;
							misc_copy[editing_misc_outer]->dest_y[editing_misc_inner] += ddy;
						}
					}
				}
				last_push_x = x2;
				last_push_y = y2;
			}
			else if(editing_misc_mode == EDITING_MISC_RESIZE)
			{
				if(editing_misc_outer > -1)
				{
					if(misc_copy[editing_misc_outer] != NULL)
					{
						int ddx = x2 - last_push_x;
						int ddy = y2 - last_push_y;
						if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
						{
							misc_copy[editing_misc_outer]->ww += ddx;
							misc_copy[editing_misc_outer]->hh += ddx;
						}
						else
						{
							misc_copy[editing_misc_outer]->ww += ddx;
							misc_copy[editing_misc_outer]->hh += ddy;
						}
						int sw = misc_copy[editing_misc_outer]->ww;
						int sh = misc_copy[editing_misc_outer]->hh;
						if(misc_copy[editing_misc_outer]->type == MISC_COPY_TEXT)
						{
							int use_x = misc_copy[editing_misc_outer]->quick_text->x();
							int use_y = misc_copy[editing_misc_outer]->quick_text->y();
							int use_w = misc_copy[editing_misc_outer]->ww;
							int use_h = misc_copy[editing_misc_outer]->hh;
							misc_copy[editing_misc_outer]->quick_text->resize(use_x, use_y, use_w, use_h);
						}
						if(!misc_copy[editing_misc_outer]->mat.empty())
						{
							cv::resize(misc_copy[editing_misc_outer]->mat, misc_copy[editing_misc_outer]->mat, cv::Size(sw, sh));
						}
					}
				}
				last_push_x = x2;
				last_push_y = y2;
			}
			else
			{
				if(Fl::event_button() == 1)
				{
					int diff_x = abs(x1 - x2);
					int diff_y = abs(y1 - y2);
					if((diff_x > 4) && (diff_y > 4))
					{
						if(x1 > x2)
						{
							int tmp = x1;
							x1 = x2;
							x2 = tmp;
						}
						if(y1 > y2)
						{
							int tmp = y1;
							y1 = y2;
							y2 = tmp;
						}
						rubberband_x = x1;
						rubberband_y = y1;
						rubberband_w = x2 - x1;
						rubberband_h = y2 - y1;
					}
				}
			}
		}
		else if(rubberband_mode == REPOSITION_MODE)
		{
			if(Fl::event_button() == 1)
			{
				Camera *cam = DisplayedCamera();
				if(cam != NULL)
				{
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					int dx = last_push_x - xx;
					int dy = last_push_y - yy;
					initial_video_out_x = cam->image_sx - dx;
					initial_video_out_y = cam->image_sy - dy;
					cam->image_sx -= dx;
					cam->image_sy -= dy;
					last_push_x = xx;
					last_push_y = yy;
				}
			}
		}
	}
	return(flag);
}

void	MyWin::MiscRemoveAll()
{
int	loop;
int	inner;

	Camera *cam = DisplayedCamera();
	for(loop = 0;loop < misc_copy_cnt;loop++)
	{
		if(misc_copy[loop] != NULL)
		{
			if(misc_copy[loop]->source == cam)
			{
				delete misc_copy[loop];
				misc_copy[loop] = NULL;
			}
		}
	}
}

void	MyWin::MiscRemoveLast()
{
int	loop;
int	inner;

	Camera *cam = DisplayedCamera();
	int last = -1;
	for(loop = 0;loop < misc_copy_cnt;loop++)
	{
		if(misc_copy[loop] != NULL)
		{
			if(misc_copy[loop]->source == cam)
			{
				last = loop;
			}
		}
	}
	if(last > -1)
	{
		delete misc_copy[last];
		misc_copy[last] = NULL;
	}
}

int	MyWin::InMiscPasted(int xx, int yy, int& r_outer, int& r_inner)
{
int	loop;
int	inner;

	int hit = 0;
	Camera *cam = DisplayedCamera();
	xx -= cam->image_sx;
	yy -= cam->image_sy;
	for(loop = 0;loop < misc_copy_cnt;loop++)
	{
		if(misc_copy[loop] != NULL)
		{
			if(misc_copy[loop]->display == 1)
			{
				if((misc_copy[loop]->type == MISC_COPY_STATIC)
				|| (misc_copy[loop]->type == MISC_COPY_DYNAMIC))
				{
					for(inner = 0;inner < misc_copy[loop]->destination_cnt;inner++)
					{
						if(misc_copy[loop]->destination[inner] == cam)
						{
							if(!misc_copy[loop]->mat.empty())
							{
								int use_x = misc_copy[loop]->dest_x[inner];
								int use_y = misc_copy[loop]->dest_y[inner];
								int use_w = misc_copy[loop]->ww;
								int use_h = misc_copy[loop]->hh;
								if((xx >= use_x) && (xx <= (use_x + use_w))
								&& (yy >= use_y) && (yy <= (use_y + use_h)))
								{
									hit = 1;
									r_outer = loop;
									r_inner = inner;
								}
							}
						}
					}
				}
				else
				{
					int use_x = misc_copy[loop]->xx;
					int use_y = misc_copy[loop]->yy;
					int use_w = misc_copy[loop]->ww;
					int use_h = misc_copy[loop]->hh;
					if((xx >= use_x) && (xx <= (use_x + use_w))
					&& (yy >= use_y) && (yy <= (use_y + use_h)))
					{
						hit = 1;
						r_outer = loop;
						r_inner = -1;
					}
				}
			}
		}
	}
	return(hit);
}

int	MyWin::HandleMousewheelResizeCapture(Camera *cam)
{
	int flag = 0;
	int suggest_w = camera[current_source]->width;
	int suggest_h = camera[current_source]->height;
	int ow = camera[current_source]->width;
	int oh = camera[current_source]->height;
	int nw = camera[current_source]->width;
	int nh = camera[current_source]->height;
	int direction = Fl::event_dy();
	if(direction > 0)
	{
		if(ow < w())
		{
			while((ow == nw) && (oh == nh) && (suggest_w < w()))
			{
				suggest_w *= 1.1;
				suggest_h *= 1.1;
				camera[current_source]->Resize(suggest_w, suggest_h);
				nw = camera[current_source]->width;
				nh = camera[current_source]->height;
			}
		}
	}
	else if(direction < 0)
	{
		if(ow > 320)
		{
			while((ow == nw) && (oh == nh) && (suggest_w > 320))
			{
				suggest_w *= 0.9;
				suggest_h *= 0.9;
				camera[current_source]->Resize(suggest_w, suggest_h);
				nw = camera[current_source]->width;
				nh = camera[current_source]->height;
			}
		}
	}
	flag = 1;
	return(flag);
}

int	MyWin::HandleMousewheelPTZ(Camera *cam)
{
	int flag = 0;
	if(cam->ptz_lock_interface != -1)
	{
		int instance = -1;
		if(ptz_window[cam->ptz_lock_interface] != NULL)
		{
			instance = ptz_window[cam->ptz_lock_interface]->ptz_interface_index;
		}
		if(instance != -1)
		{
			if(ptz_middle_mouse == 1)
			{
				int direction = Fl::event_dy();
				if(direction > 0)
				{
					if(ptz_zooming == 0)
					{
						ViscaCommand(instance, PTZ_ZOOM_IN);
						Fl::add_timeout(0.5, ptz_zoom_cb, this);
						flag = 1;
					}
				}
				else if(direction < 0)
				{
					if(ptz_zooming == 0)
					{
						ViscaCommand(instance, PTZ_ZOOM_OUT);
						Fl::add_timeout(0.5, ptz_zoom_cb, this);
						flag = 1;
					}
				}
			}
			else if(ptz_middle_mouse == 2)
			{
				int direction = Fl::event_dy();
				if(direction > 0)
				{
					ViscaCommand(instance, PTZ_FOCUS_FAR);
					Fl::add_timeout(0.1, ptz_focus_cb, this);
					flag = 1;
				}
				else if(direction < 0)
				{
					ViscaCommand(instance, PTZ_FOCUS_NEAR);
					Fl::add_timeout(0.1, ptz_focus_cb, this);
					flag = 1;
				}
			}
			else if(ptz_middle_mouse == 3)
			{
				ptz_zoomer += Fl::event_dy();
				if(ptz_zoomer > 0)
				{
					ptz_window[0]->ptz_zoomer_speed = abs(ptz_zoomer);
					if(ptz_window[0]->ptz_zoomer_speed > 20)
					{
						ptz_window[0]->ptz_zoomer_speed = 20;
					}
					ViscaCommand(instance, PTZ_ZOOM_IN);
				}
				else if(ptz_zoomer < 0)
				{
					ptz_window[0]->ptz_zoomer_speed = abs(ptz_zoomer);
					if(ptz_window[0]->ptz_zoomer_speed > 20)
					{
						ptz_window[0]->ptz_zoomer_speed = 20;
					}
					ViscaCommand(instance, PTZ_ZOOM_OUT);
				}
				else
				{
					ptz_window[0]->ptz_zoomer_speed = 0;
					ViscaCommand(instance, PTZ_ZOOM_STOP);
				}
				flag = 1;
			}
			else if(ptz_middle_mouse == 4)
			{
				unsigned char black_red = 0;
				unsigned char black_green = 0;
				unsigned char black_blue = 0;
				unsigned char black_alpha = 0;
				Fl::get_color(BLACK, black_red, black_green, black_blue, black_alpha);
				unsigned char dark_gray_red = 0;
				unsigned char dark_gray_green = 0;
				unsigned char dark_gray_blue = 0;
				unsigned char dark_gray_alpha = 0;
				Fl::get_color(DARK_GRAY, dark_gray_red, dark_gray_green, dark_gray_blue, dark_gray_alpha);
				int ii = black_alpha;
				int sy = Fl::event_dy();
				if(sy > 0)
				{
					ii++;
					if(ii > 255) ii = 255;
				}
				else
				{
					ii--;
					if(ii < 0) ii = 0;
				}
				black_alpha = ii;
				Fl::set_color(BLACK, black_red, black_green, black_blue, black_alpha);
				Fl::set_color(DARK_GRAY, dark_gray_red, dark_gray_green, dark_gray_blue, black_alpha);
				redraw();
			}
		}
	}
	return(flag);
}

int	MyWin::HandleMousewheel(Camera *cam)
{
int	loop;
static time_t	last_time = 0;

	int flag = 0;
	int no_go = 0;
	if(video_thumbnail_group->hovering == 1)
	{
		no_go = 1;
	}
	if(no_go == 0)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		int cx1 = (w() / 2) - 500;
		int cx2 = (w() / 2) + 500;
		int cy1 = (h() - 120);
		int cy2 = h();
		if((xx > cx1) && (xx < cx2)
		&& (yy > cy1) && (yy < cy2))
		{
			time_t diff = time(0) - last_time;
			if(diff > 1)
			{
				int direction = Fl::event_dy();
				if(direction > 0)
				{
					audio_display++;
					audio_display_timer = 200;
					if(audio_display > 3)
					{
						audio_display = 0;
					}
				}
				else
				{
					audio_display--;
					audio_display_timer = 200;
					if(audio_display < 0)
					{
						audio_display = 3;
					}
				}
				SaveAudioSettings("audio_settings.json");
				last_time = time(0);
			}
			no_go = 1;
		}
	}
	if(no_go == 0)
	{
		if(ptz_mode != 0)
		{
			for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
			{
				if(ptz_window[loop] != NULL)
				{
					if(ptz_window[loop]->hovering == 1)
					{
						no_go = 1;
					}
				}
			}
		}
	}
	if(no_go == 0)
	{
		if(cam != NULL)
		{
			int direction = Fl::event_dy();
			if(direction > 0)
			{
				cam->zoom += 0.01;
				if(cam->zoom > 4.0)
				{
					cam->zoom = 4.0;
				}
				flag = 1;
			}
			else if(direction < 0)
			{
				cam->zoom -= 0.1;
				if(cam->zoom <= 1.0)
				{
					cam->zoom = 1.0;
					offset_x = 0;
					offset_y = 0;
				}
				flag = 1;
			}
		}
	}
	return(flag);
}

void	color_it_set_all_cb(Fl_Widget *w, void *v)
{
	ColorItWindow *ciw = (ColorItWindow *)v;
	MyWin *win = ciw->my_window;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		int nn = 0;
		if(cam->color_it_cnt > 0)
		{
			nn = cam->color_it_cnt - 1;
		}
		cam->color_it_tolerance_r[nn] = (int)ciw->red_tolerance->value();
		cam->color_it_tolerance_g[nn] = (int)ciw->green_tolerance->value();
		cam->color_it_tolerance_b[nn] = (int)ciw->blue_tolerance->value();

		cam->color_it_replace_r[nn] = ciw->local_red;
		cam->color_it_replace_g[nn] = ciw->local_green;
		cam->color_it_replace_b[nn] = ciw->local_blue;
		cam->color_it_replace_a[nn] = ciw->local_alpha;
	}
}

int	MyWin::PushToSelectColors(Camera *cam)
{
	int flag = 0;
	if(cam != NULL)
	{
		if(Fl::event_button() == 1)
		{
			if(cam->color_it_cnt < 128)
			{
				int nx = Fl::event_x();
				int ny = Fl::event_y();
				int ii = nx - image_origin_x; 
				int jj = ny - image_origin_y; 
				if((ii > -1) && (ii < cam->width)
				&& (jj > -1) && (jj < cam->height))
				{
					unsigned char *colour = cam->mat.ptr(jj, ii);
					int r = colour[0];
					int g = colour[1];
					int b = colour[2];
					int a = colour[3];
					cam->color_it_r[cam->color_it_cnt] = r;
					cam->color_it_g[cam->color_it_cnt] = g;
					cam->color_it_b[cam->color_it_cnt] = b;
					cam->color_it_cnt++;
					if(color_it_window != NULL)
					{
						color_it_set_all_cb(NULL, color_it_window);
					}
					flag = 1;
				}
			}
		}
		else if(Fl::event_button() == 3)
		{
			if(cam->color_it_cnt > 0)
			{
				cam->color_it_cnt--;
			}
		}
	}
	return(flag);
}

int	MyWin::AddMiscCopy(Camera *in_source, int in_type, Mat local, int immediate_display, char *str, int xx, int yy, int ww, int hh, int rr, int gg, int bb, int aa, double contrast, double brightness, double saturation, double hue, double intensity)
{
	int r = 0;
	misc_copy = (MiscCopy **)realloc(misc_copy, sizeof(MiscCopy *) * (misc_copy_cnt + 1));
	if(misc_copy != NULL)
	{
		misc_copy[misc_copy_cnt] = new MiscCopy(in_source, in_type, local, immediate_display, str, xx, yy, ww, hh);
		if((rr > -1) && (gg > -1) && (bb > -1) && (aa > -1))
		{
			misc_copy[misc_copy_cnt]->red = rr;
			misc_copy[misc_copy_cnt]->green = gg;
			misc_copy[misc_copy_cnt]->blue = bb;
			misc_copy[misc_copy_cnt]->alpha = aa;
		}
		misc_copy[misc_copy_cnt]->contrast = contrast;
		misc_copy[misc_copy_cnt]->brightness = brightness;
		misc_copy[misc_copy_cnt]->saturation = saturation;
		misc_copy[misc_copy_cnt]->hue = hue;
		misc_copy[misc_copy_cnt]->intensity = intensity;
		r = misc_copy_cnt;
	}
	misc_copy_cnt++;
	return(r);
}

void	MyWin::MiscPaste(int in_x, int in_y)
{
int	loop;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < misc_copy_cnt;loop++)
		{
			if(misc_copy[loop] != NULL)
			{
				misc_copy[loop]->display = 1;
				if(misc_copy[loop]->destination_cnt < 128)
				{
					int d_cnt = misc_copy[loop]->destination_cnt;
					if((in_x > -1) && (in_y > -1))
					{
						misc_copy[loop]->dest_x[d_cnt] = in_x;
						misc_copy[loop]->dest_y[d_cnt] = in_y;
					}
					else
					{
						misc_copy[loop]->dest_x[d_cnt] = misc_copy[loop]->xx;
						misc_copy[loop]->dest_y[d_cnt] = misc_copy[loop]->yy;
					}
					misc_copy[loop]->destination[d_cnt] = cam;
					misc_copy[loop]->dest_display[d_cnt] = 1;
					misc_copy[loop]->destination_cnt++;
				}
			}
		}
	}
}

void	rubberband_popup_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		int ux = 0;
		int uy = 0;
		if(win->popup != NULL)
		{
			ux = win->popup->x();
			uy = win->popup->y();
			win->popup->hide();
		}
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			int xx = win->rubberband_x;
			int yy = win->rubberband_y;
			int ww = win->rubberband_w;
			int hh = win->rubberband_h;
			Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
			char *str = (char *)browser->text(browser->value());
			if(str != NULL)
			{
				if(strcmp(str, "Dynamic Copy") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->CropFrame(cam->mat, &local, use_x, use_y, ww, hh);
					win->AddMiscCopy(cam, MISC_COPY_DYNAMIC, local, 0, NULL, use_x, use_y, ww, hh);
					cam->priority = 1;
				}
				else if(strcmp(str, "Static Copy") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->CropFrame(cam->mat, &local, use_x, use_y, ww, hh);
					win->AddMiscCopy(cam, MISC_COPY_STATIC, local, 0, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Copy to Clipboard") == 0)
				{
					Mat local;
					int xx = 0;
					int yy = 0;
					int ww = cam->display_width;
					int hh = cam->display_height;
					if((win->rubberband_x > -1)
					&& (win->rubberband_y > -1)
					&& (win->rubberband_w > -1)
					&& (win->rubberband_h > -1))
					{
						xx = win->rubberband_x - cam->image_sx;
						yy = win->rubberband_y - cam->image_sy;
						ww = win->rubberband_w;
						hh = win->rubberband_h;
					}
					copy_to_clipboard(cam, xx, yy, ww, hh);
				}
				else if(strcmp(str, "Source Camera") == 0)
				{
					char text[8192];
					char alias[8192];
					sprintf(text, "sourced://%s", cam->path);
					if(strlen(cam->alias) > 0)
					{
						sprintf(alias, "Copy of %s", cam->alias);
					}
					else
					{
						sprintf(alias, "Copy of %s", cam->path);
					}
					int nw = cam->requested_x;
					int nh = cam->requested_y;
					int cam_n = win->SetupCamera(text, alias, nw, nh, 32, "Sans", 0, 0, 0, 0, 255, 255, 255, 255, 0);
					if(cam_n > -1)
					{
						win->DisplayCamera(cam_n);
						Camera *result = win->DisplayedCamera();
						result->requested_x = xx - cam->image_sx;
						result->requested_y = yy - cam->image_sy;
						result->requested_w = ww;
						result->requested_h = hh;
						win->video_thumbnail_group->ScrollToDisplayed();
						win->UpdateThumbButtons();
					}
					else
					{
						win->SetErrorMessage("Cannot Open Camera");
					}
				}
				else if(strcmp(str, "Cut Out") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_MASK, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Fill") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;

					int rr = 128;
					int gg = 128;
					int bb = 128;
					int aa = 255;
					my_color_chooser("Fill Color", rr, gg, bb, aa);
					win->AddMiscCopy(cam, MISC_COPY_FILL, local, 1, NULL, use_x, use_y, ww, hh, rr, gg, bb, aa);
				}
				else if(strcmp(str, "Crop") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_CROP, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Paste") == 0)
				{
					win->MiscPaste();
				}
				else if(strcmp(str, "Paste from Clipboard") == 0)
				{
					Fl::paste(*win, 1, Fl::clipboard_image);
				}
				else if(strcmp(str, "Clear Rubberband Commands") == 0)
				{
					for(loop = 0;loop < win->misc_copy_cnt;loop++)
					{
						if(win->misc_copy[loop]->source != NULL)
						{
							win->misc_copy[loop]->source->priority = 0;
						}
						delete win->misc_copy[loop];
						win->misc_copy[loop] = NULL;
					}
					free(win->misc_copy);
					win->misc_copy = NULL;
					win->misc_copy_cnt = 0;
				}
				else if(strcmp(str, "@C3Rubberband Mode") == 0)
				{
					win->rubberband_mode = RUBBERBAND_MODE;
				}
				else if(strcmp(str, "@C3Reposition Mode") == 0)
				{
					win->rubberband_mode = REPOSITION_MODE;
				}
				else if(strcmp(str, "@C3Scroll Mode") == 0)
				{
					win->rubberband_mode = SCROLL_MODE;
				}
				else if(strcmp(str, "@C3Guideline Mode") == 0)
				{
					win->rubberband_mode = GUIDELINE_MODE;
				}
				else if(strcmp(str, "Horizontal") == 0)
				{
					win->guideline_mode = HORIZONTAL_GUIDELINE;
				}
				else if(strcmp(str, "Vertical") == 0)
				{
					win->guideline_mode = VERTICAL_GUIDELINE;
				}
				else if(strcmp(str, "Hide Guidelines") == 0)
				{
					for(loop = 0;loop < win->guideline_cnt;loop++)
					{
						if(win->guideline[loop] != NULL)
						{
							win->guideline[loop]->hide = 1;
						}
					}
				}
				else if(strcmp(str, "Show Guidelines") == 0)
				{
					for(loop = 0;loop < win->guideline_cnt;loop++)
					{
						if(win->guideline[loop] != NULL)
						{
							win->guideline[loop]->hide = 0;
						}
					}
				}
				else if(strcmp(str, "Remove Guidelines") == 0)
				{
					for(loop = 0;loop < win->guideline_cnt;loop++)
					{
						if(win->guideline[loop] != NULL)
						{
							delete win->guideline[loop];
							win->guideline[loop] = NULL;
						}
					}
					win->guideline_cnt = 0;
				}
				else if(strcmp(str, "Move") == 0)
				{
					win->editing_misc_mode = EDITING_MISC_MOVE;
				}
				else if(strcmp(str, "Save Image") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->CropFrame(cam->mat, &local, use_x, use_y, ww, hh);
					cvtColor(local, local, COLOR_RGBA2BGRA);

					char filename[4096];
					int r = my_file_chooser("Image File", "*", "./", filename, 0, 1);
					if(r > 0)
					{
						if(strlen(filename) > 0)
						{
							const char *ext = fl_filename_ext(filename);
							if(ext != NULL)
							{
								if(cv::haveImageWriter(ext))
								{
									cv::imwrite(filename, local);
								}
								else
								{
									win->SetErrorMessage("Error: Cannot save image with that extension.");
								}
							}
						}
					}
				}
				else if(strcmp(str, "Load Image") == 0)
				{
					int use_x = ux - cam->image_sx;
					int use_y = uy - cam->image_sy;
					char filename[4096];
					int r = my_file_chooser("Image File", "*", "./", filename);
					if(r > 0)
					{
						if(strlen(filename) > 0)
						{
							Mat local_mat = imread(filename, IMREAD_UNCHANGED);
							if(!local_mat.empty())
							{
								if(local_mat.channels() == 3)
								{
									cvtColor(local_mat, local_mat, COLOR_BGR2RGBA);
								}
								else
								{
									cvtColor(local_mat, local_mat, COLOR_BGRA2RGBA);
								}
								int rr = win->AddMiscCopy(cam, MISC_COPY_STATIC, local_mat, 0, NULL, use_x, use_y, local_mat.cols, local_mat.rows);
								if(rr > -1)
								{
									win->MiscPaste();
								}
							}
						}
					}
				}
				else if(strcmp(str, "Remove") == 0)
				{
					if(win->editing_misc_outer > -1)
					{
						if(win->misc_copy[win->editing_misc_outer] != NULL)
						{
							if(win->editing_misc_inner == -1)
							{
								free(win->misc_copy[win->editing_misc_outer]);
								win->misc_copy[win->editing_misc_outer] = NULL;
							}
							else if(win->editing_misc_inner > -1)
							{
								win->misc_copy[win->editing_misc_outer]->destination[win->editing_misc_inner] = NULL;
								win->misc_copy[win->editing_misc_outer]->dest_x[win->editing_misc_inner] = -1;
								win->misc_copy[win->editing_misc_outer]->dest_y[win->editing_misc_inner] = -1;
								win->misc_copy[win->editing_misc_outer]->dest_display[win->editing_misc_inner] = 0;
							}
						}
					}
				}
				else if(strcmp(str, "Remove All") == 0)
				{
					win->MiscRemoveAll();
				}
				else if(strcmp(str, "Remove Last") == 0)
				{
					win->MiscRemoveLast();
				}
				else if(strcmp(str, "Rectangle") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_RECTANGLE, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Magnify") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_MAGNIFY, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Border") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_BORDER, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Reverse") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_REVERSE, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Video Settings") == 0)
				{
					double contrast = 0.5;
					double brightness = 0.5;
					double saturation = 1.0;
					double hue = 1.0;
					double intensity = 1.0;
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					int r = win->AddMiscCopy(cam, MISC_COPY_VIDEO_SETTINGS, local, 1, NULL, use_x, use_y, ww, hh, -1, -1, -1, -1, contrast, brightness, saturation, hue, intensity);
					if(r > -1)
					{
						MiscCopy *misc = win->misc_copy[r];
						my_video_settings_chooser(win, misc->contrast, misc->brightness, misc->saturation, misc->hue, misc->intensity);
					}
				}
				else if(strcmp(str, "Flip Horizontally") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_HFLIP, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Flip Vertically") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_VFLIP, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Text") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_TEXT, local, 1, "Sample Text", use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Resize") == 0)
				{
					win->editing_misc_mode = EDITING_MISC_RESIZE;
				}
				else if(strcmp(str, "Select All") == 0)
				{
					win->rubberband_x = cam->image_sx;
					win->rubberband_y = cam->image_sy;
					win->rubberband_w = cam->width;
					win->rubberband_h = cam->height;
				}
				else if(strcmp(str, "Edit Text") == 0)
				{
					if(win->editing_misc_outer > -1)
					{
						if(win->misc_copy[win->editing_misc_outer] != NULL)
						{
							MiscCopy *misc = win->misc_copy[win->editing_misc_outer];
							if(win->text_edit_window != NULL)
							{
								win->text_edit_window->hide();
								Fl::delete_widget(win->text_edit_window);
								win->text_edit_window = NULL;
							}
							win->text_edit_window = new TextEditWindow(win, cam, misc);
							win->text_edit_window->show();
						}
					}
				}
				else if(strcmp(str, "Blank") == 0)
				{
					if(cam->type == CAMERA_TYPE_SPLIT)
					{
						int nx = ux - cam->image_sx;
						int ny = uy - cam->image_sy;
						int nnx = ((double)cam->split_cols / (double)cam->width) * nx;
						int nny = ((double)cam->split_rows / (double)cam->height) * ny;
						int nn = (cam->split_cols * nny) + nnx;
						if((nn > -1) && (nn < 128))
						{
							if(cam->split_source[nn] != NULL)
							{
								free(cam->split_source[nn]);
							}
							cam->split_source[nn] = strdup("[blank]");
						}
					}
				}
			}
		}
	}
}

int	MyWin::HandleMenuPopup(int xx, int yy)
{
int	loop;

	int flag = 0;
	if(ImageWindowHit(last_push_x, last_push_y) == -1)
	{
		Camera *cam = DisplayedCamera();
		Immediate *im = cam->EventInImmediate();
		if(im == NULL)
		{
			if(rubberband_mode == RUBBERBAND_MODE)
			{
				if((rubberband_x > -1)
				|| (rubberband_y > -1)
				|| (rubberband_w > -1)
				|| (rubberband_h > -1))
				{
					if(Fl::event_button() == FL_LEFT_MOUSE)
					{
						rubberband_x = -1; 
						rubberband_y = -1;
						rubberband_w = -1;
						rubberband_h = -1;
					}
					else if(Fl::event_button() == FL_RIGHT_MOUSE)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						if((xx > cam->image_sx) && (yy > cam->image_sy)
						&& (xx < cam->image_sx + cam->width) && (yy < cam->image_sy + cam->height))
						{
							if(popup != NULL)
							{
								Fl::delete_widget(popup);
							}
							popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 160, 60);
							popup->browser->callback(rubberband_popup_cb, this);
							popup->browser->clear();
							popup->browser->add("Dynamic Copy");
							popup->browser->add("Static Copy");
							popup->browser->add("Copy to Clipboard");
							if(Fl::clipboard_contains(Fl::clipboard_image)) 
							{
								popup->browser->add("Paste from Clipboard");
							}
							if(cam->source_camera == NULL)
							{
								popup->browser->add("Source Camera");
							}
							popup->browser->add("Select All");
							popup->browser->add("Cut Out");
							popup->browser->add("Fill");
							popup->browser->add("Crop");
							popup->browser->add("Text");
							popup->browser->add("Rectangle");
							popup->browser->add("Magnify");
							popup->browser->add("Border");
							popup->browser->add("Reverse");
							popup->browser->add("Video Settings");
							popup->browser->add("Flip Horizontally");
							popup->browser->add("Flip Vertically");
							popup->browser->add("Save Image");
							popup->browser->add("@C3Scroll Mode");
							popup->browser->add("@C3Reposition Mode");
							popup->browser->add("@C3Guideline Mode");
							popup->set_non_modal();
							popup->Fit();
							popup->show();
							flag = 1;
						}
					}
				}
				else
				{
					if(Fl::event_button() == FL_RIGHT_MOUSE)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						if((xx > cam->image_sx) && (yy > cam->image_sy)
						&& (xx < cam->image_sx + cam->width) && (yy < cam->image_sy + cam->height))
						{
							editing_misc_outer = -1;
							editing_misc_inner = -1;
							int	hit = InMiscPasted(last_push_x, last_push_y, editing_misc_outer, editing_misc_inner);
							if(popup != NULL)
							{
								Fl::delete_widget(popup);
							}
							popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 160, 40);
							popup->browser->callback(rubberband_popup_cb, this);
							popup->browser->clear();
							if(misc_copy_cnt > 0)
							{
								popup->browser->add("Remove All");
								popup->browser->add("Remove Last");
								if(hit == 0)
								{
									popup->browser->add("Paste");
									popup->browser->add("Clear Rubberband Commands");
								}
								else
								{
									if(editing_misc_outer > -1)
									{
										if(misc_copy[editing_misc_outer]->type == MISC_COPY_TEXT)
										{
											popup->browser->add("Edit Text");
										}
									}
									popup->browser->add("Move");
									popup->browser->add("Remove");
									popup->browser->add("Resize");
								}
							}
							popup->browser->add("Copy to Clipboard");
							if(Fl::clipboard_contains(Fl::clipboard_image)) 
							{
								popup->browser->add("Paste from Clipboard");
							}
							popup->browser->add("Load Image");
							popup->browser->add("Select All");
							popup->browser->add("@C3Scroll Mode");
							popup->browser->add("@C3Reposition Mode");
							popup->browser->add("@C3Guideline Mode");
							popup->set_non_modal();
							popup->Fit();
							popup->show();
							flag = 1;
						}
					}
				}
			}
			else if(rubberband_mode == REPOSITION_MODE)
			{
				if(Fl::event_button() == FL_RIGHT_MOUSE)
				{
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					if((xx > cam->image_sx) && (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width) && (yy < cam->image_sy + cam->height))
					{
						if(popup != NULL)
						{
							Fl::delete_widget(popup);
						}
						popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 160, 20);
						popup->browser->callback(rubberband_popup_cb, this);
						popup->browser->clear();
						popup->browser->add("@C3Rubberband Mode");
						popup->browser->add("@C3Guideline Mode");
						popup->browser->add("@C3Scroll Mode");
						if(cam->type == CAMERA_TYPE_SPLIT)
						{
							popup->browser->add("Blank");
						}
						popup->set_non_modal();
						popup->Fit();
						popup->show();
						flag = 1;
					}
				}
			}
			else if(rubberband_mode == GUIDELINE_MODE)
			{
				if(Fl::event_button() == FL_RIGHT_MOUSE)
				{
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					if((xx > cam->image_sx) && (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width) && (yy < cam->image_sy + cam->height))
					{
						if(popup != NULL)
						{
							Fl::delete_widget(popup);
						}
						popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 160, 20);
						popup->browser->callback(rubberband_popup_cb, this);
						popup->browser->clear();
						popup->browser->add("Horizontal");
						popup->browser->add("Vertical");
						popup->browser->add("Hide Guidelines");
						popup->browser->add("Show Guidelines");
						popup->browser->add("Remove Guidelines");
						popup->browser->add("@C3Rubberband Mode");
						popup->browser->add("@C3Reposition Mode");
						popup->browser->add("@C3Scroll Mode");
						if(cam->type == CAMERA_TYPE_SPLIT)
						{
							popup->browser->add("Blank");
						}
						popup->set_non_modal();
						popup->Fit();
						popup->show();
						flag = 1;
					}
				}
			}
			else
			{
				if(Fl::event_button() == FL_RIGHT_MOUSE)
				{
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					if((xx > cam->image_sx) && (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width) && (yy < cam->image_sy + cam->height))
					{
						if(popup != NULL)
						{
							Fl::delete_widget(popup);
						}
						popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 160, 20);
						popup->browser->callback(rubberband_popup_cb, this);
						popup->browser->clear();
						popup->browser->add("@C3Rubberband Mode");
						popup->browser->add("@C3Guideline Mode");
						popup->browser->add("@C3Reposition Mode");
						if(cam->type == CAMERA_TYPE_SPLIT)
						{
							popup->browser->add("Blank");
						}
						popup->set_non_modal();
						popup->Fit();
						popup->show();
						flag = 1;
					}
				}
			}
		}
	}
	return(flag);
}

int	MyWin::ShapeHandleEvent(int event)
{
int	loop;

	int flag = 0;
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	for(loop = 0;loop < shape_cnt;loop++)
	{
		if(shape[loop] != NULL)
		{
			if(Fl::event_inside(shape[loop]))
			{
				flag = 1;
			}
		}
	}
	return(flag);
}

void	MyWin::Transparent(int flag)
{
int	loop;

	transparent_interface = flag;
	if(ptz_mode != 0)
	{
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(ptz_window[loop] != NULL)
			{
				if(flag == 1)
				{
					ptz_window[loop]->box(FL_NO_BOX);
				}
				else
				{
					ptz_window[loop]->box(FL_FLAT_BOX);
				}
				ptz_window[loop]->redraw();
			}
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(thumbnail[loop] != NULL)
		{
			if(flag == 1)
			{
				thumbnail[loop]->box(FL_NO_BOX);
			}
			else
			{
				thumbnail[loop]->box(FL_FLAT_BOX);
			}
			thumbnail[loop]->redraw();
		}
	}
	for(loop = 0;loop < audio_thumbnail_cnt;loop++)
	{
		if(audio_thumbnail[loop] != NULL)
		{
			if(flag == 1)
			{
				audio_thumbnail[loop]->alias_button->box(FL_NO_BOX);
				audio_thumbnail[loop]->select_button->box(FL_NO_BOX);
			}
			else
			{
				audio_thumbnail[loop]->alias_button->box(FL_FLAT_BOX);
				audio_thumbnail[loop]->select_button->box(FL_FLAT_BOX);
			}
			audio_thumbnail[loop]->redraw();
		}
	}
	if(button_group != NULL)
	{
		if(flag == 1)
		{
			button_group->box(FL_NO_BOX);
		}
		else
		{
			button_group->box(FL_FLAT_BOX);
		}
	}
}

int	MyWin::handle(int event)
{
int		loop;
static int	last_resize_drag_x = -1;
static int	last_resize_drag_y = -1;
static int 	stat_me = 0;

	int flag = 0;
	if(mouse_moving > 0) mouse_moving--;
	Camera *cam = camera[displayed_source];
	if((cam != NULL) && (actively_loading == 0) && (source_cnt > 0))
	{
		int shape_got_it = ShapeHandleEvent(event);
		if(shape_got_it == 0)
		{
			if(void_handle_events != NULL)
			{
				int (*handle_events)(Fl_Window *, int);
				handle_events = (int (*)(Fl_Window *, int))void_handle_events;
				flag = handle_events(this, event);
			}
			if(flag == 0)
			{
				switch(event)
				{
					case(FL_FOCUS):
					{
						flag = 1;
					}
					break;
					case(FL_UNFOCUS):
					{
						flag = 1;
					}
					break;
					case(FL_PASTE):
					{
						Mat out;
						int	rr = mat_from_copy_buffer(out);
						if(rr == 1)
						{
							if(clipboard_changed == 1)
							{
								int real_ww = out.cols;
								int real_hh = out.rows;
								int use_x = rubberband_x - cam->image_sx;
								int use_y = rubberband_y - cam->image_sy;
								int ww = rubberband_w;
								int hh = rubberband_h;
								if((ww <= 0) || (hh <= 0))
								{
									use_x = Fl::event_x() - cam->image_sx;
									use_y = Fl::event_y() - cam->image_sy;
									ww = real_ww;
									hh = real_hh;
									if((ww <= 0) || (hh <= 0))
									{
										ww = real_ww;
										hh = real_hh;
									}
								}
								if((ww > 0) && (hh > 0))
								{
									Mat use;
									cv::resize(out, out, cv::Size(ww, hh));
									if(out.channels() == 3)
									{
										cvtColor(out, out, COLOR_RGB2RGBA);
									}
									use = out.clone();
									rr = AddMiscCopy(cam, MISC_COPY_STATIC, use, 0, NULL, use_x, use_y, ww, hh);
									if(rr > -1)
									{
										MiscPaste();
									}
								}
							}
							else
							{
								int use_x = Fl::event_x() - cam->image_sx;
								int use_y = Fl::event_y() - cam->image_sy;
								MiscPaste(use_x, use_y);
							}
						}
						flag = 1;
					}
					break;
					case(FL_KEYBOARD):
					{
						int key = Fl::event_key();
						flag = HandleKeyboard(event, cam);
						int state = Fl::event_state();
						if((state & FL_CTRL) == FL_CTRL)
						{
							if(key == 'v')
							{
								Fl::paste(*this, 1, Fl::clipboard_image);
								flag = 1;
							}
							if((key == 'c') || (key == 'x'))
							{
								int xx = 0;
								int yy = 0;
								int ww = cam->display_width;
								int hh = cam->display_height;
								if((rubberband_x > -1)
								&& (rubberband_y > -1)
								&& (rubberband_w > -1)
								&& (rubberband_h > -1))
								{
									xx = rubberband_x - cam->image_sx;
									yy = rubberband_y - cam->image_sy;
									ww = rubberband_w;
									hh = rubberband_h;
								}
								copy_to_clipboard(cam, xx, yy, ww, hh);
								if(key == 'x')
								{
									Mat local;
									AddMiscCopy(cam, MISC_COPY_MASK, local, 1, NULL, xx, yy, ww, hh);
								}
								flag = 1;
							}
						}
					}
					break;
					case(FL_PUSH):
					{
						last_push_x = Fl::event_x();
						last_push_y = Fl::event_y();
						if(split != 1)
						{
							flag = HandlePushForEmbedded(last_push_x, last_push_y);
							if(flag == 0)
							{
								int newly_selected = 0;
								if(im_drawing_mode == 1)
								{
									newly_selected = HandlePushToSelectImmediate(cam);
								}
								if((immediate_drawing_window->visible()) && (newly_selected == 0))
								{
									if(buttons_shown == 0)
									{
										flag = HandlePushToEditImmediate(cam);
									}
								}
								else if(newly_selected == 1)
								{
									newly_selected = 0;
									ImmediateNewlySelectedHighlight();
								}
								if(flag == 0)
								{
									flag = HandleMenuPopup(last_push_x, last_push_y);
									if((mark_interest == 1) && (!button_group->visible()))
									{
										flag = DoMarkInterest();
									}
									else if(cam->type == CAMERA_TYPE_AV)
									{
										if(progress_scrubber != NULL)
										{
											flag = progress_scrubber->Handle(event);
										}
									}
									else if(rubberband_mode == GUIDELINE_MODE)
									{
										if((ImageWindowHit(last_push_x, last_push_y) == -1)
										&& (Fl::event_inside(resize_frame) == 0))
										{
											if(Fl::event_button() == FL_LEFT_MOUSE)
											{
												if(guideline_mode == HORIZONTAL_GUIDELINE)
												{
													if(guideline_cnt < 1024)
													{
														int use_x = last_push_x - cam->image_sx;
														int use_y = last_push_y - cam->image_sy;
														if((use_y >= 0) && (use_y < cam->display_height)
														&& (use_x >= 0) && (use_x < cam->display_width))
														{
															guideline[guideline_cnt] = new Guideline(this, HORIZONTAL_GUIDELINE, use_y);
															guideline_cnt++;
														}
													}
												}
												else if(guideline_mode == VERTICAL_GUIDELINE)
												{
													if(guideline_cnt < 1024)
													{
														int use_x = last_push_x - cam->image_sx;
														int use_y = last_push_y - cam->image_sy;
														if((use_y >= 0) && (use_y < cam->display_height)
														&& (use_x >= 0) && (use_x < cam->display_width))
														{
															guideline[guideline_cnt] = new Guideline(this, VERTICAL_GUIDELINE, use_x);
															guideline_cnt++;
														}
													}
												}
											}
										}
									}
									else if(zoom_boxing == 1)
									{
										drag_start_x = Fl::event_x();
										drag_start_y = Fl::event_y();
										flag = 1;
									}
									else if((cam->zoom > 1.0) && (Fl::event_button() == FL_LEFT_MOUSE))
									{
										start_offset_x = Fl::event_x();
										start_offset_y = Fl::event_y();
									}
									else if(restore_corner == 1)
									{
										cam->display_width = cam->width;
										cam->display_height = cam->height;
									}
									else if(selecting_colors == 1)
									{
										flag = PushToSelectColors(cam);
									}
									else if((ptz_window[0] != NULL) && (ptz_mode == 1) && (move_corner == 0) && (resize_corner == 0) && (restore_corner == 0))
									{
										if((cam->zoom <= 1.0) || (Fl::event_button() == FL_MIDDLE_MOUSE))
										{
											flag = HandlePushForPTZ(cam);
										}
									}
								}
							}
						}
					}
					break;
					case(FL_RELEASE):
					{
						if(split == 1)
						{
							flag = HandleReleaseForSplit();
						}
						else
						{
							if(im_drawing_mode == 1)
							{
								if(Fl::event_button() == FL_LEFT_MOUSE)
								{
									flag = MyWin::HandleReleaseForImmediate(cam);
								}
							}
							else if(selecting_colors != 1)
							{
								if(cam->type == CAMERA_TYPE_AV)
								{
									if(progress_scrubber != NULL)
									{
										flag = progress_scrubber->Handle(event);
									}
								}
								else if(rubberband_mode == SCROLL_MODE)
								{
									if(crop_output == 0)
									{
										if(cam->zoom <= 1.0)
										{
											if(zoom_boxing == 0)
											{
												if(cam->ptz_lock_interface != -1)
												{
													flag = HandleReleaseForPTZ(cam);
												}
											}
										}
									}
									flag = HandleRelease(cam);
								}
								last_resize_drag_x = -1;
								last_resize_drag_y = -1;
								editing_misc_mode = -1;
							}
							else
							{
								flag = 1;
							}
						}
					}
					break;
					case(FL_MOVE):
					{
						flag = HandleMove(cam);
					}
					break;
					case(FL_DRAG):
					{
						if((crop_output == 1)
						&& (output_width < cam->display_width)
						&& (output_height < cam->display_height))
						{
							int nxx = Fl::event_x();
							int nyy = Fl::event_y();
							if((nxx > (cam->image_sx + crop_output_x))
							&& (nyy > (cam->image_sy + crop_output_y))
							&& (nxx < (cam->image_sx + crop_output_x + output_width))
							&& (nyy < (cam->image_sy + crop_output_y + output_height)))
							{
								int diff_x = nxx - last_push_x;
								int diff_y = nyy - last_push_y;
								if((crop_output_x + output_width + diff_x) < display_width)
								{
									crop_output_x += diff_x;
									if(crop_output_x < 0) crop_output_x = 0;
									SaveVideoSettings();
								}
								if((crop_output_y + output_height + diff_y) < display_height)
								{
									crop_output_y += diff_y;
									if(crop_output_y < 0) crop_output_y = 0;
									SaveVideoSettings();
								}
								last_push_x = Fl::event_x();
								last_push_y = Fl::event_y();
							}
						}
						else if((crop_scaling == 1)
						&& (cam->orig_width > output_width)
						&& (cam->orig_height > output_height)
						&& (rubberband_mode == SCROLL_MODE)
						&& (im_drawing_mode == 0))
						{
							int diff_x = last_push_x - Fl::event_x();
							int diff_y = last_push_y - Fl::event_y();
							cam->crop_start_x += diff_x;
							if(cam->crop_start_x < 0) cam->crop_start_x = 0;
							cam->crop_start_y += diff_y;
							if(cam->crop_start_y < 0) cam->crop_start_y = 0;
							last_push_x = Fl::event_x();
							last_push_y = Fl::event_y();
							SaveVideoSettings();
						}
						else if((crop_scaling == 1)
						&& (cam->orig_width < output_width)
						&& (cam->orig_height < output_height)
						&& (rubberband_mode == SCROLL_MODE)
						&& (im_drawing_mode == 0))
						{
							if(cam->use_crop_start == 0)
							{
								cam->crop_start_x = cam->last_start_x;
								cam->crop_start_y = cam->last_start_y;
							}
							int diff_x = last_push_x - Fl::event_x();
							int diff_y = last_push_y - Fl::event_y();
							cam->crop_start_x -= diff_x;
							if(cam->crop_start_x < 0) cam->crop_start_x = 0;
							cam->crop_start_y -= diff_y;
							if(cam->crop_start_y < 0) cam->crop_start_y = 0;
							last_push_x = Fl::event_x();
							last_push_y = Fl::event_y();
							cam->use_crop_start = 1;
							SaveVideoSettings();
						}
						else
						{
							if(rubberband_mode == SCROLL_MODE)
							{
								cam->crop_start_x = 0;
								cam->crop_start_y = 0;
								cam->use_crop_start = 0;
							}
							if(cam->type == CAMERA_TYPE_AV)
							{
								if(progress_scrubber != NULL)
								{
									flag = progress_scrubber->Handle(event);
								}
							}
							else if(im_drawing_mode == 1)
							{
								flag = HandleImmediateDrag(cam);
							}
							else if(zoom_boxing == 0)
							{
								if(ptz_joystick == 1)
								{
									if(cam->zoom <= 1.0)
									{
										flag = HandlePTZDrag();
									}
								}
								else
								{
									flag = HandleDrag(cam);
								}
							}
						}
					}
					break;
					case(FL_MOUSEWHEEL):
					{
						if(!resize_frame->visible())
						{
							if(split == 0)
							{
								if(cam->type == CAMERA_TYPE_AV)
								{
									if(progress_scrubber != NULL)
									{
										flag = progress_scrubber->Handle(event);
									}
								}
								else if(cam->type == CAMERA_TYPE_EDGE_DETECT)
								{
									int direction = Fl::event_dy();
									if(direction > 0)
									{
										cam->edge_blend += 0.01;
										if(cam->edge_blend > 1.0)
										{
											cam->edge_blend = 1.0;
										}
									}
									else
									{
										cam->edge_blend -= 0.01;
										if(cam->edge_blend < 0.0)
										{
											cam->edge_blend = 0.0;
										}
									}
								}
								else if(use_mousewheel == 1)
								{
									if((ptz_middle_mouse > 0) && (ptz_mode == 1))
									{
										if(cam->zoom <= 1.0)
										{
											flag = HandleMousewheelPTZ(cam);
										}
									}
									else if(crop_scaling == 1)
									{
										int direction = Fl::event_dy();
										if(direction > 0)
										{
											cam->capture_scaling += 0.1;
											if(cam->capture_scaling > 4.0)
											{
												cam->capture_scaling = 4.0;
											}
										}
										else
										{
											cam->capture_scaling -= 0.1;
											if(cam->capture_scaling < 0.1)
											{
												cam->capture_scaling = 0.1;
											}
										}
										flag = 1;
									}
									else if(resize_capture == 1)
									{
										flag = HandleMousewheelResizeCapture(cam);
									}
									else
									{
										flag = HandleMousewheel(cam);
									}
								}
							}
						}
					}
					break;
				}
			}
		}
	}
	else
	{
		if(event == FL_MOVE)
		{
			int xx = Fl::event_x();
			int yy = Fl::event_y();
			ShowButtonPanel(xx, yy);
			ShowPTZ(NULL, xx, yy);
			ShowAudio(xx, yy);
		}
		else if(event == FL_PUSH)
		{
			if(source_cnt < 1)
			{
				last_push_x = Fl::event_x();
				last_push_y = Fl::event_y();
				if((last_push_x > ((Fl::w() / 2) - 160))
				&& (last_push_x < ((Fl::w() / 2) + 160))
				&& (last_push_y > ((Fl::h() / 2) - 30))
				&& (last_push_y < ((Fl::h() / 2) + 30)))
				{
					new_source_button_cb(NULL, this);
					flag = 1;
				}
			}
		}
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

void	MyWin::ShowButtonPanel(int xx, int yy)
{
	int show_m = 0;
	if((xx > button_group->x()) && (yy > button_group->y())
	&& (xx < button_group->x() + button_group->w())
	&& (yy < button_group->y() + button_group->h()))
	{
		show_m = 1;
	}
	ReallyToggleButtonPanel(show_m);
}

void	MyWin::ReallyToggleButtonPanel(int show_m)
{
	if(show_m == 1)
	{
		if(buttons_shown == 0)
		{
			ShowButtons();
			button_group->show();
			buttons_shown = 1;
		}
	}
	else
	{
		if(buttons_shown == 1)
		{
			button_group->hide();
			buttons_shown = 0;
		}
	}
}

void	MyWin::ReallyToggleButtonPanel()
{
	if(buttons_shown == 0)
	{
		ShowButtons();
		button_group->show();
		buttons_shown = 1;
		retain_commands = 1;
	}
	else
	{
		button_group->hide();
		buttons_shown = 0;
		retain_commands = 0;
	}
}

void	MyWin::RemoveSource(int src)
{
int	loop;

	if(source_cnt > 1)
	{
		if((src > -1) && (src < source_cnt))
		{
			if(camera[src] != NULL)
			{
				DisplayCamera(0);
				current_source = 0;
				delete camera[src];
				camera[src] = NULL;
				for(loop = src;loop < 127;loop++)
				{
					camera[loop] = camera[loop + 1];
				}
				source_cnt--;
				UpdateThumbButtons();
			}
		}
	}
}

void	MyWin::DumpDirectRecording(char *in_filename, char *out_filename)
{
	Camera *cam = camera[displayed_source];
	dump_type = "Extracting Video";
	dumped_frames = 0;
	dumped_limit = -1;
	if(access(last_used_filename, 0) == 0)
	{
		VideoCapture local_cap(in_filename);
		if(local_cap.isOpened())
		{
			int fd = -1;
			int ww = 0;
			int hh = 0;
			int done = 0;
			int bad_cnt = 0;
			while(done == 0)
			{
				Mat frame;
				local_cap >> frame;
				if(!frame.empty())
				{
					cvtColor(frame, frame, COLOR_BGR2RGB);
					if(fd == -1)
					{
						ww = frame.cols;
						hh = frame.rows;
						fd = open(out_filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
						write(fd, &ww, sizeof(int));
						write(fd, &hh, sizeof(int));
						int depth = 3;
						write(fd, &depth, sizeof(int));
						int ifps = (int)cam->fps;
						write(fd, &ifps, sizeof(int));
					}
					if(fd != -1)
					{
						long int ts = local_timestamp();
						write_frame(fd, frame.ptr(), ww * hh * 3, ts);
					}
					bad_cnt = 0;
					dumped_frames++;
				}
				else
				{
					bad_cnt++;
					if(bad_cnt > 10)
					{
						done = 1;
					}
				}
				redraw();
				Fl::check();
			}
			if(fd != -1)
			{
				close(fd);
			}
			local_cap.release();
		}
	}
	dump_type = NULL;
	dumped_frames = 0;
}

void	MyWin::SetUseOutputPath(int index, char *buf)
{
	if((index > -1) && (index < output_path_cnt))
	{
		if(output_active[index] == 1)
		{
			char use_buf[4096];
			strcpy(use_buf, "");
			streaming = interpret_output_path(this, output_path[index], use_buf, NULL);
			if(strlen(use_buf) > 1)
			{
				if(streaming == STREAMING_NET)
				{
					sprintf(buf, "streaming.%s", use_extension);
					strcpy(stream_url, use_buf);
				}
				else if(streaming == STREAMING_NDI)
				{
					sprintf(buf, "%s", use_buf);
				}
				else
				{
					sprintf(buf, "%s.%s", use_buf, use_extension);
				}
			}
		}
	}
}

void	MyWin::Encode()
{
char	buf[4096];
char	old_audio_name[4096];
char	old_video_name[4096];

	if(encoding == 0)
	{
		Camera *cam = DisplayedCamera();
		if(cam != NULL)
		{
			int sz = cam->width * cam->height * 3;
			if(cam->save_fifo != NULL)
			{
				delete cam->save_fifo;
				cam->save_fifo = NULL;
			}
			if(cam->fd > -1)
			{
				close(cam->fd);
			}
			cam->fd = -1;
			if(pulse_mixer != NULL)
			{
				pulse_mixer->Stop();
			}
			strcpy(old_video_name, "");
			strcpy(old_audio_name, "");
			if((muxing == 1) && (stream_only == 1))
			{
				if(last_muxed_list[0] != NULL)
				{
					rename("video.bin", "encode_video.bin");
					strcpy(old_video_name, "video.bin");
				}
			}
			else
			{
				if(single_stream == 0)
				{
					sprintf(buf, "main_%02d.bin", displayed_source);
				}
				else
				{
					sprintf(buf, "single_stream.bin");
				}
				if(access(buf, 0) == 0)
				{
					rename(buf, "encode_video.bin");
					strcpy(old_video_name, buf);
				}
			}
			if(pulse_mixer != NULL)
			{
				sprintf(buf, "audio.bin");
				if(access(buf, 0) == 0)
				{
					rename(buf, "encode_audio.bin");
					strcpy(old_audio_name, buf);
				}
			}
			ReallyEncode(cam->frame_cnt);
			if(strlen(old_video_name) > 0)
			{
				rename("encode_video.bin", old_video_name);
			}
			if(strlen(old_audio_name) > 0)
			{
				rename("encode_audio.bin", old_audio_name);
			}
		}
	}
}

void	MyWin::ReallyEncode(int number_of_frames)
{
struct tm *tm;
int	loop;
char	buf[4096];

	Camera *cam = camera[displayed_source];
	if(cam != NULL)
	{
		int *local_crop_x = NULL;
		int *local_crop_y = NULL;
		int check_trim = 0;
		long int last_used_ts = 0;
		int retained_frames = 0;
		if(review != NULL)
		{
			review->RenderTitles();
			if(review->scrub->trim_cnt > 0)
			{
				check_trim = 1;
				review->show();
				last_used_ts = review->EditToTrim(&retained_frames);
				number_of_frames = retained_frames;
			}
			speed_factor = review->speed;
			if(review->crop_activated == 1)
			{
				local_crop_x = review->crop_x;
				local_crop_y = review->crop_y;
			}
		}
		int uw = cam->width;
		int uh = cam->height;
		int depth = 3;
		int ufps = cam->fps;

		char tmp[256];
		int fdx = -1;
		char *video_in = NULL;
		char *audio_in = NULL;
		if(check_trim == 0)
		{
			fdx = open("encode_video.bin", O_RDONLY);
			video_in = "encode_video.bin";
			
			// This can be -2, for recording the desktop
			if(pulse_mixer != NULL)
			{
				audio_in = "encode_audio.bin";
			}
		}
		else
		{
			fdx = open("video_output.bin", O_RDONLY);
			video_in = "video_output.bin";

			// This can be -2, for recording the desktop
			if(pulse_mixer != NULL)
			{
				audio_in = "audio_output.bin";
			}
		}
		if(fdx > -1)
		{
			SetCodec();
			double ifps = cam->current_fps;
			int total_seconds = cam->running_time / 1000;
			if(total_seconds < 1) total_seconds = 1;

			time_t t_num = time(0);
			tm = localtime((const time_t *)&t_num);
			sprintf(buf, "muxed_video_%04d_%02d_%02d_%02d_%02d_%02d.%s", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, use_extension);
			video_count++;
			pthread_mutex_lock(&muxer_mutex);
			if(my_muxer[0] != NULL)
			{
				delete my_muxer[0];
				my_muxer[0] = NULL;
			}
			pthread_mutex_unlock(&muxer_mutex);
			long int length = filelength(fdx);
			read(fdx, &uw, sizeof(int));
			read(fdx, &uh, sizeof(int));
			read(fdx, &depth, sizeof(int));
			read(fdx, &ufps, sizeof(int));
			ifps = (double)ufps;

			int sz = uw * uh * depth;
			length -= (sizeof(int) * 4);
			if(number_of_frames > 0)
			{
				encoding_frame_cnt = number_of_frames;
			}
			else
			{
				encoding_frame_cnt = (int)(length / (sz + sizeof(int)));
			}
			double calc_fps = encoding_frame_cnt / total_seconds;

			close(fdx);
			int audio_secs = 0;
			int video_secs = encoding_frame_cnt / ifps;
			if(audio_in != NULL)
			{
				int fda = open(audio_in, O_RDONLY);
				if(fda > -1)
				{
					int hz = 1;
					int channels = 2;
					read(fda, &channels, sizeof(int));
					read(fda, &hz, sizeof(int));
					long int length = filelength(fda);
					audio_secs = (((length - sizeof(int)) / 2) / hz);
					close(fda);
				}
			}
			else
			{
				ifps *= speed_factor;
				if(ifps < minimum_fps)
				{
					ifps = minimum_fps;
				}
			}
			encoding = 1;
			Muxer *use_muxer = new Muxer(this, review, 1);
			SetUseOutputPath(0, buf);

			// COW - Forced to 30 FPS, otherwise cannot sync
			ifps = 30;

			int mux_err = use_muxer->InitMux(audio, use_video_codec, use_audio_codec, video_in, audio_in, buf, NULL, desktop_monitor, NULL, -1, uw, uh, ifps, audio_sample_rate, audio_channels, number_of_frames, local_crop_x, local_crop_y);
			if(mux_err == 0)
			{
				AddLastMuxed(buf);
			}
			else
			{
				SetErrorMessage("Encoding Error: Not recording.");
			}
			delete use_muxer;
			encoding = 0;
		}
	}
}

int	MyWin::FindMovement(Camera *in_cam, int threshold_sz, int *cx, int *cy, int *second_cx, int *second_cy, int region_x1, int region_y1, int region_x2, int region_y2)
{
Mat cow_gray;
Mat show_mat;
int loop;
int outer, inner;
int cnt_array[10][10];

	int r = -1;
	Camera *cam = NULL;
	if(in_cam != NULL)
	{
		cam = in_cam;
	}
	if(cam != NULL)
	{
		if(region_x1 == -1) region_x1 = 0;
		if(region_y1 == -1) region_y1 = 0;
		if(region_x2 == -1) region_x2 = w();
		if(region_y2 == -1) region_y2 = h();
		for(outer = 0;outer < 10;outer++)
		{
			for(inner = 0;inner < 10;inner++)
			{
				cnt_array[outer][inner] = 0;
			}
		}
		int image_sx = (w() / 2) - (cam->mat.cols / 2);
		int image_sy = (h() / 2) - (cam->mat.rows / 2);
		cvtColor(cam->mat, cow_gray, COLOR_RGBA2GRAY);
		blur(cow_gray, cow_gray, Size(7, 7));
		if(cam->once == 1)
		{
			absdiff(cam->old_mat, cow_gray, show_mat);
			threshold(show_mat, show_mat, 25, 255, THRESH_BINARY);
			dilate(show_mat, show_mat, 0, Point(-1, -1), 2, 1, 1);
			if(motion_debug == 1)
			{
				cam->motion_mat = show_mat.clone();
			}
			vector<vector<Point> > contours;
			findContours(show_mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

			vector<vector<Point> > contours_poly(contours.size());
			vector<Rect> boundRect(contours.size());
			for(int i = 0; i < contours.size(); i++)
			{	
				approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
				boundRect[i] = boundingRect(Mat(contours_poly[i]));
			}
			cam->motion_score = 0;
			for(loop = 0;loop < contours.size();loop++)
			{
				Point top_left = boundRect[loop].tl();
				Point bottom_right = boundRect[loop].br();
				int xx1 = top_left.x;
				int yy1 = top_left.y;
				int xx2 = bottom_right.x;
				int yy2 = bottom_right.y;
				int sz_x = xx2 - xx1;
				int sz_y = yy2 - yy1;
				int nn = sz_x * sz_y;
				if(nn > cam->motion_score)
				{
					cam->motion_score = nn;
				}
				if((xx1 >= region_x1)
				&& (yy1 >= region_y1)
				&& (xx2 <= region_x2)
				&& (yy2 <= region_y2))
				{
					int mid_x = xx1 + ((xx2 - xx1) / 2);
					int mid_y = yy1 + ((yy2 - yy1) / 2);
					int cnx = (10.0 / (double)cam->width) * (double)mid_x;
					int cny = (10.0 / (double)cam->height) * (double)mid_y;
					int area_flag = MatchArea(0, cnx, cny);

					if((area_flag == 1) || (interest_cnt == 0))
					{
						if((sz_x * sz_y) > threshold_sz)
						{
							if(visible_debug == 1)
							{
								fl_color(CYAN);
								fl_rect(cam->image_sx + xx1, cam->image_sy + yy1, sz_x, sz_y);
							}
							int nx = (10.0 / (double)cam->width) * (double)xx1;
							int ny = (10.0 / (double)cam->height) * (double)yy1;
							cnt_array[nx][ny] += sz_x * sz_y;
						}
						else if((sz_x * sz_y) > 0)
						{
							if(visible_debug == 1)
							{
								fl_color(RED);
								fl_rect(cam->image_sx + xx1, cam->image_sy + yy1, sz_x, sz_y);
								int px = xx1 * (cam->width / 10);
								int py = yy1 * (cam->height / 10);
								fl_color(GRAY);
								fl_rect(px, py, cam->width / 10, cam->height / 10);
							}
						}
					}
				}
			}
		}
		int old_x = -1;
		int old_y = -1;
		int highest_x = -1;
		int highest_y = -1;
		int highest = 0;
		for(outer = 0;outer < 10;outer++)
		{
			for(inner = 0;inner < 10;inner++)
			{
				if(cnt_array[outer][inner] > highest)
				{
					old_x = highest_x;
					old_y = highest_y;
					highest = cnt_array[outer][inner];
					highest_x = outer * (cam->width / 10);
					highest_y = inner * (cam->height / 10);
					int reverse_x = 0;
					int reverse_y = 0;
					int box_x = highest_x;
					int box_y = highest_y;
					if(highest_x > w() / 2)
					{
						highest_x += (cam->width / 10);
						reverse_x = 1;
					}
					if(highest_y > h() / 2)
					{
						highest_y += (cam->height / 10);
						reverse_y = 1;
					}
					if(visible_debug == 1)
					{
						int off_x = (w() / 2) - (cam->width / 2);
						int off_y = (h() / 2) - (cam->height / 2);
						fl_color(WHITE);
						fl_rect(box_x + off_x, box_y + off_y, cam->width / 10, cam->height / 10);
					}
					r = 1;
				}
			}
		}
		*cx = highest_x;
		*cy = highest_y;
		*second_cx = old_x;
		*second_cy = old_y;
		cam->once = 1;
		cam->old_mat = cow_gray;
	}
	return(r);
}

void	MyWin::CropFrame(Mat in, Mat *out, int xx, int yy, int ww, int hh)
{
	if(xx < 0) 
	{
		ww += xx;
		xx = 0;
	}
	if(yy < 0) 
	{
		yy += yy;
		yy = 0;
	}
	int extent_w = xx + ww;
	if(extent_w >= in.cols)
	{
		ww -= (extent_w - in.cols);
		ww--;
	}
	int extent_h = yy + hh;
	if(extent_h >= in.rows)
	{
		hh -= (extent_h - in.rows);
		hh--;
	}
	if((ww > 0) && (hh > 0))
	{
		cv::Rect roi;
		roi.x = xx;
		roi.y = yy;
		roi.width = ww;
		roi.height = hh;
		*out = in(roi).clone();
	}
	else
	{
printf("BAD CROP: %d %d %d %d\n", xx, yy, ww, hh);
	}
}

void	MyWin::MarkInterestGrid()
{
int	loop;

	int ww = camera[current_source]->width / 10;
	int hh = camera[current_source]->height / 10;
	int orig_x = image_origin_x;
	int orig_y = image_origin_y;
	fl_color(GRAY);
	for(loop = 0;loop < camera[current_source]->width;loop += ww)
	{
		fl_line(loop + orig_x, orig_y, loop + orig_x, orig_y + camera[current_source]->height);
	}
	for(loop = 0;loop < camera[current_source]->height;loop += hh)
	{
		fl_line(orig_x, loop + orig_y, orig_x + camera[current_source]->width, loop + orig_y);
	}
}

void	MyWin::SplitScreen()
{
int	loop;

	int nxx = 0;
	int nyy = 0;
	int sz_w = w();
	int sz_h = h();
	if(source_cnt == 1)
	{
		sz_w = w();
		sz_h = h();
	}
	else if(source_cnt < 5)
	{
		sz_w = w() / 2;
		sz_h = h() / 2;
	}
	else if(source_cnt < 10)
	{
		sz_w = w() / 3;
		sz_h = h() / 3;
	}
	for(loop = 0;loop < source_cnt;loop++)
	{
		if(camera[loop] != NULL)
		{
			int go = 0;
			Mat local_mat;
			if((camera[loop]->power == 1) 
			&& (camera[loop]->type != CAMERA_TYPE_DESKTOP) 
			&& (camera[loop]->type != CAMERA_TYPE_WINDOW)
			&& (camera[loop]->type != CAMERA_TYPE_PSEUDO)
			&& (camera[loop]->type != CAMERA_TYPE_SLIDESHOW)
			&& (camera[loop]->type != CAMERA_TYPE_PLUGIN))
			{
				if(camera[loop]->type == CAMERA_TYPE_IMAGE)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_BLANK)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_HTML)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_SOURCED)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_EDGE_DETECT)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_CHROMAKEY)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_ALTERNATING)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_ALL)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_SPLIT)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_OSG)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_AV)
				{
					if(camera[loop]->av_window != NULL)
					{
						local_mat = camera[loop]->av_window->mat.clone();
						cvtColor(local_mat, local_mat, COLOR_BGR2RGB);
						go = 1;
					}
				}
				else if((camera[loop]->type == CAMERA_TYPE_TEXT) 
				|| (camera[loop]->type == CAMERA_TYPE_DYNAMIC_TEXT)
				|| (camera[loop]->type == CAMERA_TYPE_ALERT)
				|| (camera[loop]->type == CAMERA_TYPE_PIPED))
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
			}
			else if((camera[loop]->power == 1) && (camera[loop]->type == CAMERA_TYPE_DESKTOP))
			{
				GrabDesktop();
				local_mat = desktop_mat.clone();
				go = 1;
			}
			else if((camera[loop]->power == 1) && (camera[loop]->type == CAMERA_TYPE_WINDOW))
			{
				camera[loop]->GrabWindow();
				local_mat = camera[loop]->mat.clone();
				go = 1;
			}
			else if((camera[loop]->power == 1) && (camera[loop]->type == CAMERA_TYPE_SLIDESHOW))
			{
				camera[loop]->GrabSlideshow();
				local_mat = camera[loop]->mat.clone();
				go = 1;
			}
			else if((camera[loop]->power == 1) && (camera[loop]->type == CAMERA_TYPE_PSEUDO))
			{
				local_mat = camera[loop]->mat.clone();
				go = 1;
			}
			else if((camera[loop]->power == 1) && (camera[loop]->type == CAMERA_TYPE_PLUGIN))
			{
				local_mat = camera[loop]->mat.clone();
				go = 1;
			}
			if(go == 1)
			{
				Mat new_mat;
				cv::resize(local_mat, new_mat, cv::Size(sz_w, sz_h));
				if((camera[loop]->flip_vertical == 1) && (camera[loop]->flip_horizontal == 0))
				{
					flip(new_mat, new_mat, 0);
				}
				else if((camera[loop]->flip_vertical == 0) && (camera[loop]->flip_horizontal == 1))
				{
					flip(new_mat, new_mat, 1);
				}
				else if((camera[loop]->flip_vertical == 1) && (camera[loop]->flip_horizontal == 1))
				{
					flip(new_mat, new_mat, -1);
				}
				int test_nxx = nxx + new_mat.cols;
				if(test_nxx > w())
				{
					nxx = 0;
					nyy += new_mat.rows;
				}
				fl_draw_image((unsigned char *)new_mat.ptr(), nxx, nyy, new_mat.cols, new_mat.rows, new_mat.channels());
				fl_color(YELLOW);
				int bx = nxx + (new_mat.cols - 25);
				int by = nyy + 5;
				fl_rect(bx, by, 20, 20);
				fl_line(bx, by, bx + 20, by + 20);
				fl_line(bx, by + 20, bx + 20, by);
				fl_rect(nxx + 8, nyy + 8, 14, 14, YELLOW);
				if(camera[loop]->record == 1)
				{
					fl_rectf(nxx + 10, nyy + 10, 10, 10, RED);
				}
				split_bx[loop] = bx;
				split_by[loop] = by;
				split_rx[loop] = nxx + 8;
				split_ry[loop] = nyy + 8;
				nxx += new_mat.cols;
				if(nxx >= w())
				{
					nxx = 0;
					nyy += new_mat.rows;
				}
			}
			else
			{
				fprintf(stderr, "Error: %d FAILED TO STREAM\n", loop);
			}
		}
		else
		{
			fprintf(stderr, "Error: %d FAILED TO GRAB\n", loop);
		}
	}
}

void	MyWin::ShowLog()
{
extern char		*global_log[128];
extern int		global_log_cnt;
int			loop;

	if(global_log_cnt > 0)
	{
		int hh = 60 + (global_log_cnt * 22);
		if(hh > 400) hh = 400;
		Fl_Window *win = new Fl_Window(600, hh, "Mux Error Log");
		win->box(FL_FRAME_BOX);
		win->color(BLACK);
		win->border(0);
			Fl_Box *title_box = new Fl_Box(0, 0, 600, 25, "Mux Error Log");
			title_box->color(DARK_RED);
			title_box->box(FL_FRAME_BOX);
			title_box->labelsize(13);
			title_box->labelcolor(YELLOW);
			Fl_Scroll *scroll = new Fl_Scroll(2, 30, 596, hh - 34);
			scroll->box(FL_FLAT_BOX);
			scroll->color(BLACK);
			scroll->scrollbar.hide();
				for(loop = 0;loop < global_log_cnt;loop++)
				{
					int xx = 0;
					int yy = 0;
					Fl_Output *box = new Fl_Output(0, 30 + (loop * 22), 750, 22);
					box->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					box->box(FL_FLAT_BOX);
					box->color(BLACK);
					box->textcolor(WHITE);
					box->textsize(12);
					box->value(global_log[loop]);
				}
			scroll->end();
		win->end();
		win->show();
		global_log_cnt = 0;
	}
}

void	MyWin::TagRecognized(Camera *cam, char *label, double confidence)
{
	if(tag_fp != NULL)
	{
		int total_seconds = cam->running_time / 1000;
		int minutes = total_seconds / 60;
		int seconds = total_seconds % 60;
		fprintf(tag_fp, "%03d:%02d\t(%.3f)\t[%s]\n", minutes, seconds, confidence, label);
	}
}

int	MyWin::CountRecordingCameras()
{
int	loop;

	int cnt = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			if(cam->record == 1)
			{
				cnt++;
			}
		}
	}
	return(cnt);
}

void	MyWin::MarkInterest()
{
int	loop;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		int off_x = image_origin_x;
		int off_y = image_origin_y;
		if((nominal_interest_x > -1) && (nominal_interest_y > -1))
		{
			int xx = nominal_interest_x * (cam->width / 10);
			int yy = nominal_interest_y * (cam->height / 10);
			fl_color(YELLOW);
			fl_rectf(off_x + xx, off_y + yy, cam->width / 10, cam->height / 10);
		}
		for(loop = 0;loop < interest_cnt;loop++)
		{
			int nx = interest_x[loop];
			int ny = interest_y[loop];
			int xx = nx * (cam->width / 10);
			int yy = ny * (cam->height / 10);
			fl_color(WHITE);
			fl_rectf(off_x + xx, off_y + yy, cam->width / 10, cam->height / 10);
		}
	}
}

void	MyWin::CalcInitialFPS()
{
char	buf[256];

	Camera *cam = camera[current_source];
	cam->frame_cnt++;
	if(start_time == 0)
	{
		start_time = time(0);
	}
	time_t current_time = time(0);
	time_t elapsed = current_time - start_time;
	if(elapsed < 1) elapsed = 1;
	double nn_fps = (double)cam->frame_cnt / (double)elapsed;
	nn_fps *= 0.85;
	if(nn_fps < 4.0) nn_fps = 4.0;
	if(cam->old_fps == (int)nn_fps)
	{
		cam->fps_cnt++;
	}
	cam->old_fps = (int)nn_fps;
	if((elapsed >= 100) || (cam->fps_cnt > 100))
	{
		cam->fps = nn_fps;
		cam->frame_cnt = 0;
	}
	sprintf(buf, "Testing: %d (%2.2f FPS)", (int)elapsed, nn_fps);
	fl_color(BLACK);
	fl_rectf((w() / 2) - 55, (h() / 2) - 24, 170, 22);
	fl_color(YELLOW);
	fl_font(FL_HELVETICA, 14);
	fl_draw(buf, (w() / 2) - 50, (h() / 2) - 10);
}

void	MyWin::ResizeDetail()
{
	fl_color(WHITE);
	int nx = Fl::event_x();
	int ny = Fl::event_y();

	int nx1 = drag_start_x;
	int nx2 = nx;
	if(drag_start_x > nx)
	{
		nx1 = nx;
		nx2 = drag_start_x;
	}
	int ny1 = drag_start_y;
	int ny2 = ny;
	if(drag_start_y > ny)
	{
		ny1 = ny;
		ny2 = drag_start_y;
	}
	int nnx = nx2 - nx1;
	int nny = ny2 - ny1;
	double aspect = (double)output_height / (double)output_width;
	nny = (int)((double)nnx * aspect);
	fl_rect(nx1, ny1, nnx, nny);
}

void	MyWin::DrawThumbnails()
{
int	loop;

	int tg_cnt = 0;
	int displayed_cnt = 0;
	for(loop = source_cnt;loop < 128;loop++)
	{
		ThumbGroup *tb = thumbnail[loop];
		if(tb != NULL)
		{
			tb->hide();
		}
	}
	int viewable = 0;
	if(video_thumbnail_group->visible())
	{
		for(loop = 0;loop < 128;loop++)
		{
			ThumbGroup *tb = thumbnail[loop];
			if((camera[loop] != NULL) && (tb != NULL))
			{
				Camera *cam = camera[loop];
				if(cam->power == 1)
				{
					viewable++;
				}
			}
		}
	}
	int extent_y = 0;
	if(video_thumbnail_group->visible())
	{
		for(loop = 0;loop < 128;loop++)
		{
			ThumbGroup *tb = thumbnail[loop];
			if((camera[loop] != NULL) && (tb != NULL))
			{
				tb->displayed = 0;
				Camera *cam = camera[loop];
				if(cam->power == 1)
				{
					VideoCapture *cap = cam->cap;
					if(cap != NULL)
					{
						int nw = 153;
						int nh = 86;
						tb->thumb_button->index = loop;
						if(cam->type == CAMERA_TYPE_CAMERA)
						{
							if((cap->isOpened()) || (cam->ndi_capture == 1))
							{
								if(redraw_cnt == 0)
								{
									Mat new_mat;
									if(!cam->mat.empty())
									{
										if((cam->mat.rows > 0) && (cam->mat.cols > 0))
										{
											cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
											tb->thumb_button->mat = new_mat;
											if(trigger_window != NULL)
											{
												ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
												if(trigger_thumb != NULL)
												{
													trigger_thumb->mat = new_mat;
													trigger_thumb->show();
												}
											}
										}
									}
								}
							}
						}
						else if((cam->type == CAMERA_TYPE_TEXT) 
						|| (cam->type == CAMERA_TYPE_DYNAMIC_TEXT)
						|| (cam->type == CAMERA_TYPE_ALERT)
						|| (cam->type == CAMERA_TYPE_PIPED)
						|| (cam->type == CAMERA_TYPE_CLOCK)
						|| (cam->type == CAMERA_TYPE_TIMER))
						{
							if(redraw_cnt == 0)
							{
								if(!cam->mat.empty())
								{
									if((cam->mat.rows > 0) && (cam->mat.cols > 0))
									{
										Mat new_mat;
										cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
										tb->thumb_button->mat = new_mat;
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_DESKTOP)
						{
							if(redraw_cnt == 0)
							{
								if((desktop_mat.cols > 0) && (desktop_mat.rows > 0))
								{
									Mat new_mat;
									if((cam->grab_portion_x > -1)
									&& (cam->grab_portion_y > -1)
									&& (cam->grab_portion_w > -1)
									&& (cam->grab_portion_h > -1))
									{
										GrabDesktop(1);
										Mat local_mat = desktop_mat(Rect(cam->grab_portion_x, cam->grab_portion_y, cam->grab_portion_w, cam->grab_portion_h));
										Mat use_mat = local_mat;
										if(!use_mat.empty())
										{
											cv::resize(use_mat, new_mat, cv::Size(nw, nh));
										}
									}
									else
									{
										if(!desktop_mat.empty())
										{
											cv::resize(desktop_mat, new_mat, cv::Size(nw, nh));
										}
									}
									tb->thumb_button->mat = new_mat;
									if(trigger_window != NULL)
									{
										ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
										if(trigger_thumb != NULL)
										{
											trigger_thumb->mat = new_mat;
											trigger_thumb->show();
										}
									}
								}
							}
						}
						else
						{
							if(redraw_cnt == 0)
							{
								if(!cam->mat.empty())
								{
									Mat new_mat;
									if((cam->mat.rows > 0) && (cam->mat.cols > 0))
									{
										cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
										tb->thumb_button->mat = new_mat;
										if(trigger_window != NULL)
										{
											ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
											if(trigger_thumb != NULL)
											{
												trigger_thumb->mat = new_mat;
												trigger_thumb->show();
											}
										}
									}
								}
							}
						}
					}
					if((cam->type == CAMERA_TYPE_IMAGE) 
					|| (cam->type == CAMERA_TYPE_TEXT) 
					|| (cam->type == CAMERA_TYPE_DYNAMIC_TEXT) 
					|| (cam->type == CAMERA_TYPE_ALERT) 
					|| (cam->type == CAMERA_TYPE_CLOCK) 
					|| (cam->type == CAMERA_TYPE_TIMER) 
					|| (cam->type == CAMERA_TYPE_PIPED))
					{
						tb->detect_motion->hide();
						tb->detect_object->hide();
						tb->set_color->show();
						if((cam->type == CAMERA_TYPE_TEXT) 
						|| (cam->type == CAMERA_TYPE_DYNAMIC_TEXT)
						|| (cam->type == CAMERA_TYPE_ALERT)
						|| (cam->type == CAMERA_TYPE_PIPED)
						|| (cam->type == CAMERA_TYPE_CLOCK)
						|| (cam->type == CAMERA_TYPE_TIMER))
						{
							tb->set_text_color->show();
						}
					}
					if((tg_cnt >= video_thumbnail_group->start_thumbgroup) && (tg_cnt < (video_thumbnail_group->start_thumbgroup + DISPLAYED_THUMB_CNT)))
					{
						int xx = video_thumbnail_group->x();
						int yy = video_thumbnail_group->y();
						tb->resize(xx, yy + (tb->h() * displayed_cnt), tb->w(), tb->h());
						tb->redraw();
						tb->alias_button->copy_label(cam->alias);
						tb->show();
						if(loop == displayed_source)
						{
							tb->displayed = 1;
						}
						displayed_cnt++;
						extent_y += tb->h();
					}
					else
					{
						tb->hide();
					}
					tg_cnt++;
				}
				else
				{
					int xx = video_thumbnail_group->x();
					int yy = video_thumbnail_group->y();
					tb->resize(xx, yy + (tb->h() * displayed_cnt), tb->w(), tb->h());
					tb->redraw();
					tb->alias_button->copy_label(cam->alias);
					tb->show();
					if(loop == displayed_source)
					{
						tb->box(FL_FRAME_BOX);
					}
					else
					{
						tb->box(FL_FLAT_BOX);
					}
					displayed_cnt++;
					extent_y += tb->h();
				}
			}
		}
	}
	if(viewable > DISPLAYED_THUMB_CNT)
	{
		fl_color(YELLOW);
		fl_rect(0, extent_y + 15, 260, 10);
	}
}

void	MyWin::TriggerCamera(Camera *cam)
{
int	loop;

	if(cam != NULL)
	{
		if((cam->record_trigger & ON_TRIGGER_CAMERA) == ON_TRIGGER_CAMERA)
		{
			if(cam->trigger_cnt > 0)
			{
				int flag = 0;
				for(loop = 0;loop < cam->trigger_cnt;loop++)
				{
					int trig = cam->trigger[loop];
					if(trig > -1)
					{
						if(camera[trig] != NULL)
						{
							if(camera[trig] != cam)
							{
								if(camera[trig]->record == 1)
								{
									cam->record = 1;
									flag = 1;
								}
							}
						}
					}
				}
				if(flag == 0)
				{
					cam->record = 0;
				}
			}
		}
	}
}

void	MyWin::DrawPIP()
{
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if((im_drawing_mode == 0) || (recording == 0))
		{
			if(camera[cam->pip_idx] != NULL)
			{
				Mat local_mat;
				camera[cam->pip_idx]->Capture();
				local_mat = camera[cam->pip_idx]->mat;
				if(!local_mat.empty())
				{
					Mat new_mat;
					int nw = local_mat.cols / 2;
					int nh = local_mat.rows / 2;
					cv::resize(local_mat, new_mat, cv::Size(nw, nh));
					fl_draw_image((unsigned char *)new_mat.ptr(), w() - (nw + 50), h() - (nh + 50), new_mat.cols, new_mat.rows, new_mat.channels());
					if(cam->keep_pip == 0)
					{
						fl_color(WHITE);
					}
					else
					{
						fl_color(YELLOW);
					}
					fl_rect(w() - (nw + 50), h() - (nh + 50), new_mat.cols, new_mat.rows);
				}
			}
		}
	}
}

void	MyWin::DrawEmbeddedPIP()
{
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if(camera[cam->pip_idx] != NULL)
		{
			Mat local_mat;
			camera[cam->pip_idx]->Capture();
			local_mat = camera[cam->pip_idx]->mat;
			if(!local_mat.empty())
			{
				Mat new_mat;
				Mat dst = cam->mat;
				int nw = (int)((double)local_mat.cols * pip_size);
				int nh = (int)((double)local_mat.rows * pip_size);
				cv::resize(local_mat, new_mat, cv::Size(nw, nh));

				int px = (int)((double)dst.cols * pip_x_position);
				int py = (int)((double)dst.rows * pip_y_position);

				int dx = dst.cols - (px + nw);
				if(dx < 0) px += dx;
				int dy = dst.rows - (py + nh);
				if(dy < 0) py += dy;

				new_mat.copyTo(dst.rowRange(py, py + nh).colRange(px, px + nw));
				if((pip_red > -1) && (pip_green > -1) && (pip_blue > -1))
				{
					rectangle(dst, Point(px, py), Point(px + nw, py + nh), Scalar(pip_blue, pip_green, pip_red), 1);
				}
			}
		}
	}
}

void	MyWin::DrawEncodingMessage()
{
char	buf[256];

	int ww = (w() / 2);
	sprintf(buf, "Encoding: %d of %d", encoding, encoding_frame_cnt);
	int xx = 0;
	int yy = 0;
	fl_measure(buf, xx, yy);
	int nx = ww - (xx / 2);
	fl_color(BLACK);
	fl_rectf(nx, 12, 250, 22);
	fl_font(FL_HELVETICA, 14);
	fl_color(YELLOW);
	fl_draw(buf, nx, 12, 250, 22, FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
}

void	update_extracting_message(int type)
{
	if(global_window != NULL)
	{
		global_window->extracting += type;
		if((global_window->extracting % 100) == 0)
		{
			global_window->redraw();
			Fl::check();
		}
	}
}

void	MyWin::DrawExtractingMessage()
{
char	buf[256];

	if(extracting > 0)
	{
		sprintf(buf, "Extracting Video: %d", abs(extracting));
	}
	else
	{
		sprintf(buf, "Extracting Audio: %d", abs(extracting));
	}
	fl_color(BLACK);
	fl_rectf(550, 8, 250, 27);
	fl_font(FL_HELVETICA, 14);
	fl_color(YELLOW);
	fl_draw(buf, 570, 27);
}

void	MyWin::DrawDumpingMessage()
{
char	buf[256];

	if(dumped_limit > -1)
	{
		sprintf(buf, "%s: %ld OF %ld", dump_type, dumped_frames, dumped_limit);
	}
	else if(dumped_frames > -1)
	{
		sprintf(buf, "%s: %ld", dump_type, dumped_frames);
	}
	else
	{
		sprintf(buf, "%s", dump_type);
	}
	fl_color(BLACK);
	fl_rectf(550, 8, 250, 27);
	fl_font(FL_HELVETICA, 14);
	fl_color(YELLOW);
	fl_draw(buf, 570, 27);
}

void	MyWin::DisplayRecordingCamera()
{
int	outer;

	int cnt = 0;
	int use_cam = -1;
	for(outer = 0;outer < source_cnt;outer++)
	{
		if(camera[outer] != NULL)
		{
			Camera *cam = camera[outer];
			if(cam->record == 1)
			{
				cnt++;
				use_cam = outer;
			}
		}
	}
	if(cnt == 1)
	{
		DisplayCamera(use_cam);
	}
}

void	MyWin::SetAllCamerasToStream(Camera *in_cam)
{
int	outer;

	int cnt = 0;
	int use_cam = -1;
	for(outer = 0;outer < source_cnt;outer++)
	{
		if(camera[outer] != NULL)
		{
			Camera *cam = camera[outer];
			cam->save_fifo = in_cam->save_fifo;
			cam->fd = in_cam->fd;
		}
	}
}

void	MyWin::SetAllCamerasToStop()
{
int	outer;

	int cnt = 0;
	int use_cam = -1;
	for(outer = 0;outer < source_cnt;outer++)
	{
		if(camera[outer] != NULL)
		{
			Camera *cam = camera[outer];
			cam->stopped = 1;
		}
	}
}

void	MyWin::SetAllCamerasToGo()
{
int	outer;

	int cnt = 0;
	int use_cam = -1;
	for(outer = 0;outer < source_cnt;outer++)
	{
		if(camera[outer] != NULL)
		{
			Camera *cam = camera[outer];
			cam->stopped = 0;
		}
	}
}

void	MyWin::FrameForMuxer(Camera *cam, Mat in_mat)
{
static Mat	local_mat[128];
int			loop;

	pthread_mutex_lock(&mux_mutex);
	int use = cam->id;
	if((output_width != in_mat.cols) || (output_height != in_mat.rows))
	{
		Mat scale_mat;
		if(crop_output == 0)
		{
			cv::resize(in_mat, scale_mat, cv::Size(output_width, output_height));
		}
		else
		{
			crop_section(in_mat, scale_mat, crop_output_x, crop_output_y, output_width, output_height);
		}
		cvtColor(scale_mat, local_mat[use], COLOR_RGB2YUV_I420);
		if(monitor_window != NULL)
		{
			if(monitor_window->visible())
			{
				monitor_window->mat = scale_mat.clone();
				monitor_window->depth = scale_mat.channels();
				monitor_window->resize(monitor_window->x(), monitor_window->y(), scale_mat.cols / monitor_window->size, scale_mat.rows / monitor_window->size);
			}
		}
	}
	else
	{
		cvtColor(in_mat, local_mat[use], COLOR_RGB2YUV_I420);
		if(monitor_window != NULL)
		{
			if(monitor_window->visible())
			{
				monitor_window->mat = in_mat.clone();
				monitor_window->depth = in_mat.channels();
				monitor_window->resize(monitor_window->x(), monitor_window->y(), in_mat.cols / monitor_window->size, in_mat.rows / monitor_window->size);
			}
		}
	}
	if(single_stream == 0)
	{
		int use = cam->id;
		if(my_muxer[use] != NULL)
		{
			if(my_muxer[use]->fresh_image == 0)
			{
				my_muxer[use]->frame_ptr = local_mat[use].ptr();
				my_muxer[use]->fresh_image++;
			}
		}
	}
	else
	{
		for(loop = 0;loop < 128;loop++)
		{
			if(my_muxer[loop] != NULL)
			{
				if(my_muxer[loop]->fresh_image == 0)
				{
					my_muxer[loop]->frame_ptr = local_mat[use].ptr();
					my_muxer[loop]->fresh_image = 1;
				}
			}
		}
	}
	if(ndi_streaming == 1)
	{
		StreamToNDI(cam, SEND_NDI_VIDEO);
	}
	pthread_mutex_unlock(&mux_mutex);
}

void	MyWin::DrawPIPsAfter()
{
	if(embed_pip == 0)
	{
		Camera *cam = DisplayedCamera();
		if(cam != NULL)
		{
			if(multipip > 0)
			{
				cam->DrawPIP();
			}
			else
			{
				if((cam->pip_idx > -1) && (cam->pip_idx != displayed_source))
				{
					Camera *local_cam = camera[cam->pip_idx];
					if(local_cam != NULL)
					{
						if(local_cam->power == 1)
						{
							VideoCapture *cap = local_cam->cap;
							if(cap != NULL)
							{
								DrawPIP();
							}
						}
					}
				}
			}
		}
	}
}

void	MyWin::DisplayOutput(Camera *cam, Mat in_mat, Camera *alt_cam)
{
	if(display_video == 1)
	{
		int local_display_width = cam->display_width * image_display_scale;
		int local_display_height = cam->display_height * image_display_scale;
		if(alt_cam == NULL)
		{
			if(((cam->record_trigger & ON_DETECT_MOTION) == ON_DETECT_MOTION) && (motion_debug == 1))
			{
				if((cam->motion_mat.rows == cam->mat.rows)
				&& (cam->motion_mat.cols == cam->mat.cols))
				{
					Mat dst, cow_gray;
					cvtColor(cam->mat, cow_gray, COLOR_RGB2GRAY);
					addWeighted(cow_gray, 0.5, cam->motion_mat, 0.5, 0.0, dst);
					if((initial_video_out_x > -1000000) && (initial_video_out_y > -1000000))
					{
						cam->image_sx = initial_video_out_x;
						cam->image_sy = initial_video_out_y;
					}
					fl_draw_image((unsigned char *)dst.ptr(), cam->image_sx, cam->image_sy, cam->motion_mat.cols, cam->motion_mat.rows, cam->motion_mat.channels());
					image_origin_x = cam->image_sx;
					image_origin_y = cam->image_sy;
				}
			}
			else
			{
				if((local_display_width != in_mat.cols) || (local_display_height != in_mat.rows))
				{
					Mat really_local_mat;
					int interpolation = cv::INTER_AREA;
					if(image_display_scale > 1.0)
					{
						interpolation = cv::INTER_CUBIC;
					}
					cv::resize(in_mat, really_local_mat, cv::Size(local_display_width, local_display_height), 0, 0, interpolation);
					int use_x = (Fl::w() / 2) - (really_local_mat.cols / 2);
					int use_y = (Fl::h() / 2) - (really_local_mat.rows / 2);
					if((initial_video_out_x > -1000000) && (initial_video_out_y > -1000000))
					{
						use_x = initial_video_out_x;
						use_y = initial_video_out_y;
					}
					fl_draw_image((unsigned char *)really_local_mat.ptr(), use_x, use_y, really_local_mat.cols, really_local_mat.rows, really_local_mat.channels());
					image_origin_x = use_x;
					image_origin_y = use_y;
					cam->image_sx = use_x;
					cam->image_sy = use_y;
				}
				else
				{
					if((initial_video_out_x > -1000000) && (initial_video_out_y > -1000000))
					{
						cam->image_sx = initial_video_out_x;
						cam->image_sy = initial_video_out_y;
					}
					else
					{
						cam->image_sx = (w() / 2) - (cam->mat.cols / 2);
						cam->image_sy = (h() / 2) - (cam->mat.rows / 2);
					}
					fl_draw_image((unsigned char *)in_mat.ptr(), cam->image_sx, cam->image_sy, cam->mat.cols, cam->mat.rows, cam->mat.channels());
					image_origin_x = cam->image_sx;
					image_origin_y = cam->image_sy;
				}
			}
		}
		else
		{
			Mat use_mat = alt_cam->mat;
			Mat really_local_mat;
			int interpolation = cv::INTER_AREA;
			if(image_display_scale > 1.0)
			{
				interpolation = cv::INTER_CUBIC;
			}
			cv::resize(use_mat, really_local_mat, cv::Size(local_display_width, local_display_height), 0, 0, interpolation);
			int use_x = (Fl::w() / 2) - (really_local_mat.cols / 2);
			int use_y = (Fl::h() / 2) - (really_local_mat.rows / 2);
			if((initial_video_out_x > -1000000) && (initial_video_out_y > -1000000))
			{
				use_x = initial_video_out_x;
				use_y = initial_video_out_y;
			}
			fl_draw_image((unsigned char *)really_local_mat.ptr(), use_x, use_y, really_local_mat.cols, really_local_mat.rows, really_local_mat.channels());
			image_origin_x = use_x;
			image_origin_y = use_y;
		}
	}
}

void	MyWin::DrawPTZZoomer(int use_image_sx, int use_image_sy)
{
int	loop;

	if((use_image_sx > -1) && (use_image_sy > -1))
	{
		int xx = use_image_sx + 10;
		int yy = (use_image_sy + in_mat.rows) - 40;
		if(ptz_window[0] != NULL)
		{
			for(loop = 0;loop < abs(ptz_window[0]->ptz_zoomer_speed);loop++)
			{
				if(ptz_zoomer > 0)
				{
					fl_color(WHITE);
					fl_line(xx, yy - (loop * 2), xx + 10, yy - (loop * 2));
				}
				else
				{
					fl_color(YELLOW);
					fl_line(xx, yy + (loop * 2), xx + 10, yy + (loop * 2));
				}
			}
		}
	}
}

void	MyWin::DrawEmbeddedApps()
{
int	loop;

	for(loop = 0;loop < 10;loop++)
	{
		EmbedAppWindow *eaw = embedded_app[loop];
		if(eaw != NULL)
		{
			fl_color(DARK_GRAY);
			fl_rectf(eaw->my_x, h() - 25, eaw->my_w, 25);
			fl_color(WHITE);
			fl_draw(eaw->title, eaw->my_x + 10, h() - 25, eaw->my_w, 25, FL_ALIGN_LEFT);
			fl_color(YELLOW);
			int nx1 = (eaw->my_x + eaw->my_w) - 20;
			int nx2 = (eaw->my_x + eaw->my_w) - 10;
			fl_rect(nx1, h() - 20, 11, 11);
			fl_line(nx1, h() - 20, nx2, (h() - 20) + 10); 
			fl_line(nx2, h() - 20, nx1, (h() - 20) + 10); 
		}
	}
}

void	MyWin::SetErrorMessage(char *msg, int in_timeout)
{
	error_timeout = in_timeout;
	if(error_message != NULL)
	{
		free(error_message);
	}
	error_message = strdup(msg);
	error_start_time = time(0);
}

void	MyWin::ErrorMessage()
{
	if(error_message != NULL)
	{
		fl_font(FL_HELVETICA, 32);
		int ex = 0;
		int ey = 0;
		fl_measure(error_message, ex, ey);
		ex += 16;
		ey += 4;
		int xx = (Fl::w() / 2) - (ex / 2);
		int yy = (Fl::h() / 2) - (ey / 2);
		fl_color(RED);
		fl_rectf(xx, yy, ex, ey);
		fl_color(WHITE);
		fl_rect(xx, yy, ex, ey);
		fl_draw(error_message, xx, yy, ex, ey, FL_ALIGN_CENTER);
		if((time(0) - error_start_time) > error_timeout)
		{
			free(error_message);
			error_message = NULL;
		}
	}
}

void	MyWin::draw()
{
struct tm	*tm;
int			loop;
char		buf[256];
int			inner;
int			outer;

	fl_color(BLACK);
	fl_rectf(0, 0, w(), h());
	fl_color(YELLOW);
	fl_font(FL_HELVETICA, 11);
	int use_image_sx = -1;
	int use_image_sy = -1;
	if(follow_mode == FOLLOW_MODE_DISPLAY_RECORDING_CAMERA)
	{
		DisplayRecordingCamera();
	}
	Camera *alt_cam = NULL;
	if((source_cnt > 0) && (actively_exiting == 0))
	{
		for(outer = 0;outer < source_cnt;outer++)
		{
			if(camera[outer] != NULL)
			{
				Camera *cam = camera[outer];
				if(cam->power == 1)
				{
					VideoCapture *cap = cam->cap;
					if(cap != NULL)
					{
						if(cap->isOpened())
						{
							TriggerCamera(cam);
						}
						else if(cam->type == CAMERA_TYPE_IMAGE)
						{
							TriggerCamera(cam);
						}
					}
					current_source = outer;
					all_frames++;
					if((redraw_cnt == 0) 
					|| (outer == displayed_source) 
					|| (split == 1) 
					|| (cam->priority == 1) 
					|| (cam->snapshot == 1) 
					|| (cam->record == 1))
					{
						cam->Capture();
						cam->focus_frame_ready = 1;
						if(alt_displayed_source > -1)
						{
							alt_cam = camera[alt_displayed_source];
							if(alt_cam->power == 1)
							{
								alt_cam->Capture();	
							}
						}
					}
					if(outer == displayed_source)
					{
						if(embed_pip == 1)
						{
							if(multipip > 0)
							{
								cam->DrawPIP();
							}
							else
							{
								cam->DrawEmbeddedPIP();
							}
						}
					}
					in_mat = cam->mat;
					if(!in_mat.empty())
					{
						cam->true_total_frames++;
						cam->local_ts = local_timestamp();
						cam->failed = 0;
						int moving_element = 0;
						int someone_is_dragging = 0;
						if(cam->record == 1)
						{
							cam->DrawImageWindowsBefore(-1, 1, in_mat, moving_element, someone_is_dragging);
							if((muxer_cnt > 0) || (single_stream == 0) || (ndi_streaming == 1))
							{
								FrameForMuxer(cam, in_mat);
							}
							else
							{
								cam->Record();
							}
						}
						if(monitor_window != NULL)
						{
							if(monitor_window->visible())
							{
								monitor_window->redraw();
							}
						}
						if(transmitting == 1)
						{
							if(outer == displayed_source)
							{
								cam->PrepImageForNet(in_mat);
							}
						}
						int took_snapshot = 0;
						if(cam->snapshot == 1)
						{
							if(outer == displayed_source)
							{
								cam->SnapshotFrame();
								fl_color(YELLOW);
								took_snapshot = 1;
								cam->snapshot = 0;
							}
						}
						if(outer == displayed_source)
						{
							if(split == 0)
							{
								if(cam->zoom_box_display == 0)
								{
									use_image_sx = cam->image_sx;
									use_image_sy = cam->image_sy;
								}
								DisplayOutput(cam, in_mat, alt_cam);
								cam->PaintRecognizedObjects(test_recognition);
								if((crop_output == 1) && (alt_cam == NULL))
								{
									if((output_width < in_mat.cols) || (output_height < in_mat.rows))
									{
										int xx = crop_output_x + cam->image_sx;
										int yy = crop_output_y + cam->image_sy;
										fl_rect(xx, yy, output_width, output_height, YELLOW);
										fl_line(xx - 3, yy + 10, xx - 3, yy - 3, xx + 10, yy - 3);
										fl_line(xx + output_width - 10, yy - 3, xx + output_width + 3, yy - 3, xx + output_width + 3, yy + 10);
										fl_line(xx - 3, yy + output_height - 10, xx - 3, yy + output_height + 3, xx + 10, yy + output_height + 3);
										fl_line(xx + output_width + 3, yy + output_height - 10, xx + output_width + 3, yy + output_height + 3, xx + output_width - 10, yy + output_height + 3);
									}
								}
								if(move_corner == 1)
								{
									fl_color(YELLOW);
									fl_rectf(cam->image_sx + 2, cam->image_sy + 2, 25, 25);
								}
								if(resize_corner == 1)
								{
									fl_color(BLUE);
									fl_rectf(cam->image_sx + cam->display_width - 27, cam->image_sy + cam->display_height - 27, 25, 25);
								}
								if(restore_corner == 1)
								{
									fl_color(FL_GREEN);
									fl_rectf(cam->image_sx + 2, cam->image_sy + cam->display_height - 27, 25, 25);
								}
								if((buttonized_visible == 1) || (someone_is_dragging == 1))
								{
									cam->DrawImageWindowsAfter();
								}
								if(highlight_image_windows == 1)
								{
									cam->HighlightImageWindows();
								}
								if(grid_size > 1)
								{
									if(moving_element == 1)
									{
										cam->DrawImageWindowGrid(grid_size);
									}
								}
							}
						}
						if(took_snapshot == 1)
						{
							if((cam->display_width < w()) || (cam->display_height < h()))
							{
								fl_rect(cam->image_sx - 5, cam->image_sy - 5, cam->display_width + 10, cam->display_height + 10);
							}
							else
							{
								fl_rectf(0, 0, w(), h());
							}
						}
						if(outer == displayed_source)
						{
							if(guideline_cnt > 0)
							{
								for(loop = 0;loop < guideline_cnt;loop++)
								{
									if(guideline[loop] != NULL)
									{
										if(guideline[loop]->hide == 0)
										{
											if(guideline[loop]->type == HORIZONTAL_GUIDELINE)
											{
												int use_y = guideline[loop]->pos + cam->image_sy;
												fl_color(RED);
												fl_line(cam->image_sx, use_y, cam->image_sx + (int)display_width, use_y);
											}
											else if(guideline[loop]->type == VERTICAL_GUIDELINE)
											{
												int use_x = guideline[loop]->pos + cam->image_sx;
												fl_color(RED);
												fl_line(use_x, cam->image_sy, use_x, cam->image_sy + (int)display_height);
											}
										}
									}
								}
							}
						}
						if(mark_interest == 1)
						{
							if(split == 0)
							{
								MarkInterestGrid();
							}
						}
						else if(cam->fps > 0.0)
						{
							if(zoom_boxing == 0)
							{
								if(pulse_mixer != NULL)
								{
									if(split == 0)
									{
										int no_go = 0;
										if(anim_timeline != NULL)
										{
											if(anim_timeline->visible())
											{
												no_go = 1;
											}
										}
										if(no_go == 0)
										{
											DrawAudioGraph(cam);
										}
									}
								}
								if(cam == DisplayedCamera())
								{
									if(split == 0)
									{
										current_fps_window->showing = 1;
										current_fps_window->draw();
										current_fps_window->showing = 0;
									}
								}
							}
						}
						else
						{
							CalcInitialFPS();
						}
					}
					else
					{
						if(outer == displayed_source)
						{
							if(cam->failed > 30)
							{
								SetErrorMessage("No Frame");
								cam->failed = 0;
							}
							cam->failed++;
							usleep(30000);
						}
					}
				}
				if(split == 0)
				{
					cam->DrawFilterDialogs();
					cam->HighlightShapes();
				}
			}
			else
			{
				fprintf(stderr, "Error: Current stream (%d of %d) is NULL.\n", outer, source_cnt);
				CompressCameraList();
				UpdateThumbButtons();
			}
		}
		if(split == 0)
		{
			if((magic_x > -1) && (magic_y > -1))
			{
				int sx = (w() / 2) - (1280 / 2) + magic_x;
				int sy = (h() / 2) - (720 / 2) + magic_y;
				fl_color(YELLOW);
				fl_rect(sx, sy, 100, 100);
			}
			if(mark_interest == 1)
			{
				MarkInterest();
			}
			if((zoom_boxing == 1) && (drag_start_x > -1) && (drag_start_y > -1))
			{
				ResizeDetail();
			}
			if(ptz_zoomer != 0)
			{
				DrawPTZZoomer(use_image_sx, use_image_sy);
			}
			if(ptz_joystick == 1)
			{
				fl_color(GRAY);
				int cx = w() / 2;
				int cy = h() / 2;
				for(loop = 1;loop <= 100;loop += 10)
				{
					fl_rect(cx - loop, cy - loop, (loop * 2), (loop * 2));
				}
				fl_color(YELLOW);
				fl_rect(cx + (ptz_joystick_x - 10), cy + (ptz_joystick_y - 10), 20, 20);
			}
			if(center_message_timer > 0)
			{
				fl_color(YELLOW);
				fl_font(FL_HELVETICA, 36);
				int use_x = 0;
				int use_y = 0;
				fl_measure(center_message, use_x, use_y);
				fl_draw(center_message, (w() / 2) - (use_x / 2), (h() / 2) - (use_y / 2));
				center_message_timer--;
			}
			if(source_cnt > 0)
			{
				if(video_thumbnail_group->visible())
				{
					DrawThumbnails();
				}
				DrawPIPsAfter();
			}
		}
		else
		{
			fl_rectf(x(), y(), w(), h(), BLACK);
			SplitScreen();
		}
		if((dumped_frames > 0) || (dump_type != NULL))
		{
			DrawDumpingMessage();
		}
		if(encoding > 0)
		{
			DrawEncodingMessage();
		}
		if(extracting != 0)
		{
			DrawExtractingMessage();
		}
		else
		{
			Camera *cam = DisplayedCamera();
			if(cam != NULL)
			{
				if(cam->type == CAMERA_TYPE_AV)
				{
					cam->DisplayAVWindow();
				}
				else
				{
					progress_scrubber->hide();
				}
			}
			else
			{
				progress_scrubber->hide();
			}
		}
		Fl_Double_Window::draw();
		if(transitions_window != NULL)
		{
			if(transitions_window->visible())
			{
				transitions_window->Update();
			}
		}
		DrawEmbeddedApps();
		if(dragging_thumb != NULL)
		{
			ThumbButton *tb = dragging_thumb;
			fl_draw_image(tb->mat.ptr(), Fl::event_x(), Fl::event_y(), tb->mat.cols, tb->mat.rows, tb->mat.channels());
			dragging_thumb_x = Fl::event_x();
			dragging_thumb_y = Fl::event_y();
		}
		if(split == 0)
		{
			if((rubberband_x > -1)
			&& (rubberband_y > -1)
			&& (rubberband_w > -1)
			&& (rubberband_h > -1))
			{
				fl_color(WHITE);
				fl_rect(rubberband_x, rubberband_y, rubberband_w, rubberband_h);
			}
			if(retain_commands == 0)
			{
				if(mouse_moving > 0)
				{
					fl_color(YELLOW);
					if(!button_group->visible())
					{
						if(button_group_side == SIDE_RIGHT)
						{
							fl_line(w() - 1, button_group->y(), w() - 1, button_group->y() + button_group->h());
						}
						else
						{
							fl_line(0, button_group->y(), 0, button_group->y() + button_group->h());
						}
					}
					if(!video_thumbnail_group->visible())
					{
						if(button_group_side == SIDE_RIGHT)
						{
							fl_line(0, video_thumbnail_group->y(), 0, video_thumbnail_group->y() + video_thumbnail_group->h());
						}
						else
						{
							fl_line(w() - 1, video_thumbnail_group->y(), w() - 1, video_thumbnail_group->y() + button_group->h());
						}
					}
					if(!audio_thumbnail_group->visible())
					{
						fl_line(audio_thumbnail_group->x(), 0, audio_thumbnail_group->x() + audio_thumbnail_group->w(), 0);
					}
					for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
					{
						if(ptz_window[loop] != NULL)
						{
							if(ptz_window[loop]->showing == 1)
							{
								if(!ptz_window[loop]->visible())
								{
									fl_line(ptz_window[loop]->x(), h() - 1, ptz_window[loop]->x() + ptz_window[loop]->w(), h() - 1);
								}
							}
						}
					}
				}
			}
		}
		redraw_cnt++;
		if(redraw_cnt > 60)
		{
			redraw_cnt = 0;
		}
		refreshed = 1;
	}
	else
	{
		SetErrorMessage("No Source\n(click here)");
	}
	if(exit_timer > 0)
	{
		if(actively_exiting == 0)
		{
			char buf[128];
			time_t diff = exit_timer - time(0);
			sprintf(buf, "%ld", diff);
			fl_color(WHITE);
			fl_font(FL_HELVETICA, 64);
			fl_draw("Press Escape to Exit", 0, 0, w(), h() - 250, FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			fl_font(FL_HELVETICA, 128);
			fl_draw(buf, 0, 0, w(), h(), FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		}
		else
		{
			fl_color(WHITE);
			fl_font(FL_HELVETICA, 42);
			fl_draw("Exiting", 0, 0, w(), h(), FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		}
	}
	else
	{
		ErrorMessage();
	}
}

void	MyWin::FrameImage(Camera *cam, Mat& in_mat, Mat& out_mat, double force_aspect_x, double force_aspect_y)
{
	if((force_aspect_x != 1.0) || (force_aspect_y != 1.0))
	{
		int ww = in_mat.cols * force_aspect_x;
		int hh = in_mat.rows * force_aspect_y;
		cv::resize(in_mat, in_mat, cv::Size(ww, hh));
	}
	if((in_mat.cols != output_width) || (in_mat.rows != output_height))
	{
		if(crop_scaling == 0)
		{
			double ratio = (double)in_mat.cols / (double)in_mat.rows;
			double output_ratio = (double)output_width / (double)output_height;
			if(ratio != output_ratio)
			{
				double use_ratio_x = (double)output_width / (double)in_mat.cols;
				double use_ratio_y = (double)output_height / (double)in_mat.rows;
				double use_ratio = use_ratio_y;
				if(use_ratio_x < use_ratio_y)
				{
					use_ratio = use_ratio_x;
				}
				int nn_rows = (int)((double)in_mat.rows * use_ratio);
				int nn_cols = (int)((double)in_mat.cols * use_ratio);
				cv::resize(in_mat, out_mat, cv::Size(nn_cols, nn_rows));
				if(in_mat.channels() == 4)
				{
					cv::Mat local_mat(output_height, output_width, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					int start_x = (output_width / 2) - (out_mat.cols / 2);
					int start_y = (output_height / 2) - (out_mat.rows / 2);
					out_mat.copyTo(local_mat.rowRange(start_y, start_y + out_mat.rows).colRange(start_x, start_x + out_mat.cols));
					out_mat = local_mat.clone();
					cam->last_start_x = start_x;
					cam->last_start_y = start_y;
				}
				else
				{
					cv::Mat local_mat(output_height, output_width, CV_8UC3, cv::Scalar(0, 100, 80));
					int start_x = (output_width / 2) - (out_mat.cols / 2);
					int start_y = (output_height / 2) - (out_mat.rows / 2);
					out_mat.copyTo(local_mat.rowRange(start_y, start_y + out_mat.rows).colRange(start_x, start_x + out_mat.cols));
					out_mat = local_mat.clone();
					cam->last_start_x = start_x;
					cam->last_start_y = start_y;
				}
			}
		}
		else if(crop_scaling == 1)
		{
			if((in_mat.cols > output_width) && (in_mat.rows > output_height))
			{
				if(cam->crop_start_x + output_width >= in_mat.cols)
				{
					cam->crop_start_x = (in_mat.cols - output_width) - 1;
				}
				if(cam->crop_start_y + output_height >= in_mat.rows)
				{
					cam->crop_start_y = (in_mat.rows - output_height) - 1;
				}
				if(cam->crop_start_x < 0) cam->crop_start_x = 0;
				if(cam->crop_start_y < 0) cam->crop_start_y = 0;
				crop_section(in_mat, out_mat, cam->crop_start_x, cam->crop_start_y, output_width, output_height);
				cam->last_start_x = cam->crop_start_x;
				cam->last_start_y = cam->crop_start_y;
			}
			else if((in_mat.cols < output_width) && (in_mat.rows < output_height))
			{
				cv::Mat local_mat(output_height, output_width, CV_8UC4, cv::Scalar(0, 0, 0, 0));
				int start_x = (output_width / 2) - (out_mat.cols / 2);
				int start_y = (output_height / 2) - (out_mat.rows / 2);
				if(cam->use_crop_start == 1)
				{
					start_x = cam->crop_start_x;
					if(start_x + out_mat.cols >= local_mat.cols)
					{
						int diff = (start_x + out_mat.cols) - local_mat.cols;
						start_x -= (diff + 1);
					}
					start_y = cam->crop_start_y;
					if(start_y + out_mat.rows >= local_mat.rows)
					{
						int diff = (start_y + out_mat.rows) - local_mat.rows;
						start_y -= (diff + 1);
					}
				}
				out_mat.copyTo(local_mat.rowRange(start_y, start_y + out_mat.rows).colRange(start_x, start_x + out_mat.cols));
				out_mat = local_mat.clone();
				cam->last_start_x = start_x;
				cam->last_start_y = start_y;
			}
			else
			{
				cv::resize(in_mat, out_mat, cv::Size(output_width, output_height));
				cam->last_start_x = 0;
				cam->last_start_y = 0;
			}
		}
		else
		{
			cv::resize(in_mat, out_mat, cv::Size(output_width, output_height));
			cam->last_start_x = 0;
			cam->last_start_y = 0;
		}
	}
}

void	MyWin::GrabDesktop(int retain_size)
{
static int		radius = 10;
static char		buf[256];
static int 		text_countdown = 0;

	int depth = 0;
	int sz = 0;
	if(desktop_x == -1) desktop_x = 0;
	if(desktop_y == -1) desktop_y = 0;
	if(desktop_w == -1) desktop_w = Fl::w();
	if(desktop_h == -1) desktop_h = Fl::h();
	time_t start = time(0);
	unsigned char *b = NULL;
	Mat use;
	int alt_capture = 0;
	int width = 0;
	int height = 0;
	if(void_capture_capture != NULL)
	{
		b = local_capture_cap(&width, &height);
		alt_capture = 1;
		retain_size = 0;
	}
	else
	{
		int use_w = desktop_w;
		int use_h = desktop_h;
		b = grab_raw_image(NULL, desktop_x, desktop_y, use_w, use_h, &sz, &depth);
		width = use_w;
		height = use_h;
	}
	if(b != NULL)
	{
		int mx = 0;
		int my = 0;
		int buttons = 0;
		x11_mouse(mx, my, buttons);
		char keystring[256];
		strcpy(keystring, "");
		map_busy_key(keystring);
	
		double s = Fl::screen_scale(0);
		Mat src(height, width, CV_8UC4, (void *)b);
		if((render_mouse == 1) && (alt_capture == 0))
		{
			if(tutorial_mode == 1)
			{
				int do_it = 0;
				Scalar line_color(150, 240, 255);
				if((buttons & BUTTON_1_MASK) == BUTTON_1_MASK)
				{
					do_it = 1;
					line_color = Scalar(150, 240, 255);
					sprintf(buf, "Mouse 1");
					text_countdown = 30;
				}
				if((buttons & BUTTON_2_MASK) == BUTTON_2_MASK)
				{
					do_it = 1;
					sprintf(buf, "Mouse 2");
					line_color = Scalar(255, 240, 150);
					text_countdown = 30;
				}
				if((buttons & BUTTON_3_MASK) == BUTTON_3_MASK)
				{
					do_it = 1;
					sprintf(buf, "Mouse 3");
					line_color = Scalar(0, 100, 255);
					text_countdown = 30;
				}
				if(strlen(keystring) > 0)
				{
					strcpy(buf, keystring);
					do_it = 2;
					text_countdown = 30;
				}
				if((do_it > 0) || (text_countdown > 0))
				{
					if(do_it == 1)
					{
						int thickness = 2;
						Point center(mx, my);
						circle(src, center, radius, line_color, thickness);
						radius += 4;
						if(radius > 50)
						{
							radius = 10;
						}
					}
					if(strlen(buf) > 0)
					{
						if(text_countdown > 0)
						{
							int baseLine;
							Size labelSize = getTextSize(buf, FONT_HERSHEY_SIMPLEX, 0.5, 1, &baseLine);
							int tw = labelSize.width;
							putText(src, 
								buf, 
								cv::Point((desktop_w / 2) - tw, desktop_h - 30), 
								cv::FONT_HERSHEY_DUPLEX, 
								2.0, 
								CV_RGB(255, 255, 255), 
								1, 
								cv::LINE_AA);
							text_countdown--;
						}
						else
						{
							strcpy(buf, "");
						}
					}
				}
				else
				{
					radius = 10;
				}
			}
			x11_add_mouse(src, mx, my);
		}
		cvtColor(src, src, COLOR_BGRA2BGR);
		cvtColor(src, src, COLOR_BGR2RGBA);
		if(retain_size == 1)
		{
			cv::resize(src, src, cv::Size(desktop_w, desktop_h));
			desktop_mat = src;
		}
		else
		{
			scale_mat_to_fit(src, desktop_mat, output_width, output_height);
		}
	}
	else
	{
		fprintf(stderr, "Error: Bad Frame\n");
	}
}

void	MyWin::DrawAudioGraph(Camera *cam)
{
int	inner;
int	loop;

	if((audio_display & AUDIO_DISPLAY_FREQUENCY) == AUDIO_DISPLAY_FREQUENCY)
	{
		if(pulse_mixer != NULL)
		{
			pulse_mixer->fft_calc = 1;
			if(pulse_mixer->fft_frequency_cnt > 0)
			{
				int start_x = (w() / 2) - ((pulse_mixer->fft_frequency_cnt * 10) / 2);
				int start_y = h() - 60;
				int bar_cnt = 0;
				for(loop = 0;loop < pulse_mixer->fft_frequency_cnt;loop++)
				{
					double nn = pulse_mixer->fft_frequency[loop];
					if(nn > 1.0) nn = 1.0;
					if(nn < -1.0) nn = -1.0;
					double height = 64.0 * nn;
					for(inner = 0;inner < height;inner++)
					{
						int rr = (255 / 64) * inner;
						int gg = 0;
						int bb = 100 - ((100 / 64) * inner);
						if((bar_cnt % 2) == 0)
						{
							gg = 100 - ((100 / 64) * inner);
							bb = 0;
						}
						fl_color(fl_rgb_color(rr, gg, bb));
						fl_line(start_x + (bar_cnt * 10), start_y - inner, start_x + (bar_cnt * 10) + 7, start_y - inner);
					}
					bar_cnt++;
				}
			}
		}
	}
	else
	{
		pulse_mixer->fft_calc = 0;
	}
	if((audio_display & AUDIO_DISPLAY_AMPLITUDE) == AUDIO_DISPLAY_AMPLITUDE)
	{
		if(pulse_mixer != NULL)
		{
			if(pulse_mixer->buffer != NULL)
			{
				int start_x = (w() / 2) - (pulse_mixer->size / 4);
				int start_y = h() - 80;
				if(audio_channels == 2)
				{
					start_y -= 20;
				}
				int bar_cnt = 0;
				for(inner = 0;inner < pulse_mixer->size;inner += 2)
				{
					short int nn = pulse_mixer->buffer[inner];
					if(pulse_mixer->recording == 1)
					{
						nn = pulse_mixer->preserve[inner];
					}
					if(pulse_mixer->mute == 1)
					{
						nn = 0;
					}
					double height = (240.0 / 32768.0) * (double)nn;
					int sign_it = 1;
					if(height < 0.0) sign_it = -1;
					for(int ii = 0;ii < abs(height);ii++)
					{
						int rr = (255 / 64) * ii;
						int gg = 0;
						int bb = 100 - ((100 / 64) * ii);
						fl_color(fl_rgb_color(rr, gg, bb));
						fl_point(start_x + bar_cnt, start_y + (ii * sign_it));
					}
					if(audio_channels == 2)
					{
						int start_y = h() - 60;
						short int nn = pulse_mixer->buffer[inner + 1];
						if(pulse_mixer->recording == 1)
						{
							nn = pulse_mixer->preserve[inner];
						}
						if(pulse_mixer->mute == 1)
						{
							nn = 0;
						}
						double height = (240.0 / 32768.0) * (double)nn;
						int sign_it = 1;
						if(height < 0.0) sign_it = -1;
						for(int ii = 0;ii < abs(height);ii++)
						{
							int rr = (255 / 64) * ii;
							int gg = 0;
							int bb = 100 - ((100 / 64) * ii);
							fl_color(fl_rgb_color(rr, gg, bb));
							fl_point(start_x + bar_cnt, start_y + (ii * sign_it));
						}
					}
					bar_cnt++;
				}
				if(pulse_mixer->mute == 1)
				{
					fl_color(YELLOW);
					fl_font(FL_HELVETICA, 36);
					fl_draw("MUTING", start_x + (bar_cnt / 2) - 50, start_y - 50);
				}
			}
		}
	}
	if(audio_display_timer > 0)
	{
		int start_x = (w() / 2);
		int start_y = h() - 80;
		fl_color(WHITE);
		fl_font(FL_HELVETICA, 32);
		audio_display_timer--;
		if(((audio_display & AUDIO_DISPLAY_FREQUENCY) == AUDIO_DISPLAY_FREQUENCY)
		&& ((audio_display & AUDIO_DISPLAY_AMPLITUDE) == AUDIO_DISPLAY_AMPLITUDE))
		{
			int ww = 0;
			int hh = 0;
			fl_measure("Frequency & Amplitude", ww, hh);
			start_x -= (ww / 2);
			start_y -= (hh / 2);
			fl_draw("Frequency & Amplitude", start_x, start_y);
		}
		else if((audio_display & AUDIO_DISPLAY_FREQUENCY) == AUDIO_DISPLAY_FREQUENCY)
		{
			int ww = 0;
			int hh = 0;
			fl_measure("Frequency", ww, hh);
			start_x -= (ww / 2);
			start_y -= (hh / 2);
			fl_draw("Frequency", start_x, start_y);
		}
		else if((audio_display & AUDIO_DISPLAY_AMPLITUDE) == AUDIO_DISPLAY_AMPLITUDE)
		{
			int ww = 0;
			int hh = 0;
			fl_measure("Amplitude", ww, hh);
			start_x -= (ww / 2);
			start_y -= (hh / 2);
			fl_draw("Amplitude", start_x, start_y);
		}
		else
		{
			int ww = 0;
			int hh = 0;
			fl_measure("No Audio Display", ww, hh);
			start_x -= (ww / 2);
			start_y -= (hh / 2);
			fl_draw("No Audio Display", start_x, start_y);
		}
	}
}

void	MyWin::RecordAll()
{
	if(refreshed == 1)
	{
		int depth = 0;
		int sz = 0;
		int ww = -1;
		int hh = -1;
		unsigned char *b = grab_raw_image((Fl_Double_Window *)this, -1, -1, ww, hh, &sz, &depth);
		if(b != NULL)
		{
			if(all_fd > -1)
			{
				double s = Fl::screen_scale(0);
				int nw = w() * s;
				int nh = h() * s;
				Mat src = Mat(nh, nw, CV_8UC4, b);
				cv::resize(src, src, cv::Size(original_w, original_h));
				write_frame(all_fd, src.ptr(), original_w * original_h * 4, 0);
				record_all_cnt++;
			}
			else
			{
				record_all_start = time(0);
				all_fd = open("global.bin", O_CREAT | O_WRONLY | O_TRUNC, 0777);
				int uw = original_w;
				int uh = original_h;
				int depth = 4;
				int ufps = 25;
				write(all_fd, &uw, sizeof(int));
				write(all_fd, &uh, sizeof(int));
				write(all_fd, &depth, sizeof(int));
				write(all_fd, &ufps, sizeof(int));
			}
		}
		else
		{
			fprintf(stderr, "Error: Bad Frame\n");
		}
		refreshed = 0;
	}
}

void	MyWin::SnapAll()
{
	int depth = 0;
	int sz = 0;
	int ww = -1;
	int hh = -1;
	unsigned char *b = grab_raw_image(NULL, -1, -1, ww, hh, &sz, &depth);
	if(b != NULL)
	{
		time_t now = time(0);
		struct tm *tm = localtime(&now);
		if(tm != NULL)
		{
			int width = ww;
			int height = hh;
			Mat src(height, width, CV_8UC4, (void *)b);
			Mat out;
			cv::cvtColor(src, out, COLOR_BGRA2BGR);
			cv::resize(out, out, cv::Size(), 0.25, 0.25);
			char filename[4096];
	 		sprintf(filename, "desktop_%04d_%02d_%02d_%02d_%02d_%02d.png", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
			imwrite(filename, out);
		}
	}
}

void	MyWin::UpdateThumbButtons()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		ThumbGroup *tb = thumbnail[loop];
		if(tb != NULL)
		{
			if(camera[loop] != NULL)
			{
				Camera *cam = camera[loop];
				tb->UpdateButtons(cam);
			}
		}
	}
}

void	MyWin::AddEmbeddedWindow(EmbedAppWindow *embed)
{
int	loop;

	int done = -1;
	embedded_app_cnt = 0;
	for(loop = 0;loop < 10;loop++)
	{
		if(embedded_app[loop] == NULL)
		{
			if(done == -1)
			{
				done = loop;
			}
		}
		else
		{
			embedded_app_cnt++;
		}
	}
	if(done != -1)
	{
		add(embed);
		embedded_app[done] = embed;
		embedded_app_cnt++;
	}
}

void	MyWin::RemoveEmbeddedWindow(EmbedAppWindow *embed)
{
int	loop;

	if(embed != NULL)
	{
		int done = -1;
		for(loop = 0;loop < 10;loop++)
		{
			if(embedded_app[loop] == embed)
			{
				done = loop;
			}
		}
		if(done != -1)
		{
			embed->hide();
			remove(embed);
			embedded_app[done] = NULL;
			if(embedded_app_cnt > 0)
			{
				embedded_app_cnt--;
			}
			if(embed->pid != 0)
			{
				kill(embed->pid, SIGTERM);
			}
		}
	}
}

void	MyWin::CalcEmbeddedWindowPosition(int use_w, int use_h, int& x_pos, int& y_pos)
{
int	loop;

	y_pos = (h() - use_h);
	int accum = 0;
	for(loop = 0;loop < 10;loop++)
	{
		if(embedded_app[loop] != NULL)
		{
			accum += (embedded_app[loop]->my_w + 2);
		}
	}
	x_pos = accum + 2;
}

FilterDialog	*MyWin::MakeFilterDialog(char *name)
{
int	loop;

	FilterDialog *dialog = NULL;
	if(strcmp(name, "Grayscale") == 0)
	{
		dialog = new GrayscaleFilterDialog(this, 0, 0, 100, 22, (char *)strdup(name));
	}
	else if(strcmp(name, "Threshold") == 0)
	{
		dialog = new ThresholdFilterDialog(this, 0, 0, 100, 90, (char *)strdup(name));
		dialog->number[0] = 128.0;
		dialog->number[1] = 255.0;
		dialog->str[0] = strdup("Binary");
		dialog->str[1] = strdup("Binary Inv.");
		dialog->str[2] = strdup("Truncate");
		dialog->str[3] = strdup("To Zero");
		dialog->str[4] = strdup("To Zero Inv.");
		dialog->limit = 5;
	}
	else if(strcmp(name, "Invert") == 0)
	{
		dialog = new InvertFilterDialog(this, 0, 0, 100, 22, (char *)strdup(name));
	}
	else if(strcmp(name, "Edge Detect") == 0)
	{
		dialog = new EdgeDetectFilterDialog(this, 0, 0, 100, 110, (char *)strdup(name));
		dialog->number[0] = 3.0;
		dialog->number[1] = 30.0;
		dialog->number[2] = 70.0;
		dialog->number[3] = 0.5;
	}
	else if(strcmp(name, "Brightness") == 0)
	{
		dialog = new BrightnessFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 0.5;
	}
	else if(strcmp(name, "Contrast") == 0)
	{
		dialog = new ContrastFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 0.5;
	}
	else if(strcmp(name, "Saturation") == 0)
	{
		dialog = new SaturationFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 1.0;
	}
	else if(strcmp(name, "Hue") == 0)
	{
		dialog = new HueFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 1.0;
	}
	else if(strcmp(name, "CLAHE") == 0)
	{
		dialog = new ClaheFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 2.0;
	}
	else if(strcmp(name, "Color Intensity") == 0)
	{
		dialog = new ColorIntensityFilterDialog(this, 0, 0, 100, 110, (char *)strdup(name));
		dialog->number[0] = 1.0;
		dialog->number[1] = 1.0;
		dialog->number[2] = 1.0;
		dialog->number[3] = 1.0;
	}
	else if(strcmp(name, "Blur") == 0)
	{
		dialog = new BlurFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 1.0;
	}
	else if(strcmp(name, "Crop") == 0)
	{
		dialog = new CropFilterDialog(this, 0, 0, 100, 110, (char *)strdup(name));
		dialog->number[0] = 0.0;
		dialog->number[1] = 1.0;
		dialog->number[2] = 0.0;
		dialog->number[3] = 1.0;
	}
	else if(strcmp(name, "Scale") == 0)
	{
		dialog = new ScaleFilterDialog(this, 0, 0, 100, 110, (char *)strdup(name));
		dialog->number[0] = 1.0;
		dialog->number[1] = 1.0;
	}
	else if(strcmp(name, "Blend") == 0)
	{
		dialog = new BlendFilterDialog(this, 0, 0, 100, 90, (char *)strdup(name));
		dialog->number[0] = 0.5;
		int cnt = 0;
		for(loop = 0;loop < source_cnt;loop++)
		{
			Camera *cam = camera[loop];
			if(cam != NULL)
			{
				dialog->str[cnt] = strdup(cam->alias);
				cnt++;
			}
		}
		dialog->limit = cnt;
	}
	else if(strcmp(name, "Bevel") == 0)
	{
		dialog = new BevelFilterDialog(this, 0, 0, 100, 130, (char *)strdup(name));
		dialog->number[0] = 30;
		dialog->number[1] = 32;
		dialog->number[2] = 1;
		dialog->number[3] = 1;
		dialog->number[4] = 1;
	}
	else if(strcmp(name, "Gradient") == 0)
	{
		dialog = new GradientFilterDialog(this, 0, 0, 100, 220, (char *)strdup(name));
		dialog->str[0] = strdup("Vertical");
		dialog->str[1] = strdup("Horizontal");
		dialog->limit = 2;
		dialog->number[0] = 0;
		dialog->number[1] = 0;
		dialog->number[2] = 0;
		dialog->number[3] = 0;
		dialog->number[4] = 255;
		dialog->number[5] = 255;
		dialog->number[6] = 255;
		dialog->number[7] = 255;
	}
	return(dialog);
}

void	MyWin::Scheduled()
{
int	loop;

	time_t now = time(0);
	struct tm *tm = localtime(&now);
	hour = tm->tm_hour;
	minute = tm->tm_min;
	second = tm->tm_sec;
	year = tm->tm_year + 1900;
	month = tm->tm_mon + 1;
	day = tm->tm_mday;
	weekday = tm->tm_wday;
	for(loop = 0;loop < source_cnt;loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			int triggered = cam->Triggers();
			if(triggered == 1)
			{
				if(cam->record == 0)
				{
					cam->RecordOn();
				}
			}
			else
			{
				if(cam->record == 1)
				{
					cam->RecordOff();
				}
			}
		}
	}
}

void	MyWin::Done()
{
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if(pulse_mixer != NULL)
		{
			pulse_mixer->Stop();
		}
		cam->last = 1;
		if((muxer_cnt > 0) || (muxing == 0))
		{
			cam->Record();
			cam->resuming = 1;
		}
		RecordOff();
		SetAllCamerasToStop();
	}
}

int	MyWin::ImageWindowHit(int xx, int yy)
{
int	loop;

	int hit = -1;
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < cam->image_window_cnt;loop++)
		{
			if(cam->image_window[loop] != NULL)
			{
				ImageWindow *im = cam->image_window[loop];
				if((xx >= im->x()) && (xx <= (im->x() + im->w()))
				&& (yy >= im->y()) && (yy <= (im->y() + im->h())))
				{
					hit = loop;
				}
			}
		}
	}
	return(hit);
}

void	MyWin::AddImmediate(Immediate *in)
{
int	loop;

	int done = -1;
	if(immediate_list != NULL)
	{
		for(loop = 0;((loop < immediate_cnt) && (done == -1));loop++)
		{
			if(immediate_list[loop] == NULL)
			{
				done = loop;
			}
		}
	}
	if(done > -1)
	{
		immediate_list[done] = in;
	}
	else
	{
		immediate_list = (Immediate **)realloc(immediate_list, sizeof(Fl_Widget *) * (immediate_cnt + 1));
		if(immediate_list != NULL)
		{
			immediate_list[immediate_cnt] = in;
			immediate_cnt++;
		}
	}
}

void	MyWin::PasteImmediate()
{
int	loop;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		Immediate *old_im[1024];
		int use_cnt = immediate_cnt;
		for(loop = 0;((loop < use_cnt) && (loop < 1024));loop++)
		{
			old_im[loop] = immediate_list[loop];
		}
		for(loop = 0;((loop < use_cnt) && (loop < 1024));loop++)
		{
			if(old_im[loop] != NULL)
			{
				Immediate *new_im = new Immediate(old_im[loop], cam);
				cam->AddImmediate(new_im);
				add(new_im);
			}
		}
	}
}

void	MyWin::ClearImmediate()
{
int	loop;

	if(immediate_list != NULL)
	{
		for(loop = 0;loop < immediate_cnt;loop++)
		{
			if(immediate_list[loop] != NULL)
			{
				Fl::delete_widget(immediate_list[loop]);
			}
		}
		free(immediate_list);
		immediate_cnt = 0;
		immediate_list = NULL;
		immediate_drawing_window->paste_button->hide();
		immediate_drawing_window->clear_copy_buffer_button->hide();
		immediate_drawing_window->redraw();
	}
}

void	MyWin::ClearCameraCaps()
{
int	loop;

	for(loop = 0;loop < camera_caps_cnt;loop++)
	{
		if(camera_caps[loop] != NULL)
		{
			delete camera_caps[loop];
			camera_caps[loop] = NULL;
		}
	}
	camera_caps_cnt = 0;
}

int	MyWin::PopulateCameraCaps()
{
int		loop;
char	path[4096];
char	card_name[4096];

	ClearCameraCaps();
	camera_caps_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		strcpy(card_name, "");
		sprintf(path, "/dev/video%d", loop);
		get_v4l_card_name(path, card_name);
		if(strlen(card_name) > 0)
		{
			if(camera_caps_cnt < 128)
			{
				camera_caps[camera_caps_cnt] = new CameraCaps();
				camera_caps[camera_caps_cnt]->path = strdup(path);
				camera_caps[camera_caps_cnt]->alias = strdup(card_name);
				int nn = get_v4l_formats(path, camera_caps[camera_caps_cnt]->fourcc, camera_caps[camera_caps_cnt]->fourcc_description);
				camera_caps[camera_caps_cnt]->fourcc_cnt = nn;
				camera_caps_cnt++;
			}
		}
	}
	return(camera_caps_cnt);
}

Camera	*MyWin::FindCameraByPath(char *path)
{
int	loop;

	Camera *r = NULL;
	for(loop = 0;((loop < source_cnt) && (r == NULL));loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			if(strcmp(path, cam->path) == 0)
			{
				r = cam;
			}
		}
	}
	return(r);
}


void	MyWin::GrabAllCameras()
{
int		loop;

	for(loop = 0;loop < source_cnt;loop++)
	{
		if(camera[loop] != NULL)
		{
			Camera *cam = camera[loop];
			if(cam->power == 1)
			{
				if(cam->cap != NULL)
				{
					long int nn = precise_time();
					if((cam->last_grab_time + cam->grab_interval) < nn)
					{
						if(cam->cap->isOpened())
						{
							cam->cap->grab();
							cam->last_grab_time = nn;
						}
					}
					if(cam == DisplayedCamera())
					{
						cam->grab_interval = 0;
					}
					else
					{
						cam->grab_interval = 100000;
					}
				}
			}
		}
	}
}

void	MyWin::SendToNetwork()
{
	if(jpeg_streaming != NULL)
	{
		create_task((int (*)(int *))send_to_network, (void *)this);
		create_task((int (*)(int *))requesting_control, (void *)this);
		create_task((int (*)(int *))respond_to_control, (void *)this);
	}
}

int	MyWin::AddShape(Shape *in_shape)
{
int	loop;

	int found = -1;
	for(loop = 0;((loop < shape_cnt) && (found == -1));loop++)
	{
		if(shape[loop] == NULL)
		{
			shape[loop] = in_shape;
			found = loop;
		}
	}
	if(found == -1)
	{
		Shape **tmp = (Shape **)realloc(shape, (shape_cnt + 1) * sizeof(Shape *));
		if(tmp != NULL)
		{
			shape = tmp;
			shape[shape_cnt] = in_shape;
			found = shape_cnt;
			shape_cnt++;
		}
	}
	add(in_shape);
	return(found);
}

int	MyWin::RemoveShape(Shape *in_shape)
{
int	loop;

	int found = -1;
	for(loop = 0;((loop < shape_cnt) && (found == -1));loop++)
	{
		if(shape[loop] == in_shape)
		{
			shape[loop] = NULL;
			found = loop;
		}
	}
	remove(in_shape);
	return(found);
}

Shape	**MyWin::FindShapesOnCamera(Camera *cam, int& final)
{
Shape	*tmp[1024];
int		loop;

	int cnt = 0;
	for(loop = 0;loop < shape_cnt;loop++)
	{
		if(shape[loop] != NULL)
		{
			if(shape[loop]->destination == cam)
			{
				if(cnt < 1024)
				{
					tmp[cnt] = shape[loop];
					cnt++;
				}
			}
		}
	}
	Shape **list = NULL;
	if(cnt > 0)
	{
		list = (Shape **)malloc(cnt * sizeof(Shape *));
		if(list != NULL)
		{
			memcpy(list, tmp, cnt * sizeof(Shape *));
		}
	}
	final = cnt;
	return(list);
}

Shape	**MyWin::FindShapesFromCamera(Camera *cam, int& final)
{
Shape	*tmp[1024];
int		loop;

	int cnt = 0;
	for(loop = 0;loop < shape_cnt;loop++)
	{
		if(shape[loop]->source == cam)
		{
			if(cnt < 1024)
			{
				tmp[cnt] = shape[loop];
				cnt++;
			}
		}
	}
	Shape **list = NULL;
	if(cnt > 0)
	{
		list = (Shape **)malloc(cnt * sizeof(Shape *));
		if(list != NULL)
		{
			memcpy(list, tmp, cnt * sizeof(Shape *));
		}
	}
	final = cnt;
	return(list);
}

void	MyWin::copy_interest(unsigned char *dest, unsigned char *src, int sz, int sx, int sy, int ex, int ey)
{
int	xx, yy;

	for(yy = sy;yy < ey;yy++)
	{
		for(xx = sx;xx < ex;xx++)
		{
			int off = (yy * camera[current_source]->width * 3) + (xx * 3);
			char *ptr = (char *)(src + off);
			*dest++ = *ptr++;
			*dest++ = *ptr++;
			*dest++ = *ptr++;
		}
	}
}

int	MyWin::MatchArea(int score, int xx, int yy)
{
int	loop;

	int flag = 0;
	for(loop = 0;loop < interest_cnt;loop++)
	{
		if((interest_x[loop] == xx) && (interest_y[loop] == yy))
		{
			flag = 1;
		}
	}
	return(flag);
}

void	MyWin::SetupObjectDetection()
{
	if((access(yolo_cfg_filename, F_OK) == 0)
	&& (access(yolo_weights_filename, F_OK) == 0))
	{
		net = readNetFromDarknet(yolo_cfg_filename, yolo_weights_filename);
		if(!net.empty()) 
		{
			net.setPreferableBackend(DNN_BACKEND_CUDA);
			net.setPreferableTarget(DNN_TARGET_CUDA);
		}
		else
		{
			fprintf(stderr, "Error: While reading net from darknet, %s or %s produced an empty network.\n", yolo_cfg_filename, yolo_weights_filename);
		}
	}
	else
	{
		fprintf(stderr, "Error: While reading net from darknet, %s or %s cannot be accessed.\n", yolo_cfg_filename, yolo_weights_filename);
	}
}

int	MyWin::DrawPred(Camera *cam, int classId, float conf, int left, int top, int right, int bottom, Mat &frame)
{
	int found_bird = 0;
	char *label = recognize_class_name[classId];
	if(cam->object_index[classId] == 1)
	{
		rectangle(frame, Point(left, top), Point(right, bottom), Scalar(255, 255, 255), 1);

		int baseLine;
		Size labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, &baseLine);
		top = max(top, labelSize.height);
		rectangle(frame, Point(left, top - round(1.2 * labelSize.height)), Point(left + round(1.2 * labelSize.width), top + baseLine), Scalar(255, 255, 255), FILLED);
		putText(frame, label, Point(left, top), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0), 1);
		found_bird = classId;
	}
	return(found_bird);
}

void	MyWin::ReadClasses()
{
char	buf[256];

	recognize_class_cnt = 0;
	FILE *fp = fopen(yolo_names_filename, "r");
	if(fp != NULL)
	{
		while(fgets(buf, 255, fp))
		{
			strip_lf(buf);
			recognize_class_name[recognize_class_cnt] = strdup(buf);
			recognize_class_cnt++;
		}
		fclose(fp);
	}
}

void	MyWin::RecordOn()
{
int	loop;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		cam->record = 1;
		recording_camera = cam;
		if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
		{
			cam->TriggerSnapshot();
		}
	}
	recording = 1;
	if(pulse_mixer != NULL)
	{
		pulse_mixer->recording = 1;
		for(loop = 0;loop < audio_thumbnail_cnt;loop++)
		{
			if(audio_thumbnail[loop] != NULL)
			{
				if(audio_thumbnail[loop]->select_button->value())
				{
					if(audio_thumbnail[loop]->microphone != NULL)
					{
						audio_thumbnail[loop]->microphone->Record();
					}
				}
			}
		}
	}
}

void	MyWin::RecordOff()
{
int	loop;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		cam->record = 0;
		if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
		{
			cam->UnTriggerSnapshot();
		}
	}
	int no_go = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			if(cam->record == 1)
			{
				no_go = 1;
			}
		}
	}
	if(no_go == 0)
	{
		recording = 0;
	}
	if(pulse_mixer != NULL)
	{
		pulse_mixer->Stop();
		for(loop = 0;loop < audio_thumbnail_cnt;loop++)
		{
			if(audio_thumbnail[loop] != NULL)
			{
				if(audio_thumbnail[loop]->microphone != NULL)
				{
					audio_thumbnail[loop]->microphone->Stop();
				}
			}
		}
	}
}

void	MyWin::ToggleRecord(int camera_index)
{
	if((camera_index > -1) && (camera_index < source_cnt))
	{
		Camera *cam = camera[camera_index];
		if(cam != NULL)
		{
			ToggleRecord(cam);
		}
	}
}

void	MyWin::AltDisplay(int camera_index)
{
	if((camera_index > -1) && (camera_index < source_cnt))
	{
		if(camera_index != displayed_source)
		{
			alt_displayed_source = camera_index;
		}
		else
		{
			alt_displayed_source = -1;
		}
	}
}

void	MyWin::RecordingFullStop()
{
void	reset_button_cb(Fl_Widget *w, void *v);

	Camera *cam = DisplayedCamera();
	record_button->copy_label("Record");
	encode_speed_window->Reset();
	encode_speed_window->hide();
	if(pulse_mixer != NULL)
	{
		pulse_mixer->Stop();
	}
	int err = cam->Record();
	if(cam != NULL)
	{
		if(cam->total_frames == 0)
		{
			encode_button->hide();
		}
		else if(encoding == 0)
		{
			if(muxing == 0)
			{
				encode_button->show();
			}
		}
	}
	cam->resuming = 0;
	RecordOff();
	SetAllCamerasToStop();
	reset_button_cb(NULL, this);
}

void	MyWin::AddLastMuxed(char *filename)
{
int	loop;

	if(last_muxed_list[63] != NULL)
	{
		free(last_muxed_list[63]);
		last_muxed_list[63] = NULL;
	}
	for(loop = 63;loop > 0;loop--)
	{
		last_muxed_list[loop] = last_muxed_list[loop - 1];
	}
	last_muxed_list[loop] = strdup(filename);
	strcpy(last_used_filename, filename);
}

void	MyWin::SaveInterest()
{
int	loop;

	if(interest_cnt > 0)
	{
		char filename[4096];
		int r = my_file_chooser("Select an interest file", "*.json", "./", filename, 0, 1);
		if(r > 0)
		{
			if(strlen(filename) > 0)
			{
				FILE *fp = fopen(filename, "w");
				if(fp != NULL)
				{
					fprintf(fp, "{\n");
					fprintf(fp, "\t\"interest cnt\": %d,\n", interest_cnt);
					fprintf(fp, "\t\"interest\": [\n");
					for(loop = 0;loop < interest_cnt;loop++)
					{
						fprintf(fp, "%d,%d", interest_x[loop], interest_y[loop]);
						if(loop < (interest_cnt - 1))
						{
							fprintf(fp, ",");
						}
					}
					fprintf(fp, "]\n");
					fprintf(fp, "}\n");
					fclose(fp);
				}
			}
		}
	}
}

void	MyWin::LoadInterest()
{
int	loop;

	char filename[4096];
	strcpy(filename, "");
	int nn = my_file_chooser("Load Interest File", "*.json", "./", filename);
	if(nn > 0)
	{
		char *buf = ReadWholeFile(filename);
		if(buf != NULL)
		{
			cJSON *json = cJSON_Parse(buf);
			if(json == NULL)
			{
				const char *error_ptr = cJSON_GetErrorPtr();
				if(error_ptr != NULL)
				{
					fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
				}
			}
			else
			{
				int success = json_parse_int(json, "interest cnt", interest_cnt);
				cJSON *item = NULL;
				cJSON *items = json_parse_array(json, "interest");
				if(items != NULL)
				{
					int cnt = 0;
					int a_cnt = 0;
					cJSON_ArrayForEach(item, items)
					{
						if((cnt % 2) == 0)
						{
							interest_x[a_cnt] = (uchar)item->valueint;
						}
						else
						{
							interest_y[a_cnt] = (uchar)item->valueint;
							a_cnt++;
						}
						cnt++;
					}
				}
				cJSON_Delete(json);
			}
			free(buf);
		}
	}
}

void	MyWin::MakeNewSourceWindow()
{
	NewSourceWindow *nsw = new NewSourceWindow(this, 370, 320);
	new_source_window = nsw;
}

void	MyWin::MakeAliasWindow()
{
	AliasWindow *aw = new AliasWindow(this);
	alias_window = aw;
}

void	MyWin::HideButtons()
{
	record_button->hide();
	load_setup_button->hide();
	save_setup_button->hide();
	override_button->hide();
	encode_button->hide();
	show_debug_button->hide();
	test_recognition_button->hide();
	review_button->hide();
	reset_button->hide();
	review_muxed_button->hide();
	set_interest_button->hide();
	clear_interest_button->hide();
	save_interest_button->hide();
	load_interest_button->hide();
	zoom_box_button->hide();
	split_button->hide();
	open_standalone_button->hide();
	new_source_button->hide();
	edit_source_button->hide();
	edit_output_button->hide();
	select_output_button->hide();
	alias_button->hide();
	video_settings_button->hide();
	ptz_lock_window_button->hide();
	camera_settings_button->hide();
	snapshot_settings_button->hide();
	transitions_button->hide();
	filter_built_in_button->hide();
	hide_video_button->hide();
	keyboard_settings_button->hide();
	gui_settings_button->hide();
	filter_built_in_button->hide();
	if(filter_plugins_button != NULL)
	{
		filter_plugins_button->hide();
	}
	if(external_pgm_button != NULL)
	{
		external_pgm_button->hide();
	}
	if(fltk_plugin_button != NULL)
	{
		fltk_plugin_button->hide();
	}
	immediate_drawing_button->hide();
	dynamic_coloring_button->hide();
	save_camera_button->hide();
	load_camera_button->hide();
	codecs_button->hide();
	reset_camera_button->hide();
	flip_horizontal_button->hide();
	flip_vertical_button->hide();
	timestamp_button->hide();
	snapshot_button->hide();
	if(jpeg_streaming_button != NULL)
	{
		jpeg_streaming_button->hide();
	}
	reset_button->hide();
	reset_cameras_button->hide();
	resize_capture_button->hide();
	show_motion_debug_button->hide();
	quit_button->hide();
	power_button->hide();
	freeze_button->hide();
	mute_video_button->hide();
	trigger_button->hide();
	dump_button->hide();
	audio_mute_button->hide();
	audio_settings_button->hide();
	audio_bind_to_camera_button->hide();
	audio_save_button->hide();
	audio_load_button->hide();
	monitor_audio_button->hide();
	audio_library_button->hide();
	audio_library_list_button->hide();
	play_audio_file_button->hide();
	stop_playing_audio_button->hide();
	pause_playing_audio_button->hide();
	monitor_video_button->hide();
	toggle_camera_effects_button->hide();
	if(audio_filter_plugins_button != NULL)
	{
		audio_filter_plugins_button->hide();
	}
	filter_built_in_button->hide();
	toggle_objects_button->hide();
}

void	MyWin::ShowButtons()
{
	if(mark_interest == 0)
	{
		Camera *cam = NULL;
		cam = DisplayedCamera();
		if(cam != NULL)
		{
			load_setup_button->show();
			video_settings_button->show();
			if(global_my_format_cnt > 0)
			{
				codecs_button->show();
			}
			if(cam->power == 1)
			{
				camera_settings_button->show();
				if(cam->triggers_requested == 1)
				{
					record_button->copy_label("Stop");
					encode_speed_window->show();
					reset_camera_button->hide();
					reset_cameras_button->hide();
					load_setup_button->hide();
					video_settings_button->hide();
					if(global_my_format_cnt > 0)
					{
						codecs_button->hide();
					}
					if(audio == 1)
					{
						audio_mute_button->show();
						monitor_audio_button->show();
						audio_library_button->show();
						audio_library_list_button->show();
						play_audio_file_button->show();
						if(active_audio_playback == 1)
						{
							stop_playing_audio_button->show();
							pause_playing_audio_button->show();
						}
						audio_settings_button->show();
						audio_bind_to_camera_button->show();
						audio_save_button->show();
						audio_load_button->show();
					}
				}
				else
				{
					record_button->copy_label("Record");
					encode_speed_window->hide();
					reset_camera_button->show();
					reset_cameras_button->show();
					load_setup_button->show();
					video_settings_button->show();
					if(global_my_format_cnt > 0)
					{
						codecs_button->show();
					}
					if(audio == 1)
					{
						audio_mute_button->hide();
						audio_settings_button->hide();
						audio_bind_to_camera_button->hide();
						audio_save_button->hide();
						audio_load_button->hide();
						monitor_audio_button->hide();
						audio_library_button->hide();
						audio_library_list_button->hide();
						play_audio_file_button->hide();
						stop_playing_audio_button->hide();
						pause_playing_audio_button->hide();
					}
				}
			}
			if(audio_filter_plugins_button != NULL)
			{
				audio_filter_plugins_button->show();
			}
			if(use_old == 0)
			{
				if(cam->power == 1)
				{
					record_button->show();
					if(cam->record_trigger != 0)
					{
						override_button->show();
					}
				}
			}
			save_setup_button->show();
			if(encoding == 0)
			{
				if(muxing == 0)
				{
					if(recorded_frames > 0)
					{
						encode_button->show();
					}
				}
			}
			if(recorded_frames > 0)
			{
				dump_button->show();
			}
			else
			{
				dump_button->hide();
			}
			show_debug_button->show();
			test_recognition_button->show();
			if(review == NULL)
			{
				if(recorded_frames > 0)
				{
					review_button->show();
				}
				else
				{
					review_button->hide();
				}
			}
			else
			{
				review_button->hide();
			}
			if(last_muxed_list[0] != NULL)
			{
				if(recording == 0)
				{
					review_muxed_button->show();
				}
			}
			if(interest_cnt > 0)
			{
				clear_interest_button->show();
				save_interest_button->show();
			}
			load_interest_button->show();
			if(cam->zoom_box_display == 1)
			{
				zoom_box_button->copy_label("Cease Box Zoom");
			}
			else
			{
				zoom_box_button->copy_label("Box Zoom");
			}
			zoom_box_button->show();
			if(source_cnt > 1)
			{
				split_button->show();
				open_standalone_button->show();
			}
			new_source_button->show();
			if(cam != NULL)
			{
				edit_source_button->show();
			}
			else
			{
				edit_source_button->hide();
			}
			if(recording == 0)
			{
				edit_output_button->show();
				select_output_button->show();
			}
			else
			{
				edit_output_button->hide();
				select_output_button->hide();
			}
			if(showing_alias_window == 0)
			{
				alias_button->show();
			}
			if(cam->power == 1)
			{
				flip_horizontal_button->show();
				flip_vertical_button->show();
				snapshot_settings_button->show();
				transitions_button->show();
			}
			filter_built_in_button->show();
			if(global_potential_filter_cnt > 0)
			{
				filter_plugins_button->show();
			}
			if(external_pgm_button != NULL)
			{
				external_pgm_button->show();
			}
			if(fltk_plugin_button != NULL)
			{
				fltk_plugin_button->show();
			}
			if(cam->power == 1)
			{
				immediate_drawing_button->show();
				dynamic_coloring_button->show();
			}
			if(ptz_mode == 1)
			{
				ptz_lock_window_button->show();
			}
			keyboard_settings_button->show();
			gui_settings_button->show();
			save_camera_button->show();
			load_camera_button->show();
			timestamp_button->show();
			if(cam->power == 1)
			{
				snapshot_button->show();
			}
			if(jpeg_streaming != NULL)
			{
				jpeg_streaming_button->show();
			}
			reset_button->show();
			resize_capture_button->show();
			show_motion_debug_button->show();
			quit_button->show();
			if(cam->power == 1)
			{
				power_button->copy_label("Turn Off");
			}
			else
			{
				power_button->copy_label("Turn On");
			}
			power_button->show();
			if(cam->power == 1)
			{
				if(cam->mute_video == 1)
				{
					mute_video_button->copy_label("Unmute Video");
				}
				else
				{
					mute_video_button->copy_label("Mute Video");
				}
				mute_video_button->show();
				if(cam->freeze_video == 1)
				{
					freeze_button->copy_label("Defrost");
				}
				else
				{
					freeze_button->copy_label("Freeze");
				}
				freeze_button->show();
			}
			save_setup_button->show();
			if(cam->power == 1)
			{
				trigger_button->show();
			}
			audio_mute_button->show();
			audio_settings_button->show();
			audio_bind_to_camera_button->show();
			audio_save_button->show();
			audio_load_button->show();
			monitor_audio_button->show();
			audio_library_button->show();
			audio_library_list_button->show();
			play_audio_file_button->show();
			if(active_audio_playback == 1)
			{
				stop_playing_audio_button->show();
				pause_playing_audio_button->show();
			}
			if(init_detect == 1)
			{
				if(!net.empty()) 
				{
					toggle_objects_button->show();
				}
			}
			set_interest_button->show();
			if(audio_filter_plugins_button != NULL)
			{
				audio_filter_plugins_button->show();
			}
			filter_built_in_button->show();
			monitor_video_button->show();
			toggle_camera_effects_button->show();
		}
		else
		{
			if(record_button != NULL)
				record_button->hide();
			if(audio_mute_button != NULL)
				audio_mute_button->hide();
			if(audio_settings_button != NULL)
				audio_settings_button->hide();
			if(audio_bind_to_camera_button != NULL)
				audio_bind_to_camera_button->hide();
			if(audio_save_button != NULL)
				audio_save_button->hide();
			if(audio_load_button != NULL)
				audio_load_button->hide();
			if(monitor_video_button != NULL)
				monitor_video_button->hide();
			if(monitor_audio_button != NULL)
				monitor_audio_button->hide();
			if(audio_library_button != NULL)
				audio_library_button->hide();
			if(audio_library_list_button != NULL)
				audio_library_list_button->hide();
			if(play_audio_file_button != NULL)
				play_audio_file_button->hide();
			if(stop_playing_audio_button != NULL)
				stop_playing_audio_button->hide();
			if(pause_playing_audio_button != NULL)
				pause_playing_audio_button->hide();
			if(audio_filter_plugins_button != NULL)
				audio_filter_plugins_button->hide();
			if(override_button != NULL)
				override_button->hide();
			if(encode_button != NULL)
				encode_button->hide();
			if(show_debug_button != NULL)
				show_debug_button->hide();
			if(test_recognition_button != NULL)
				test_recognition_button->hide();
			if(review_button != NULL)
				review_button->hide();
			if(reset_button != NULL)
				reset_button->hide();
			if(review_muxed_button != NULL)
				review_muxed_button->hide();
			if(clear_interest_button != NULL)
				clear_interest_button->hide();
			if(save_interest_button != NULL)
				save_interest_button->hide();
			if(load_interest_button != NULL)
				load_interest_button->hide();
			if(zoom_box_button != NULL)
				zoom_box_button->hide();
			if(split_button != NULL)
				split_button->hide();
			if(open_standalone_button != NULL)
				open_standalone_button->hide();
			if(new_source_button != NULL)
				new_source_button->show();
			if(edit_source_button != NULL)
				edit_source_button->hide();
			if(edit_output_button != NULL)
				edit_output_button->hide();
			if(select_output_button != NULL)
				select_output_button->hide();
			if(alias_button != NULL)
				alias_button->hide();
			if(reset_camera_button != NULL)
				reset_camera_button->hide();
			if(flip_horizontal_button != NULL)
				flip_horizontal_button->hide();
			if(flip_vertical_button != NULL)
				flip_vertical_button->hide();
			if(ptz_lock_window_button != NULL)
				ptz_lock_window_button->hide();
			if(video_settings_button != NULL)
				video_settings_button->show();
			if(camera_settings_button != NULL)
				camera_settings_button->hide();
			if(snapshot_settings_button != NULL)
				snapshot_settings_button->hide();
			if(transitions_button != NULL)
				transitions_button->hide();
			if(filter_plugins_button != NULL)
				filter_plugins_button->hide();
			if(filter_built_in_button != NULL)
				filter_built_in_button->hide();
			if(external_pgm_button != NULL)
				external_pgm_button->hide();
			if(fltk_plugin_button != NULL)
				fltk_plugin_button->hide();
			if(immediate_drawing_button != NULL)
				immediate_drawing_button->hide();
			if(dynamic_coloring_button != NULL)
				dynamic_coloring_button->hide();
			if(save_camera_button != NULL)
				save_camera_button->hide();
			if(load_camera_button != NULL)
				load_camera_button->hide();
			if(codecs_button != NULL)
				codecs_button->show();
			if(timestamp_button != NULL)
				timestamp_button->hide();
			if(snapshot_button != NULL)
				snapshot_button->hide();
			if(jpeg_streaming_button != NULL)
				jpeg_streaming_button->hide();
			if(reset_button != NULL)
				reset_button->hide();
			if(reset_cameras_button != NULL)
				reset_cameras_button->hide();
			if(resize_capture_button != NULL)
				resize_capture_button->hide();
			if(show_motion_debug_button != NULL)
				show_motion_debug_button->hide();
			if(quit_button != NULL)
				quit_button->show();
			if(power_button != NULL)
				power_button->hide();
			if(mute_video_button != NULL)
				mute_video_button->hide();
			if(freeze_button != NULL)
				freeze_button->hide();
			if(hide_video_button != NULL)
				hide_video_button->hide();
			if(load_setup_button != NULL)
				load_setup_button->show();
			if(save_setup_button != NULL)
				save_setup_button->hide();
			if(trigger_button != NULL)
				trigger_button->hide();
			if(dump_button != NULL)
				dump_button->hide();
			if(toggle_objects_button != NULL)
				toggle_objects_button->hide();
			if(set_interest_button != NULL)
				set_interest_button->hide();
			if(toggle_camera_effects_button != NULL)
				toggle_camera_effects_button->hide();
		}
	}
	else
	{
		if(set_interest_button != NULL)
			set_interest_button->show();
	}
	AdjustMainMenuHeight();
	button_group->redraw();
	redraw();
}

int	MyWin::CountActiveMics()
{
int	loop;

	int cnt = 0;
	for(loop = 0;loop < pulse_microphone_cnt;loop++)
	{
		if(pulse_microphone[loop] != NULL)
		{
			if(pulse_microphone[loop]->failure == 0)
			{
				if(pulse_microphone[loop]->stop == 0)
				{
					cnt++;
				}
			}
		}
	}
	return(cnt);
}

void	MyWin::CompressAudioThumbnailList()
{
int	loop;
PulseAudioButton	*new_list[128];

	for(loop = 0;loop < 128;loop++)
	{
		new_list[loop] = NULL;
	}
	int cnt = 0;
	for(loop = 0;loop < audio_thumbnail_cnt;loop++)
	{
		if(audio_thumbnail[loop] != NULL)
		{
			new_list[cnt] = audio_thumbnail[loop];
			cnt++;
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		audio_thumbnail[loop] = new_list[loop];
	}
	audio_thumbnail_cnt = cnt;
}

void	MyWin::RunPulse(int mode)
{
	if(mode == MODE_RECORD)
	{
		pthread_t signal_thread = create_task((int (*)(int *))pulse_record_all, (void *)this);
	}
	else
	{
		pthread_t signal_thread = create_task((int (*)(int *))pulse_play_all, (void *)this);
	}
}

void	MyWin::OpenNamedPulse()
{
	ScanPulse(1);
}

void	MyWin::ScanPulse(int use_source_list)
{
int	loop;

	char *list[128];
	char *description[128];
	char def_source[4096];
	char def_sink[4096];
	int index[128];
	int channels[128];
	int rate[128];
	int nn = 0;
	if(use_source_list == 0)
	{
		nn = pulse_list_devices(def_source, def_sink, 1, 128, list, description, index, channels, rate);
	}
	if(audio_source != NULL)
	{
		for(loop = 0;loop < audio_source_cnt;loop++)
		{
			if(audio_source[loop] != NULL)
			{
				list[nn] = strdup(audio_source[loop]);
				description[nn] = NULL;
				nn++;
			}
		}
	}
	int nyy = 10;
	int nxx = 600;
	pulse_mixer = new PulseMixer(this, FRAMES_PER_BUFFER, audio_channels);
	int at_cnt = 0;
	for(loop = 0;loop < nn;loop++)
	{
		if(list[loop] != NULL)
		{
			char *str = list[loop];
			char *str2 = description[loop];
			if(str != NULL)
			{
				int def = 0;
				if(strcmp(str, def_source) == 0)
				{
					def = 1;
				}
				char *alias = NULL;
				char *cp = str;
				while(*cp != '\0')
				{
					if(strncmp(cp, "[alias=", strlen("[alias=")) == 0)
					{
						*cp = '\0';
						alias = cp + strlen("[alias=");
						char *cp2 = alias;
						while(*cp2 != '\0')
						{
							if(*cp2 == ']')
							{
								*cp2 = '\0';
							}
							cp2++;
						}
					}
					cp++;
				}
				if((nxx + 253) > w())
				{
					nxx = 600;
					nyy += 40;
				}
				char *use_str = NULL;
				if(alias == NULL)
				{
					if(str2 != NULL)
					{
						use_str = strdup(str2);
						remove_superfluous_characters(str2, use_str);
					}
					else
					{
						use_str = strdup(str);
						remove_superfluous_characters(str, use_str);
					}
				}
				else
				{
					use_str = strdup(alias);
				}
				PulseAudioButton *at = NULL;
				char buf[4096];
				sprintf(buf, "Initialize audio:\n%s", use_str);
				start_win->Update(buf);
				at = new PulseAudioButton(this, str, audio_sample_rate, audio_channels, nxx, nyy, 150, 80, use_str);
				if(at != NULL)
				{
					if(at->microphone != NULL)
					{
						audio_thumbnail[at_cnt] = at;
						at_cnt++;
						nxx += 155;
						int which = at_cnt / 7;
						if(which < 3)
						{
							audio_thumbnail_pack[which]->add(at);
							int use_w = audio_thumbnail_pack[0]->children() * 160;
							audio_thumbnail_group->resize(audio_thumbnail_group->x(), audio_thumbnail_group->y(), use_w, (which + 1) * 81);
						}
						if(def == 1)
						{
							at->select_button->value(1);
							at->select_button->do_callback(NULL, at);
							at->microphone->in_use = 1;
						}
					}
					else
					{
						at->hide();
						Fl::delete_widget(at);
					}
				}
			}
			if(list[loop] != NULL)
			{
				free(list[loop]);
			}
			if(description[loop] != NULL)
			{
				free(description[loop]);
			}
		}
	}
	if(at_cnt == 0)
	{
		audio_thumbnail_group->resize(audio_thumbnail_group->x(), audio_thumbnail_group->y(), 160, 71);
	}
	audio_thumbnail_cnt = at_cnt;
	if((nn > 0) || (muxing == 1))
	{
		RunPulse(MODE_RECORD);
		RunPulse(MODE_PLAY);
	}
}

void	MyWin::ViscaSpecs(VISCAInterface_t *interface, MyVISCACamera *cam)
{
int	err;

	VISCA_get_camera_info(interface, cam);
	char visca_filename[4096];
	sprintf(visca_filename, "VISCA_CAMERA_%x_%x.specs", cam->vendor, cam->model);
	FILE *fp = fopen(visca_filename, "r");
	if(fp != NULL)
	{
		fscanf(fp, "%d", &cam->param_pan_limit);
		fscanf(fp, "%d", &cam->param_tilt_up_limit);
		fscanf(fp, "%d", &cam->param_tilt_down_limit);
		fscanf(fp, "%d", &cam->param_zoom_limit);
		fscanf(fp, "%d", &cam->param_pan_max_speed);
		fscanf(fp, "%d", &cam->param_tilt_max_speed);
		if(cam->param_pan_max_speed < 20)
		{
			cam->param_pan_max_speed = 20;
		}
		if(cam->param_tilt_max_speed < 20)
		{
			cam->param_tilt_max_speed = 20;
		}
		fclose(fp);
	}
	else
	{
		FILE *fp = fopen(visca_filename, "w");
		if(fp != NULL)
		{
			char local_buf[8192];
			sprintf(local_buf, "Deriving specs for %s", visca_filename);
			start_win->Update(local_buf);
			VISCA_set_pantilt_home(interface, cam);
			usleep(100000);
			VISCA_set_pantilt_absolute_position(interface, cam, 20, 20, 0, 0);
			usleep(100000);
			VISCA_set_zoom_value(interface, cam, 0);
			usleep(100000);

			int16_t pan_reading = 0;
			int16_t tilt_reading = 0;
			VISCA_set_pantilt_upright(interface, cam, 20, 20);
			usleep(10000000);
			VISCA_set_pantilt_stop(interface, cam, 20, 20);
			usleep(100000);
			err = VISCA_get_pantilt_position(interface, cam, &pan_reading, &tilt_reading);
			cam->param_pan_limit = pan_reading;
			cam->param_tilt_up_limit = tilt_reading;

			pan_reading = 0;
			tilt_reading = 0;
			VISCA_set_pantilt_downleft(interface, cam, 20, 20);
			usleep(10000000);
			VISCA_set_pantilt_stop(interface, cam, 20, 20);
			usleep(100000);
			err = VISCA_get_pantilt_position(interface, cam, &pan_reading, &tilt_reading);
			cam->param_tilt_down_limit = tilt_reading;

			VISCA_set_pantilt_home(interface, cam);
			usleep(100000);
			VISCA_set_zoom_value(interface, cam, 0);
			usleep(100000);
			int err = VISCA_set_zoom_tele_speed(interface, cam, 20);
			usleep(10000000);
			int zoom_reading = 0;
			VISCA_get_zoom_value(interface, cam, (uint16_t *)&zoom_reading);
			cam->param_zoom_limit = zoom_reading;

			VISCA_get_pantilt_maxspeed(interface, cam, (uint8_t *)&cam->param_pan_max_speed, (uint8_t *)&cam->param_tilt_max_speed);
			if(cam->param_pan_max_speed < 20)
			{
				cam->param_pan_max_speed = 20;
			}
			if(cam->param_tilt_max_speed < 20)
			{
				cam->param_tilt_max_speed = 20;
			}
			fprintf(fp, "%d\n", abs(cam->param_pan_limit));
			fprintf(fp, "%d\n", cam->param_tilt_up_limit);
			fprintf(fp, "%d\n", cam->param_tilt_down_limit);
			fprintf(fp, "%d\n", cam->param_zoom_limit);
			fprintf(fp, "%d\n", cam->param_pan_max_speed);
			fprintf(fp, "%d\n", cam->param_tilt_max_speed);
			fclose(fp);

			VISCA_set_pantilt_home(interface, cam);
			VISCA_set_zoom_value(interface, cam, 0);
			VISCA_set_pantilt_absolute_position(interface, cam, 20, 20, 0, 0);
		}
	}
}


void	MyWin::ViscaCommand(int index, int command, int arg_cnt, int arg0, int arg1, int arg2, int arg3, int arg4)
{
	if((command == PTZ_RELATIVE_POSITION)
	|| (command == PTZ_ABSOLUTE_POSITION))
	{
		if(pthread_mutex_trylock(&visca_mutex) == 0)
		{
			visca_command = command;
			ptz_window_index = index;
			visca_arg_cnt = arg_cnt;
			visca_arg[0] = arg0;
			visca_arg[1] = arg1;
			visca_arg[2] = arg2;
			visca_arg[3] = arg3;
			visca_arg[4] = arg4;
			pthread_mutex_unlock(&visca_mutex);
			pthread_cond_signal(&visca_cond);
		}
	}
	else
	{
		pthread_mutex_lock(&visca_mutex);
		ptz_window_index = index;
		visca_command = command;
		visca_arg_cnt = arg_cnt;
		visca_arg[0] = arg0;
		visca_arg[1] = arg1;
		visca_arg[2] = arg2;
		visca_arg[3] = arg3;
		visca_arg[4] = arg4;
		pthread_mutex_unlock(&visca_mutex);
		pthread_cond_signal(&visca_cond);
	}
}

int	visca(int *flag)
{
	MyWin *win = (MyWin *)flag;
	if(win != NULL)
	{
		if(win->ptz_mode == 0)
		{
			win->ptz_mode = 1;
			win->visca_command = 0;;
			win->visca_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
			win->visca_cond = PTHREAD_COND_INITIALIZER;
			int done = 0;
			while(done == 0)
			{
				pthread_cond_wait(&win->visca_cond, &win->visca_mutex);
				pthread_mutex_lock(&win->visca_mutex);
				int index = win->ptz_window_index;
				int vc = win->visca_command;
				int arg_cnt = win->visca_arg_cnt;
				int arg0 = win->visca_arg[0];
				int arg1 = win->visca_arg[1];
				int arg2 = win->visca_arg[2];
				int arg3 = win->visca_arg[3];
				int arg4 = win->visca_arg[4];
				if(vc == VISCA_QUIT)
				{
					done = 1;
				}
				else if(vc > 0)
				{
					win->PTZ_DoCommand(index, vc, arg_cnt, arg0, arg1, arg2, arg3, arg4);
					win->visca_command = 0;
					win->visca_arg_cnt = 0;
					win->visca_arg[0] = 0;
					win->visca_arg[1] = 0;
					win->visca_arg[2] = 0;
					win->visca_arg[3] = 0;
					win->visca_arg[4] = 0;
				}
				pthread_mutex_unlock(&win->visca_mutex);
				if(vc <= 0)
				{
					usleep(10000);
				}
			}
			win->ptz_mode = 0;
		}
	}
	return(0);
}

void	MyWin::StartVisca()
{
	pthread_t signal_thread = create_task((int (*)(int *))visca, (void *)this);
}

void	MyWin::SetupPTZWindow(int in_instance)
{
int	loop;
int	inner;
int	aa, ab, ac;

	PTZ_Window *local_ptz_window = NULL;
	if(button_group_side == SIDE_RIGHT)
	{
		local_ptz_window = new PTZ_Window(this, ptz_alias[in_instance], in_instance, 10 + (in_instance * 300), h() - 330, 300, 330);
	}
	else
	{
		local_ptz_window = new PTZ_Window(this, ptz_alias[in_instance], in_instance, (w() - 310) - (in_instance * 300), h() - 330, 300, 330);
	}
	local_ptz_window->prefer_ndi = ptz_prefer_ndi[in_instance];
	local_ptz_window->prefer_v4l = ptz_prefer_v4l[in_instance];
	local_ptz_window->end();
	ptz_window[in_instance] = local_ptz_window;
	if(in_instance != 0)
	{
		if(ptz_window[in_instance]->bound_camera == NULL)
		{
			local_ptz_window->showing = 0;
			local_ptz_window->hide();
		}
		else
		{
			local_ptz_window->showing = 1;
		}
	}
	else
	{
		local_ptz_window->showing = 1;
	}
	if(in_instance == 0)
	{
		local_ptz_window->DigitalZoom(0);
		local_ptz_window->BacklightCompensation(0);
	}
}

void	MyWin::ResetCommandKeys()
{
	command_key[KEY_TOGGLE_RECORD] = ' ';
	command_key[KEY_DELETE_IMMEDIATE] = FL_Delete;
	command_key[KEY_TOGGLE_PTZ_JOYSTICK] = 'j';
	command_key[KEY_INCREASE_PTZ_LITTLE_SPEED] = FL_KP + '+';
	command_key[KEY_DECREASE_PTZ_LITTLE_SPEED] = FL_KP + '-';
	command_key[KEY_CYCLE_PTZ_LITTLE_MODE] = FL_KP_Enter;
	command_key[KEY_PTZ_HOME] = FL_Home;
	command_key[KEY_CYCLE_DOWN_THUMBGROUP] = FL_Down;
	command_key[KEY_CYCLE_UP_THUMBGROUP] = FL_Up;
	command_key[KEY_DISPLAY_THUMBGROUP_0] = '0';
	command_key[KEY_DISPLAY_THUMBGROUP_1] = '1';
	command_key[KEY_DISPLAY_THUMBGROUP_2] = '2';
	command_key[KEY_DISPLAY_THUMBGROUP_3] = '3';
	command_key[KEY_DISPLAY_THUMBGROUP_4] = '4';
	command_key[KEY_DISPLAY_THUMBGROUP_5] = '5';
	command_key[KEY_DISPLAY_THUMBGROUP_6] = '6';
	command_key[KEY_DISPLAY_THUMBGROUP_7] = '7';
	command_key[KEY_DISPLAY_THUMBGROUP_8] = '8';
	command_key[KEY_DISPLAY_THUMBGROUP_9] = '9';
	command_key[KEY_LITTLE_MOTION_1] = FL_KP + '1';
	command_key[KEY_LITTLE_MOTION_2] = FL_KP + '2';
	command_key[KEY_LITTLE_MOTION_3] = FL_KP + '3';
	command_key[KEY_LITTLE_MOTION_4] = FL_KP + '4';
	command_key[KEY_LITTLE_MOTION_5] = FL_KP + '6';
	command_key[KEY_LITTLE_MOTION_6] = FL_KP + '7';
	command_key[KEY_LITTLE_MOTION_7] = FL_KP + '8';
	command_key[KEY_LITTLE_MOTION_8] = FL_KP + '9';
	command_key[KEY_LITTLE_MOTION_OTHER_1] = 'w';
	command_key[KEY_LITTLE_MOTION_OTHER_2] = 'a';
	command_key[KEY_LITTLE_MOTION_OTHER_3] = 's';
	command_key[KEY_LITTLE_MOTION_OTHER_4] = 'd';
	command_key[KEY_LITTLE_MOTION_OTHER_5] = 'q';
	command_key[KEY_LITTLE_MOTION_OTHER_6] = 'e';
	command_key[KEY_LITTLE_MOTION_OTHER_7] = 'z';
	command_key[KEY_LITTLE_MOTION_OTHER_8] = 'x';
	command_key[KEY_LOCAL_ZOOM_IN] = '='; // NOTE: SHIFTED TO PRODUCE '+'
	command_key[KEY_LOCAL_ZOOM_OUT] = '-';
	command_key[KEY_REVIEW] = '.';
	command_key[KEY_TOGGLE_FROZEN] = FL_Pause;
	command_key[KEY_SNAPSHOT] = FL_Print;
	command_key[KEY_SNAPSHOT_OTHER] = 'p';
	command_key[KEY_SCALE_VIDEO_UP] = FL_Page_Up;
	command_key[KEY_SCALE_VIDEO_DOWN] = FL_Page_Down;
	command_key[KEY_SCALE_VIDEO_RESET] = FL_End;
	command_key[KEY_DISPLAY_SPLIT_SELECTION_0] = '0';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_1] = '1';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_2] = '2';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_3] = '3';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_4] = '4';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_5] = '5';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_6] = '6';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_7] = '7';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_8] = '8';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_9] = '9';
	command_key[KEY_DISPLAY_ELEMENTS] = FL_Tab;
	command_key[KEY_EXIT] = FL_Escape;
	command_key[KEY_OPEN_MENU] = FL_F + 1;
	command_key[KEY_OPEN_CAMERAS] = FL_F + 2;
	command_key[KEY_OPEN_AUDIO] = FL_F + 3;
	command_key[KEY_OPEN_PTZ] = FL_F + 4;
}

int	MyWin::CheckCommandTitle(char *name)
{
	int nn = -1;
	if(strcasecmp("TOGGLE RECORD", name) == 0) nn = KEY_TOGGLE_RECORD;
	if(strcasecmp("DELETE IMMEDIATE", name) == 0) nn = KEY_DELETE_IMMEDIATE;
	if(strcasecmp("TOGGLE PTZ JOYSTICK", name) == 0) nn = KEY_TOGGLE_PTZ_JOYSTICK;
	if(strcasecmp("INCREASE PTZ LITTLE SPEED", name) == 0) nn = KEY_INCREASE_PTZ_LITTLE_SPEED;
	if(strcasecmp("DECREASE PTZ LITTLE SPEED", name) == 0) nn = KEY_DECREASE_PTZ_LITTLE_SPEED;
	if(strcasecmp("CYCLE PTZ LITTLE MODE", name) == 0) nn = KEY_CYCLE_PTZ_LITTLE_MODE;
	if(strcasecmp("PTZ HOME", name) == 0) nn = KEY_PTZ_HOME;
	if(strcasecmp("CYCLE DOWN THUMBGROUP", name) == 0) nn = KEY_CYCLE_DOWN_THUMBGROUP;
	if(strcasecmp("CYCLE UP THUMBGROUP", name) == 0) nn = KEY_CYCLE_UP_THUMBGROUP;
	if(strcasecmp("DISPLAY THUMBGROUP 0", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_0;
	if(strcasecmp("DISPLAY THUMBGROUP 1", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_1;
	if(strcasecmp("DISPLAY THUMBGROUP 2", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_2;
	if(strcasecmp("DISPLAY THUMBGROUP 3", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_3;
	if(strcasecmp("DISPLAY THUMBGROUP 4", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_4;
	if(strcasecmp("DISPLAY THUMBGROUP 5", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_5;
	if(strcasecmp("DISPLAY THUMBGROUP 6", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_6;
	if(strcasecmp("DISPLAY THUMBGROUP 7", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_7;
	if(strcasecmp("DISPLAY THUMBGROUP 8", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_8;
	if(strcasecmp("DISPLAY THUMBGROUP 9", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_9;
	if(strcasecmp("LITTLE MOTION 1", name) == 0) nn = KEY_LITTLE_MOTION_1;
	if(strcasecmp("LITTLE MOTION 2", name) == 0) nn = KEY_LITTLE_MOTION_2;
	if(strcasecmp("LITTLE MOTION 3", name) == 0) nn = KEY_LITTLE_MOTION_3;
	if(strcasecmp("LITTLE MOTION 4", name) == 0) nn = KEY_LITTLE_MOTION_4;
	if(strcasecmp("LITTLE MOTION 5", name) == 0) nn = KEY_LITTLE_MOTION_5;
	if(strcasecmp("LITTLE MOTION 6", name) == 0) nn = KEY_LITTLE_MOTION_6;
	if(strcasecmp("LITTLE MOTION 7", name) == 0) nn = KEY_LITTLE_MOTION_7;
	if(strcasecmp("LITTLE MOTION 8", name) == 0) nn = KEY_LITTLE_MOTION_8;
	if(strcasecmp("LITTLE MOTION OTHER 1", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_1;
	if(strcasecmp("LITTLE MOTION OTHER 2", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_2;
	if(strcasecmp("LITTLE MOTION OTHER 3", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_3;
	if(strcasecmp("LITTLE MOTION OTHER 4", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_4;
	if(strcasecmp("LITTLE MOTION OTHER 5", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_5;
	if(strcasecmp("LITTLE MOTION OTHER 6", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_6;
	if(strcasecmp("LITTLE MOTION OTHER 7", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_7;
	if(strcasecmp("LITTLE MOTION OTHER 8", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_8;
	if(strcasecmp("LOCAL ZOOM IN", name) == 0) nn = KEY_LOCAL_ZOOM_IN;
	if(strcasecmp("LOCAL ZOOM OUT", name) == 0) nn = KEY_LOCAL_ZOOM_OUT;
	if(strcasecmp("REVIEW", name) == 0) nn = KEY_REVIEW;
	if(strcasecmp("TOGGLE FROZEN", name) == 0) nn = KEY_TOGGLE_FROZEN;
	if(strcasecmp("SNAPSHOT", name) == 0) nn = KEY_SNAPSHOT;
	if(strcasecmp("SNAPSHOT OTHER", name) == 0) nn = KEY_SNAPSHOT_OTHER;
	if(strcasecmp("DISPLAY SPLIT SELECTION 0", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_0;
	if(strcasecmp("DISPLAY SPLIT SELECTION 1", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_1;
	if(strcasecmp("DISPLAY SPLIT SELECTION 2", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_2;
	if(strcasecmp("DISPLAY SPLIT SELECTION 3", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_3;
	if(strcasecmp("DISPLAY SPLIT SELECTION 4", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_4;
	if(strcasecmp("DISPLAY SPLIT SELECTION 5", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_5;
	if(strcasecmp("DISPLAY SPLIT SELECTION 6", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_6;
	if(strcasecmp("DISPLAY SPLIT SELECTION 7", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_7;
	if(strcasecmp("DISPLAY SPLIT SELECTION 8", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_8;
	if(strcasecmp("DISPLAY SPLIT SELECTION 9", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_9;
	if(strcasecmp("TOGGLE DISPLAY ELEMENTS", name) == 0) nn = KEY_DISPLAY_ELEMENTS;
	if(strcasecmp("EXIT", name) == 0) nn = KEY_EXIT;
	if(strcasecmp("OPEN MENU", name) == 0) nn = KEY_OPEN_MENU;
	if(strcasecmp("OPEN CAMERAS", name) == 0) nn = KEY_OPEN_CAMERAS;
	if(strcasecmp("OPEN AUDIO", name) == 0) nn = KEY_OPEN_AUDIO;
	if(strcasecmp("OPEN PTZ", name) == 0) nn = KEY_OPEN_PTZ;
	return(nn);
}

char	*MyWin::CommandKeyName(int nn)
{
static char	buf[32];

	char *str = NULL;
	int cnt = 0;
	int done = 0;
	while(done == 0)
	{
		if(named_key[cnt].val != 0)
		{
			if(named_key[cnt].val == nn)
			{
				str = named_key[cnt].name;
				done = 1;
			}
		}
		else
		{
			done = 1;
		}
		cnt++;
	}
	if(str == NULL)
	{
		sprintf(buf, "%c", nn);
		str = buf;
	}
	return(str);
}

void	MyWin::SaveCommandKeyDefinitions(char *filename)
{
	FILE *fp = fopen(filename, "w");
	if(fp != NULL)
	{
		fprintf(fp, "TOGGLE RECORD\t%s\n", CommandKeyName(command_key[KEY_TOGGLE_RECORD]));
		fprintf(fp, "DELETE IMMEDIATE\t%s\n", CommandKeyName(command_key[KEY_DELETE_IMMEDIATE]));
		fprintf(fp, "TOGGLE PTZ JOYSTICK\t%s\n", CommandKeyName(command_key[KEY_TOGGLE_PTZ_JOYSTICK]));
		fprintf(fp, "INCREASE PTZ LITTLE SPEED\t%s\n", CommandKeyName(command_key[KEY_INCREASE_PTZ_LITTLE_SPEED]));
		fprintf(fp, "DECREASE PTZ LITTLE SPEED\t%s\n", CommandKeyName(command_key[KEY_DECREASE_PTZ_LITTLE_SPEED]));
		fprintf(fp, "CYCLE PTZ LITTLE MODE\t%s\n", CommandKeyName(command_key[KEY_CYCLE_PTZ_LITTLE_MODE]));
		fprintf(fp, "PTZ HOME\t%s\n", CommandKeyName(command_key[KEY_PTZ_HOME]));
		fprintf(fp, "CYCLE DOWN THUMBGROUP\t%s\n", CommandKeyName(command_key[KEY_CYCLE_DOWN_THUMBGROUP]));
		fprintf(fp, "CYCLE UP THUMBGROUP\t%s\n", CommandKeyName(command_key[KEY_CYCLE_UP_THUMBGROUP]));
		fprintf(fp, "DISPLAY THUMBGROUP 0\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_0]));
		fprintf(fp, "DISPLAY THUMBGROUP 1\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_1]));
		fprintf(fp, "DISPLAY THUMBGROUP 2\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_2]));
		fprintf(fp, "DISPLAY THUMBGROUP 3\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_3]));
		fprintf(fp, "DISPLAY THUMBGROUP 4\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_4]));
		fprintf(fp, "DISPLAY THUMBGROUP 5\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_5]));
		fprintf(fp, "DISPLAY THUMBGROUP 6\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_6]));
		fprintf(fp, "DISPLAY THUMBGROUP 7\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_7]));
		fprintf(fp, "DISPLAY THUMBGROUP 8\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_8]));
		fprintf(fp, "DISPLAY THUMBGROUP 9\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_9]));
		fprintf(fp, "LITTLE MOTION 1\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_1]));
		fprintf(fp, "LITTLE MOTION 2\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_2]));
		fprintf(fp, "LITTLE MOTION 3\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_3]));
		fprintf(fp, "LITTLE MOTION 4\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_4]));
		fprintf(fp, "LITTLE MOTION 5\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_5]));
		fprintf(fp, "LITTLE MOTION 6\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_6]));
		fprintf(fp, "LITTLE MOTION 7\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_7]));
		fprintf(fp, "LITTLE MOTION 8\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_8]));
		fprintf(fp, "LITTLE MOTION OTHER 1\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_1]));
		fprintf(fp, "LITTLE MOTION OTHER 2\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_2]));
		fprintf(fp, "LITTLE MOTION OTHER 3\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_3]));
		fprintf(fp, "LITTLE MOTION OTHER 4\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_4]));
		fprintf(fp, "LITTLE MOTION OTHER 5\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_5]));
		fprintf(fp, "LITTLE MOTION OTHER 6\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_6]));
		fprintf(fp, "LITTLE MOTION OTHER 7\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_7]));
		fprintf(fp, "LITTLE MOTION OTHER 8\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_8]));
		fprintf(fp, "LOCAL ZOOM IN\t%s\n", CommandKeyName(command_key[KEY_LOCAL_ZOOM_IN]));
		fprintf(fp, "LOCAL ZOOM OUT\t%s\n", CommandKeyName(command_key[KEY_LOCAL_ZOOM_OUT]));
		fprintf(fp, "REVIEW\t%s\n", CommandKeyName(command_key[KEY_REVIEW]));
		fprintf(fp, "TOGGLE FROZEN\t%s\n", CommandKeyName(command_key[KEY_TOGGLE_FROZEN]));
		fprintf(fp, "SNAPSHOT\t%s\n", CommandKeyName(command_key[KEY_SNAPSHOT]));
		fprintf(fp, "SNAPSHOT OTHER\t%s\n", CommandKeyName(command_key[KEY_SNAPSHOT_OTHER]));
		fprintf(fp, "SCALE VIDEO UP\t%s\n", CommandKeyName(command_key[KEY_SCALE_VIDEO_UP]));
		fprintf(fp, "SCALE VIDEO DOWN\t%s\n", CommandKeyName(command_key[KEY_SCALE_VIDEO_DOWN]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 0\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 1\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 2\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 3\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 4\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 5\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 6\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 7\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 8\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 9\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "TOGGLE DISPLAY ELEMENTS\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_ELEMENTS]));
		fprintf(fp, "EXIT\t%s\n", CommandKeyName(command_key[KEY_EXIT]));
		fprintf(fp, "OPEN MENU\t%s\n", CommandKeyName(command_key[KEY_OPEN_MENU]));
		fprintf(fp, "OPEN CAMERAS\t%s\n", CommandKeyName(command_key[KEY_OPEN_CAMERAS]));
		fprintf(fp, "OPEN AUDIO\t%s\n", CommandKeyName(command_key[KEY_OPEN_AUDIO]));
		fprintf(fp, "OPEN PTZ\t%s\n", CommandKeyName(command_key[KEY_OPEN_PTZ]));
		fclose(fp);
	}
}

void	MyWin::ReadCommandKeyDefinitions(char *filename)
{
char	buf[256];

	FILE *fp = fopen(filename, "r");
	if(fp != NULL)
	{
		while(fgets(buf, 255, fp) != NULL)
		{
			strip_lf(buf);
			char *cp = buf;
			char *definition = NULL;
			char *title = cp;
			int shifted = 0;
			int alted = 0;
			int ctrled = 0;
			int done = 0;
			while((definition == NULL) && (done == 0))
			{
				while((*cp != '\t') && (*cp != '\0'))
				{
					cp++;
				}
				if(*cp == '\t')
				{
					*cp = '\0';
					cp++;
					char *str = cp;
					if(strncasecmp(str, "[shift]", strlen("[shift]")) == 0)
					{
						shifted = 1;
					}
					else if(strncasecmp(str, "[alt]", strlen("[alt]")) == 0)
					{
						alted = 1;
					}
					else if(strncasecmp(str, "[ctrl]", strlen("[ctrl]")) == 0)
					{
						ctrled = 1;
					}
					else
					{
						definition = cp;
					}
				}
				else if(*cp == '\0')
				{
					done = 1;
				}
			}
			if(strlen(title) > 0)
			{
				int nn = CheckCommandTitle(title);
				if(nn > -1)
				{
					if(definition != NULL)
					{
						if(strlen(definition) == 1)
						{
							command_key[nn] = *definition;
						}
						else if(strlen(definition) > 1)
						{
							if(strcasecmp(definition, "Alt L") == 0) command_key[nn] = 0xffe9;
							if(strcasecmp(definition, "Alt R") == 0) command_key[nn] = 0xffea;
							if(strcasecmp(definition, "Back") == 0) command_key[nn] = 0xEF26;
							if(strcasecmp(definition, "BackSpace") == 0) command_key[nn] = 0xff08;
							if(strcasecmp(definition, "Button") == 0) command_key[nn] = 0xfee8;
							if(strcasecmp(definition, "Caps Lock") == 0) command_key[nn] = 0xffe5;
							if(strcasecmp(definition, "Control L") == 0) command_key[nn] = 0xffe3;
							if(strcasecmp(definition, "Control R") == 0) command_key[nn] = 0xffe4;
							if(strcasecmp(definition, "Delete") == 0) command_key[nn] = 0xffff;
							if(strcasecmp(definition, "Down") == 0) command_key[nn] = 0xff54;
							if(strcasecmp(definition, "Eisu") == 0) command_key[nn] = 0xff2f;
							if(strcasecmp(definition, "End") == 0) command_key[nn] = 0xff57;
							if(strcasecmp(definition, "Enter") == 0) command_key[nn] = 0xff0d;
							if(strcasecmp(definition, "Escape") == 0) command_key[nn] = 0xff1b;
							if(strcasecmp(definition, "Function 1") == 0) command_key[nn] = 0xffbe;
							if(strcasecmp(definition, "Function 2") == 0) command_key[nn] = 0xffbe + 1;
							if(strcasecmp(definition, "Function 3") == 0) command_key[nn] = 0xffbe + 2;
							if(strcasecmp(definition, "Function 4") == 0) command_key[nn] = 0xffbe + 3;
							if(strcasecmp(definition, "Function 5") == 0) command_key[nn] = 0xffbe + 4;
							if(strcasecmp(definition, "Function 6") == 0) command_key[nn] = 0xffbe + 5;
							if(strcasecmp(definition, "Function 7") == 0) command_key[nn] = 0xffbe + 6;
							if(strcasecmp(definition, "Function 8") == 0) command_key[nn] = 0xffbe + 7;
							if(strcasecmp(definition, "Function 9") == 0) command_key[nn] = 0xffbe +  8;
							if(strcasecmp(definition, "Function 10") == 0) command_key[nn] = 0xffbe + 9;
							if(strcasecmp(definition, "Function 11") == 0) command_key[nn] = 0xffbe + 10;
							if(strcasecmp(definition, "Function 12") == 0) command_key[nn] = 0xffbe + 11;
							if(strcasecmp(definition, "Favorites") == 0) command_key[nn] = 0xEF30;
							if(strcasecmp(definition, "Forward") == 0) command_key[nn] = 0xEF27;
							if(strcasecmp(definition, "Help") == 0) command_key[nn] = 0xff68;
							if(strcasecmp(definition, "Home") == 0) command_key[nn] = 0xff50;
							if(strcasecmp(definition, "Home Page") == 0) command_key[nn] = 0xEF18;
							if(strcasecmp(definition, "Insert") == 0) command_key[nn] = 0xff63;
							if(strcasecmp(definition, "Iso Key") == 0) command_key[nn] = 0xff0c;
							if(strcasecmp(definition, "JIS Underscore") == 0) command_key[nn] = 0xff31;
							if(strcasecmp(definition, "Kana") == 0) command_key[nn] = 0xff2e;
							if(strcasecmp(definition, "KP 1") == 0) command_key[nn] = 0xff80 + '1';
							if(strcasecmp(definition, "KP 2") == 0) command_key[nn] = 0xff80 + '2';
							if(strcasecmp(definition, "KP 3") == 0) command_key[nn] = 0xff80 + '3';
							if(strcasecmp(definition, "KP 4") == 0) command_key[nn] = 0xff80 + '4';
							if(strcasecmp(definition, "KP 5") == 0) command_key[nn] = 0xff80 + '5';
							if(strcasecmp(definition, "KP 6") == 0) command_key[nn] = 0xff80 + '6';
							if(strcasecmp(definition, "KP 7") == 0) command_key[nn] = 0xff80 + '7';
							if(strcasecmp(definition, "KP 8") == 0) command_key[nn] = 0xff80 + '8';
							if(strcasecmp(definition, "KP 9") == 0) command_key[nn] = 0xff80 + '9';
							if(strcasecmp(definition, "KP 0") == 0) command_key[nn] = 0xff80 + '0';
							if(strcasecmp(definition, "KP +") == 0) command_key[nn] = 0xff80 + '+';
							if(strcasecmp(definition, "KP -") == 0) command_key[nn] = 0xff80 + '-';
							if(strcasecmp(definition, "KP Enter") == 0) command_key[nn] = 0xff8d;
							if(strcasecmp(definition, "Left") == 0) command_key[nn] = 0xff51;
							if(strcasecmp(definition, "Mail") == 0) command_key[nn] = 0xEF19;
							if(strcasecmp(definition, "Media Next") == 0) command_key[nn] = 0xEF17;
							if(strcasecmp(definition, "Media Play") == 0) command_key[nn] = 0xEF14;
							if(strcasecmp(definition, "Media Prev") == 0) command_key[nn] = 0xEF16;
							if(strcasecmp(definition, "Media Stop") == 0) command_key[nn] = 0xEF15;
							if(strcasecmp(definition, "Menu") == 0) command_key[nn] = 0xff67;
							if(strcasecmp(definition, "Meta L") == 0) command_key[nn] = 0xffe7;
							if(strcasecmp(definition, "Meta R") == 0) command_key[nn] = 0xffe8;
							if(strcasecmp(definition, "Num Lock") == 0) command_key[nn] = 0xff7f;
							if(strcasecmp(definition, "Page Down") == 0) command_key[nn] = 0xff56;
							if(strcasecmp(definition, "Page Up") == 0) command_key[nn] = 0xff55;
							if(strcasecmp(definition, "Pause") == 0) command_key[nn] = 0xff13;
							if(strcasecmp(definition, "Print") == 0) command_key[nn] = 0xff61;
							if(strcasecmp(definition, "Refresh") == 0) command_key[nn] = 0xEF29;
							if(strcasecmp(definition, "Right") == 0) command_key[nn] = 0xff53;
							if(strcasecmp(definition, "Scroll Lock") == 0) command_key[nn] = 0xff14;
							if(strcasecmp(definition, "Search") == 0) command_key[nn] = 0xEF1B;
							if(strcasecmp(definition, "Shift L") == 0) command_key[nn] = 0xffe1;
							if(strcasecmp(definition, "Shift R") == 0) command_key[nn] = 0xffe2;
							if(strcasecmp(definition, "Sleep") == 0) command_key[nn] = 0xEF2F;
							if(strcasecmp(definition, "Stop") == 0) command_key[nn] = 0xEF28;
							if(strcasecmp(definition, "Tab") == 0) command_key[nn] = 0xff09;
							if(strcasecmp(definition, "Up") == 0) command_key[nn] = 0xff52;
							if(strcasecmp(definition, "Volume Down") == 0) command_key[nn] = 0xEF11;
							if(strcasecmp(definition, "Volume Mute") == 0) command_key[nn] = 0xEF12;
							if(strcasecmp(definition, "Volume Up") == 0) command_key[nn] = 0xEF13;
							if(strcasecmp(definition, "Yen") == 0) command_key[nn] = 0xff30;
							if(strcasecmp(definition, "Exit") == 0) command_key[nn] = 0xff1b;
						}
					}
				}
			}
		}
		fclose(fp);
	}
}

int	MyWin::CalcMenuHeight(MyGroup *button_group_pack)
{
int	loop;

	int sz = 0;
	int button_cnt = 0;
	for(loop = 0;loop < button_group_pack->children();loop++)
	{
		Fl_Widget *chld = button_group_pack->child(loop);
		if(chld != NULL)
		{
			if(chld->visible())
			{
				sz += chld->h();
				button_cnt++;
			}
		}
	}
	return(sz);
}

void	MyWin::BuildMainMenu()
{
int	loop;

	int y_pos = 10;
	int y_inc = 22;
	start_win->Update("Initialize main menu");

	int font_sz = (int)24.0;
	int button_height = 40.0;

	int button_sz = 180;
	button_panel_sz = 200;

	button_group = new MainMenu(this, 0, 0, button_panel_sz, h());
	if(transparent_interface == 0)
	{
		button_group->box(FL_FLAT_BOX);
	}
	else
	{
		button_group->box(FL_NO_BOX);
	}
	button_group->color(DARK_GRAY);

	button_group_pack = new Fl_Pack(8, 0, button_panel_sz, h() - 30);
	button_group_pack->spacing(2);

	Fl_Box *spacer = new Fl_Box(8, y_pos, button_sz, button_height / 2);
	spacer->box(FL_NO_BOX);
	y_pos += (y_inc / 2);

	record_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Record");
	record_button->copy_tooltip("Toggle recording or begin testing for record-trigger conditions.");
	record_button->callback(record_button_cb, this);
	record_button->shortcut(FL_F + 10);
	if(use_old == 1)
	{
		record_button->hide();
	}
	y_pos += button_height;

	encode_speed_window = new EncodeSpeedWindow(this, 8, y_pos, button_sz, 16);
	encode_speed_window->copy_tooltip("Set recording speed as a fraction or multiplier of normal.");
	y_pos += y_inc;

	override_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Override");
	override_button->copy_tooltip("Override a recording trigger and start recording immediately.");
	override_button->callback(override_button_cb, this);
	y_pos += y_inc;

	snapshot_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Snap Photo");
	snapshot_button->copy_tooltip("Capture the displayed camera and save it as a PNG.");
	snapshot_button->callback(snapshot_button_cb, this);
	y_pos += y_inc;

	trigger_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Trigger Conditions");
	trigger_button->copy_tooltip("Set trigger conditions for recording.");
	trigger_button->callback(trigger_camera_button_cb, this);
	y_pos += y_inc;

	camera_settings_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Camera Settings");
	camera_settings_button->copy_tooltip("Camera settings for the currently displayed camera.");
	camera_settings_button->callback(camera_settings_button_cb, this);
	y_pos += y_inc;

	snapshot_settings_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Snapshot Settings");
	snapshot_settings_button->copy_tooltip("Set trigger settings for the snapshot function.\n");
	snapshot_settings_button->callback(snapshot_settings_button_cb, this);
	y_pos += y_inc;

	zoom_box_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Box Zoom");
	zoom_box_button->copy_tooltip("Zoom in using a draggable selection area.");
	zoom_box_button->callback(zoom_box_button_cb, this);
	y_pos += y_inc;

	alias_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Set Camera Alias");
	alias_button->copy_tooltip("Set the alias for the currently displayed camera.");
	alias_button->callback(alias_button_cb, this);
	y_pos += y_inc;

	reset_camera_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Reset Camera");
	reset_camera_button->copy_tooltip("Reset the currently displayed camera.");
	reset_camera_button->callback(reset_camera_button_cb, this);
	y_pos += y_inc;

	flip_horizontal_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Flip Horizontal");
	flip_horizontal_button->copy_tooltip("Flip the currently displayed camera's image horizontally.");
	flip_horizontal_button->callback(flip_horizontal_button_cb, this);
	y_pos += y_inc;

	flip_vertical_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Flip Vertical");
	flip_vertical_button->copy_tooltip("Flip the currently displayed camera's image vertically.");
	flip_vertical_button->callback(flip_vertical_button_cb, this);
	y_pos += y_inc;

	filter_built_in_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Filters");
	filter_built_in_button->copy_tooltip("Apply filters to the currently displayed camera.\n");
	filter_built_in_button->callback(filter_built_in_button_cb, this);
	y_pos += y_inc;

	filter_plugins_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Filter Plugins");
	filter_plugins_button->copy_tooltip("Apply plug-in filters to the currently displayed camera.\n");
	filter_plugins_button->callback(filter_plugins_button_cb, this);
	if(global_potential_filter_cnt <= 0)
	{
		filter_plugins_button->hide();
	}
	y_pos += y_inc;

	fltk_plugin_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "FLTK Plugin");
	fltk_plugin_button->copy_tooltip("Apply a FLTK program to the GUI. The primary FLTK class is passed to the plugin. This allows the plugin to alter the primary GUI classes attached to the passed entry point.\n");
	fltk_plugin_button->callback(fltk_plugin_button_cb, this);
	y_pos += y_inc;

	immediate_drawing_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Immediate Drawing");
	immediate_drawing_button->copy_tooltip("Apply selected drawing functions to the currently displayed camera.\n");
	immediate_drawing_button->callback(immediate_drawing_button_cb, this);
	y_pos += y_inc;

	dynamic_coloring_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Dynamic Coloring");
	dynamic_coloring_button->copy_tooltip("Apply a color change to a range of tones selected with the mouse from within the image.");
	dynamic_coloring_button->callback(dynamic_coloring_button_cb, this);
	y_pos += y_inc;

	toggle_camera_effects_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Turn Off Effects");
	toggle_camera_effects_button->copy_tooltip("Toggle the effects that have been applied to the currently displayed camera.");
	toggle_camera_effects_button->callback(toggle_camera_effects_button_cb, this);
	y_pos += y_inc;

	save_camera_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Save Camera");
	save_camera_button->copy_tooltip("Save the currently displayed camera's settings to a file.\n");
	save_camera_button->callback(save_camera_button_cb, this);
	y_pos += y_inc;

	hide_video_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Hide Video");
	hide_video_button->copy_tooltip("Hide the images coming from the currently displayed camera.");
	hide_video_button->callback(hide_video_button_cb, this);
	y_pos += y_inc;

	freeze_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Freeze");
	freeze_button->copy_tooltip("Freeze the image coming from the currently displayed camera.");
	freeze_button->callback(freeze_button_cb, this);
	y_pos += y_inc;

	mute_video_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Mute Video");
	mute_video_button->copy_tooltip("Toggle the images coming from the currently displayed camera.");
	mute_video_button->callback(mute_video_button_cb, this);
	y_pos += y_inc;

	power_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Turn Off");
	power_button->copy_tooltip("Toggle sampling the currently displayed camera.");
	power_button->callback(power_button_cb, this);
	y_pos += y_inc;

	toggle_objects_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Select Objects");
	toggle_objects_button->copy_tooltip("Toggle displaying objects that appear on currently displayed camera's image.");
	toggle_objects_button->callback(toggle_objects_button_cb, this);
	y_pos += y_inc;

	Fl_Box *spacer2 = new Fl_Box(8, y_pos, button_sz, button_height / 2);
	spacer2->box(FL_NO_BOX);
	y_pos += (y_inc / 2);

	audio_mute_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Mute Audio");
	audio_mute_button->copy_tooltip("Mute all audio from the audio mixer.");
	audio_mute_button->callback(audio_mute_button_cb, this);
	y_pos += y_inc;

	monitor_audio_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Monitor Audio");
	monitor_audio_button->copy_tooltip("Monitor the audio mixer through the system's default output audio device.");
	monitor_audio_button->callback(monitor_audio_button_cb, this);
	y_pos += y_inc;

	audio_library_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Audio Library");
	audio_library_button->copy_tooltip("Manage a library of audio files.");
	audio_library_button->callback(audio_library_button_cb, this);
	y_pos += y_inc;

	audio_library_list_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Play Audio Library");
	audio_library_list_button->copy_tooltip("Play an audio file from the audio library.");
	audio_library_list_button->callback(audio_library_list_button_cb, this);
	y_pos += y_inc;

	play_audio_file_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Play Audio File");
	play_audio_file_button->copy_tooltip("Play an audio file.");
	play_audio_file_button->callback(play_audio_file_button_cb, this);
	y_pos += y_inc;

	pause_playing_audio_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Pause Playing");
	pause_playing_audio_button->copy_tooltip("Pause playing an audio file.");
	pause_playing_audio_button->callback(pause_playing_audio_button_cb, this);
	pause_playing_audio_button->hide();
	y_pos += y_inc;

	stop_playing_audio_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Stop Playing");
	stop_playing_audio_button->copy_tooltip("Stop playing an audio file.");
	stop_playing_audio_button->callback(stop_playing_audio_button_cb, this);
	stop_playing_audio_button->hide();
	y_pos += y_inc;

	audio_filter_plugins_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Audio Filter Plugins");
	audio_filter_plugins_button->copy_tooltip("Apply audio effects available as plug-ins.");
	audio_filter_plugins_button->callback(audio_filter_plugins_button_cb, this);
	if(global_potential_audio_filter_cnt <= 0)
	{
		audio_filter_plugins_button->hide();
	}
	y_pos += y_inc;
	audio_bind_to_camera_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Bind to Camera");
	audio_bind_to_camera_button->copy_tooltip("Bind currently selected audio sources to displayed camera.");
	audio_bind_to_camera_button->callback(audio_bind_to_camera_button_cb, this);
	y_pos += y_inc;

	audio_settings_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Audio Settings");
	audio_settings_button->copy_tooltip("Set audio settings.");
	audio_settings_button->callback(audio_settings_button_cb, this);
	y_pos += y_inc;

	audio_save_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Save Audio Sources");
	audio_save_button->copy_tooltip("Save audio sources.");
	audio_save_button->callback(audio_save_button_cb, this);
	y_pos += y_inc;

	audio_load_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Load Audio Sources");
	audio_load_button->copy_tooltip("Load audio sources.");
	audio_load_button->callback(audio_load_button_cb, this);
	y_pos += y_inc;

	Fl_Box *spacer3 = new Fl_Box(8, y_pos, button_sz, button_height / 2);
	spacer3->box(FL_NO_BOX);
	y_pos += (y_inc / 2);

	new_source_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "New Source");
	new_source_button->copy_tooltip("Create new cameras and microphones, including several special purpose virtual devices.");
	new_source_button->callback(new_source_button_cb, this);
	y_pos += y_inc;

	edit_source_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Edit Source");
	edit_source_button->copy_tooltip("Edit the settings for the currently displayed video source.");
	edit_source_button->callback(edit_source_button_cb, this);
	y_pos += y_inc;

	select_output_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Select Output");
	select_output_button->copy_tooltip("Select the outputs for the muxed audio/video stream while recording.");
	select_output_button->callback(select_output_button_cb, this);
	y_pos += y_inc;

	edit_output_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Edit Outputs");
	select_output_button->copy_tooltip("Define the outputs for the muxed audio/video stream while recording.");
	edit_output_button->callback(edit_output_button_cb, this);
	y_pos += y_inc;

	save_setup_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Save Setup");
	save_setup_button->copy_tooltip("Save the full system settings including sources.");
	save_setup_button->callback(save_setup_button_cb, this);
	y_pos += y_inc;

	load_setup_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Load Setup");
	load_setup_button->copy_tooltip("Load the full system settings including defined sources.");
	load_setup_button->callback(load_setup_button_cb, this);
	y_pos += y_inc;

	transitions_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Transitions");
	transitions_button->copy_tooltip("Select between several transitions invoked when changing the recording camera.");
	transitions_button->callback(transitions_button_cb, this);
	y_pos += y_inc;

	timestamp_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Timestamp");
	timestamp_button->copy_tooltip("Imprint a timestamp on the images coming in from the recording camera.");
	timestamp_button->callback(timestamp_button_cb, this);
	y_pos += y_inc;

	dump_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Dump Frames");
	dump_button->copy_tooltip("Save the individual frames coming in from the recording camera as image files.");
	dump_button->callback(dump_button_cb, this);
	dump_button->hide();
	y_pos += y_inc;

	encode_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Force Encode");
	encode_button->copy_tooltip("Encode frames recorded to a buffer file in the selected muxed format.");
	encode_button->callback(encode_button_cb, this);
	encode_button->hide();
	y_pos += y_inc;

	test_recognition_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Test Recognition");
	test_recognition_button->copy_tooltip("Attempt to recognize selected objects, but do not trigger recording.");
	test_recognition_button->callback(test_recognition_button_cb, this);
	y_pos += y_inc;

	show_debug_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Record Recognition");
	show_debug_button->copy_tooltip("Imprint onto the video graphics demonstrating recognized objects.");
	show_debug_button->callback(show_debug_button_cb, this);
	y_pos += y_inc;

	show_motion_debug_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Show Motion Debug");
	show_motion_debug_button->copy_tooltip("Show motion information overlayed on the viewed image signal.");
	show_motion_debug_button->callback(show_motion_debug_button_cb, this);
	y_pos += y_inc;

	review_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Review Footage");
	review_button->copy_tooltip("Review buffer footage in a simple video viewer and editor.");
	review_button->callback(review_button_cb, this);
	y_pos += y_inc;

	review_muxed_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Review Muxed");
	review_muxed_button->copy_tooltip("Review muxed footage in a simple video viewer.");
	review_muxed_button->callback(review_muxed_button_cb, this);
	review_muxed_button->hide();
	y_pos += y_inc;

	jpeg_streaming_button = NULL;
	jpeg_streaming_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "JPEG Stream");
	jpeg_streaming_button->copy_tooltip("Enable streaming of frames as JPG to a networked server.");
	jpeg_streaming_button->callback(jpeg_streaming_button_cb, this);
	if(jpeg_streaming == NULL)
	{
		jpeg_streaming_button->hide();
	}
	y_pos += y_inc;

	set_interest_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Set Interest");
	set_interest_button->copy_tooltip("Set areas of interest when using motion detection.");
	set_interest_button->callback(set_interest_button_cb, this);
	y_pos += y_inc;

	clear_interest_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Clear Interest");
	clear_interest_button->copy_tooltip("Clear all areas of interest when using motion detection.");
	clear_interest_button->callback(clear_interest_button_cb, this);
	y_pos += y_inc;

	save_interest_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Save Interest");
	clear_interest_button->copy_tooltip("Save areas of interest to a file.");
	save_interest_button->callback(save_interest_button_cb, this);
	y_pos += y_inc;

	load_interest_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Load Interest");
	clear_interest_button->copy_tooltip("Load saved areas of interest when using motion detection.");
	load_interest_button->callback(load_interest_button_cb, this);
	y_pos += y_inc;

	reset_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Reset Recording");
	reset_button->copy_tooltip("Reset the recording. This allows you to start over to a fresh file.");
	reset_button->callback(reset_button_cb, this);
	y_pos += y_inc;

	reset_cameras_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Reset Cameras");
	reset_cameras_button->copy_tooltip("Reset all cameras.");
	reset_cameras_button->callback(reset_cameras_button_cb, this);
	y_pos += y_inc;

	split_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Split Screen");
	split_button->copy_tooltip("Divide the screen up into panels, each displaying one of the available cameras.");
	split_button->callback(split_button_cb, this);
	y_pos += y_inc;

	monitor_video_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Monitor Video");
	monitor_video_button->copy_tooltip("Monitor the signal coming in from the recording camera.");
	monitor_video_button->callback(monitor_video_button_cb, this);
	y_pos += y_inc;

	open_standalone_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Standalone Display");
	open_standalone_button->copy_tooltip("Open a window displaying the currently displayed camera, without controls.");
	open_standalone_button->callback(open_standalone_cb, this);
	y_pos += y_inc;

	resize_capture_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Resize Capture (reset)");
	resize_capture_button->copy_tooltip("Resize the resolution for a video source. This will cause the source to reset.");
	resize_capture_button->callback(resize_capture_button_cb, this);
	y_pos += y_inc;

	load_camera_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Load Camera");
	load_camera_button->copy_tooltip("Load a camera from a previously saved file.");
	load_camera_button->callback(load_camera_button_cb, this);
	y_pos += y_inc;

	ptz_lock_window_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "PTZ Lock Camera");
	ptz_lock_window_button->copy_tooltip("Lock a camera to a set of PTZ controls.");
	ptz_lock_window_button->callback(ptz_lock_window_button_cb, this);
	y_pos += y_inc;

	video_settings_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Video Settings");
	video_settings_button->copy_tooltip("Set overall video settings.");
	video_settings_button->callback(video_settings_button_cb, this);
	y_pos += y_inc;

	keyboard_settings_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Keyboard Settings");
	keyboard_settings_button->copy_tooltip("Change keyboard bindings to commands.");
	keyboard_settings_button->callback(keyboard_settings_button_cb, this);
	y_pos += y_inc;

	gui_settings_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "GUI Settings");
	gui_settings_button->copy_tooltip("Change user interface settings.");
	gui_settings_button->callback(gui_settings_button_cb, this);
	y_pos += y_inc;

	codecs_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Codecs");
	codecs_button->copy_tooltip("Select the codec to be used when recording or rendering from buffers.");
	codecs_button->callback(container_menu_cb, this);
	if(global_my_format_cnt > 0)
	{
		codecs_button->show();
	}
	else
	{
		codecs_button->hide();
	}
	y_pos += y_inc;

	external_pgm_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "External PGMs");
	external_pgm_button->copy_tooltip("In open an external X11 program and embed the resulting window.\n");
	external_pgm_button->callback(external_pgm_button_cb, this);
	y_pos += y_inc;

	Fl_Box *spacer4 = new Fl_Box(8, y_pos, button_sz, button_height / 2);
	spacer4->box(FL_NO_BOX);
	y_pos += (y_inc / 2);

	quit_button = new MenuButton(button_group, font_sz, 8, y_pos, button_sz, button_height, "Exit");
	quit_button->copy_tooltip("Exit the program.");
	quit_button->callback(quit_cb, this);
	y_pos += y_inc;

	button_group_pack->end();
	button_group->end();
	if(button_group_side == SIDE_RIGHT)
	{
		button_group->resize(w() - button_panel_sz, 0, button_panel_sz, h());
	}
	else if(button_group_side == SIDE_LEFT)
	{
		button_group->resize(0, 0, button_panel_sz, h());
	}
	if((initial_button_group_x > -1) && (initial_button_group_y > -1))
	{
		button_group->resize(initial_button_group_x, initial_button_group_y, button_group->w(), button_group->h());
	}
	button_group->hide();
	AdjustMainMenuHeight();
	HideButtons();
	ShowButtons();
}

void	MyWin::AdjustMainMenuHeight()
{
int	loop;

	int new_y = 10;
	for(loop = 0;loop < button_group_pack->children();loop++)
	{
		Fl_Widget *child = button_group_pack->child(loop);
		if(child != NULL)
		{
			child->resize(child->x(), new_y, child->w(), 22);
			child->labelsize(11);
			new_y += 22;
		}
	}
	int new_h = 40;
	int calced_height = CalcMenuHeight((MyGroup *)button_group_pack);
	while((calced_height > (h() - 120)) && (new_h > 10))
	{
		new_h--;
		int new_y = 10;
		for(loop = 0;loop < button_group_pack->children();loop++)
		{
			Fl_Widget *child = button_group_pack->child(loop);
			if(child != NULL)
			{
				child->resize(child->x(), new_y, child->w(), new_h);
				child->labelsize(new_h - 6);
				new_y += new_h;
			}
		}
		calced_height = CalcMenuHeight((MyGroup *)button_group_pack);
	}
}

void	MyWin::SelectCamera(char *name)
{
int		loop;

	int done = 0;
	for(loop = 0;((loop < source_cnt) && (done == 0));loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			char *use = NULL;
			char *alias = (char *)cam->alias;
			if(strlen(alias) > 0)
			{
				use = alias;
			}
			if(use == NULL)
			{
				use = cam->path;
			}
			if(use != NULL)
			{
				if(strcmp(use, name) == 0)
				{
					done = 1;
					DisplayCamera(cam);
				}
			}
		}
	}
}

void	MyWin::SelectPulseAudioButton(char *name)
{
void	pulse_audio_select_cb(Fl_Widget *w, void *v);
int		loop;

	int done = 0;
	for(loop = 0;((loop < audio_thumbnail_cnt) && (done == 0));loop++)
	{
		PulseAudioButton *pat = audio_thumbnail[loop];
		if(pat != NULL)
		{
			char *use = NULL;
			char *alias = (char *)pat->alias_button->label();
			if(alias != NULL)
			{
				if(strlen(alias) > 0)
				{
					use = alias;
				}
			}
			if(use == NULL)
			{
				use = pat->device_name;
			}
			if(use != NULL)
			{
				if(strcmp(use, name) == 0)
				{
					done = 1;
					pulse_audio_select_cb(NULL, pat);
					pat->select_button->value(1);
					if(pat->microphone != NULL)
					{
						pat->microphone->in_use = 1;
					}
				}
				else
				{
					if(pat->microphone != NULL)
					{
						pat->microphone->in_use = 0;
					}
				}
			}
		}
	}
}

void	MyWin::DisplayCamera(int index)
{
	Camera *cam = camera[index];
	if(cam != NULL)
	{
		DisplayCamera(cam);
	}
}

void	MyWin::DisplayCamera(Camera *cam)
{
int	loop;
int	inner;

	if(cam != NULL)
	{
		if(trigger_select_mode == 0)
		{
			if((single_stream == 1) || (muxing == 1))
			{
				if(displayed_source > -1)
				{
					last_cam = camera[displayed_source];
				}
			}
			displayed_source = cam->id;
			cam->ActivateBoundMics();
			alt_displayed_source = -1;
			if(single_stream == 1)
			{
				if(last_cam != NULL)
				{
					if(last_cam->recording == 1)
					{
						if(follow_mode == FOLLOW_MODE_RECORDING_FOLLOWS_DISPLAY)
						{
							cam->total_frames = last_cam->total_frames;
							last_cam->triggers_requested = 0;
							last_cam->recording = 0;
							cam->triggers_requested = 1;
							cam->recording = 1;
						}
					}
				}
			}
			if(ptz_mode == 1)
			{
				if(cam->ptz_lock_interface > -1)
				{
					for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
					{
						if(ptz_window[loop] != NULL)
						{
							if((ptz_window[loop]->bound_camera == NULL) || (ptz_window[loop]->bound_camera == cam))
							{
								ptz_window[loop]->ptz_interface_button->SetCurrent(cam->ptz_lock_interface);
								ptz_select_interface_cb(NULL, ptz_window[loop]);
								if(cam->ptz_lock_camera > -1)
								{
									Fl_Widget *wid = ptz_window[loop]->ptz_camera_select_button[cam->ptz_lock_camera];
									if(wid != NULL)
									{
										ptz_select_camera_cb(wid, ptz_window[loop]);
									}
								}
							}
						}
					}
				}
			}
		}
		else
		{
			if(cam != DisplayedCamera())
			{
				Camera *another = camera[displayed_source];
				if(another != NULL)
				{
					int bad = 0;
					for(inner = 0;inner < another->trigger_cnt;inner++)
					{
						if(another->trigger[inner] == cam->id)
						{
							bad = 1;
						}
					}
					if(bad == 0)
					{
						another->trigger[another->trigger_cnt] = cam->id;
						another->trigger_cnt++;
					}
				}
			}
		}
		ShowButtons();
	}
}

PulseAudioButton	*MyWin::AddAudioSource(int started_here, char *str, char *use_str)
{
int	loop;

	int nyy = 10;
	int nxx = (600) + (audio_thumbnail_cnt * 155);
	PulseAudioButton *at = new PulseAudioButton(this, str, audio_sample_rate, audio_channels, nxx, nyy, 150, 80, use_str);
	if(at->microphone != NULL)
	{
		int which = audio_thumbnail_cnt / 7;
		int done = -1;
		for(loop = 0;((loop < audio_thumbnail_cnt) && (done == -1));loop++)
		{
			if(audio_thumbnail[loop] == NULL)
			{
				done = loop;
			}
		}
		if(done == -1)
		{
			audio_thumbnail[audio_thumbnail_cnt] = at;
			audio_thumbnail_cnt++;
		}
		else
		{
			int nxx = (600) + (done * 155);
			at->resize(nxx, at->y(), at->w(), at->h());
			audio_thumbnail[done] = at;
		}
		if(which < 3)
		{
			Fl_Pack *pack = audio_thumbnail_pack[which];
			if(pack != NULL)
			{
				pack->add(at);
				int use_w = audio_thumbnail_pack[0]->children() * 160;
				audio_thumbnail_group->resize(audio_thumbnail_group->x(), audio_thumbnail_group->y(), use_w, (which + 1) * 81);
			}
		}
	}
	else
	{
		at->hide();
		Fl::delete_widget(at);
	}
	if(started_here == 1)
	{
		RunPulse(MODE_RECORD);
		RunPulse(MODE_PLAY);
	}
	return(at);
}

// SECTION ************************************** SLIDING ELEMENT **********************************************

void	sliding_element_open_cb(void *v)
{
	SlidingElement *se = (SlidingElement *)v;
	se->in_motion = 0;
	int speed = 10;
	if(se->direction == OPEN_LEFT)
	{
		if(se->x() > se->final)
		{
			se->in_motion = 1;
			int nn = se->x() - speed;
			if(nn < se->final)
			{
				nn = se->final;
			}
			se->resize(nn, se->y(), se->w(), se->h());
			Fl::repeat_timeout(0.001, sliding_element_open_cb, se);
		}
	}
	else if(se->direction == OPEN_RIGHT)
	{
		if(se->x() < se->final)
		{
			se->in_motion = 1;
			int nn = se->x() + speed;
			if(nn > se->final)
			{
				nn = se->final;
			}
			se->resize(nn, se->y(), se->w(), se->h());
			Fl::repeat_timeout(0.001, sliding_element_open_cb, se);
		}
	}
	if(se->direction == OPEN_UP)
	{
		if(se->y() > se->final)
		{
			se->in_motion = 1;
			int nn = se->y() - speed;
			if(nn < se->final)
			{
				nn = se->final;
			}
			se->resize(se->x(), nn, se->w(), se->h());
			Fl::repeat_timeout(0.001, sliding_element_open_cb, se);
		}
	}
	else if(se->direction == OPEN_DOWN)
	{
		if(se->y() < se->final)
		{
			se->in_motion = 1;
			int nn = se->y() + speed;
			if(nn > se->final)
			{
				nn = se->final;
			}
			se->resize(se->x(), nn, se->w(), se->h());
			Fl::repeat_timeout(0.001, sliding_element_open_cb, se);
		}
	}
}

void	sliding_element_close_cb(void *v)
{
	SlidingElement *se = (SlidingElement *)v;
	se->in_motion = 0;
	int speed = 10;
	if(se->direction == OPEN_LEFT)
	{
		if(se->x() < se->my_window->w())
		{
			se->in_motion = 1;
			int nn = se->x() + speed;
			if(nn > se->my_window->w())
			{
				nn = se->my_window->w();
			}
			se->resize(nn, se->y(), se->w(), se->h());
			Fl::repeat_timeout(0.001, sliding_element_close_cb, se);
		}
		else
		{
			se->resize(se->my_window->w() - se->w(), se->y(), se->w(), se->h());
			se->TrueHide();
		}
	}
	else if(se->direction == OPEN_RIGHT)
	{
		if(se->x() > -se->w())
		{
			se->in_motion = 1;
			int nn = se->x() - speed;
			if(nn < -se->w())
			{
				nn = -se->w();
			}
			se->resize(nn, se->y(), se->w(), se->h());
			Fl::repeat_timeout(0.001, sliding_element_close_cb, se);
		}
		else
		{
			se->resize(0, se->y(), se->w(), se->h());
			se->TrueHide();
		}
	}
	if(se->direction == OPEN_UP)
	{
		if(se->y() < se->my_window->h())
		{
			se->in_motion = 1;
			int nn = se->y() + speed;
			if(nn > se->my_window->h())
			{
				nn = se->my_window->h();
			}
			se->resize(se->x(), nn, se->w(), se->h());
			Fl::repeat_timeout(0.001, sliding_element_close_cb, se);
		}
		else
		{
			se->resize(se->x(), se->my_window->h() - se->h(), se->w(), se->h());
			se->TrueHide();
		}
	}
	else if(se->direction == OPEN_DOWN)
	{
		if(se->y() > -se->h())
		{
			se->in_motion = 1;
			int nn = se->y() - speed;
			if(nn < -se->h())
			{
				nn = -se->h();
			}
			se->resize(se->x(), nn, se->w(), se->h());
			Fl::repeat_timeout(0.001, sliding_element_close_cb, se);
		}
		else
		{
			se->resize(se->x(), 0, se->w(), se->h());
			se->TrueHide();
		}
	}
}

SlidingElement::SlidingElement(MyWin *in_win, int in_direction, int xx, int yy, int ww, int hh, char *lbl) : DragGroup(xx, yy, ww, hh, lbl)
{
	my_window = in_win;
	direction = in_direction;
	behavior = OPENING;
	final = 0;
	if(my_window->button_group_side == SIDE_LEFT)
	{
		if(direction == OPEN_LEFT) direction = OPEN_RIGHT;
		else if(direction == OPEN_RIGHT) direction = OPEN_LEFT;
	}
	in_motion = 0;
	animated = my_window->animate_panels;
}

SlidingElement::~SlidingElement()
{
}

void	SlidingElement::show()
{
	if(my_window->actively_loading == 0)
	{
		DragGroup::show();
		if(animated == 1)
		{
			behavior = OPENING;
			if(in_motion == 0)
			{
				if(direction == OPEN_RIGHT)
				{
					in_motion = 1;
					direction = OPEN_RIGHT;
					final = x();
					resize(-w(), y(), w(), h());
					Fl::add_timeout(0.01, sliding_element_open_cb, this);
				}
				else if(direction == OPEN_LEFT)
				{
					in_motion = 1;
					direction = OPEN_LEFT;
					final = x();
					resize(my_window->w(), y(), w(), h());
					Fl::add_timeout(0.01, sliding_element_open_cb, this);
				}
				else if(direction == OPEN_DOWN)
				{
					in_motion = 1;
					direction = OPEN_DOWN;
					final = y();
					resize(x(), -h(), w(), h());
					Fl::add_timeout(0.01, sliding_element_open_cb, this);
				}
				else if(direction == OPEN_UP)
				{
					in_motion = 1;
					direction = OPEN_UP;
					final = y();
					resize(x(), my_window->h(), w(), h());
					Fl::add_timeout(0.01, sliding_element_open_cb, this);
				}
			}
		}
	}
}

void	SlidingElement::hide()
{
	if(my_window->actively_loading == 0)
	{
		if(animated == 1)
		{
			behavior = CLOSING;
			if(in_motion == 0)
			{
				if(direction == OPEN_RIGHT)
				{
					in_motion = 1;
					direction = OPEN_RIGHT;
					Fl::add_timeout(0.01, sliding_element_close_cb, this);
				}
				else if(direction == OPEN_LEFT)
				{
					in_motion = 1;
					direction = OPEN_LEFT;
					Fl::add_timeout(0.01, sliding_element_close_cb, this);
				}
				else if(direction == OPEN_DOWN)
				{
					in_motion = 1;
					direction = OPEN_DOWN;
					Fl::add_timeout(0.01, sliding_element_close_cb, this);
				}
				else if(direction == OPEN_UP)
				{
					in_motion = 1;
					direction = OPEN_UP;
					Fl::add_timeout(0.01, sliding_element_close_cb, this);
				}
			}
		}
		else
		{
			DragGroup::hide();
		}
	}
}

void	SlidingElement::TrueHide()
{
	DragGroup::hide();
}

void	SlidingElement::TrueShow()
{
	DragGroup::show();
}

int	SlidingElement::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = DragGroup::handle(event);
	}
	return(flag);
}

// SECTION ************************************** SELECT AND EDIT OUTPUT WINDOWS **********************************************

void	set_output_repopulate_cb(void *v)
{
	EditOutputWindow *win = (EditOutputWindow *)v;
	win->Populate();
	win->redraw();
}

EditOutputWindow::EditOutputWindow(MyWin *in_win, int xx, int yy, int ww, int hh) : Dialog(xx, yy, ww, hh, "Edit Outputs")
{
void	hide_window_cb(Fl_Widget *w, void *v);

	my_window = in_win;
	last_x = 0;
	last_y = 0;
	my_window->LoadOutputPathList("outputs.txt");
	int cnt = my_window->output_path_cnt;

	int new_yp = 20;
	int y_pos = new_yp + 5;

	Fl_Box *box1 = new Fl_Box(2, y_pos, 50, 20, "Active");
	box1->color(BLACK);
	box1->labelsize(11);
	box1->labelcolor(YELLOW);
	box1->box(FL_FLAT_BOX);
	Fl_Box *box2 = new Fl_Box(60, y_pos, 120, 20, "Name");
	box2->color(BLACK);
	box2->labelsize(11);
	box2->labelcolor(YELLOW);
	box2->box(FL_FLAT_BOX);
	Fl_Box *box3 = new Fl_Box(180, y_pos, 516, 20, "Path/URL (sans extension)");
	box3->color(BLACK);
	box3->labelsize(11);
	box3->labelcolor(YELLOW);
	box3->box(FL_FLAT_BOX);
	y_pos += 22;

	scroll = new Fl_Scroll(2, y_pos, ww - 4, hh - 160);
	scroll->box(FL_FLAT_BOX);
	scroll->color(BLACK);
	scroll->type(Fl_Scroll::VERTICAL);
	scroll->hscrollbar.hide();
	scroll->end();
	pack = new Fl_Pack(0, y_pos, ww, hh);
	pack->box(FL_NO_BOX);
	pack->color(GRAY);
	pack->end();
	Populate();
	scroll->add(pack);

	Fl_Box *instruction = new Fl_Box(80, hh - 130, ww - 100, 100);
	instruction->box(FL_FLAT_BOX);
	instruction->color(BLACK);
	instruction->labelsize(9);
	instruction->labelcolor(WHITE);
	instruction->labelfont(FL_SCREEN);
	instruction->align(FL_ALIGN_TOP | FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	instruction->label(
		"Insert into the path:\n\n"
		"%home = home directory\t\t\t"
		"%cwd = current working directory\n"
		"%Y = current year\t\t\t"
		"%M = current month\t\t\t"
		"%D = current day\n"
		"%h = hour\t\t\t\t"
		"%m = minute\t\t\t\t"
		"%s = second\n"
		"%u = microsecond\t\t\t"
		"%U = millisecond\t\t\t"
		"%S = current time in seconds\n\n"
		"So: \"video_%Y_%M_%D_%h_%m_%s\" will produce \"video_2024_1_22_13_6_31.flv\" on January 22nd, 2024");

	MyButton *add = new MyButton(75, hh - 25, 80, 20, "Add");
	add->box(FL_NO_BOX);
	add->color(WHITE);
	add->labelcolor(YELLOW);
	add->labelsize(12);
	add->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	add->copy_tooltip("Add another output path");
	add->callback(set_output_add_cb, this);

	MyButton *accept = new MyButton(470, hh - 25, 80, 20, "Accept");
	accept->box(FL_NO_BOX);
	accept->color(WHITE);
	accept->labelcolor(YELLOW);
	accept->labelsize(12);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->copy_tooltip("Accept the current output paths and close");
	accept->callback(set_output_accept_cb, this);

	MyButton *cancel = new MyButton(540, hh - 25, 80, 20, "Cancel");
	cancel->box(FL_NO_BOX);
	cancel->color(WHITE);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(12);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->copy_tooltip("Cancel changes and close");
	cancel->callback(set_output_cancel_cb, this);
	end();
}

EditOutputWindow::~EditOutputWindow()
{
}

int	EditOutputWindow::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	EditOutputWindow::Debrief()
{
int	loop;

	my_window->ClearMuxerArray();
	int cnt = my_window->output_path_cnt;
	for(loop = 0;loop < cnt;loop++)
	{
		if(my_window->output_path[loop] != NULL)
		{
			free(my_window->output_path[loop]);
			my_window->output_path[loop] = NULL;
		}
	}
	int num = pack->children();
	cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		my_window->output_active[loop] = 0;
	}
	for(loop = 0;loop < num;loop++)
	{
		if(preset[loop] != NULL)
		{
			char *str = (char *)name[loop]->value();
			if(str != NULL)
			{
				if(strlen(str) > 0)
				{
					my_window->output_name[cnt] = strdup(str);
				}
			}
			str = (char *)preset[loop]->value();
			if(str != NULL)
			{
				if(strlen(str) > 0)
				{
					my_window->output_path[cnt] = strdup(str);
					my_window->output_active[cnt] = button[loop]->value();
					cnt++;
				}
			}
		}
	}
	my_window->output_path_cnt = cnt;
}

void	EditOutputWindow::Populate()
{
int	loop;
int	inner;

	pack->clear();
	int cnt = my_window->output_path_cnt;
	int y_pos = 5;
	for(loop = 0;loop < cnt;loop++)
	{
		MyGroup *grp = new MyGroup(0, y_pos, w(), 20);
		grp->box(FL_FLAT_BOX);
		grp->color(BLACK);
			button[loop] = new MyLightButton(15, y_pos, 20, 20);
			button[loop]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
			button[loop]->box(FL_FLAT_BOX);
			button[loop]->color(BLACK);
			button[loop]->down_color(YELLOW);
			button[loop]->labelcolor(YELLOW);
			button[loop]->value(0);
			button[loop]->copy_tooltip("Activate this output path");
			button[loop]->callback(set_output_select_cb, this);
			button[loop]->value(my_window->output_active[loop]);

			name[loop] = new Fl_Input(60, y_pos, 80, 20);
			name[loop]->color(BLACK);
			name[loop]->textcolor(WHITE);
			name[loop]->textsize(11);
			name[loop]->cursor_color(WHITE);
			name[loop]->labelcolor(YELLOW);
			name[loop]->labelsize(9);
			name[loop]->box(FL_FLAT_BOX);
			name[loop]->copy_tooltip("Edit the name of the output path");
			name[loop]->value(my_window->output_name[loop]);

			preset[loop] = new Fl_Input(181, y_pos, 520, 20);
			preset[loop]->color(BLACK);
			preset[loop]->textcolor(WHITE);
			preset[loop]->textsize(11);
			preset[loop]->cursor_color(WHITE);
			preset[loop]->labelcolor(YELLOW);
			preset[loop]->labelsize(9);
			preset[loop]->box(FL_FLAT_BOX);
			preset[loop]->value(my_window->output_path[loop]);
			preset[loop]->copy_tooltip("Edit the output path");
			preset[loop]->callback(set_output_rescan_cb, this);

			char out[4096];
			int	streaming = interpret_output_path(my_window, my_window->output_path[loop], out, NULL);
			if(streaming == STREAMING_NET)
			{
				preset[loop]->color(DARK_RED);
				preset[loop]->copy_label("URL:");
			}
			else if(streaming == STREAMING_NDI)
			{
				preset[loop]->color(DARK_BLUE);
				preset[loop]->copy_label("NDI:");
			}
			else
			{
				preset[loop]->copy_label("File:");
			}
		grp->end();
		pack->add(grp);
		y_pos += 22;
	}
}

void	EditOutputWindow::NDI_Exclusive(Fl_Widget *which)
{
int	loop;

	int go_ahead = 0;
	int cnt = my_window->output_path_cnt;
	for(loop = 0;((loop < cnt) && (go_ahead == 0));loop++)
	{
		if(button[loop] != NULL)
		{
			if(button[loop] == which)
			{
				if(preset[loop] != NULL)
				{
					char *str = (char *)preset[loop]->value();
					if(str != NULL)
					{
						go_ahead = test_for_ndi_path(str);
					}
				}
			}
		}
	}
	if(go_ahead == 1)
	{
		for(loop = 0;loop < cnt;loop++)
		{
			if(button[loop] != NULL)
			{
				if(button[loop] != which)
				{
					if(preset[loop] != NULL)
					{
						char *str = (char *)preset[loop]->value();
						if(str != NULL)
						{
							if(test_for_ndi_path(str))
							{
								button[loop]->value(0);
							}
						}
					}
				}
			}
		}
	}
}

SelectOutputWindow::SelectOutputWindow(MyWin *in_win, int xx, int yy, int ww, int hh) : Dialog(xx, yy, ww, hh, "Select Output")
{
void	hide_window_cb(Fl_Widget *w, void *v);

	my_window = in_win;
	last_x = 0;
	last_y = 0;
	int new_yp = 20;

	pack = new Fl_Pack(5, new_yp + 5, 120, hh - 60);
	pack->box(FL_FRAME);
	pack->color(GRAY);
	pack->end();

	close = new MyButton((w() / 2) - 30, y() - 25, 60, 20, "Close");
	close->box(FL_FLAT_BOX);
	close->color(BLACK);
	close->labelcolor(YELLOW);
	close->labelsize(11);
	close->copy_tooltip("Activate an output path");
	close->callback(hide_window_cb, this);

	end();
}

SelectOutputWindow::~SelectOutputWindow()
{
}

int	SelectOutputWindow::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	select_specific_output_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	SelectOutputWindow *here = (SelectOutputWindow *)w->window();
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		MyToggleButton *b = (MyToggleButton *)w;
		char *str = (char *)b->label();
		if(str != NULL)
		{
			int done = 0;
			for(loop = 0;((loop < win->output_path_cnt) && (done == 0));loop++)
			{
				if(strcmp(str, win->output_name[loop]) == 0)
				{
					win->output_active[loop] = b->value();
					reset_button_cb(NULL, win);
					done = 1;
				}
			}
		}
	}
	here->Populate();
	here->redraw();
}

void	SelectOutputWindow::Populate()
{
int	loop;

	pack->clear();
	int yp = 0;
	int test_all_ndi = 0;
	for(loop = 0;loop < my_window->output_path_cnt;loop++)
	{
		if(test_for_ndi_path(my_window->output_path[loop]))
		{
			if(my_window->output_active[loop] == 1)
			{
				test_all_ndi = 1;
			}
		}
	}
	for(loop = 0;loop < my_window->output_path_cnt;loop++)
	{
		int do_it = 1;
		if(test_all_ndi == 1)
		{
			if(test_for_ndi_path(my_window->output_path[loop]))
			{
				do_it = 0;
				if(my_window->output_active[loop] == 1)
				{
					do_it = 1;
				}
			}
		}
		if(do_it == 1)
		{
			MyToggleButton *button = new MyToggleButton(10, yp, 100, 18, my_window->output_name[loop]);
			button->color(BLACK);
			button->labelcolor(YELLOW);
			button->labelsize(9);
			button->box(FL_FLAT_BOX);
			button->value(my_window->output_active[loop]);
			button->down_color(DARK_BLUE);
			button->callback(select_specific_output_button_cb, my_window);
			pack->add(button);
			yp += 19;
		}
	}
	pack->resize(5, 22, 120, yp);
	resize(x(), y(), 130, yp + 50);
	close->resize(close->x(), h() - 25, close->w(), 20);
}

// SECTION ************************************** OBJECT MENU **********************************************

ObjectMenu::ObjectMenu(MyWin *in_win) : Dialog(360, 60, 600, 920, "Objects")
{
int		loop;
char	*sorted_list[1024];

	my_window = in_win;
	int new_yp = 20;
	int nxx = 10;
	int nyy = 10 + new_yp;
	Fl_Box *object_box = new Fl_Box(0, 0, 600, 920);
	object_box->box(FL_FRAME_BOX);
	object_box->color(BLACK);
	object_box->hide();
	for(loop = 0;loop < my_window->recognize_class_cnt;loop++)
	{
		sorted_list[loop] = my_window->recognize_class_name[loop];
	}
	object_page = 0;
	qsort(sorted_list, my_window->recognize_class_cnt, sizeof(char *), cmpstringp);
	for(loop = 0;loop < my_window->recognize_class_cnt;loop++)
	{
		object_name_button[loop] = new MyButton(nxx, nyy, 200, 16);
		object_name_button[loop]->copy_label(sorted_list[loop]);
		object_name_button[loop]->box(FL_NO_BOX);
		object_name_button[loop]->color(BLACK);
		object_name_button[loop]->labelcolor(YELLOW);
		object_name_button[loop]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		object_name_button[loop]->callback(select_objects_cb, my_window);
		object_name_button[loop]->labelsize(11);
		object_name_button[loop]->hide();
		nyy += 17;
		if(nyy > 890)
		{
			nyy = 10 + new_yp;
			nxx += 200;
			if(nxx > 700)
			{
				nxx = 300;
			}
		}
	}
	Fl_Box *box = new Fl_Box(w() - 190, 15 + new_yp, 180, 130);
	box->color(DARK_GRAY);
	box->box(FL_FRAME_BOX);

	int yp = 25 + new_yp;
	object_clear_button = new MyButton(w() - 180, yp, 120, 20, "Clear");
	object_clear_button->box(FL_NO_BOX);
	object_clear_button->color(BLACK);
	object_clear_button->labelcolor(YELLOW);
	object_clear_button->labelsize(11);
	object_clear_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_clear_button->callback(clear_select_objects_cb, my_window);
	object_clear_button->hide();
	yp += 22;

	object_all_button = new MyButton(w() - 180, yp, 120, 20, "Select All");
	object_all_button->box(FL_NO_BOX);
	object_all_button->color(BLACK);
	object_all_button->labelcolor(YELLOW);
	object_all_button->labelsize(11);
	object_all_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_all_button->callback(select_all_objects_cb, my_window);
	object_all_button->hide();
	yp += 22;

	object_apply_all_button = new MyButton(w() - 180, yp, 120, 20, "Apply to All Cameras");
	object_apply_all_button->box(FL_NO_BOX);
	object_apply_all_button->color(BLACK);
	object_apply_all_button->labelcolor(YELLOW);
	object_apply_all_button->labelsize(11);
	object_apply_all_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_apply_all_button->callback(apply_all_select_objects_cb, my_window);
	object_apply_all_button->hide();
	yp += 22;

	object_done_button = new MyButton(w() - 180, yp, 120, 20, "Done");
	object_done_button->box(FL_NO_BOX);
	object_done_button->color(BLACK);
	object_done_button->labelcolor(YELLOW);
	object_done_button->labelsize(11);
	object_done_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_done_button->callback(done_select_objects_cb, my_window);
	object_done_button->hide();
	yp += 22;

	object_next_button = new MyButton(w() - 180, yp, 120, 20, "Next Page");
	object_next_button->box(FL_NO_BOX);
	object_next_button->color(BLACK);
	object_next_button->labelcolor(YELLOW);
	object_next_button->labelsize(11);
	object_next_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_next_button->callback(next_page_objects_cb, this);
	object_next_button->hide();
	yp += 22;

	object_prev_button = new MyButton(w() - 180, yp, 180, 20, "Prev Page");
	object_prev_button->box(FL_NO_BOX);
	object_prev_button->color(BLACK);
	object_prev_button->labelcolor(YELLOW);
	object_prev_button->labelsize(11);
	object_prev_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_prev_button->callback(prev_page_objects_cb, this);
	object_prev_button->hide();
	end();
}

void	json_get_colors(cJSON *json, char *color_name, uchar& red, uchar& green, uchar& blue)
{
	cJSON *item = NULL;
	cJSON *items = json_parse_array(json, color_name);
	if(items != NULL)
	{
		int cnt = 0;
		cJSON_ArrayForEach(item, items)
		{
			if(cnt == 0)
			{
				red = (uchar)item->valueint;
			}
			else if(cnt == 1)
			{
				green = (uchar)item->valueint;
			}
			else if(cnt == 2)
			{
				blue = (uchar)item->valueint;
			}
			cnt++;
		}
	}
}

void	MyWin::ReadGUISettings()
{
int			loop;

	char *buf = ReadWholeFile("GUI_settings.json");
	if(buf != NULL)
	{
		cJSON *json = cJSON_Parse(buf);
		if(json == NULL)
		{
			const char *error_ptr = cJSON_GetErrorPtr();
			if(error_ptr != NULL)
			{
				fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
			}
		}
		else
		{
			int success = json_parse_int(json, "hide status", hide_status);
			success = json_parse_int(json, "retain commands", retain_commands);
			success = json_parse_int(json, "retain cameras", retain_cameras);
			success = json_parse_int(json, "retain audio", retain_audio);
			success = json_parse_int(json, "retain ptz", retain_ptz);
			success = json_parse_int(json, "button group side", button_group_side);
			success = json_parse_int(json, "transparent interface", transparent_interface);
			success = json_parse_int(json, "animate panels", animate_panels);
			success = json_parse_int(json, "exclude directories", file_selector_exclude_directories);
			success = json_parse_int(json, "use tooltips", use_tooltips);
			if(use_tooltips == 1)
			{
				Fl_Tooltip::enable();
			}
			else
			{
				Fl_Tooltip::disable();
			}
			success = json_parse_int(json, "initial button group x", initial_button_group_x);
			success = json_parse_int(json, "initial button group y", initial_button_group_y);
			success = json_parse_int(json, "initial thumbnail group x", initial_thumbnail_group_x);
			success = json_parse_int(json, "initial thumbnail group y", initial_thumbnail_group_y);
			success = json_parse_int(json, "initial audio thumbnail group x", initial_audio_thumbnail_group_x);
			success = json_parse_int(json, "initial audio thumbnail group y", initial_audio_thumbnail_group_y);
			success = json_parse_int(json, "initial current fps x", initial_current_fps_x);
			success = json_parse_int(json, "initial current fps y", initial_current_fps_y);
			success = json_parse_int(json, "initial video out x", initial_video_out_x);
			success = json_parse_int(json, "initial video out y", initial_video_out_y);
			cJSON *item = NULL;
			cJSON *items = json_parse_array(json, "PTZ Window Position");
			if(items != NULL)
			{
				int cnt = 0;
				int a_cnt = 0;
				cJSON_ArrayForEach(item, items)
				{
					if((cnt % 2) == 0)
					{
						initial_ptz_x[a_cnt] = item->valueint;
					}
					else
					{
						initial_ptz_y[a_cnt] = item->valueint;
						a_cnt++;
					}
					cnt++;
				}
			}
			success = json_parse_int(json, "status color r", status_color_r);
			success = json_parse_int(json, "status color g", status_color_g);
			success = json_parse_int(json, "status color b", status_color_b);
			uchar red, green, blue;
			json_get_colors(json, "color black", red, green, blue);
			Fl::set_color(BLACK, red, green, blue);
			json_get_colors(json, "color white", red, green, blue);
			Fl::set_color(WHITE, red, green, blue);
			json_get_colors(json, "color yellow", red, green, blue);
			Fl::set_color(YELLOW, red, green, blue);
			json_get_colors(json, "color gray", red, green, blue);
			Fl::set_color(GRAY, red, green, blue);
			json_get_colors(json, "color dark gray", red, green, blue);
			Fl::set_color(DARK_GRAY, red, green, blue);
			json_get_colors(json, "color red", red, green, blue);
			Fl::set_color(RED, red, green, blue);
			json_get_colors(json, "color dark red", red, green, blue);
			Fl::set_color(DARK_RED, red, green, blue);
			json_get_colors(json, "color blue", red, green, blue);
			Fl::set_color(BLUE, red, green, blue);
			json_get_colors(json, "color dark blue", red, green, blue);
			Fl::set_color(DARK_BLUE, red, green, blue);
			json_get_colors(json, "color cyan", red, green, blue);
			Fl::set_color(CYAN, red, green, blue);

			char *str = json_parse_string(json, "font");
			if(str != NULL)
			{
				Fl::set_font(FL_HELVETICA, strdup(str));
			}
			cJSON_Delete(json);
		}
		free(buf);
	}
}

// SECTION ************************************** IMMEDIATE DRAWING **********************************************

void	draw_all(Camera *cam, int xx, int yy, int ww, int hh, int red, int green, int blue, int alpha, double angle, double scale_x, double scale_y, int clip_x, int clip_y, int clip_w, int clip_h)
{
	if(cam->cairo_context != NULL)
	{
		int half_w = (ww / 2);
		int half_h = (hh / 2);
		int nx = xx + half_w;
		int ny = yy + half_h;
		cairo_t *cr = cam->cairo_context;
		cairo_save(cr);
		if((clip_w > 0) && (clip_h > 0))
		{
			cairo_rectangle(cr, clip_x, clip_y, clip_w, clip_h);
			cairo_clip(cr);
		}
		cairo_translate(cr, nx, ny);
		cairo_rotate(cr, angle);
		cairo_scale(cr, scale_x, scale_y);
		my_cairo_set_source_rgba(cr, red, green, blue, alpha);
		cairo_rectangle(cr, -half_w, -half_h, ww, hh);
		cairo_fill(cr);
		cairo_restore(cr);
	}
}

ImDefault::ImDefault()
{
	my_window = NULL;
	my_immediate = NULL;
	cnt = 0;
	xx = NULL;
	yy = NULL;
	pt_type = NULL;
	strcpy(font_name, "Sans");
	strcpy(image_file_path, "");
	strcpy(freehand_filename, "");
}

ImDefault::~ImDefault()
{
}

void	ImDefault::SetToDialog()
{
	if(my_immediate != NULL)
	{
		if(my_immediate->idw != NULL)
		{
			ImmediateDrawingWindow *idw = my_immediate->idw;

			if((idw->mode == DRAWING_MODE_RECTANGLE)
			|| (idw->mode == DRAWING_MODE_ELLIPSE))
			{
				width = idw->rectangle_size;
				red = idw->rectangle_color_red;
				green = idw->rectangle_color_green;
				blue = idw->rectangle_color_blue;
				alpha = idw->rectangle_color_alpha;
				style = idw->rectangle_style;
				filled = idw->rectangle_filled;
				square = idw->rectangle_square;
				erase = idw->rectangle_erase;
			}
			else
			{
				red = idw->line_color_red;
				green = idw->line_color_green;
				blue = idw->line_color_blue;
				alpha = idw->line_color_alpha;
			}
			background_red = idw->back_color_red;
			background_green = idw->back_color_green;
			background_blue = idw->back_color_blue;
			background_alpha = idw->back_color_alpha;

			if(idw->freehand_shape_square_button->value()) shape = FREEHAND_SHAPE_SQUARE;
			if(idw->freehand_shape_circle_button->value()) shape = FREEHAND_SHAPE_CIRCLE;
			if(idw->freehand_shape_erase_square_button->value()) shape = FREEHAND_SHAPE_ERASE_SQUARE;
			if(idw->freehand_shape_erase_circle_button->value()) shape = FREEHAND_SHAPE_ERASE_CIRCLE;
			if(idw->freehand_shape_stamp_button->value()) shape = FREEHAND_SHAPE_STAMP;
			if(idw->freehand_shape_key_button->value()) shape = FREEHAND_SHAPE_KEY;

			box_type = idw->text_box_type;
			italic = idw->text_italic_button->value();
			bold = idw->text_bold_button->value();
			outline = idw->text_outline_button->value();
			font_alpha = idw->font_color_alpha;
			background_alpha = idw->back_color_alpha;
			outline_alpha = idw->outline_color_alpha;

			strcpy(font_name, idw->selected_font);
			if(strlen(font_name) < 1)
			{
				strcpy(font_name, "Sans");
			}
			char *filename = (char *)idw->image_file_path->value();
			if(filename != NULL)
			{
				strcpy(image_file_path, filename);
			}
		}
	}
}

void	ImDefault::Copy(Immediate *in_im, ImDefault *source)
{
	my_window = source->my_window;
	my_immediate = in_im;
	width = source->width;
	red = source->red;
	green = source->green;
	blue = source->blue;
	alpha = source->alpha;
	style = source->style;
	shape = source->shape;
	use_size = source->use_size;
	filled = source->filled;
	square = source->square;
	selecting = source->selecting;
	erase = source->erase;
	box_type = source->box_type;

	xx = NULL;
	yy = NULL;
	pt_type = NULL;
	cnt = source->cnt;
	if(cnt > 0)
	{
		if((source->xx != NULL) && (source->yy != NULL) && (source->pt_type != NULL))
		{
			xx = (int *)malloc(cnt * sizeof(int));
			memcpy(xx, source->xx, cnt * sizeof(int));
			yy = (int *)malloc(cnt * sizeof(int));
			memcpy(yy, source->yy, cnt * sizeof(int));
			pt_type = (int *)malloc(cnt * sizeof(int));
			memcpy(pt_type, source->pt_type, cnt * sizeof(int));
		}
		else
		{
			cnt = 0;
		}
	}
	key = source->key;

	freehand_mat = source->freehand_mat.clone();
	my_mat = source->my_mat.clone();

	italic = source->italic;
	bold = source->bold;
	outline = source->outline;
	font_alpha = source->font_alpha;
	background_alpha = source->background_alpha;
	outline_alpha = source->outline_alpha;
}

ImRectangle::ImRectangle(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	end();
	my_window = in_win;
	my_immediate = in_im;
	width = 1;
	red = 255;
	green = 255;
	blue = 255;
	style = 0;
	filled = 0;
	square = 0;
	erase = 0;
	SetToDialog();
}

ImRectangle::~ImRectangle()
{
}

void	ImRectangle::draw()
{
	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		cairo_t *cr = cam->cairo_context;
		int sx = my_immediate->relative_x;
		int sy = my_immediate->relative_y;
		int sw = w();
		int sh = h();
		int use_w = sw;
		int use_h = sh;

		if(erase == 1)
		{
			int sw = w() * my_immediate->scale_w;
			int sh = h() * my_immediate->scale_h;
			rectangle(cam->mat, Point(sx, sy), Point(sx + sw, sy + sh), Vec4b(0, 0, 0, 0), cv::FILLED);
		}
		else
		{
			my_cairo_set_line_style(cr, style, width);
			double scale_w = my_immediate->scale_w;
			double scale_h = my_immediate->scale_h;
			cairo_save(cr);
			if((my_immediate->crop_w > 0) && (my_immediate->crop_h > 0))
			{
				int crop_x = sx + my_immediate->crop_x;
				int crop_y = sy + my_immediate->crop_y;
				int crop_w = my_immediate->crop_w;
				int crop_h = my_immediate->crop_h;
				cairo_rectangle(cr, crop_x, crop_y, crop_w, crop_h);
				cairo_clip(cr);
			}
			int use_alpha = (int)((double)alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cr, red, green, blue, use_alpha);
			cairo_translate(cr, sx + (sw / 2), sy + (sh / 2));
			cairo_scale(cr, scale_w, scale_h);
			cairo_rotate(cr, my_immediate->angle);
			if(square == 1)
			{
				use_w = sw;
				use_h = sw;
			}
			cairo_rectangle(cr, -(sw / 2), -(sh / 2), use_w, use_h);
			if(filled == 0)
			{
				cairo_stroke(cr);
			}
			else
			{
				cairo_fill(cr);
			}
			cairo_restore(cr);
		}
		my_immediate->resize(sx + cam->image_sx, sy + cam->image_sy, use_w, use_h);
	}
}

ImPixelate::ImPixelate(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	end();
	my_window = in_win;
	my_immediate = in_im;
	use_size = 10;
	style = PIXELATE_MODE_PIXELATE;
	SetToDialog();
}

ImPixelate::~ImPixelate()
{
}

void	ImPixelate::resize(int xx, int yy, int ww, int hh)
{
	Fl_Group::resize(xx, yy, ww, hh);
}

void	ImPixelate::draw()
{
int	xx, yy;

	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		int sx = my_immediate->relative_x;
		int sy = my_immediate->relative_y;
		int sw = w() * my_immediate->scale_w;
		int sh = h() * my_immediate->scale_h;
		cairo_t *cr = cam->cairo_context;
		if(style == PIXELATE_MODE_PIXELATE)
		{
			Mat use = cam->mat.clone();
			cvtColor(use, use, COLOR_RGBA2RGB);
			int nx1 = (sx + sw);
			int ny1 = (sy + sh);
			if(use_size < 2) use_size = 2;
			int ux = sw / use_size;
			int uy = sh / use_size;
			if(ux < 2) ux = 2;
			if(uy < 2) uy = 2;
			cairo_save(cr);
			if((my_immediate->crop_w > 0) && (my_immediate->crop_h > 0))
			{
				int crop_x = sx + my_immediate->crop_x;
				int crop_y = sy + my_immediate->crop_y;
				int crop_w = my_immediate->crop_w;
				int crop_h = my_immediate->crop_h;
				cairo_rectangle(cr, crop_x, crop_y, crop_w, crop_h);
				cairo_clip(cr);
			}
			cairo_translate(cr, sx + (sw / 2), sy + (sh / 2));
			cairo_rotate(cr, my_immediate->angle);
			cairo_translate(cr, -(sw / 2), -(sh / 2));
			for(yy = 0;yy + uy < sh;yy += uy)
			{
				for(xx = 0;xx + ux < sw;xx += ux)
				{
					int nx = sx + xx;
					int ny = sy + yy;
					Vec3b colour = use.at<Vec3b>(Point(nx, ny));
					int r = colour[0];
					int g = colour[1];
					int b = colour[2];
					my_cairo_set_source_rgb(cr, r, g, b);
					cairo_rectangle(cr, xx, yy, ux, uy);
					cairo_fill(cr);
				}
			}
			cairo_restore(cr);
		}
		else if(style == PIXELATE_MODE_BLUR)
		{
			if((w() > 0) && (h() > 0))
			{
				Mat mat;
				int nx = sx;
				int ny = sy;
				if((nx > 0) && (ny >= 0))
				{
					crop_section(cam->mat, mat, nx, ny, sw, sh);
					blur(mat, mat, Size(use_size, use_size));
					cairo_save(cam->cairo_context);
					if((my_immediate->crop_w > 0) && (my_immediate->crop_h > 0))
					{
						int crop_x = sx + my_immediate->crop_x;
						int crop_y = sy + my_immediate->crop_y;
						int crop_w = my_immediate->crop_w;
						int crop_h = my_immediate->crop_h;
						cairo_rectangle(cam->cairo_context, crop_x, crop_y, crop_w, crop_h);
						cairo_clip(cam->cairo_context);
					}
					cairo_surface_t *surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
					if(surface != NULL)
					{
						cairo_translate(cr, sx + (sw / 2), sy + (sh / 2));
						cairo_rotate(cr, my_immediate->angle);
						cairo_translate(cr, -(sw / 2), -(sh / 2));
						cairo_set_source_surface(cr, surface, 0, 0);
						cairo_paint(cr);
						cairo_surface_destroy(surface);
					}
					cairo_restore(cam->cairo_context);
				}
			}
		}
		my_immediate->resize(sx + cam->image_sx, sy + cam->image_sy, w(), h());
	}
}

ImRectanglePassThru::ImRectanglePassThru(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	end();
	my_window = in_win;
	my_immediate = in_im;
	selecting = 0;
	SetToDialog();
}

ImRectanglePassThru::~ImRectanglePassThru()
{
}

void	ImRectanglePassThru::draw()
{
	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		cairo_t *cr = cam->cairo_context;
		fl_color(WHITE);
		fl_rect(x(), y(), w(), h());
		if((w() > 0) && (h() > 0))
		{
			int sx = my_immediate->relative_x;
			int sy = my_immediate->relative_y;
			int sw = w();
			int sh = h();
			Mat use;
			Mat mat;
			cv::resize(cam->reserve_mat, use, cv::Size(cam->mat.cols, cam->mat.rows));
			crop_section(use, mat, sx, sy, w(), h());
			cairo_save(cam->cairo_context);
			if((my_immediate->crop_w > 0) && (my_immediate->crop_h > 0))
			{
				int crop_x = sx + my_immediate->crop_x;
				int crop_y = sy + my_immediate->crop_y;
				int crop_w = my_immediate->crop_w;
				int crop_h = my_immediate->crop_h;
				cairo_rectangle(cam->cairo_context, crop_x, crop_y, crop_w, crop_h);
				cairo_clip(cam->cairo_context);
			}
			double scale_w = my_immediate->scale_w;
			double scale_h = my_immediate->scale_h;
			cairo_translate(cr, sx + (sw / 2), sy + (sh / 2));
			cairo_scale(cr, scale_w, scale_h);
			cairo_rotate(cr, my_immediate->angle);
			cairo_surface_t *surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
			if(surface != NULL)
			{
				cairo_set_source_surface(cr, surface, -(sw / 2), -(sh / 2));
				cairo_paint(cr);
				cairo_surface_destroy(surface);
			}
			cairo_restore(cam->cairo_context);
			my_immediate->resize(sx + cam->image_sx, sy + cam->image_sy, w(), h());
		}
	}
}

ImImage::ImImage(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	end();
	my_window = in_win;
	my_immediate = in_im;
	if((in_im->idw->image_mat.rows > 0) && (in_im->idw->image_mat.cols > 0) && (!in_im->idw->image_mat.empty()))
	{
		if(in_im->idw->from_paste == 0)
		{
			char *filename = (char *)in_im->idw->image_file_path->value();
			strcpy(image_file_path, filename);
		}
		else
		{
			my_mat = in_im->idw->image_mat.clone();
		}
	}
	SetToDialog();
}

ImImage::~ImImage()
{
}

void	ImImage::draw()
{
	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		cairo_t *cr = cam->cairo_context;
		Mat local_mat;
		if(my_mat.empty())
		{
			my_mat = imread(image_file_path);
			if(!my_mat.empty())
			{
				cvtColor(my_mat, my_mat, COLOR_BGR2RGBA);
			}
		}
		if(!my_mat.empty())
		{
			if((my_mat.rows > 0) && (my_mat.cols > 0))
			{
				int xx = my_immediate->relative_x;
				int yy = my_immediate->relative_y;
				int ww = w();
				int hh = h();
				if((ww > 0) && (hh > 0))
				{
					int orig_w = my_mat.cols;
					int orig_h = my_mat.rows;
					double scale = (double)ww / orig_w;
					int nw = orig_w * scale;
					int nh = orig_h * scale;
					if((nw > 0) && (nh > 0))
					{
						cairo_save(cam->cairo_context);
						cv::resize(my_mat, local_mat, cv::Size(nw, nh));
						cairo_surface_t *surface = cairo_image_surface_create_for_data(local_mat.ptr(), CAIRO_FORMAT_ARGB32, local_mat.cols, local_mat.rows, local_mat.step);
						if(surface != NULL)
						{
							if((my_immediate->crop_w > 0) && (my_immediate->crop_h > 0))
							{
								int crop_x = xx + my_immediate->crop_x;
								int crop_y = yy + my_immediate->crop_y;
								int crop_w = my_immediate->crop_w;
								int crop_h = my_immediate->crop_h;
								cairo_rectangle(cam->cairo_context, crop_x, crop_y, crop_w, crop_h);
								cairo_clip(cam->cairo_context);
							}
							cairo_translate(cr, xx + (nw / 2), yy + (nh / 2));
							cairo_rotate(cr, my_immediate->angle);
							cairo_set_source_surface(cr, surface, -(nw / 2), -(nh / 2));
							cairo_paint(cr);
							cairo_surface_destroy(surface);
						}
						cairo_restore(cam->cairo_context);
					}
				}
				my_immediate->resize(xx + cam->image_sx, yy + cam->image_sy, w(), h());
			}
		}
	}
}

ImEllipse::ImEllipse(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	end();
	my_window = in_win;
	my_immediate = in_im;
	width = 1;
	red = 255;
	green = 255;
	blue = 255;
	style = 0;
	filled = 0;
	square = 0;
	erase = 0;
	SetToDialog();
}

ImEllipse::~ImEllipse()
{
}

void	ImEllipse::draw()
{
	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		int sx = my_immediate->relative_x;
		int sy = my_immediate->relative_y;
		int sw = w() * my_immediate->scale_w;
		int sh = h() * my_immediate->scale_h;
		if(erase == 1)
		{
			double cx = sx + (w() / 2.0);
			double cy = sy + (h() / 2.0);
			ellipse(cam->mat, Point(cx, cy), Size(sw / 2.0, sh / 2.0), 0, 0, 360, Scalar(0, 0, 0, 0), -1, LINE_AA);
		}
		else
		{
			cairo_t *cr = cam->cairo_context;
			cairo_save(cr);
			if((my_immediate->crop_w > 0) && (my_immediate->crop_h > 0))
			{
				int crop_x = sx + my_immediate->crop_x;
				int crop_y = sy + my_immediate->crop_y;
				int crop_w = my_immediate->crop_w;
				int crop_h = my_immediate->crop_h;
				cairo_rectangle(cam->cairo_context, crop_x, crop_y, crop_w, crop_h);
				cairo_clip(cam->cairo_context);
			}
			int use_alpha = (int)((double)alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cr, red, green, blue, use_alpha);
			double cx = (double)(sx + (sw / 2.0));
			double cy = (double)(sy + (sh / 2.0));
			if(square == 1)
			{
				cx = (double)(sx + (sw / 2.0));
				cy = (double)(sy + (sw / 2.0));
			}
			cairo_matrix_t save_matrix;
			cairo_get_matrix(cr, &save_matrix);
			cairo_translate(cr, cx, cy);
			cairo_rotate(cr, my_immediate->angle);
			double sy = 1.0;
			if(square == 0)
			{
				if(sw > 0)
				{
					sy = (double)sh / (double)sw;
				}
			}
			cairo_scale(cr, 1.0, sy);
			cairo_arc(cr, 0, 0, sw / 2.0, 0.0, 2 * M_PI);
			cairo_set_matrix(cr, &save_matrix);
			my_cairo_set_line_style(cam->cairo_context, style, width);
			if(filled == 0)
			{
				cairo_stroke(cr);
			}
			else
			{
				cairo_fill(cr);
			}
			cairo_restore(cr);
		}
		if(square == 0)
		{
			my_immediate->resize(sx + cam->image_sx, sy + cam->image_sy, w(), h());
		}
		else
		{
			my_immediate->resize(sx + cam->image_sx, sy + cam->image_sy, w(), w());
		}
	}
}

ImEllipsePassThru::ImEllipsePassThru(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	end();
	my_window = in_win;
	my_immediate = in_im;
	width = 1;
	red = 255;
	green = 255;
	blue = 255;
	style = 0;
	filled = 0;
	square = 0;
	erase = 0;
	SetToDialog();
}

ImEllipsePassThru::~ImEllipsePassThru()
{
}

void	ImEllipsePassThru::draw()
{
	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		fl_color(WHITE);
		fl_rect(x(), y(), w(), h());
		int sx = my_immediate->relative_x;
		int sy = my_immediate->relative_y;
		int sw = w() * my_immediate->scale_w;
		int sh = h() * my_immediate->scale_h;
		Mat use;
		cv::resize(cam->reserve_mat, use, cv::Size(cam->mat.cols, cam->mat.rows));
		cv::Mat mask(use.rows, use.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
		double cx = sx + (w() / 2.0);
		double cy = sy + (h() / 2.0);
		ellipse(mask, Point(cx, cy), Size(sw / 2.0, sh / 2.0), 0, 0, 360, Scalar(255, 255, 255, 255), -1, LINE_AA);
		Mat out;
		mask_mats(use, mask, out);
		cairo_save(cam->cairo_context);
		if((my_immediate->crop_w > 0) && (my_immediate->crop_h > 0))
		{
			int crop_x = sx + my_immediate->crop_x;
			int crop_y = sy + my_immediate->crop_y;
			int crop_w = my_immediate->crop_w;
			int crop_h = my_immediate->crop_h;
			cairo_rectangle(cam->cairo_context, crop_x, crop_y, crop_w, crop_h);
			cairo_clip(cam->cairo_context);
		}
		cairo_translate(cam->cairo_context, cx, cy);
		cairo_rotate(cam->cairo_context, my_immediate->angle);
		cairo_surface_t *surface = cairo_image_surface_create_for_data(out.ptr(), CAIRO_FORMAT_ARGB32, out.cols, out.rows, out.step);
		if((surface != NULL) && (cam->cairo_surface != NULL))
		{
			cairo_set_source_surface(cam->cairo_context, surface, -cx, -cy);
			cairo_paint(cam->cairo_context);
			cairo_surface_destroy(surface);
		}
		cairo_restore(cam->cairo_context);
		my_immediate->resize(sx + cam->image_sx, sy + cam->image_sy, w(), h());
	}
}

ImFreehand::ImFreehand(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	end();
	my_window = in_win;
	my_immediate = in_im;
	width = 1;
	red = 255;
	green = 255;
	blue = 255;
	style = 0;
	SetToDialog();
}

ImFreehand::~ImFreehand()
{
}

void	ImFreehand::draw()
{
	fl_color(fl_rgb_color(red, green, blue));
}

ImLine::ImLine(MyWin *in_win, Immediate *in_im, int in_type, int in_x, int in_y, int ww, int hh) : MyGroup(in_x, in_y, ww, hh)
{
	end();
	my_window = in_win;
	my_immediate = in_im;
	cnt = 0;
	width = 1;
	red = 255;
	green = 255;
	blue = 255;
	alpha = 255;
	style = 0;
	xx = NULL;
	yy = NULL;
	pt_type = NULL;
	erase = 0;
	extent_x1 = 0;
	extent_y1 = 0;
	extent_x2 = 0;
	extent_y2 = 0;
	SetToDialog();
	shape = in_type;
}

ImLine::~ImLine()
{
	if(xx != NULL)
	{
		free(xx);
		xx = NULL;
	}
	if(yy != NULL)
	{
		free(yy);
		yy = NULL;
	}
	if(pt_type != NULL)
	{
		free(pt_type);
		pt_type = NULL;
	}
	cnt = 0;
}

void	ImLine::resize(int in_xx, int in_yy, int in_ww, int in_hh)
{
	Extent();
	int old_x = x();
	int old_y = y();
	Fl_Group::resize(in_xx, in_yy, in_ww, in_hh);
	if(my_immediate->actively_drawing == 0)
	{
		int dx = in_xx - old_x;
		int dy = in_yy - old_y;
		if((xx != NULL) && (yy != NULL))
		{
			xx[0] += dx;
			yy[0] += dy;
		}
		Extent();
	}
}

void	ImLine::Revise(int in_x, int in_y)
{
int	loop;

	for(loop = 0;loop < cnt;loop++)
	{
		xx[loop] -= in_x;
		yy[loop] -= in_y;
		if(my_immediate->idw->grid_size > 1)
		{
			xx[loop] = force_to_grid(my_immediate->idw->grid_size, xx[loop] - my_immediate->my_camera->image_sx);
			yy[loop] = force_to_grid2(my_immediate->idw->grid_size, yy[loop] - my_immediate->my_camera->image_sy);
			xx[loop] += my_immediate->my_camera->image_sx;
			yy[loop] += my_immediate->my_camera->image_sy;
		}
	}
}

void	ImLine::AddPoint(int in_x, int in_y)
{
	xx = (int *)realloc(xx, sizeof(int) * (cnt + 1));
	yy = (int *)realloc(yy, sizeof(int) * (cnt + 1));
	pt_type = (int *)realloc(pt_type, sizeof(int) * (cnt + 1));
	if((xx != NULL) && (yy != NULL))
	{
		if(cnt > 0)
		{
			in_x -= xx[0];
			in_y -= yy[0];
		}
		xx[cnt] = in_x;
		yy[cnt] = in_y;
		pt_type[cnt] = 0;
		if((style & MY_TYPE_CURVES) == MY_TYPE_CURVES)
		{
			pt_type[cnt] = POINT_TYPE_CURVE;
		}
		cnt++;
	}
}

void	ImLine::ImageLine(cairo_t *cr, int x0, int y0, int x1, int y1, int in_sz)
{
int	xx, yy;

	int dx = abs(x1 - x0);
	int sx = x0 < x1 ? 1 : -1;
	int dy = abs(y1 - y0);
	int sy = y0 < y1 ? 1 : -1;
	int err = (dx > dy ? dx : -dy) / 2;
	int e2;
	int sz = (in_sz / 2) + 1;
	if(sz < 1)
	{
		sz = 1;
	}
	for(;;)
	{
		if(sz > 1)
		{
			for(yy = -sz;yy < sz;yy++)
			{
				for(xx = -sz;xx < sz;xx++)
				{
					DoStamp(cr, x0 + xx, y0 + yy);
				}
			}
		}
		else
		{
			DoStamp(cr, x0, y0);
		}
		if((x0 == x1) && (y0 == y1))
		{
			break;
		}
		e2 = err;
		if(e2 > -dx)
		{
			err -= dy;
			x0 += sx;
		}
		if(e2 < dy)
		{
			err += dx;
			y0 += sy;
		}
	}
}

void	ImLine::draw()
{
int		loop;

	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		int sx = my_immediate->relative_x;
		int sy = my_immediate->relative_y;
		int sw = w() * my_immediate->scale_w;
		int sh = h() * my_immediate->scale_h;
		cairo_save(cam->cairo_context);
		if((my_immediate->crop_w > 0) && (my_immediate->crop_h > 0))
		{
			int crop_x = sx + my_immediate->crop_x;
			int crop_y = sy + my_immediate->crop_y;
			int crop_w = my_immediate->crop_w;
			int crop_h = my_immediate->crop_h;
			cairo_rectangle(cam->cairo_context, crop_x, crop_y, crop_w, crop_h);
			cairo_clip(cam->cairo_context);
		}
		int half_w = sw / 2;
		int half_h = sh / 2;
		int ssx = sx + half_w;
		int ssy = sy + half_h;
		cairo_translate(cam->cairo_context, ssx, ssy);
		cairo_rotate(cam->cairo_context, my_immediate->angle);
		if(shape != DRAWING_MODE_FREEHAND)
		{
			if(my_immediate != NULL)
			{
				if(my_immediate->idw != NULL)
				{
					if(my_immediate->idw->selected_widget == my_immediate)
					{
						for(loop = 0;loop < cnt;loop++)
						{
							if(pt_type[loop] == POINT_TYPE_CURVE)
							{
								my_cairo_set_source_rgb(cam->cairo_context, 255, 240, 180);
								int nx = xx[loop] - my_window->image_origin_x;
								int ny = yy[loop] - my_window->image_origin_y;
								cairo_rectangle(cam->cairo_context, nx - 5, ny - 5, 10, 10);
								cairo_fill(cam->cairo_context);
							}
						}
					}
				}
			}
			int use_alpha = (int)((double)alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cam->cairo_context, red, green, blue, use_alpha);
			my_cairo_set_line_style(cam->cairo_context, style, width);
			if((shape == DRAWING_MODE_LINE)
			|| (shape == DRAWING_MODE_LOOP)
			|| (shape == DRAWING_MODE_POLYGON))
			{
				if((shape == DRAWING_MODE_POLYGON) && (erase == 1))
				{
					if(cnt > 2)
					{
						int a_xx[1024];
						int a_yy[1024];
						for(loop = 0;loop < cnt;loop++)
						{
							a_xx[loop] = xx[loop] - cam->image_sx;
							a_yy[loop] = yy[loop] - cam->image_sy;
						}
						erase_polygon(cam->mat, cnt, a_xx, a_yy);
					}
				}
				else
				{
					loop = 0;
					int origin_x = 0;
					int origin_y = 0;
					while(loop < cnt)
					{
						int nx = xx[loop];
						int ny = yy[loop];
						if(loop == 0)
						{
							nx -= (my_window->image_origin_x + ssx);
							ny -= (my_window->image_origin_y + ssy);
							cairo_move_to(cam->cairo_context, nx, ny);
							origin_x = nx;
							origin_y = ny;
							loop++;
						}
						else
						{
							int ux = (nx * my_immediate->scale_w) + origin_x;
							int uy = (ny * my_immediate->scale_h) + origin_y;
							if(pt_type[loop] == POINT_TYPE_CURVE)
							{
								if((cnt > 3) && ((loop + 2) < cnt))
								{
									int nx1 = (xx[loop] * my_immediate->scale_w) + origin_x;
									int ny1 = (yy[loop] * my_immediate->scale_h) + origin_y;
									int nx2 = (xx[loop + 1] * my_immediate->scale_w) + origin_x;
									int ny2 = (yy[loop + 1] * my_immediate->scale_h) + origin_y;
									int nx3 = (xx[loop + 2] * my_immediate->scale_w) + origin_x;
									int ny3 = (yy[loop + 2] * my_immediate->scale_h) + origin_y;
									cairo_curve_to(cam->cairo_context, nx1, ny1, nx2, ny2, nx3, ny3);
									loop += 3;
								}
								else
								{
									loop++;
								}
							}
							else
							{
								cairo_line_to(cam->cairo_context, ux, uy);
								loop++;
							}
						}
					}
					if(my_immediate->actively_drawing == 1)
					{
						if(cnt > 0)
						{
							int cur_x = Fl::event_x();
							int cur_y = Fl::event_y();
							cur_x -= (my_window->image_origin_x + ssx);
							cur_y -= (my_window->image_origin_y + ssy);
							cairo_line_to(cam->cairo_context, cur_x, cur_y);
							if(cnt < 3)
							{
								cairo_stroke(cam->cairo_context);
							}
						}
					}
					if((shape == DRAWING_MODE_LOOP)
					|| (shape == DRAWING_MODE_POLYGON))
					{
						if(cnt > 2)
						{
							cairo_close_path(cam->cairo_context);
						}
					}
					if(shape == DRAWING_MODE_POLYGON)
					{
						cairo_fill(cam->cairo_context);
					}
					else
					{
						cairo_stroke(cam->cairo_context);
					}
					if(shape == DRAWING_MODE_LINE)
					{
						if((style & MY_CAP_ARROW) == MY_CAP_ARROW)
						{
							if(cnt > 1)
							{
								int nn = 3 * width;
								if(nn < 10) nn = 10;
								int nx1 = (xx[cnt - 1] * my_immediate->scale_w) + origin_x;
								int ny1 = (yy[cnt - 1] * my_immediate->scale_h) + origin_y;
								int nx2 = (xx[cnt - 2] * my_immediate->scale_w) + origin_x;
								int ny2 = (yy[cnt - 2] * my_immediate->scale_h) + origin_y;
								my_cairo_draw_arrow(cam->cairo_context, nx1, ny1, nx2, ny2, nn, nn);
							}
						}
					}
				}
			}
			else if(shape == DRAWING_MODE_POLYGON_PASSTHRU)
			{
				if(my_immediate->idw->mode == DRAWING_MODE_POLYGON_PASSTHRU)
				{
					int origin_x = 0;
					int origin_y = 0;
					fl_color(WHITE);
					fl_begin_loop();
					for(loop = 0;loop < cnt;loop++)
					{
						int nx = xx[loop];
						int ny = yy[loop];
						if(loop == 0)
						{
							origin_x = nx;
							origin_y = ny;
							fl_vertex(nx, ny);
						}
						else
						{
							int ux = (nx * my_immediate->scale_w) + origin_x;
							int uy = (ny * my_immediate->scale_h) + origin_y;
							fl_vertex(ux, uy);
						}
					}
					fl_end_loop();
				}
				if(cnt > 2)
				{
					int origin_x = 0;
					int origin_y = 0;
					int a_xx[1024];
					int a_yy[1024];
					for(loop = 0;loop < cnt;loop++)
					{
						if(loop == 0)
						{
							a_xx[loop] = xx[loop] - cam->image_sx;
							a_yy[loop] = yy[loop] - cam->image_sy;
							origin_x = a_xx[loop];
							origin_y = a_yy[loop];
						}
						else
						{
							a_xx[loop] = ((xx[loop] * my_immediate->scale_w) + origin_x);
							a_yy[loop] = ((yy[loop] * my_immediate->scale_h) + origin_y);
						}
					}
					Mat out;
					Mat use;
					cv::resize(cam->reserve_mat, use, cv::Size(cam->mat.cols, cam->mat.rows));
					mask_polygon(use, out, cnt, a_xx, a_yy);
					cairo_surface_t *surface = cairo_image_surface_create_for_data(out.ptr(), CAIRO_FORMAT_ARGB32, out.cols, out.rows, out.step);
					if((surface != NULL) && (cam->cairo_surface != NULL))
					{
						cairo_set_source_surface(cam->cairo_context, surface, -ssx, -ssy);
						cairo_paint(cam->cairo_context);
						cairo_surface_destroy(surface);
					}
				}
			}
		}
		else
		{
			int use_alpha = (int)((double)alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cam->cairo_context, red, green, blue, use_alpha);
			int origin_x = 0;
			int origin_y = 0;
			for(loop = 0;loop < cnt;loop++)
			{
				if(loop == 0)
				{
					origin_x = xx[loop] - (my_window->image_origin_x + ssx);
					origin_y = yy[loop] - (my_window->image_origin_y + ssy);
				}
				else
				{
					if(loop < (cnt - 1))
					{
						int cx1 = (xx[loop] * my_immediate->scale_w) + origin_x;
						int cy1 = (yy[loop] * my_immediate->scale_h) + origin_y;
						int cx2 = (xx[loop + 1] * my_immediate->scale_w) + origin_x;
						int cy2 = (yy[loop + 1] * my_immediate->scale_h) + origin_y;
						ImageLine(cam->cairo_context, cx1, cy1, cx2, cy2, 1);
					}
					else
					{
						int cx = (xx[loop] * my_immediate->scale_w) + origin_x;
						int cy = (yy[loop] * my_immediate->scale_h) + origin_y;
						DoStamp(cam->cairo_context, cx, cy);
					}
				}
			}
		}
		cairo_restore(cam->cairo_context);
		my_immediate->resize(sx + cam->image_sx, sy + cam->image_sy, w(), h());
	}
}

void	ImLine::DoStamp(cairo_t *cr, double in_x, double in_y)
{
	int cx = in_x;
	int cy = in_y;
	if(style == FREEHAND_SHAPE_SQUARE)
	{
		cairo_rectangle(cr, cx - (width / 2), cy - (width / 2), width, width);
		cairo_fill(cr);
	}
	else if(style == FREEHAND_SHAPE_CIRCLE)
	{
		cairo_arc(cr, cx, cy, (width / 2) + 1, 0.0, 2 * M_PI);
		cairo_fill(cr);
	}
	else if(style == FREEHAND_SHAPE_ERASE_SQUARE)
	{
		Camera *cam = my_immediate->my_camera;
		int x1 = cx - (width / 2);
		int y1 = cy - (width / 2);
		int x2 = x1 + width;
		int y2 = y1 + width;
		rectangle(cam->mat, Point(x1, y1), Point(x2, y2), Vec4b(0, 0, 0, 0), cv::FILLED);
	}
	else if(style == FREEHAND_SHAPE_ERASE_CIRCLE)
	{
		Camera *cam = my_immediate->my_camera;
		ellipse(cam->mat, Point(cx, cy), Size(width, width), 0, 0, 360, Scalar(0, 0, 0, 0), -1, LINE_AA);
	}
	else if(style == FREEHAND_SHAPE_STAMP)
	{
		if(freehand_mat.empty())
		{
			freehand_mat = imread(freehand_filename);
		}
		if(!freehand_mat.empty())
		{
			if((freehand_mat.cols > 0) && (freehand_mat.rows > 0))
			{
				Mat local_mat;
				cv::resize(freehand_mat, local_mat, cv::Size(width, width));
				cvtColor(local_mat, local_mat, COLOR_RGB2RGBA);
				cairo_surface_t *surface = cairo_image_surface_create_for_data(local_mat.ptr(), CAIRO_FORMAT_ARGB32, local_mat.cols, local_mat.rows, local_mat.step);
				if(surface != NULL)
				{
					cairo_set_source_surface(cr, surface, cx - (width / 2), cy - (width / 2));
					cairo_paint(cr);
					cairo_surface_destroy(surface);
				}
			}
		}
	}
	else if(style == FREEHAND_SHAPE_KEY)
	{
		char buf[2];
		buf[0] = key;
		buf[1] = '\0';
		cairo_font_slant_t slant = CAIRO_FONT_SLANT_NORMAL;
		cairo_font_weight_t bold = CAIRO_FONT_WEIGHT_NORMAL;
		cairo_select_font_face(cr, "Sans", slant, bold);
		cairo_set_font_size(cr, width);
		cairo_move_to(cr, cx - (width / 4), cy + (width / 4));
		cairo_show_text(cr, buf);
	}
}

void	ImLine::Extent()
{
	Extent(extent_x1, extent_y1, extent_x2, extent_y2);
}

void	ImLine::Extent(int& x1, int& y1, int& x2, int& y2)
{
int	loop;

	int lx1 = 1000000;
	int ly1 = 1000000;
	int lx2 = -1000000;
	int ly2 = -1000000;
	int nn = width / 2;
	if((shape == DRAWING_MODE_LINE)
	|| (shape == DRAWING_MODE_POLYGON)
	|| (shape == DRAWING_MODE_POLYGON_PASSTHRU)
	|| (shape == DRAWING_MODE_FREEHAND)
	|| (shape == DRAWING_MODE_LOOP))
	{
		nn = 0;
	}
	if(cnt > 1)
	{
		for(loop = 0;loop < cnt;loop++)
		{
			int tx = xx[loop];
			int ty = yy[loop];
			if(loop > 0)
			{
				tx = xx[loop] * my_immediate->scale_w;
				ty = yy[loop] * my_immediate->scale_h;
				tx += xx[0];
				ty += yy[0];
			}
			if((tx - nn) < lx1)
			{
				lx1 = (tx - nn);
			}
			if((ty - nn) < ly1)
			{
				ly1 = (ty - nn);
			}
			if((tx + nn) > lx2)
			{
				lx2 = (tx + nn);
			}
			if((ty + nn) > ly2)
			{
				ly2 = (ty + nn);
			}
		}
	}
	else if(cnt == 1)
	{
		lx1 = xx[0] - nn;
		ly1 = yy[0] - nn;
		lx2 = xx[0] + nn;
		ly2 = yy[0] + nn;
	}
	x1 = lx1;
	y1 = ly1;
	x2 = lx2;
	y2 = ly2;
}

QuickText::QuickText(Camera *in_cam, char *init_text, int xx, int yy, int ww, int hh) : Fl_Multiline_Input(xx, yy, ww, hh)
{
	my_camera = in_cam;
	textcolor(WHITE);
	textsize(32);
	value(init_text);
	focused = 0;
	alpha = 255;
	bold = 0;
	italic = 0;
	outline = 0;
	strcpy(use_font, "sans");
}

QuickText::~QuickText()
{
}

int	QuickText::handle(int event)
{
	int flag = 0;
	if(event == FL_DRAG)
	{
		flag = 1;
	}
	else if(event == FL_PUSH)
	{
		if(my_camera != NULL)
		{
			if(my_camera->my_window != NULL)
			{
				if((my_camera->my_window->editing_misc_mode == EDITING_MISC_MOVE)
				|| (my_camera->my_window->editing_misc_mode == EDITING_MISC_RESIZE))
				{
					flag = -1;
				}
			}
		}
		if(Fl::event_button() == FL_RIGHT_MOUSE)
		{
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Multiline_Input::handle(event);
		if(event == FL_FOCUS)
		{
			focused = 1;
		}
		if(event == FL_UNFOCUS)
		{
			focused = 0;
		}
	}
	if(flag == -1)
	{
		flag = 0;
	}
	return(flag);
}

void	QuickText::draw()
{
int		 loop;
char	*line[4096];

	char *str = (char *)value();
	int pos = insert_position();

	Camera *cam = my_camera;
	int font_sz = textsize();

	uchar rr, gg, bb;
	Fl_Color font_color = textcolor();
	Fl::get_color(font_color, rr, gg, bb);

	int style = 0;
	int outline_r = 0;
	int outline_g = 0;
	int outline_b = 0;
	if(italic == 1) style |= FONT_STYLE_ITALIC;
	if(bold == 1) style |= FONT_STYLE_BOLD;
	if(outline == 1) 
	{
		style |= FONT_STYLE_OUTLINE;
		outline_r = 255 - rr;
		outline_g = 255 - gg;
		outline_b = 255 - bb;
	}
	int xx = x() - cam->image_sx;
	int yy = y() - cam->image_sy;
	if(strlen(str) > 0)
	{
		if(focused == 0) pos = -1;
		int extent_w = 0;
		int extent_h = 0;
		my_cairo_draw_text(my_camera->my_window, my_camera, cam->cairo_context, xx, yy + font_sz, str, use_font, style, font_sz, pos, rr, gg, bb, alpha, outline_r, outline_g, outline_b, alpha, extent_w, extent_h);
	}
	if(my_camera != NULL)
	{
		if(my_camera->my_window != NULL)
		{
			if((my_camera->my_window->editing_misc_mode == EDITING_MISC_MOVE)
			|| (my_camera->my_window->editing_misc_mode == EDITING_MISC_RESIZE))
			{
				fl_color(FL_WHITE);
				fl_rect(x(), y(), w(), h());
			}
		}
	}
}

ImText::ImText(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : ImDefault(), Fl_Multiline_Input(xx, yy, ww, hh)
{
	my_window = in_win;
	my_immediate = in_im;
	italic = my_immediate->idw->text_italic_button->value();
	bold = my_immediate->idw->text_bold_button->value();
	outline = my_immediate->idw->text_outline_button->value();
	font_alpha = my_immediate->idw->font_color_alpha;
	background_alpha = my_immediate->idw->back_color_alpha;
	outline_alpha = my_immediate->idw->outline_color_alpha;
	box_type = my_immediate->idw->text_box_type;

	strcpy(font_name, my_immediate->idw->selected_font);
	if(strlen(font_name) < 1)
	{
		strcpy(font_name, "Sans");
	}
	char *initial_text = (char *)my_immediate->idw->text_initial_text->value();
	value(initial_text);
	focused = 0;
	SetToDialog();
}

ImText::~ImText()
{
}

int	ImText::handle(int event)
{
static int once = 0;

	int flag = 0;
	if(event == FL_DRAG)
	{
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Multiline_Input::handle(event);
		int ww = 0;
		int hh = 0;
		if(my_immediate->extent_taken == 0)
		{
			fl_font(textfont(), textsize());
			fl_measure(value(), ww, hh);
			my_immediate->orig_w = ww;
			my_immediate->orig_h = hh;
			resize(x(), y(), ww, hh);
			my_immediate->resize(x(), y(), ww, hh);
			my_immediate->scale_w = 1.0;
			my_immediate->scale_h = 1.0;
		}
		else
		{
			ww = my_immediate->extent_w;
			hh = my_immediate->extent_h;
			resize(x(), y(), ww, hh);
		}
		if(event == FL_FOCUS)
		{
			focused = 1;
		}
		if(event == FL_UNFOCUS)
		{
			focused = 0;
		}
	}
	return(flag);
}

void	ImText::draw()
{
int		loop;

	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		cairo_t *cr = cam->cairo_context;
		char *str = (char *)value();
		char *use = strdup(str);
		int pos = insert_position();

		int font_sz = use_size;
		uchar rr, gg, bb;
		alpha = font_alpha;
		uchar back_r, back_g, back_b;

		back_r = background_red;
		back_g = background_green;
		back_b = background_blue;

		int sx = my_immediate->relative_x;
		int sy = my_immediate->relative_y;
		int save_sx = sx;
		int save_sy = sy;

		int ssx = sx + (w() / 2);
		int ssy = sy + (h() / 2);
		cairo_save(cr);
		if((my_immediate->crop_w > 0) && (my_immediate->crop_h > 0))
		{
			int crop_x = sx + my_immediate->crop_x;
			int crop_y = sy + my_immediate->crop_y;
			int crop_w = my_immediate->crop_w;
			int crop_h = my_immediate->crop_h;
			cairo_rectangle(cr, crop_x, crop_y, crop_w, crop_h);
			cairo_clip(cr);
		}
		cairo_translate(cr, ssx, ssy);
		cairo_rotate(cr, my_immediate->angle);
		sx -= ssx;
		sy -= ssy;
		if(box_type == FL_FLAT_BOX)
		{
			int use_alpha = (int)((double)background_alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cr, back_r, back_g, back_b, use_alpha);
			cairo_rectangle(cr, sx, sy, my_immediate->w(), my_immediate->h());
			cairo_fill(cr);
		}
		else if(box_type == FL_FRAME)
		{
			int use_alpha = (int)((double)background_alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cr, back_r, back_g, back_b, use_alpha);
			cairo_rectangle(cr, sx, sy, my_immediate->w(), my_immediate->h());
			cairo_stroke(cr);
		}
		else if(box_type == FL_FRAME_BOX)
		{
			int use_alpha = (int)((double)background_alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cr, back_r, back_g, back_b, use_alpha);
			cairo_rectangle(cr, sx, sy, my_immediate->w(), my_immediate->h());
			cairo_fill(cr);

			use_alpha = (int)((double)font_alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cr, red, green, blue, use_alpha);
			cairo_rectangle(cr, sx, sy, my_immediate->w(), my_immediate->h());
			cairo_stroke(cr);
		}
		int y_pos = sy;
		if(strlen(use) > 0)
		{
			int style = 0;
			int outline_r = 0;
			int outline_g = 0;
			int outline_b = 0;
			if(italic == 1) style |= FONT_STYLE_ITALIC;
			if(bold == 1) style |= FONT_STYLE_BOLD;
			if(outline == 1) 
			{
				style |= FONT_STYLE_OUTLINE;
				outline_r = my_immediate->idw->outline_color_red;
				outline_g = my_immediate->idw->outline_color_green;
				outline_b = my_immediate->idw->outline_color_blue;
			}
			int use_alpha = (int)((double)font_alpha * my_immediate->overall_alpha);
			if(focused == 0) pos = -1;
			int extent_w = 0;
			int extent_h = 0;
			my_cairo_draw_text(cam->my_window, cam, cr, sx, y_pos, use, font_name, style, font_sz, pos, red, green, blue, use_alpha, outline_r, outline_g, outline_b, outline_alpha, extent_w, extent_h, my_immediate->scale_w, my_immediate->scale_h);
			my_immediate->extent_w = extent_w;
			my_immediate->extent_h = extent_h;
			my_immediate->extent_taken = 1;
		}
		free(use);
		cairo_restore(cr);
		my_immediate->resize(save_sx + cam->image_sx, save_sy + cam->image_sy, my_immediate->w(), my_immediate->h());
	}
}

AnimButton::AnimButton(MyWin *in_win, int xx, int yy) : Fl_Box(xx, yy, 10, 10)
{
	box(FL_NO_BOX);
	color(BLACK);
	align(FL_ALIGN_BOTTOM | FL_ALIGN_CENTER);
	labelcolor(WHITE);
	labelsize(8);

	frame = 0;
}

AnimButton::~AnimButton()
{
}

void	AnimButton::draw()
{
char	buf[256];

	fl_color(WHITE);
	fl_line(x(), y(), x() + 5, y() + 10);
	fl_line(x() + 5, y() + 10, x() - 5, y() + 10);
	fl_line(x() - 5, y() + 10, x(), y());

	sprintf(buf, "%d", frame);
	fl_font(FL_HELVETICA, 8);
	fl_draw(buf, x() - 10, y() + 12, 20, 10, FL_ALIGN_CENTER);
}

int		AnimButton::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Fl_Box::handle(event);
	}
	return(flag);
}

void	anim_timeline_set_start_cb(Fl_Widget *w, void *v)
{
	AnimTimeline *anim = (AnimTimeline *)v;
	MyInput *in = (MyInput *)w;
	char *val = (char *)in->value();
	if(val != NULL)
	{
		int nn = atoi(val);
		if(nn > 0)
		{
			anim->start = nn;
			int calced_frame = anim->start + (int)(((double)anim->range / (double)anim->w()) * (double)anim->frame_indicator->x());
			anim->current_frame = calced_frame;
		}
	}
	in->hide();
	anim->redraw();
}

void	anim_timeline_set_range_cb(Fl_Widget *w, void *v)
{
	AnimTimeline *anim = (AnimTimeline *)v;
	MyInput *in = (MyInput *)w;
	char *val = (char *)in->value();
	if(val != NULL)
	{
		int nn = atoi(val);
		if((nn > 0) && (nn > anim->start))
		{
			anim->range = nn - anim->start;
			int calced_frame = anim->start + (int)(((double)anim->range / (double)anim->w()) * (double)anim->frame_indicator->x());
			anim->current_frame = calced_frame;
		}
	}
	in->hide();
	anim->redraw();
}

void	anim_timeline_preview_cb(Fl_Widget *w, void *v)
{
	MyButton *preview = (MyButton *)w;
	AnimTimeline *anim = (AnimTimeline *)v;
	Camera *cam = anim->my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->anim_preview == 0)
		{
			anim->Reset();
			cam->anim_preview = 1;
			preview->copy_label("@square");
		}
		else
		{
			cam->anim_preview = 0;
			preview->copy_label("@>");
		}
	}
}

AnimTimeline::AnimTimeline(MyWin *in_win, int xx, int yy, int ww, int hh) : Fl_Window(xx, yy, ww, hh, "Animation Timeline")
{
	my_window = in_win;
	box(FL_FLAT_BOX);
	color(BLACK);
	frame_indicator = new AnimButton(in_win, 1, 5);
	range = 1000;
	start = 1;
	current_frame = 1;
	input = new MyInput(2, 24, 30, 12, "");
	input->textsize(8);
	input->box(FL_FRAME_BOX);
	input->color(YELLOW);
	input->textcolor(BLACK);
	input->hide();
	preview_button = new MyButton((w() / 2) - 5, 24, 10, 10, "@>");
	preview_button->box(FL_FLAT_BOX);
	preview_button->color(BLACK);
	preview_button->labelcolor(YELLOW);
	preview_button->labelsize(8);
	preview_button->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	preview_button->callback(anim_timeline_preview_cb, this);
	end();
}

AnimTimeline::~AnimTimeline()
{
}

void	AnimTimeline::draw()
{
char	buf[256];
int		outer;
int		inner;

	frame_indicator->frame = current_frame;
	Fl_Window::draw();
	fl_color(YELLOW);
	fl_line(1, 0, 1, 20);
	fl_line(1, 5, w() - 2, 5);
	fl_line(w() - 2, 0, w() - 2, 20);

	if((!input->visible()) || (input->x() > (w() / 2)))
	{
		sprintf(buf, "%d", start);
		fl_font(FL_HELVETICA, 8);
		fl_draw(buf, 2, 24, 20, 10, FL_ALIGN_CENTER);
	}
	if((!input->visible()) || (input->x() < (w() / 2)))
	{
		sprintf(buf, "%d", start + range);
		fl_font(FL_HELVETICA, 8);
		fl_draw(buf, w() - 30, 24, 20, 10, FL_ALIGN_CENTER);
	}
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		for(outer = 0;outer < cam->immediate_cnt;outer++)
		{
			Immediate *im = cam->immediate_list[outer];
			if(im != NULL)
			{
				for(inner = 0;inner < im->anim_cnt;inner++)
				{
					if(im->anim[inner] != NULL)
					{
						int frame = im->anim[inner]->frame;
						fl_color(FL_RED);
						fl_rectf(frame - 1, 3, 4, 4);
					}
				}
			}
		}
	}
}

int		AnimTimeline::handle(int event)
{
char	buf[256];

	int flag = 0;
	if(event == FL_PUSH)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		if(yy < 18)
		{
			int calced_frame = start + (int)(((double)range / (double)w()) * (double)xx);
			current_frame = calced_frame;
			frame_indicator->resize(xx, frame_indicator->y(), frame_indicator->w(), frame_indicator->h());
			frame_indicator->redraw();
			input->hide();
			redraw();
			flag = 1;
		}
		else if((xx > 0) && (xx < 30))
		{
			sprintf(buf, "%d", start);
			input->value(buf);
			input->resize(2, 24, input->w(), input->h());
			input->callback(anim_timeline_set_start_cb, this);
			input->show();
		}
		else if((xx > w() - 30) && (xx < w()))
		{
			sprintf(buf, "%d", start + range);
			input->value(buf);
			input->resize(w() - 30, 24, input->w(), input->h());
			input->callback(anim_timeline_set_range_cb, this);
			input->show();
		}
	}
	else if(event == FL_DRAG)
	{
		int xx = Fl::event_x();
		if((xx > 0) && (xx < w()))
		{
			int calced_frame = start + (int)(((double)range / (double)w()) * (double)xx);
			current_frame = calced_frame;
			frame_indicator->resize(xx, frame_indicator->y(), frame_indicator->w(), frame_indicator->h());
			frame_indicator->redraw();
			redraw();
		}
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(event);
}

void	AnimTimeline::Reset()
{
int	loop;

	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < cam->immediate_cnt;loop++)
		{
			Immediate *im = cam->immediate_list[loop];
			if(im != NULL)
			{
				im->anim_index = 0;
				im->anim_frame = 0;
				im->anim_complete = 0;
			}
		}
	}
}

ImAnim::ImAnim()
{
}

ImAnim::ImAnim(int in_frame, Immediate *in_im)
{
int	use_red;
int	use_green;
int	use_blue;
int	use_alpha;

	frame = in_frame;
	xx = in_im->x();
	yy = in_im->y();
	ww = in_im->w();
	hh = in_im->h();
	angle = in_im->angle;

	in_im->GetColor(use_red, use_green, use_blue, use_alpha);
	red = use_red;
	green = use_green;
	blue = use_blue;
	alpha = use_alpha;
}

ImAnim::~ImAnim()
{
}

void	ImAnim::Edit(int in_frame, Immediate *in_im)
{
int	use_red;
int	use_green;
int	use_blue;
int	use_alpha;

	frame = in_frame;
	xx = in_im->x();
	yy = in_im->y();
	ww = in_im->w();
	hh = in_im->h();
	angle = in_im->angle;

	in_im->GetColor(use_red, use_green, use_blue, use_alpha);
	red = use_red;
	green = use_green;
	blue = use_blue;
	alpha = use_alpha;
}

Immediate::Immediate(MyWin *in_win, Camera *in_cam, ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
int	loop;

	my_window = in_win;
	my_camera = in_cam;
	idw = in_idw;
	inw = NULL;
	immediate_type = idw->mode;
	layer = 0;
	if(my_camera != NULL)
	{
		layer = my_camera->edit_layer;
	}
	name = NULL;
	draw_it = 1;
	initial_x = 0;
	initial_y = 0;
	orig_w = ww;
	orig_h = hh;
	last_x = 0;
	last_y = 0;
	dragging = 0;
	drag_mode = DRAG_MODE_MOVE;
	popup = NULL;
	overall_alpha = 1.0;
	use_as_mask = 0;
	box(FL_NO_BOX);
	mw_mode = MW_MODE_NONE;
	scale_w = 1.0;
	scale_h = 1.0;
	extent_w = ww;
	extent_h = hh;
	extent_taken = 0;
	actively_drawing = 0;
	crop_x = 0;
	crop_y = 0;
	crop_w = 0;
	crop_h = 0;
	angle = 0.0;
	anim_flag = 0;
	anim_index = 0;
	anim_frame = 0;
	anim_complete = 0;
	anim_x = x();
	anim_y = y();
	anim_ix = 0.0;
	anim_iy = 0.0;
	anim_iangle = 0.0;
	anim_w = w();
	anim_h = h();
	anim_iw = 0.0;
	anim_ih = 0.0;
	anim_red = 0.0;
	anim_green = 0.0;
	anim_blue = 0.0;
	anim_alpha = 0.0;
	anim_ired = 0.0;
	anim_igreen = 0.0;
	anim_iblue = 0.0;
	anim_ialpha = 0.0;
	anim_looping = 0;
	for(loop = 0;loop < 1024;loop++)
	{
		anim[loop] = NULL;
	}
	anim_cnt = 0;
	save_initial = 0;
	save_x = 0;
	save_y = 0;
	save_w = 0;
	save_h = 0;
	save_red = 0;
	save_green = 0;
	save_blue = 0;
	save_alpha = 0;

	text = NULL;
	line = NULL;
	rectangle = NULL;
	rectangle_passthru = NULL;
	ellipse = NULL;
	ellipse_passthru = NULL;
	freehand = NULL;
	pixelate = NULL;
	image_im = NULL;
	if(immediate_type == DRAWING_MODE_TEXT)
	{
		text = new ImText(my_window, this, xx, yy, ww, hh);
		text->textfont(idw->font_num);
		text->textsize(idw->font_size);
		text->use_size = idw->font_size;

		text->textcolor(fl_rgb_color(idw->font_color_red, idw->font_color_green, idw->font_color_blue));
		text->red = idw->font_color_red;
		text->green = idw->font_color_green;
		text->blue = idw->font_color_blue;
		text->alpha = idw->font_color_alpha;

		text->color(fl_rgb_color(idw->back_color_red, idw->back_color_green, idw->back_color_blue));
		text->background_red = idw->back_color_red;
		text->background_green = idw->back_color_green;
		text->background_blue = idw->back_color_blue;
		text->background_alpha = idw->back_color_alpha;

		text->box(idw->text_box_type);
		text->box_type = idw->text_box_type;
		text->show();
		text->take_focus();
		im_type = IM_TEXT;
	}
	else if((immediate_type == DRAWING_MODE_LINE)
	|| (immediate_type == DRAWING_MODE_POLYGON)
	|| (immediate_type == DRAWING_MODE_POLYGON_PASSTHRU)
	|| (immediate_type == DRAWING_MODE_FREEHAND)
	|| (immediate_type == DRAWING_MODE_LOOP))
	{
		line = new ImLine(my_window, this, immediate_type, xx, yy, ww, hh);
		strcpy(line->freehand_filename, idw->freehand_filename);
		line->freehand_mat = idw->freehand_mat.clone();
		line->erase = idw->erase;
		im_type = IM_LINE;
	}
	else if(immediate_type == DRAWING_MODE_RECTANGLE)
	{
		rectangle = new ImRectangle(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		im_type = IM_RECTANGLE;
	}
	else if(immediate_type == DRAWING_MODE_RECTANGLE_PASSTHRU)
	{
		rectangle_passthru = new ImRectanglePassThru(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		im_type = IM_RECTANGLE_PASSTHRU;
	}
	else if(immediate_type == DRAWING_MODE_PIXELATE)
	{
		pixelate = new ImPixelate(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		pixelate->style = idw->line_style;
		pixelate->use_size = idw->pixelate_size;
		im_type = IM_PIXELATE;
	}
	else if(immediate_type == DRAWING_MODE_ELLIPSE)
	{
		ellipse = new ImEllipse(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		im_type = IM_ELLIPSE;
	}
	else if(immediate_type == DRAWING_MODE_ELLIPSE_PASSTHRU)
	{
		ellipse_passthru = new ImEllipsePassThru(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		im_type = IM_ELLIPSE_PASSTHRU;
	}
	else if(immediate_type == DRAWING_MODE_IMAGE)
	{
		image_im = new ImImage(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		im_type = IM_IMAGE;
	}
	end();
}

Immediate::Immediate(MyWin *in_win, Camera *in_cam, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
int	loop;

	my_window = in_win;
	my_camera = in_cam;
	idw = NULL;
	inw = NULL;
	immediate_type = -1;
	name = NULL;
	layer = my_camera->edit_layer;
	draw_it = 1;
	initial_x = 0;
	initial_y = 0;
	last_x = 0;
	last_y = 0;
	dragging = 0;
	drag_mode = DRAG_MODE_MOVE;
	popup = NULL;
	overall_alpha = 1.0;
	use_as_mask = 0;
	box(FL_NO_BOX);
	mw_mode = MW_MODE_NONE;
	scale_w = 1.0;
	scale_h = 1.0;
	orig_w = ww;
	orig_h = hh;
	crop_x = 0;
	crop_y = 0;
	crop_w = 0;
	crop_h = 0;
	actively_drawing = 0;
	if(my_camera != NULL)
	{
		relative_x = xx - my_camera->image_sx;
		relative_y = yy - my_camera->image_sy;
	}
	anim_flag = 0;
	anim_index = 0;
	anim_frame = 0;
	anim_complete = 0;
	anim_x = x();
	anim_y = y();
	anim_ix = 0.0;
	anim_iy = 0.0;
	anim_iangle = 0.0;
	anim_w = w();
	anim_h = h();
	anim_iw = 0.0;
	anim_ih = 0.0;
	anim_ired = 0.0;
	anim_igreen = 0.0;
	anim_iblue = 0.0;
	anim_ialpha = 0.0;
	anim_looping = 0;
	for(loop = 0;loop < 1024;loop++)
	{
		anim[loop] = NULL;
	}
	anim_cnt = 0;
	save_initial = 0;
	save_x = 0;
	save_y = 0;
	save_w = 0;
	save_h = 0;
	save_red = 0;
	save_green = 0;
	save_blue = 0;
	save_alpha = 0;

	text = NULL;
	line = NULL;
	rectangle = NULL;
	rectangle_passthru = NULL;
	ellipse = NULL;
	ellipse_passthru = NULL;
	freehand = NULL;
	pixelate = NULL;
	image_im = NULL;

	end();
}

Immediate::Immediate(Immediate *old, Camera *in_cam) : MyGroup(old->x(), old->y(), old->w(), old->h())
{
int	loop;

	int xx = old->x();
	int yy = old->y();
	int ww = old->w();
	int hh = old->h();
	my_window = old->my_window;
	my_camera = in_cam;
	idw = old->idw;
	inw = NULL;
	if(name != NULL)
	{
		free(name);
		name = NULL;
	}
	if(old->name != NULL)
	{
		name = strdup(old->name);
	}
	immediate_type = old->immediate_type;
	layer = 0;
	if(my_camera != NULL)
	{
		layer = my_camera->edit_layer;
	}
	draw_it = 1;
	initial_x = 0;
	initial_y = 0;
	orig_w = ww;
	orig_h = hh;
	last_x = 0;
	last_y = 0;
	dragging = 0;
	drag_mode = DRAG_MODE_MOVE;
	popup = NULL;
	overall_alpha = 1.0;
	use_as_mask = 0;
	box(FL_NO_BOX);
	mw_mode = MW_MODE_NONE;
	scale_w = old->scale_w;
	scale_h = old->scale_h;
	extent_w = old->extent_w;
	extent_h = old->extent_h;
	extent_taken = old->extent_taken;
	actively_drawing = 0;
	crop_x = old->crop_x;
	crop_y = old->crop_y;
	crop_w = old->crop_w;
	crop_h = old->crop_h;
	angle = old->angle;
	anim_flag = 0;
	anim_index = 0;
	anim_frame = 0;
	anim_complete = 0;
	anim_x = x();
	anim_y = y();
	anim_ix = 0.0;
	anim_iy = 0.0;
	anim_iangle = 0.0;
	anim_w = w();
	anim_h = h();
	anim_iw = 0.0;
	anim_ih = 0.0;
	anim_ired = 0.0;
	anim_igreen = 0.0;
	anim_iblue = 0.0;
	anim_ialpha = 0.0;
	anim_looping = 0;
	for(loop = 0;loop < 1024;loop++)
	{
		anim[loop] = NULL;
	}
	anim_cnt = 0;
	save_initial = 0;
	save_x = 0;
	save_y = 0;
	save_w = 0;
	save_h = 0;
	save_red = 0;
	save_green = 0;
	save_blue = 0;
	save_alpha = 0;
	if(my_camera != NULL)
	{
		relative_x = xx - my_camera->image_sx;
		relative_y = yy - my_camera->image_sy;
	}
	text = NULL;
	line = NULL;
	rectangle = NULL;
	rectangle_passthru = NULL;
	ellipse = NULL;
	ellipse_passthru = NULL;
	freehand = NULL;
	pixelate = NULL;
	image_im = NULL;
	if(immediate_type == DRAWING_MODE_TEXT)
	{
		text = new ImText(my_window, this, xx, yy, ww, hh);
		text->Copy(this, old->text);
		text->show();
		text->take_focus();
		im_type = IM_TEXT;
	}
	else if((immediate_type == DRAWING_MODE_LINE)
	|| (immediate_type == DRAWING_MODE_POLYGON)
	|| (immediate_type == DRAWING_MODE_POLYGON_PASSTHRU)
	|| (immediate_type == DRAWING_MODE_FREEHAND)
	|| (immediate_type == DRAWING_MODE_LOOP))
	{
		line = new ImLine(my_window, this, immediate_type, xx, yy, ww, hh);
		line->Copy(this, old->line);
		im_type = IM_LINE;
	}
	else if(immediate_type == DRAWING_MODE_RECTANGLE)
	{
		rectangle = new ImRectangle(my_window, this, xx, yy, ww, hh);
		rectangle->Copy(this, old->rectangle);
		im_type = IM_RECTANGLE;
	}
	else if(immediate_type == DRAWING_MODE_RECTANGLE_PASSTHRU)
	{
		rectangle_passthru = new ImRectanglePassThru(my_window, this, xx, yy, ww, hh);
		rectangle_passthru->Copy(this, old->rectangle_passthru);
		im_type = IM_RECTANGLE_PASSTHRU;
	}
	else if(immediate_type == DRAWING_MODE_PIXELATE)
	{
		pixelate = new ImPixelate(my_window, this, xx, yy, ww, hh);
		pixelate->Copy(this, old->pixelate);
		im_type = IM_PIXELATE;
	}
	else if(immediate_type == DRAWING_MODE_ELLIPSE)
	{
		ellipse = new ImEllipse(my_window, this, xx, yy, ww, hh);
		ellipse->Copy(this, old->ellipse);
		im_type = IM_ELLIPSE;
	}
	else if(immediate_type == DRAWING_MODE_ELLIPSE_PASSTHRU)
	{
		ellipse_passthru = new ImEllipsePassThru(my_window, this, xx, yy, ww, hh);
		ellipse_passthru->Copy(this, old->ellipse_passthru);
		im_type = IM_ELLIPSE_PASSTHRU;
	}
	else if(immediate_type == DRAWING_MODE_IMAGE)
	{
		image_im = new ImImage(my_window, this, xx, yy, ww, hh);
		image_im->Copy(this, old->image_im);
		im_type = IM_IMAGE;
	}
	end();
}

Immediate::~Immediate()
{
int	loop;

	if(my_window != NULL)
	{
		if(my_window->resize_frame != NULL)
		{
			if(my_window->resize_frame->use == this)
			{
				my_window->resize_frame->hide();
				my_window->resize_frame->use = NULL;
			}
		}
	}
	if(inw != NULL)
	{
		inw->hide();
		Fl::delete_widget(inw);
		inw = NULL;
	}
	if(name != NULL)
	{
		free(name);
		name = NULL;
	}
	for(loop = 0;loop < anim_cnt;loop++)
	{
		if(anim[loop] != NULL)
		{
			delete anim[loop];
			anim[loop] = NULL;
		}
	}
	anim_cnt = 0;
}

void	Immediate::SaveAsJSON(FILE *fp)
{
int	inner;

	ImDefault *use_default = NULL;

	if(text != NULL) use_default = (ImDefault *)text;
	if(line != NULL) use_default = (ImDefault *)line;
	if(rectangle != NULL) use_default = (ImDefault *)rectangle;
	if(rectangle_passthru != NULL) use_default = (ImDefault *)rectangle_passthru;
	if(ellipse != NULL) use_default = (ImDefault *)ellipse;
	if(ellipse_passthru != NULL) use_default = (ImDefault *)ellipse_passthru;
	if(freehand != NULL) use_default = (ImDefault *)freehand;
	if(pixelate != NULL) use_default = (ImDefault *)pixelate;
	if(image_im != NULL) use_default = (ImDefault *)image_im;

	fprintf(fp, "\t\t\t\"sx\": %d,\n", x());
	fprintf(fp, "\t\t\t\"sy\": %d,\n", y());
	fprintf(fp, "\t\t\t\"sw\": %d,\n", w());
	fprintf(fp, "\t\t\t\"sh\": %d,\n", h());
	fprintf(fp, "\t\t\t\"im type\": %d,\n", im_type);
	fprintf(fp, "\t\t\t\"draw it\": %d,\n", draw_it);
	fprintf(fp, "\t\t\t\"immediate type\": %d,\n", immediate_type);
	fprintf(fp, "\t\t\t\"initial x\": %d,\n", initial_x);
	fprintf(fp, "\t\t\t\"initial y\": %d,\n", initial_y);
	fprintf(fp, "\t\t\t\"layer\": %d,\n", layer);
	fprintf(fp, "\t\t\t\"crop x\": %d,\n", crop_x);
	fprintf(fp, "\t\t\t\"crop y\": %d,\n", crop_y);
	fprintf(fp, "\t\t\t\"crop w\": %d,\n", crop_w);
	fprintf(fp, "\t\t\t\"crop h\": %d,\n", crop_h);
	fprintf(fp, "\t\t\t\"overall alpha\": %f,\n", overall_alpha);
	fprintf(fp, "\t\t\t\"use as mask\": %d,\n", use_as_mask);
	if(use_default == text)
	{
		fprintf(fp, "\t\t\t\"text value\": \"%s\",\n", text->value());
		fprintf(fp, "\t\t\t\"text font name\": \"%s\",\n", text->font_name);
	}
	fprintf(fp, "\t\t\t\"image file path\": \"%s\",\n", use_default->image_file_path);
	fprintf(fp, "\t\t\t\"freehand filename\": \"%s\",\n", use_default->freehand_filename);
	fprintf(fp, "\t\t\t\"width\": %d,\n", use_default->width);
	fprintf(fp, "\t\t\t\"red\": %d,\n", use_default->red);
	fprintf(fp, "\t\t\t\"green\": %d,\n", use_default->green);
	fprintf(fp, "\t\t\t\"blue\": %d,\n", use_default->blue);
	fprintf(fp, "\t\t\t\"alpha\": %d,\n", use_default->alpha);
	fprintf(fp, "\t\t\t\"style\": %d,\n", use_default->style);
	fprintf(fp, "\t\t\t\"shape\": %d,\n", use_default->shape);
	fprintf(fp, "\t\t\t\"use size\": %d,\n", use_default->use_size);
	fprintf(fp, "\t\t\t\"filled\": %d,\n", use_default->filled);
	fprintf(fp, "\t\t\t\"square\": %d,\n", use_default->square);
	fprintf(fp, "\t\t\t\"box type\": %d,\n", use_default->box_type);
	fprintf(fp, "\t\t\t\"point cnt\": %d,\n", use_default->cnt);
	fprintf(fp, "\t\t\t\"Point\": [\n");
	for(inner = 0;inner < use_default->cnt;inner++)
	{
		fprintf(fp, "\t\t\t\t{\n");
		fprintf(fp, "\t\t\t\t\t\"xx\": %d,\n", use_default->xx[inner]);
		fprintf(fp, "\t\t\t\t\t\"yy\": %d,\n", use_default->yy[inner]);
		fprintf(fp, "\t\t\t\t\t\"pt type\": %d\n", use_default->pt_type[inner]);
		if(inner == use_default->cnt - 1)
		{
			fprintf(fp, "\t\t\t\t}\n");
		}
		else
		{
			fprintf(fp, "\t\t\t\t},\n");
		}
	}
	fprintf(fp, "\t\t\t],\n");
	fprintf(fp, "\t\t\t\"key\": %d,\n", use_default->key);
	fprintf(fp, "\t\t\t\"italic\": %d,\n", use_default->italic);
	fprintf(fp, "\t\t\t\"bold\": %d,\n", use_default->bold);
	fprintf(fp, "\t\t\t\"outline\": %d,\n", use_default->outline);
	fprintf(fp, "\t\t\t\"font alpha\": %d,\n", use_default->font_alpha);
	fprintf(fp, "\t\t\t\"background red\": %d,\n", use_default->background_red);
	fprintf(fp, "\t\t\t\"background green\": %d,\n", use_default->background_green);
	fprintf(fp, "\t\t\t\"background blue\": %d,\n", use_default->background_blue);
	fprintf(fp, "\t\t\t\"background alpha\": %d,\n", use_default->background_alpha);
	fprintf(fp, "\t\t\t\"outline alpha\": %d,\n", use_default->outline_alpha);

	fprintf(fp, "\t\t\t\"anim cnt\": %d,\n", anim_cnt);
	fprintf(fp, "\t\t\t\"Anim\": [\n");
	if(anim_cnt > 0)
	{
		for(inner = 0;inner < anim_cnt;inner++)
		{
			fprintf(fp, "\t\t\t\t{\n");
			if(anim[inner] != NULL)
			{
				ImAnim *my_anim = anim[inner];
				fprintf(fp, "\t\t\t\t\t\"frame\": %d,\n", my_anim->frame);
				fprintf(fp, "\t\t\t\t\t\"xx\": %f,\n", my_anim->xx);
				fprintf(fp, "\t\t\t\t\t\"yy\": %f,\n", my_anim->yy);
				fprintf(fp, "\t\t\t\t\t\"ww\": %f,\n", my_anim->ww);
				fprintf(fp, "\t\t\t\t\t\"hh\": %f,\n", my_anim->hh);
				fprintf(fp, "\t\t\t\t\t\"angle\": %f,\n", my_anim->angle);
				fprintf(fp, "\t\t\t\t\t\"red\": %f,\n", my_anim->red);
				fprintf(fp, "\t\t\t\t\t\"green\": %f,\n", my_anim->green);
				fprintf(fp, "\t\t\t\t\t\"blue\": %f,\n", my_anim->blue);
				fprintf(fp, "\t\t\t\t\t\"alpha\": %f\n", my_anim->alpha);
			}
			if(inner == anim_cnt - 1)
			{
				fprintf(fp, "\t\t\t\t}\n");
			}
			else
			{
				fprintf(fp, "\t\t\t\t},\n");
			}
		}
	}
	fprintf(fp, "\t\t\t]\n");
}

void	Immediate::SetColor(int red, int green, int blue, int alpha)
{
	if(text != NULL)
	{
		text->red = (uchar)red;
		text->green = (uchar)green;
		text->blue = (uchar)blue;
		text->alpha = (uchar)alpha;
	}
	if(line != NULL)
	{
		line->red = (uchar)red;
		line->green = (uchar)green;
		line->blue = (uchar)blue;
		line->alpha = (uchar)alpha;
	}
	if(rectangle != NULL)
	{
		rectangle->red = (uchar)red;
		rectangle->green = (uchar)green;
		rectangle->blue = (uchar)blue;
		rectangle->alpha = (uchar)alpha;
	}
	if(ellipse != NULL)
	{
		ellipse->red = (uchar)red;
		ellipse->green = (uchar)green;
		ellipse->blue = (uchar)blue;
		ellipse->alpha = (uchar)alpha;
	}
	if(freehand != NULL)
	{
		freehand->red = (uchar)red;
		freehand->green = (uchar)green;
		freehand->blue = (uchar)blue;
		freehand->alpha = (uchar)alpha;
	}
}

void	Immediate::GetColor(int& red, int& green, int& blue, int& alpha)
{
	if(text != NULL)
	{
		red = text->red;
		green = text->green;
		blue = text->blue;
		alpha = text->alpha;
	}
	if(line != NULL)
	{
		red = line->red;
		green = line->green;
		blue = line->blue;
		alpha = line->alpha;
	}
	if(rectangle != NULL)
	{
		red = rectangle->red;
		green = rectangle->green;
		blue = rectangle->blue;
		alpha = rectangle->alpha;
	}
	if(ellipse != NULL)
	{
		red = ellipse->red;
		green = ellipse->green;
		blue = ellipse->blue;
		alpha = ellipse->alpha;
	}
	if(freehand != NULL)
	{
		red = freehand->red;
		green = freehand->green;
		blue = freehand->blue;
		alpha = freehand->alpha;
	}
}

void	Immediate::ResetAnimParameters()
{
	anim_ix = 0.0;
	anim_iy = 0.0;
	anim_iw = 0.0;
	anim_ih = 0.0;
	anim_ired = 0.0;
	anim_igreen = 0.0;
	anim_iblue = 0.0;
	anim_ialpha = 0.0;
}

void	Immediate::RestoreInitialParameters()
{
	if(save_initial == 1)
	{
		ResetAnimParameters();
		resize(save_x, save_y, save_w, save_h);
		SetColor(save_red, save_green, save_blue, save_alpha);
		anim_x = save_x;
		anim_y = save_y;
		anim_w = save_w;
		anim_h = save_h;
		anim_red = save_red;
		anim_green = save_green;
		anim_blue = save_blue;
		anim_alpha = save_alpha;
	}
}

void	Immediate::SaveParameters()
{
	save_initial = 1;
	save_x = x();
	save_y = y();
	save_w = w();
	save_h = h();
	GetColor(save_red, save_green, save_blue, save_alpha);
}

void	Immediate::KeyFrame()
{
int red, green, blue, alpha;

	Camera *cam = my_camera;
	if(cam != NULL)
	{
		if(anim_index == 0)
		{
			ResetAnimParameters();
			resize(anim[0]->xx, anim[0]->yy, anim[0]->ww, anim[0]->hh);
			SetColor(anim[0]->red, anim[0]->green, anim[0]->blue, anim[0]->alpha);
		}
		else
		{
			double diff_frames = (double)abs(anim[anim_index]->frame - anim_frame);
			if(diff_frames > 0)
			{
				anim_ix = (anim[anim_index]->xx - (double)x()) / diff_frames;
				anim_iy = (anim[anim_index]->yy - (double)y()) / diff_frames;
				anim_iw = (anim[anim_index]->ww - (double)w()) / diff_frames;
				anim_ih = (anim[anim_index]->hh - (double)h()) / diff_frames;
				GetColor(red, green, blue, alpha);
				anim_ired = (anim[anim_index]->red - (double)red) / diff_frames;
				anim_igreen = (anim[anim_index]->green - (double)green) / diff_frames;
				anim_iblue = (anim[anim_index]->blue - (double)blue) / diff_frames;
				anim_ialpha = (anim[anim_index]->alpha - (double)alpha) / diff_frames;
			}
		}
	}
}

void	Immediate::MeetKey()
{
	Camera *cam = my_camera;
	if(cam != NULL)
	{
		if((anim_cnt > 0) && (anim_complete == 0))
		{
			if(anim_index == 0)
			{
				RestoreInitialParameters();
			}
			if(anim_index < anim_cnt)
			{
				if(anim_frame == anim[anim_index]->frame)
				{
					if(anim_frame != 0)
					{
						anim_index++;
					}
					if(anim_index < anim_cnt)
					{
						KeyFrame();
					}
				}
				else
				{
					anim_x += anim_ix;
					anim_y += anim_iy;
					angle += anim_iangle;
					anim_w += anim_iw;
					anim_h += anim_ih;
					anim_red += anim_ired;
					anim_green += anim_igreen;
					anim_blue += anim_iblue;
					anim_alpha += anim_ialpha;
					SetColor(anim_red, anim_green, anim_blue, anim_alpha);
					resize(anim_x, anim_y, anim_w, anim_h);
				}
			}
			else
			{
				ResetAnimParameters();
				anim_index = 0;
				if(anim_looping == 1)
				{
					anim_frame = -1;
					anim_complete = 0;
				}
				else
				{
					anim_complete = 1;
				}
			}
		}
	}
}

void	Immediate::SetKey(int in_frame)
{
int red, green, blue, alpha;

	if(anim_cnt == 0)
	{
		SaveParameters();
		ResetAnimParameters();
	}
	GetColor(red, green, blue, alpha);
	anim_red = red;
	anim_green = green;
	anim_blue = blue;
	anim_alpha = alpha;
	ImAnim *im_anim = new ImAnim(in_frame, this);
	if(anim_cnt < 1024)
	{
		anim[anim_cnt] = im_anim;
		anim_cnt++;
	}
}

void	Immediate::SetKeyframeAll()
{
int	loop;

	if(my_window != NULL)
	{
		if(my_window->anim_timeline != NULL)
		{
			int frame = my_window->anim_timeline->current_frame;
			Camera *cam = my_window->DisplayedCamera();
			if(cam != NULL)
			{
				for(loop = 0;loop < cam->immediate_cnt;loop++)
				{
					Immediate *im = cam->immediate_list[loop];
					if(im != NULL)
					{
						im->SetKey(frame);
						im->SortKeys();
					}
				}
				my_window->anim_timeline->redraw();
			}
		}
	}
}

void	Immediate::SetKeyframe()
{
	if(my_window != NULL)
	{
		if(my_window->anim_timeline != NULL)
		{
			int frame = my_window->anim_timeline->current_frame;
			SetKey(frame);
			SortKeys();
			my_window->anim_timeline->redraw();
		}
	}
}

void	Immediate::EditKey(int in_frame)
{
int	loop;

	int done = 0;
	for(loop = 0;((loop < anim_cnt) && (done == 0));loop++)
	{
		if(anim[loop] != NULL)
		{
			if(anim[loop]->frame == in_frame)
			{
				anim[loop]->Edit(in_frame, this);
				done = 1;
			}
		}
	}
}

void	Immediate::RemoveKeyframes()
{
int	loop;

	RestoreInitialParameters();
	for(loop = 0;loop < anim_cnt;loop++)
	{
		if(anim[loop] != NULL)
		{
			delete anim[loop];
			anim[loop] = NULL;
		}
	}
	anim_cnt = 0;
	if(my_window != NULL)
	{
		if(my_window->anim_timeline != NULL)
		{
			my_window->anim_timeline->redraw();
		}
	}
}

void	Immediate::RemoveKeyframesFromAll()
{
int	loop;

	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < cam->immediate_cnt;loop++)
		{
			Immediate *im = cam->immediate_list[loop];
			if(im != NULL)
			{
				im->RemoveKeyframes();
			}
		}
	}
}

void	Immediate::SortKeys()
{
int	loop;

	int done = 0;
	while(done == 0)
	{
		done = 1;
		if(anim_cnt > 1)
		{
			for(loop = 0;loop < (anim_cnt - 1);loop++)
			{
				if((anim[loop] != NULL) && (anim[loop + 1] != NULL))
				{
					if(anim[loop]->frame > anim[loop + 1]->frame)
					{
						ImAnim *tmp = anim[loop];
						anim[loop] = anim[loop + 1];
						anim[loop + 1] = tmp;
						done = 0;
					}
				}
			}
		}
	}
}

void	Immediate::Draw()
{
int		loop;
char	buf[256];

	if(my_camera == my_window->DisplayedCamera())
	{
		if((my_camera->recording == 1) || (my_camera->anim_preview == 1))
		{
			MeetKey();
			anim_frame++;
		}
	}
	if(draw_it == 1)
	{
		MyGroup::draw();
	}
	if((hovering == 1) || (dragging == 1) || (my_window->immediate_drawing_window->selected_widget == this))
	{
		if(my_camera == my_window->DisplayedCamera())
		{
			if(mw_mode == MW_MODE_STACKING_ORDER)
			{
				fl_font(FL_HELVETICA, 24);
				sprintf(buf, "%d", layer);
				fl_draw(buf, x(), y(), w(), h(), FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
			}
		}
	}
	if(idw != NULL)
	{
		if(idw->grid_size > 1)
		{
			fl_color(GRAY);
			int sx = my_camera->image_sx;
			int sy = my_camera->image_sy;
			fl_line_style(FL_DOT);
			for(loop = 0;loop < my_camera->mat.cols;loop += idw->grid_size)
			{
				fl_line(sx + loop, sy, sx + loop, sy + my_camera->mat.rows);
			}
			for(loop = 0;loop < my_camera->mat.rows;loop += idw->grid_size)
			{
				fl_line(sx, sy + loop, sx + my_camera->mat.cols, sy + loop);
			}
			fl_line_style(FL_SOLID);
		}
	}
}

void	Immediate::Hide()
{
	draw_it = 0;
}

void	Immediate::Show()
{
	draw_it = 1;
}

void	Immediate::Copy()
{
	if(my_window != NULL)
	{
		Immediate *new_im = new Immediate(this, NULL);
		my_window->AddImmediate(new_im);
		if(my_window->immediate_drawing_window != NULL)
		{
			my_window->immediate_drawing_window->paste_button->show();
			my_window->immediate_drawing_window->clear_copy_buffer_button->show();
			my_window->immediate_drawing_window->redraw();
		}
	}
}

void	Immediate::resize(int xx, int yy, int ww, int hh)
{
	int old_ww = orig_w;
	int old_hh = orig_h;
	if(my_camera != NULL)
	{
		relative_x = xx - my_camera->image_sx;
		relative_y = yy - my_camera->image_sy;
	}
	if((old_ww > 0) && (old_hh > 0)
	&& (actively_drawing == 0))
	{
		double use_scale_w = (1.0 / (double)old_ww) * (double)ww;
		double use_scale_h = (1.0 / (double)old_hh) * (double)hh;
		Fl_Group::resize(xx, yy, ww, hh);
		scale_w = use_scale_w;
		scale_h = use_scale_h;
		if((immediate_type == DRAWING_MODE_LINE)
		|| (immediate_type == DRAWING_MODE_POLYGON)
		|| (immediate_type == DRAWING_MODE_POLYGON_PASSTHRU)
		|| (immediate_type == DRAWING_MODE_FREEHAND)
		|| (immediate_type == DRAWING_MODE_LOOP))
		{
			if(line != NULL)
			{
				line->resize(xx, yy, ww, hh);
			}
		}
	}
	else
	{
		Fl_Group::resize(xx, yy, ww, hh);
		if(immediate_type == DRAWING_MODE_IMAGE)
		{
			if(image_im != NULL)
			{
				image_im->resize(xx, yy, ww, hh);
			}
		}
		else if(immediate_type == DRAWING_MODE_RECTANGLE)
		{
			if(rectangle != NULL)
			{
				rectangle->resize(xx, yy, ww, hh);
			}
		}
		else if(immediate_type == DRAWING_MODE_ELLIPSE)
		{
			if(ellipse != NULL)
			{
				ellipse->resize(xx, yy, ww, hh);
			}
		}
		else if((immediate_type == DRAWING_MODE_LINE)
		|| (immediate_type == DRAWING_MODE_POLYGON)
		|| (immediate_type == DRAWING_MODE_POLYGON_PASSTHRU)
		|| (immediate_type == DRAWING_MODE_FREEHAND)
		|| (immediate_type == DRAWING_MODE_LOOP))
		{
			if(line != NULL)
			{
				line->resize(xx, yy, ww, hh);
			}
		}
		else if(immediate_type == DRAWING_MODE_PIXELATE)
		{
			if(pixelate != NULL)
			{
				pixelate->resize(xx, yy, ww, hh);
			}
		}
		scale_w = 1.0;
		scale_h = 1.0;
		old_ww = ww;
		old_hh = hh;
	}
}

void	immediate_popup_cb(Fl_Widget *w, void *v)
{
	Immediate *im = (Immediate *)v;
	if(im != NULL)
	{
		if(im->popup != NULL)
		{
			im->popup->hide();
		}
		Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
		char *str = (char *)browser->text(browser->value());
		if(str != NULL)
		{
			if(strcmp(str, "Name") == 0)
			{
				im->Name();
			}
			else if(strcmp(str, "Set Keyframe For All") == 0)
			{
				im->SetKeyframeAll();
			}
			else if(strcmp(str, "Set Keyframe") == 0)
			{
				im->SetKeyframe();
			}
			else if(strcmp(str, "Remove Keyframes") == 0)
			{
				im->RemoveKeyframes();
			}
			else if(strcmp(str, "Remove Keyframes From All") == 0)
			{
				im->RemoveKeyframesFromAll();
			}
			else if(strcmp(str, "Loop") == 0)
			{
				im->anim_looping = 1;
				im->anim_frame = 0;
				im->anim_index = 0;
				im->anim_complete = 0;
			}
			else if(strcmp(str, "Cease Looping") == 0)
			{
				im->anim_looping = 0;
				im->anim_frame = 0;
				im->anim_index = 0;
			}
			else if(strcmp(str, "Delete") == 0)
			{
				im->Delete();
			}
			else if(strcmp(str, "Hide") == 0)
			{
				im->Hide();
			}
			else if(strcmp(str, "Show") == 0)
			{
				im->Show();
			}
			else if(strcmp(str, "Copy") == 0)
			{
				im->Copy();
			}
			else if(strcmp(str, "Zip Left") == 0)
			{
				im->ZipLeft();
			}
			else if(strcmp(str, "Zip Right") == 0)
			{
				im->ZipRight();
			}
			else if(strcmp(str, "Zip Up") == 0)
			{
				im->ZipUp();
			}
			else if(strcmp(str, "Zip Down") == 0)
			{
				im->ZipDown();
			}
			else if(strcmp(str, "MW Frame") == 0)
			{
				im->mw_mode = MW_MODE_NONE;
				im->redraw();
			}
			else if(strcmp(str, "MW Transparency") == 0)
			{
				im->mw_mode = MW_MODE_TRANSPARENCY;
				im->redraw();
			}
			else if(strcmp(str, "MW Stacking Order") == 0)
			{
				im->mw_mode = MW_MODE_STACKING_ORDER;
				im->redraw();
			}
			else if(strcmp(str, "Make Transparent") == 0)
			{
				im->overall_alpha = 0.0;
			}
			else if(strcmp(str, "Make Opaque") == 0)
			{
				im->overall_alpha = 1.0;
			}
			else if(strcmp(str, "Mask") == 0)
			{
				im->use_as_mask = 1;
			}
		}
	}
}

void	Immediate::ZipLeft()
{
	Camera *cam = my_camera;
	if(cam != NULL)
	{
		int	val = cam->FindLeft(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			resize(val, y(), w(), h());
		}
		else
		{
			resize(cam->image_sx, y(), w(), h());
		}
	}
}

void	Immediate::ZipRight()
{
	Camera *cam = my_camera;
	if(cam != NULL)
	{
		int	val = cam->FindRight(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			resize(val - w(), y(), w(), h());
		}
		else
		{
			resize((cam->image_sx + cam->width) - w(), y(), w(), h());
		}
	}
}

void	Immediate::ZipUp()
{
	Camera *cam = my_camera;
	if(cam != NULL)
	{
		int	val = cam->FindTop(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			resize(x(), val, w(), h());
		}
		else
		{
			resize(x(), cam->image_sy, w(), h());
		}
	}
}

void	Immediate::ZipDown()
{
	Camera *cam = my_camera;
	if(cam != NULL)
	{
		int	val = cam->FindBottom(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			resize(x(), val - h(), w(), h());
		}
		else
		{
			resize(x(), (cam->image_sy + cam->height) - h(), w(), h());
		}
	}
}

void	Immediate::Move()
{
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	int dx = xx - initial_x;
	int dy = yy - initial_y;
	int nx = x() - dx;
	int ny = y() - dy;

	int xxx = Fl::event_x_root();
	int yyy = Fl::event_y_root();
	int ddx = last_x - xxx;
	int ddy = last_y - yyy;
	resize(x() - ddx, y() - ddy, w(), h());
	last_x = xxx;
	last_y = yyy;

	if((immediate_type == DRAWING_MODE_LINE)
	|| (immediate_type == DRAWING_MODE_POLYGON)
	|| (immediate_type == DRAWING_MODE_POLYGON_PASSTHRU)
	|| (immediate_type == DRAWING_MODE_FREEHAND)
	|| (immediate_type == DRAWING_MODE_LOOP))
	{
		line->Revise(nx, ny);
	}
	child(0)->resize(x(), y(), w(), h());
}

void	Immediate::Name()
{
	if((idw != NULL) && (my_camera != NULL))
	{
		inw = new ImmediateNameWindow(my_window, this);
		inw->show();
	}
}

void	Immediate::Delete()
{
	if((idw != NULL) && (my_camera != NULL))
	{
		idw->ClearSelectedWidget();
		my_camera->RemoveImmediate(this);
		Fl::delete_widget(this);
	}
}

void	Immediate::ShowPopup()
{
	if(my_camera == my_window->DisplayedCamera())
	{
		if(popup == NULL)
		{
			popup = new PopupMenu(Fl::event_x_root() - 10, Fl::event_y_root() - 10, 160, 170);
			popup->browser->callback(immediate_popup_cb, this);
		}
		else
		{
			popup->resize(Fl::event_x_root() - 10, Fl::event_y_root() - 10, popup->w(), popup->h());
		}
		if(popup != NULL)
		{
			popup->browser->clear();
			popup->browser->add("Name");
			popup->browser->add("Set Keyframe");
			popup->browser->add("Set Keyframe For All");
			if(anim_cnt > 0)
			{
				popup->browser->add("Remove Keyframes");
				popup->browser->add("Remove Keyframes From All");
			}
			if(anim_looping == 0)
			{
				popup->browser->add("Loop");
			}
			else
			{
				popup->browser->add("Cease Looping");
			}
			popup->browser->add("Delete");
			popup->browser->add("Hide");
			popup->browser->add("Show");
			popup->browser->add("Copy");
			popup->browser->add("");
			popup->browser->add("Zip Left");
			popup->browser->add("Zip Right");
			popup->browser->add("Zip Up");
			popup->browser->add("Zip Down");
			popup->browser->add("");
			popup->browser->add("MW Frame");
			popup->browser->add("MW Transparency");
			popup->browser->add("MW Stacking Order");
			popup->browser->add("Make Transparent");
			popup->browser->add("Make Opaque");
			popup->set_non_modal();
			popup->Fit();
			popup->show();
		}
	}
}

int	Immediate::handle(int event)
{
	int flag = 0;
	if(my_camera != NULL)
	{
		if(my_camera == my_window->DisplayedCamera())
		{
			if(my_camera->edit_layer == layer)
			{
				if(event == FL_ENTER)
				{
					my_window->use_mousewheel = 0;
					if(actively_drawing == 0)
					{
						my_window->resize_frame->Use(FRAME_OBJECT_TYPE_IMMEDIATE, this);
						my_window->resize_frame->show();
					}
					hovering = 1;
					flag = 1;
				}
				else if(event == FL_LEAVE)
				{
					my_window->resize_frame->hide();
					my_window->use_mousewheel = 1;
					my_window->resize_frame->use = NULL;
					hovering = 0;
					flag = 1;
				}
				else if(event == FL_PUSH)
				{
					if(Fl::event_button() == FL_LEFT_MOUSE)
					{
						if(my_window->resize_frame->use == this)
						{
							hovering = 0;
							dragging = 1;
							flag = my_window->resize_frame->handle(event);
						}
						else
						{
							initial_x = Fl::event_x() - x();
							initial_y = Fl::event_y() - y();
							last_x = Fl::event_x_root();
							last_y = Fl::event_y_root();
							hovering = 0;
							dragging = 1;
							flag = 1;
						}
					}
					else if(Fl::event_button() == FL_RIGHT_MOUSE)
					{
						ShowPopup();
						flag = 1;
					}
				}
				else if(event == FL_RELEASE)
				{
					if(Fl::event_button() == FL_LEFT_MOUSE)
					{
						if(my_window->resize_frame->use == this)
						{
							dragging = 0;
							flag = my_window->resize_frame->handle(event);
						}
						else
						{
							initial_x = 0;
							initial_y = 0;
							dragging = 0;
							flag = 1;
						}
					}
					else if(Fl::event_button() == FL_RIGHT_MOUSE)
					{
						ShowPopup();
					}
				}
				else if(event == FL_DRAG)
				{
					if(dragging == 1)
					{
						if(my_window->resize_frame->use == this)
						{
							if((Fl::event_inside(my_window->resize_frame))
							|| (my_window->resize_frame->operation == FRAME_OPERATION_PROPORTIONAL_RESIZE)
							|| (my_window->resize_frame->operation == FRAME_OPERATION_FREE_RESIZE)
							|| (my_window->resize_frame->mode != 0))
							{
								flag = my_window->resize_frame->handle(event);
							}
						}
					}
				}
				else if(event == FL_MOUSEWHEEL)
				{
					if(my_window->resize_frame->use == this)
					{
						if(mw_mode == MW_MODE_NONE)
						{
							if(Fl::event_inside(my_window->resize_frame))
							{
								flag = my_window->resize_frame->handle(event);
							}
						}
					}
					if(flag == 0)
					{
						if(mw_mode == MW_MODE_TRANSPARENCY)
						{
							int nn = Fl::event_dy();
							if(nn > 0)
							{
								if(overall_alpha < 1.0)
								{
									overall_alpha += 0.01;
								}
							}
							else if(nn < 0)
							{
								if(overall_alpha > 0.0)
								{
									overall_alpha -= 0.01;
								}
							}
						}
						else if(mw_mode == MW_MODE_STACKING_ORDER)
						{
							int nn = Fl::event_dy();
							if(nn > 0)
							{
								if(layer < 7)
								{
									layer++;
									my_camera->edit_layer = layer;
								}
							}
							else if(nn < 0)
							{
								if(layer > 0)
								{
									layer--;
									my_camera->edit_layer = layer;
								}
							}
						}
						flag = 1;
					}
				}
			}
		}
	}
	if(flag == 0)
	{
		flag = MyGroup::handle(event);
	}
	if(my_camera != NULL)
	{
		if(my_camera->edit_layer == layer)
		{
			if(flag == 1)
			{
				if((immediate_type == DRAWING_MODE_TEXT) && (text != NULL))
				{
					if((event == FL_FOCUS)
					|| (event == FL_UNFOCUS)
					|| (event == FL_KEYBOARD))
					{
						int ww = 0;
						int hh = 0;
						fl_font(text->textfont(), text->textsize());
						fl_measure(text->value(), ww, hh);
						resize(x(), y(), ww + 20, hh + 20);
						text->resize(x(), y(), w(), h());
						text->redraw();
					}
				}
			}
			if((immediate_type == DRAWING_MODE_LINE)
			|| (immediate_type == DRAWING_MODE_POLYGON)
			|| (immediate_type == DRAWING_MODE_POLYGON_PASSTHRU)
			|| (immediate_type == DRAWING_MODE_FREEHAND)
			|| (immediate_type == DRAWING_MODE_LOOP))
			{
				if(actively_drawing == 1)
				{
					if(line != NULL)
					{
						int x1, y1, x2, y2;
						line->Extent(x1, y1, x2, y2);
						int ww = x2 - x1;
						int hh = y2 - y1;
						if((ww > 0) && (hh > 0))
						{
							line->resize(x1, y1, ww, hh);
							resize(x1, y1, ww, hh);
						}
					}
				}
			}
		}
	}
	if(flag == 2)
	{
		flag = 1;
	}
	return(flag);
}

void	Immediate::CompleteRectangle(int xx, int yy)
{
	int use_x = initial_x;
	int use_y = initial_y;
	int use_w = 0;
	int use_h = 0;
	if((xx > initial_x) && (yy > initial_y))
	{
		use_x = initial_x;
		use_y = initial_y;
		use_w = xx - initial_x;
		use_h = yy - initial_y;
	}
	else if((xx < initial_x) && (yy > initial_y))
	{
		use_x = xx;
		use_y = initial_y;
		use_w = initial_x - xx;
		use_h = yy - initial_y;
	}
	else if((xx < initial_x) && (yy < initial_y))
	{
		use_x = xx;
		use_y = yy;
		use_w = initial_x - xx;
		use_h = initial_y - yy;
	}
	else if((xx > initial_x) && (yy < initial_y))
	{
		use_x = initial_x;
		use_y = yy;
		use_w = xx - initial_x;
		use_h = initial_y - yy;
	}
	resize(use_x, use_y, use_w, use_h);
	if(immediate_type == DRAWING_MODE_RECTANGLE)
	{
		rectangle->resize(use_x, use_y, use_w, use_h);
		rectangle->redraw();
	}
	if(immediate_type == DRAWING_MODE_RECTANGLE_PASSTHRU)
	{
		rectangle_passthru->resize(use_x, use_y, use_w, use_h);
		rectangle_passthru->redraw();
	}
	if(immediate_type == DRAWING_MODE_PIXELATE)
	{
		pixelate->resize(use_x, use_y, use_w, use_h);
		pixelate->redraw();
	}
	if(immediate_type == DRAWING_MODE_ELLIPSE)
	{
		ellipse->resize(use_x, use_y, use_w, use_h);
		ellipse->redraw();
	}
	if(immediate_type == DRAWING_MODE_ELLIPSE_PASSTHRU)
	{
		ellipse_passthru->resize(use_x, use_y, use_w, use_h);
		ellipse_passthru->redraw();
	}
	if(immediate_type == DRAWING_MODE_IMAGE)
	{
		if(idw != NULL)
		{
			int orig_w = idw->image_mat.cols;
			int orig_h = idw->image_mat.rows;
			double scale = (double)use_w / orig_w;
			if(use_h > use_w)
			{
				scale = (double)use_h / orig_h;
			}
			int nw = orig_w * scale;
			int nh = orig_h * scale;
			if((nw > 0) && (nh > 0))
			{
				resize(use_x, use_y, nw, nh);
				image_im->resize(use_x, use_y, nw, nh);
				image_im->redraw();
			}
		}
	}
}

// SECTION ************************************** COLOR IT WINDOW AND COLOR SLIDER **********************************************

void	color_slider_reset_cb(Fl_Widget *w, void *v)
{
	if(v != NULL)
	{
		ColorSlider *slider = (ColorSlider *)v;
		slider->value(slider->initial_value);
		slider->do_callback();
		slider->redraw();
	}
}

ColorSlider::ColorSlider(int xx, int yy, int ww, int hh, double val, char *lbl) : MySlider(xx, yy, ww, hh, lbl)
{
	color(BLACK);
	box(FL_FRAME_BOX);
	align(FL_ALIGN_LEFT);
	labelcolor(WHITE);
	labelsize(9);
	value(val);
	range(0, 255);
	step(1);
	type(FL_HOR_SLIDER);
	initial_value = val;
	if(lbl != NULL)
	{
		if(strlen(lbl) > 0)
		{
			int lx = 0;
			int ly = 0;
			int lw = 0;
			int lh = 0;
			int	rr = find_label_position(this, lx, ly, lw, lh);
			if(rr == 1)
			{
				reset = new MyButton(lx, ly, lw, lh);
				reset->box(FL_NO_BOX);
				reset->callback(color_slider_reset_cb, this);
				reset->copy_tooltip("Reset to default value");
				labelcolor(YELLOW);
			}
		}
	}
}

ColorSlider::~ColorSlider()
{
}

void	color_it_clear_last_cb(Fl_Widget *w, void *v)
{
	ColorItWindow *ciw = (ColorItWindow *)v;
	MyWin *win = ciw->my_window;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->color_it_cnt > 0)
		{
			cam->color_it_cnt--;
		}
	}
}

void	color_it_clear_all_cb(Fl_Widget *w, void *v)
{
	ColorItWindow *ciw = (ColorItWindow *)v;
	MyWin *win = ciw->my_window;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		cam->color_it_cnt = 0;
	}
}

ColorItWindow::ColorItWindow(MyWin *in_win) : Dialog(465, 280, "Dynamic Coloring")
{
	my_window = in_win;
	last_x = 0;
	last_y = 0;
	set_non_modal();

	int new_yp = 20;
	int y_pos = new_yp + 18;
	
	red_tolerance = new ColorSlider(100, y_pos, 300, 20, 24, "Red Tolerance");
	red_tolerance->callback(color_it_set_all_cb, this);
	red_tolerance->copy_tooltip("Amount of difference in the red channel to cause selection");
	y_pos += 22;
	green_tolerance = new ColorSlider(100, y_pos, 300, 20, 24, "Green Tolerance");
	green_tolerance->callback(color_it_set_all_cb, this);
	green_tolerance->copy_tooltip("Amount of difference in the green channel to cause selection");
	y_pos += 22;
	blue_tolerance = new ColorSlider(100, y_pos, 300, 20, 24, "Blue Tolerance");
	blue_tolerance->callback(color_it_set_all_cb, this);
	blue_tolerance->copy_tooltip("Amount of difference in the green channel to cause selection");
	y_pos += 32;

	local_red = 255;
	local_blue = 255;
	local_green = 255;
	local_alpha = 255;
	color_panel = new ColorPanel(in_win, &local_red, &local_green, &local_blue, &local_alpha, 4, y_pos, 450, 142);
	color_panel->red->copy_tooltip("Amount of red to use in replacement color");
	color_panel->green->copy_tooltip("Amount of green to use in replacement color");
	color_panel->blue->copy_tooltip("Amount of blue to use in replacement color");
	color_panel->alpha->copy_tooltip("Amount of alpha to use in replacement color");
	y_pos += 155;

	MyButton *clear_last_button = new MyButton(60, y_pos, 70, 20, "Clear Last");
	clear_last_button->box(FL_FLAT_BOX);
	clear_last_button->color(BLACK);
	clear_last_button->labelcolor(YELLOW);
	clear_last_button->labelsize(11);
	clear_last_button->align(FL_ALIGN_CENTER);
	clear_last_button->copy_tooltip("Restore the last selected color to original coloring");
	clear_last_button->callback(color_it_clear_last_cb, this);
	MyButton *clear_all_button = new MyButton((w() / 2) - 35, y_pos, 70, 20, "Clear All");
	clear_all_button->box(FL_FLAT_BOX);
	clear_all_button->color(BLACK);
	clear_all_button->labelcolor(YELLOW);
	clear_all_button->labelsize(11);
	clear_all_button->align(FL_ALIGN_CENTER);
	clear_all_button->copy_tooltip("Restore the all colors to original coloring");
	clear_all_button->callback(color_it_clear_all_cb, this);
	MyButton *done = new MyButton(w() - 130, y_pos, 70, 20, "Done");
	done->box(FL_FLAT_BOX);
	done->color(BLACK);
	done->labelcolor(YELLOW);
	done->labelsize(11);
	done->align(FL_ALIGN_CENTER);
	done->copy_tooltip("Close dialog");
	done->callback(hide_window_cb, this);
	end();
}

ColorItWindow::~ColorItWindow()
{
}

int		ColorItWindow::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	ColorItWindow::hide()
{
	my_window->selecting_colors = 0;
	Dialog::hide();
}

void	ColorItWindow::show()
{
	my_window->selecting_colors = 1;
	Dialog::show();
}

// SECTION ************************************** MATRIX STATE ***************************************************

MatrixState::MatrixState()
{
	strcpy(name, "");
	type = -1;
	command = -1;
	current_frame = 0;

	start_x = 0.0;
	start_y = 0.0;
	start_z = 0.0;
	end_x = 0.0;
	end_y = 0.0;
	end_z = 0.0;
	current_x = 0.0;
	current_y = 0.0;
	current_z = 0.0;
	
	node = NULL;
}

MatrixState::~MatrixState()
{
}

// SECTION ************************************** INSTRUMENT WINDOW ***************************************************

void	instrument_cb(Fl_Widget *w, void *v)
{
int	loop;

	InstrumentWindow *iw = (InstrumentWindow *)v;
	if(iw != NULL)
	{
		MyWin *my_win = iw->my_window;
		Camera *cam = iw->my_camera;
		if(cam != NULL)
		{
			for(loop = 0;loop < iw->widget_cnt;loop++)
			{
				double start_x = atof(iw->start_x_in[loop]->value());
				double start_y = atof(iw->start_y_in[loop]->value());
				double start_z = atof(iw->start_z_in[loop]->value());
				double end_x = atof(iw->end_x_in[loop]->value());
				double end_y = atof(iw->end_y_in[loop]->value());
				double end_z = atof(iw->end_z_in[loop]->value());
				int frames = atoi(iw->frames[loop]->value());
				int command = INSTRUMENT_COMMAND_SET;
				if(strcmp(iw->command[loop]->label(), "Set") == 0)
				{
					command = INSTRUMENT_COMMAND_SET;
				}
				else if(strcmp(iw->command[loop]->label(), "Once") == 0)
				{
					command = INSTRUMENT_COMMAND_ONCE;
				}
				else if(strcmp(iw->command[loop]->label(), "Repeat") == 0)
				{
					command = INSTRUMENT_COMMAND_REPEAT;
				}
				else if(strcmp(iw->command[loop]->label(), "Cycle") == 0)
				{
					command = INSTRUMENT_COMMAND_CYCLE;
				}
				int type = 0;

				osg::Node *nd = (osg::Node *)iw->start_x_in[loop]->user_data();
				std:string str = nd->getName();
				char *use = (char *)str.c_str();
				if((strncmp(use, "World Center", strlen("World Center")) == 0)
				|| (strncmp(use, "World Translate", strlen("World Translate")) == 0)
				|| (strncmp(use, "Center ", strlen("Center ")) == 0)
				|| (strncmp(use, "Translate ", strlen("Translate ")) == 0))
				{
					type = MATRIX_STATE_TYPE_TRANSLATE;
				}
				if((strncmp(use, "World Rotate", strlen("World Rotate")) == 0)
				|| (strncmp(use, "Local Rotate", strlen("Local Rotate")) == 0)
				|| (strncmp(use, "Outer Rotate ", strlen("Outer Rotate ")) == 0)
				|| (strncmp(use, "Rotate ", strlen("Rotate ")) == 0))
				{
					type = MATRIX_STATE_TYPE_ROTATE;
				}
				if((strncmp(use, "World Scale", strlen("World Scale")) == 0)
				|| (strncmp(use, "Scale ", strlen("Scale ")) == 0))
				{
					type = MATRIX_STATE_TYPE_SCALE;
				}
				strncpy(cam->matrix_state[loop]->name, use, 256);
				cam->matrix_state[loop]->type = type;
				cam->matrix_state[loop]->start_x = start_x;
				cam->matrix_state[loop]->start_y = start_y;
				cam->matrix_state[loop]->start_z = start_z;
				cam->matrix_state[loop]->current_x = start_x;
				cam->matrix_state[loop]->current_y = start_y;
				cam->matrix_state[loop]->current_z = start_z;
				cam->matrix_state[loop]->end_x = end_x;
				cam->matrix_state[loop]->end_y = end_y;
				cam->matrix_state[loop]->end_z = end_z;
				cam->matrix_state[loop]->command = command;
				cam->matrix_state[loop]->current_frame = 0;
				cam->matrix_state[loop]->frames = frames;
				cam->matrix_state[loop]->node = nd;
			}
		}
	}
}

void	instrument_command_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	if(strcmp(b->label(), "Set") == 0)
	{
		b->copy_label("Once");
	}
	else if(strcmp(b->label(), "Once") == 0)
	{
		b->copy_label("Repeat");
	}
	else if(strcmp(b->label(), "Repeat") == 0)
	{
		b->copy_label("Cycle");
	}
	else if(strcmp(b->label(), "Cycle") == 0)
	{
		b->copy_label("Set");
	}
}

void	InstrumentWindow::PopulateFromCamera()
{
int		loop;
char	buf[256];

	Camera *cam = my_camera;
	for(loop = 0;loop < cam->matrix_state_cnt;loop++)
	{
		sprintf(buf, "%g", cam->matrix_state[loop]->start_x);
		start_x_in[loop]->value(buf);
		sprintf(buf, "%g", cam->matrix_state[loop]->start_y);
		start_y_in[loop]->value(buf);
		sprintf(buf, "%g", cam->matrix_state[loop]->start_z);
		start_z_in[loop]->value(buf);

		sprintf(buf, "%g", cam->matrix_state[loop]->end_x);
		end_x_in[loop]->value(buf);
		sprintf(buf, "%g", cam->matrix_state[loop]->end_y);
		end_y_in[loop]->value(buf);
		sprintf(buf, "%g", cam->matrix_state[loop]->end_z);
		end_z_in[loop]->value(buf);

		if(cam->matrix_state[loop]->command == INSTRUMENT_COMMAND_SET)
		{
			command[loop]->copy_label("Set");
		}
		else if(cam->matrix_state[loop]->command == INSTRUMENT_COMMAND_ONCE)
		{
			command[loop]->copy_label("Once");
		}
		else if(cam->matrix_state[loop]->command == INSTRUMENT_COMMAND_REPEAT)
		{
			command[loop]->copy_label("Repeat");
		}
		else if(cam->matrix_state[loop]->command == INSTRUMENT_COMMAND_CYCLE)
		{
			command[loop]->copy_label("Cycle");
		}
		sprintf(buf, "%d", cam->matrix_state[loop]->frames);
		frames[loop]->value(buf);
	}
}

InstrumentWindow::InstrumentWindow(MyWin *in_win, Camera *in_cam, int ww, int hh) : Dialog(ww, hh, "Instruments")
{
int	loop;

	my_window = in_win;
	my_camera = in_cam;
	int new_yp = 20;
	if(my_camera != NULL)
	{
		Camera *cam = my_camera;
		if(cam->type == CAMERA_TYPE_OSG)
		{
			color(BLACK);
			node_cnt = 0;
			for(loop = 0;loop < 128;loop++)
			{
				node[loop] = NULL;
				start_x_in[loop] = NULL;
				start_y_in[loop] = NULL;
				start_z_in[loop] = NULL;
				end_x_in[loop] = NULL;
				end_y_in[loop] = NULL;
				end_z_in[loop] = NULL;

				cam->matrix_state[loop] = NULL;
			}
			Populate();

			go_button = new MyButton(10, 10 + new_yp, 60, 22, "Go");
			go_button->box(FL_FLAT_BOX);
			go_button->labelcolor(YELLOW);
			go_button->labelsize(14);
			go_button->color(BLACK);
			go_button->callback(instrument_cb, this);

			close_button = new MyButton(80, 10 + new_yp, 60, 22, "Close");
			close_button->box(FL_FLAT_BOX);
			close_button->labelcolor(YELLOW);
			close_button->labelsize(14);
			close_button->color(BLACK);
			close_button->callback(hide_window_cb, this);

			int x_pos = 230;
			int y_pos = 20 + new_yp;
			int cnt = 0;

			Fl_Box *label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Start X");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(BLACK);
			label_box->labelcolor(WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Start Y");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(BLACK);
			label_box->labelcolor(WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Start Z");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(BLACK);
			label_box->labelcolor(WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 72;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Command");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(BLACK);
			label_box->labelcolor(WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Frames");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(BLACK);
			label_box->labelcolor(WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 72;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "End X");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(BLACK);
			label_box->labelcolor(WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "End Y");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(BLACK);
			label_box->labelcolor(WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "End Z");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(BLACK);
			label_box->labelcolor(WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

			y_pos = 40 + new_yp;
			for(loop = 0;loop < node_cnt;loop++)
			{
				std:string str = node[loop]->getName();
				char *use = strdup((char *)str.c_str());
				if((strncmp(use, "World Center", strlen("World Center")) == 0)
				|| (strncmp(use, "World Translate", strlen("World Translate")) == 0)
				|| (strncmp(use, "Center ", strlen("Center ")) == 0)
				|| (strncmp(use, "Translate ", strlen("Translate ")) == 0)
				|| (strncmp(use, "World Rotate", strlen("World Rotate")) == 0)
				|| (strncmp(use, "Local Rotate", strlen("Local Rotate")) == 0)
				|| (strncmp(use, "Outer Rotate ", strlen("Outer Rotate ")) == 0)
				|| (strncmp(use, "Rotate ", strlen("Rotate ")) == 0)
				|| (strncmp(use, "World Scale", strlen("World Scale")) == 0)
				|| (strncmp(use, "Scale ", strlen("Scale ")) == 0))
				{
					Fl_Box *node_box = new Fl_Box(10, y_pos, 200, 20, use);
					node_box->box(FL_FLAT_BOX);
					node_box->color(BLACK);
					node_box->labelcolor(WHITE);
					node_box->labelsize(11);
					node_box->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);

					int x_pos = 230;
					start_x_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					start_x_in[cnt]->user_data(node[loop]);
					x_pos += 62;
					start_y_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					start_y_in[cnt]->user_data(node[loop]);
					x_pos += 62;
					start_z_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					start_z_in[cnt]->user_data(node[loop]);
					x_pos += 72;

					command[cnt] = new MyButton(x_pos, y_pos, 60, 18, "Set");
					command[cnt]->box(FL_FLAT_BOX);
					command[cnt]->labelcolor(YELLOW);
					command[cnt]->labelsize(9);
					command[cnt]->color(BLACK);
					command[cnt]->callback(instrument_command_cb, this);
					x_pos += 62;
					frames[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					x_pos += 72;

					end_x_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					end_x_in[cnt]->user_data(node[loop]);
					x_pos += 62;
					end_y_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					end_y_in[cnt]->user_data(node[loop]);
					x_pos += 62;
					end_z_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					end_z_in[cnt]->user_data(node[loop]);
					if((strncmp(use, "World Scale", strlen("World Scale")) == 0)
					|| (strncmp(use, "Scale ", strlen("Scale ")) == 0))
					{
						start_x_in[cnt]->value("1.0");
						start_y_in[cnt]->value("1.0");
						start_z_in[cnt]->value("1.0");
						end_x_in[cnt]->value("1.0");
						end_y_in[cnt]->value("1.0");
						end_z_in[cnt]->value("1.0");
					}
					if(strncmp(use, "World Scale", strlen("World Scale")) == 0)
					{
						y_pos += 31;
					}
					else
					{
						y_pos += 21;
					}
					cam->matrix_state[cnt] = new MatrixState();
					cam->matrix_state_cnt = cnt;
					cnt++;
				}
			}
			widget_cnt = cnt;
			resize(x(), y(), 800, y_pos + 20);
		}
	}
	end();
}

InstrumentWindow::~InstrumentWindow()
{
}

int	InstrumentWindow::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	InstrumentWindow::Populate()
{
int	loop;

	if(my_camera != NULL)
	{
		if(my_camera->type == CAMERA_TYPE_OSG)
		{
			osg::Group *(*osg_get_scene)(MyViewer *);
			osg_get_scene = (osg::Group *(*)(MyViewer *))void_OSG_get_scene_data;

			osg::Group *root = osg_get_scene(my_camera->osg_viewer);
			int	total = osg_walk_tree(root, 128, 0, node);
			node_cnt = total;
		}
	}
}

// SECTION ************************************** MISC COPY ***************************************************

MiscCopy::MiscCopy(Camera *in_source, int in_type, Mat local, int immediate_display, char *in_str, int in_xx, int in_yy, int in_ww, int in_hh)
{
int	loop;

	mat = local.clone();
	xx = in_xx;
	yy = in_yy;
	ww = in_ww;
	hh = in_hh;
	source = in_source;
	for(loop = 0;loop < 128;loop++)
	{
		destination[loop] = NULL;
		dest_x[loop] = -1;
		dest_y[loop] = -1;
		dest_display[loop] = 0;
	}
	destination_cnt = 0;
	type = in_type;
	display = immediate_display;
	aux_str = NULL;
	contrast = 0.5;
	brightness = 0.5;
	saturation = 1.0;
	hue = 1.0;
	intensity = 1.0;
	if(in_str != NULL)
	{
		aux_str = strdup(in_str);
	}
	quick_text = NULL;
	if(in_type == MISC_COPY_TEXT)
	{
		int ux = xx + in_source->image_sx;
		int uy = yy + in_source->image_sy;
		quick_text = new QuickText(in_source, aux_str, ux, uy, ww, hh);
		in_source->my_window->add(quick_text);
	}
}

MiscCopy::~MiscCopy()
{
	if(quick_text != NULL)
	{
		quick_text->hide();
		delete quick_text;
	}
	if(aux_str != NULL)
	{
		free(aux_str);
	}
}

// SECTION ************************************** REVIEW WINDOW AND MUX REVIEW WINDOW ***************************************************

void	review_win_play_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	ReviewWin *win = (ReviewWin *)v;
	if(win->playing == 0)
	{
		b->copy_label("@||");
		win->encode->deactivate();
		win->playing = 1;
		win->start_time = time(0);
		Fl::repeat_timeout(win->delay, review_win_cb, win);
	}
	else
	{
		b->copy_label("@>");
		win->playing = 0;
		win->encode->activate();
		win->frames_shown = 0;
	}
}

void	review_win_play_trimmed_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	ReviewWin *win = (ReviewWin *)v;
	if(win->playing == 0)
	{
		b->copy_label("@||");
		win->encode->deactivate();
		win->playing = 1;
		win->playing_trimmed = 1;
		win->start_time = time(0);
		Fl::repeat_timeout(win->delay, review_win_cb, win);
	}
	else
	{
		b->copy_label("@->");
		win->playing = 0;
		win->playing_trimmed = 0;
		win->encode->activate();
		win->frames_shown = 0;
	}
}

void	review_win_encode_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	ReviewWin *win = (ReviewWin *)v;
	if(win->playing == 0)
	{
		if(win->my_win != NULL)
		{
			if((win->my_win->encoding == 0) && (win->encoding == 0))
			{
				win->encoding = 1;
				win->my_win->Encode();
				win->encoding = 0;
			}
		}
	}
}

void	scrub_cb(void *w, void *v)
{
	MyScrubber *scrub = (MyScrubber *)w;
	ReviewWin *win = (ReviewWin *)v;
	int nn = scrub->Value();
	win->ScrubTo(nn);
}

void	speed_cb(Fl_Widget *w, void *v)
{
	Fl_Value_Slider *slider = (Fl_Value_Slider *)w;
	ReviewWin *win = (ReviewWin *)v;
	double val = slider->value();
	win->speed = val;
}

void	review_win_start_trim_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	ReviewWin *win = (ReviewWin *)v;

	int ok = win->scrub->CheckTrim(-1, win->current_frame);
	if(ok == 1)
	{
		win->scrub->AddTrim(win->current_frame, win->current_frame);
		win->end_trim_button->activate();
		win->start_trim_button->deactivate();
		win->encode->deactivate();
	}
	win->clear_trim_button->show();
	win->redraw();
}

void	review_win_end_trim_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	ReviewWin *win = (ReviewWin *)v;

	int ok = win->scrub->CheckTrim(-1, win->current_frame);
	if(ok == 1)
	{
		win->scrub->SetEndTrim(win->current_frame);
		win->end_trim_button->deactivate();
		win->start_trim_button->activate();
		win->encode->activate();
	}
	win->play_trim->show();
	win->clear_trim_button->show();
	win->redraw();
}

void	review_win_clear_trim_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	ReviewWin *win = (ReviewWin *)v;

	win->scrub->ClearTrims();

	win->end_trim_button->deactivate();
	win->start_trim_button->activate();
	win->clear_trim_button->hide();
	win->play_trim->hide();
	win->redraw();
}

void	review_win_advance_one_cb(Fl_Widget *w, void *v)
{
	ReviewWin *win = (ReviewWin *)v;
	if(win->current_frame < (win->frame_cnt - 1))
	{
		win->single_frame = 1;
		win->playing = 1;
		win->current_frame++;
		win->redraw();
	}
}

void	review_win_retreat_one_cb(Fl_Widget *w, void *v)
{
	ReviewWin *win = (ReviewWin *)v;
	if(win->current_frame > 0)
	{
		win->single_frame = 1;
		win->playing = 1;
		win->current_frame--;
		win->redraw();
	}
}

void	review_win_snap_one_cb(Fl_Widget *w, void *v)
{
char		filename[256];
struct tm	*tm;

	ReviewWin *win = (ReviewWin *)v;
	if(win->current_frame > 0)
	{
		win->single_frame = 1;
		win->playing = 1;
		win->redraw();
		
		time_t t_num = time(0);
		tm = localtime((const time_t *)&t_num);
		if(tm != NULL)
		{
		 	sprintf(filename, "photo_%04d_%02d_%02d_%02d_%02d_%02d.png", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
			Mat src = Mat(win->h(), win->w(), CV_8UC3, win->frame);
			cvtColor(src, src, COLOR_RGB2BGR);
			imwrite(filename, src);
		}
	}
}

void	add_text_cb(Fl_Widget *w, void *v)
{
	ReviewWin *win = (ReviewWin *)v;
	if(win->add_text == 0)
	{
		win->add_text = 1;
		win->add_text_button->color(WHITE);
		win->add_text_button->labelcolor(BLACK);
	}
	else
	{
		win->add_text = 0;
		win->add_text_button->color(BLACK);
		win->add_text_button->labelcolor(WHITE);
	}
}

void	moving_crop_cb(Fl_Widget *w, void *v)
{
	ReviewWin *win = (ReviewWin *)v;
	if(win->crop_activated == 0)
	{
		win->InitCrop();
		win->crop_activated = 1;
	}
	else
	{
		win->crop_activated = 0;
	}
	win->redraw();
}

void	ReviewWin::InitCrop()
{
int	loop;

	if(crop_x != NULL)
	{
		free(crop_x);
	}
	crop_x = (int *)malloc(frame_cnt * sizeof(int));
	if(crop_y != NULL)
	{
		free(crop_y);
	}
	crop_y = (int *)malloc(frame_cnt * sizeof(int));
	for(loop = 0;loop < frame_cnt;loop++)
	{
		crop_x[loop] = (w() / 2) - 320;
		crop_y[loop] = (h() / 2) - 240;
	}
}

void	close_review_window(Fl_Widget *w, void *v)
{
	ReviewWin *rw = (ReviewWin *)w;
	if(rw != NULL)
	{
		if(rw->my_win->encoding == 0)
		{
			Fl::remove_timeout(review_win_cb);
			rw->hide();
			Fl::delete_widget(rw);
		}
	}
}

void	mux_preview_refresh_cb(void *v)
{
	MuxPreviewWindow *mpw = (MuxPreviewWindow *)v;
	mpw->redraw();
	Fl::repeat_timeout(0.03, mux_preview_refresh_cb, mpw);
}

void	delete_mux_preview_window(Fl_Widget *w, void *v)
{
	MuxPreviewWindow *mpw = (MuxPreviewWindow *)v;
	Fl::remove_timeout(mux_preview_refresh_cb, mpw);
	mpw->hide();
	Fl::delete_widget(mpw);
}

void	load_mux_video_cb(Fl_Widget *w, void *v)
{
	Fl_Menu_Button *mb = (Fl_Menu_Button *)w;
	MuxPreviewWindow *mpw = (MuxPreviewWindow *)v;
	char *val = (char *)mb->text();
	if(val != NULL)
	{
		if(strcmp(val, "Cancel") != 0)
		{
			mpw->ResetMedia(val);
		}
	}
}

MuxPreviewWindow::MuxPreviewWindow(MyWin *in_win, int ww, int hh, char *title) : Fl_Double_Window(ww, hh, title)
{
int	loop;

	my_window = in_win;
	reset_button_cb(NULL, in_win);
	pthread_mutex_lock(&my_window->muxer_mutex);
	for(loop = 0;loop < 128;loop++)
	{
		if(my_window->my_muxer[loop] != NULL)
		{
			my_window->my_muxer[loop]->FinishMux();
			delete my_window->my_muxer[loop];
			my_window->my_muxer[loop] = NULL;
		}
	}
	pthread_mutex_unlock(&my_window->muxer_mutex);
	my_window->muxer_cnt = 0;
	color(BLACK);
	box(FL_NO_BOX);
	vlc_window = NULL;
	if(in_win->last_muxed_list[0] != NULL)
	{
		vlc_window = new VLC_Window(in_win->last_muxed_list[0], ww, hh);
		Fl::add_timeout(0.1, vlc_window_start_cb, vlc_window);
		Fl::add_timeout(0.1, mux_preview_refresh_cb, this);
	}
	progress_scrubber = new ProgressScrubber(in_win, this, 30, hh - 60, ww - 60, 40);
	progress_scrubber->box(FL_NO_BOX);

   	Fl_Menu_Button *popup_menu = new Fl_Menu_Button(0, 0, ww, hh - 60, "Muxed");
   	popup_menu->type(Fl_Menu_Button::POPUP3);
	popup_menu->color(BLACK);
	popup_menu->textcolor(WHITE);
	popup_menu->textsize(9);
	popup_menu->labelsize(10);
	popup_menu->box(FL_FLAT_BOX);
	for(loop = 0;loop < 64;loop++)
	{
   		if(my_window->last_muxed_list[loop] != NULL)
		{
			popup_menu->add(my_window->last_muxed_list[loop], "", load_mux_video_cb, this);
		}
	}
   	popup_menu->add("Cancel", "", NULL, this);

	end();
	callback(delete_mux_preview_window, this);
}

MuxPreviewWindow::~MuxPreviewWindow()
{
	if(vlc_window != NULL)
	{
		vlc_window->Pause();
		vlc_window->Stop();
		delete vlc_window;
		vlc_window = NULL;
	}
	if(my_window != NULL)
	{
		if(my_window->review_muxed == this)
		{
			my_window->review_muxed = NULL;
		}
	}
}

void	MuxPreviewWindow::ResetMedia(char *path)
{
	Fl::remove_timeout(mux_preview_refresh_cb, this);
	if(vlc_window != NULL)
	{
		vlc_window->Pause();
		vlc_window->Stop();
		delete vlc_window;
		vlc_window = NULL;
	}
	vlc_window = new VLC_Window(path, w(), h());
	Fl::add_timeout(0.1, vlc_window_start_cb, vlc_window);
	Fl::add_timeout(0.1, mux_preview_refresh_cb, this);
}

void	MuxPreviewWindow::draw()
{
char	buf[256];

	fl_color(BLACK);
	fl_rectf(0, 0, w(), h());
	if(vlc_window != NULL)
	{
		int width = vlc_window->mat.cols;
		int height = vlc_window->mat.rows;
		int depth = vlc_window->mat.channels();
		unsigned char *ptr = (unsigned char *)vlc_window->mat.ptr();
		if((width > 0) && (height > 0) && (ptr != NULL))
		{
			Mat mat = vlc_window->mat.clone();
			cvtColor(mat, mat, COLOR_BGR2RGB);
			fl_draw_image(mat.ptr(), 0, 0, width, height, depth);
			sprintf(buf, "%08d", vlc_window->current_frame);
			fl_font(FL_HELVETICA, 9);
			fl_color(YELLOW);
			fl_draw(buf, 20, 20);
			if(progress_scrubber != NULL)
			{
				double position = vlc_window->Position();
				progress_scrubber->Position(position);
			}
		}
	}
	Fl_Double_Window::draw();
}

int	MuxPreviewWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == ' ')
		{
			if(vlc_window->paused == 0)
			{
				vlc_window->Pause();
			}
			else
			{
				vlc_window->Resume();
			}
			flag = 1;
		}
	}
	if((event == FL_PUSH)
	|| (event == FL_RELEASE)
	|| (event == FL_MOUSEWHEEL))
	{
		if(progress_scrubber != NULL)
		{
			flag = progress_scrubber->Handle(event);
		}
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

// SECTION ************************************** TITLE BOX ***************************************************

void	title_box_remove_cb(Fl_Widget *w, void *v)
{
	TitleBox *tb = (TitleBox *)v;
	if(tb != NULL)
	{
		tb->end_frame = tb->review_window->current_frame;
		tb->hide();
		if(tb->start_frame == tb->end_frame)
		{
			tb->review_window->RemoveTitle(tb);
		}
		tb->review_window->add_text = 0;
	}
}

TitleBox::TitleBox(ReviewWin *in_win, int xx, int yy, int in_start_frame) : Fl_Window(xx, yy, 300, 100)
{
	draw_mode = 0;
	held = 0;
	init_x = 0;
	init_y = 0;
	my_color = WHITE;
	font_num = FL_HELVETICA;
	review_window = in_win;
	font_size = 12;
	start_frame = in_start_frame;
	box(FL_FRAME_BOX);
	color(BLACK);

	text_in = new Fl_Multiline_Input(0, 0, w() - 10, 100);
	text_in->textcolor(WHITE);
	text_in->color(BLACK);
	text_in->box(FL_FRAME_BOX);

	remove_button = new MyButton(w() - 10, 0, 10, 10, "X");
	remove_button->color(BLACK);
	remove_button->labelcolor(YELLOW);
	remove_button->box(FL_FRAME_BOX);
	remove_button->callback(title_box_remove_cb, this);

	end();
}

TitleBox::~TitleBox()
{
}

int	TitleBox::handle(int event)
{
	int flag = 0;
	switch(event)
	{
		case(FL_PUSH):
		{
			if(init_x < (w() - 10))
			{
				held = 1;
				init_x = Fl::event_x();
				init_y = Fl::event_y();
				flag = 1;
			}
		}
		break;
		case(FL_RELEASE):
		{
			held = 0;
			flag = 1;
		}
		break;
		case(FL_DRAG):
		{
			int diff_x = init_x - Fl::event_x();
			int diff_y = init_y - Fl::event_y();
			resize(x() - diff_x, y() - diff_y, w(), h());
			flag = 1;
		}
		break;
		case(FL_MOUSEWHEEL):
		{
			if(held == 0)
			{
				int direction = Fl::event_dy();
				font_size += direction;
				if(font_size < 4) font_size = 4;
				if(font_size > 128) font_size = 128;
				text_in->textsize(font_size);
				redraw();
			}
			else
			{
				int direction = Fl::event_dy();
				font_num += direction;
				if(font_num < 0) font_num = 15;
				if(font_num > 15) font_num = 0;
				text_in->textfont(font_num);
				redraw();
			}
			flag = 1;
		}
		break;
		case(FL_FOCUS):
		case(FL_UNFOCUS):
		case(FL_KEYBOARD):
		{
			flag = text_in->handle(event);
			review_window->redraw();
			redraw();
		}
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	TitleBox::draw()
{
	int nx = 0;
	int ny = 0;
	fl_font(font_num, font_size);
	fl_measure(text_in->value(), nx, ny);
	if(nx < 100) nx = 100;
	if(ny < 30) ny = 30;
	resize(x(), y(), nx + 10, ny + 10);
	text_in->resize(0, 0, nx, ny + 10);
	remove_button->resize(w() - 10, 0, 10, 10);
	if(draw_mode == 0)
	{
		Fl_Window::draw();
	}
	else
	{
		fl_color(WHITE);
		fl_draw(text_in->value(), x(), y(), w(), h(), FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_WRAP);
	}
}

// SECTION ************************************** REVIEW WINDOW ***************************************************

ReviewWin::ReviewWin(MyWin *in_my_win, int ww, int hh, int in_fps, char *lbl, char *in_filename) : Fl_Double_Window(ww, hh, lbl)
{
int	loop;

	color(BLACK);
	box(FL_FLAT_BOX);

	my_win = in_my_win;
	fd = -1;
	sz = 0;
	playing = 0;
	playing_trimmed = 0;
	encoding = 0;
	scrubbing = 0;
	frame_cnt = 0;
	current_frame = 0;
	single_frame = 0;
	alt_frame = NULL;
	crop_activated = 0;
	crop_x = NULL;
	crop_y = NULL;
	speed = 1.0;
	fps = 0.0;
	add_text = 0;
	title_box_cnt = 0;
	strcpy(filename, in_filename);
	for(loop = 0;loop < 1024;loop++)
	{
		title_box[loop] = NULL;
	}
	title_box_cnt = 0;
	if(fps > 0)
	{
		delay = (double)(1.0 / (double)in_fps);
	}
	else
	{
		delay = 0.03;
	}
	frame_advance = 1.0;
	start_time = 0;
	frames_shown = 0;
	sz = w() * h() * 3;
	frame = (char *)malloc(sz);
	fd = open(filename, O_RDONLY);
	if(fd > -1)
	{
		long int length = filelength(fd);
		length -= (sizeof(int) * 4);
		frame_cnt = length / sz;
		long int ts = 0;
		int read_w = 0;
		int read_h = 0;
		int read_depth = 0;
		int read_fps = 0;
	}
	controls = new Fl_Window(0, h() - 30, ww, 26);
	controls->color(BLACK);

		int nxx = 8;
		play = new MyButton(nxx, 2, 14, 14, "@>");
		play->labelcolor(WHITE);
		play->box(FL_NO_BOX);
		play->copy_tooltip("Play");
		play->callback(review_win_play_cb, this);
		nxx += 18;

		play_trim = new MyButton(nxx, 2, 14, 14, "@->");
		play_trim->labelcolor(WHITE);
		play_trim->box(FL_NO_BOX);
		play_trim->copy_tooltip("Play with trims");
		play_trim->callback(review_win_play_trimmed_cb, this);
		play_trim->hide();
		nxx += 18;

		retreat_one = new MyRepeatButton(nxx, 2, 14, 14, "-");
		retreat_one->labelcolor(WHITE);
		retreat_one->box(FL_NO_BOX);
		retreat_one->copy_tooltip("Retreat one frame");
		retreat_one->callback(review_win_retreat_one_cb, this);
		nxx += 18;

		advance_one = new MyRepeatButton(nxx, 2, 14, 14, "+");
		advance_one->labelcolor(WHITE);
		advance_one->box(FL_NO_BOX);
		advance_one->copy_tooltip("Advance one frame");
		advance_one->callback(review_win_advance_one_cb, this);
		nxx += 28;

		encode = new MyButton(nxx, 4, 14, 14, "@-4square");
		encode->labelcolor(RED);
		encode->box(FL_NO_BOX);
		encode->copy_tooltip("Encode with trims");
		encode->callback(review_win_encode_cb, this);
		nxx += 28;
	
		start_trim_button = new MyButton(nxx, 4, 14, 14, ">|");
		start_trim_button->labelcolor(WHITE);
		start_trim_button->box(FL_NO_BOX);
		start_trim_button->copy_tooltip("Start of trim");
		start_trim_button->callback(review_win_start_trim_cb, this);
		nxx += 28;
	
		end_trim_button = new MyButton(nxx, 4, 14, 14, "|<");
		end_trim_button->labelcolor(WHITE);
		end_trim_button->box(FL_NO_BOX);
		end_trim_button->copy_tooltip("End of trim");
		end_trim_button->callback(review_win_end_trim_cb, this);
		end_trim_button->deactivate();
		nxx += 28;

		clear_trim_button = new MyButton(nxx, 4, 14, 14, "@undo");
		clear_trim_button->labelcolor(WHITE);
		clear_trim_button->box(FL_NO_BOX);
		clear_trim_button->copy_tooltip("Reset all trims");
		clear_trim_button->callback(review_win_clear_trim_cb, this);
		clear_trim_button->hide();
		nxx += 48;

		snap_one_button = new MyButton(nxx, 4, 14, 14, "@-7circle");
		snap_one_button->labelcolor(WHITE);
		snap_one_button->box(FL_NO_BOX);
		snap_one_button->copy_tooltip("Save as image");
		snap_one_button->callback(review_win_snap_one_cb, this);
		nxx += 28;

		moving_crop_button = new MyButton(nxx, 4, 14, 14, "");
		moving_crop_button->labelcolor(WHITE);
		moving_crop_button->box(FL_FRAME_BOX);
		moving_crop_button->copy_tooltip("Moving Crop");
		moving_crop_button->callback(moving_crop_cb, this);
		nxx += 28;
	
		add_text_button = new MyButton(nxx, 4, 17, 17, "T");
		add_text_button->labelcolor(WHITE);
		add_text_button->color(BLACK);
		add_text_button->box(FL_FRAME_BOX);
		add_text_button->copy_tooltip("Titles");
		add_text_button->callback(add_text_cb, this);
		nxx += 28;
	
		speed_slider = new Fl_Value_Slider(w() - 180, 3, 160, 12);
		speed_slider->type(FL_HOR_NICE_SLIDER);
		speed_slider->color(BLACK);
		speed_slider->textcolor(WHITE);
		speed_slider->box(FL_FLAT_BOX);
		speed_slider->range(0.01, 10.0);
		speed_slider->value(1.0);
		speed_slider->step(0.01);
		speed_slider->copy_tooltip("Playback and encoding speed");
		speed_slider->callback(speed_cb, this);

		frame_box = new Fl_Box(w() - (240 + 180), 2, 240, 13, "");
		frame_box->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		frame_box->labelcolor(WHITE);
		frame_box->labelsize(9);
		frame_box->box(FL_NO_BOX);
	controls->end();

	scrub = new MyScrubber(5, h() - 52, w() - 10, 16);
	scrub->color(BLACK);
	scrub->box(FL_FRAME_BOX);
	scrub->Range(frame_cnt);
	scrub->Callback(scrub_cb, this);

	controls->show();
	callback(close_review_window, this);
	set_modal();

	my_win->review_button->hide();
	my_win->review_muxed_button->hide();
	my_win->button_group->hide();
	my_win->buttons_shown = 0;
}

ReviewWin::~ReviewWin()
{
int	loop;

	if(fd != -1)
	{
		close(fd);
		fd = -1;
	}
	if(frame != NULL)
	{
		free(frame);
		frame = NULL;
	}
	if(main != NULL)
	{
		if(main->review == this)
		{
			main->review = NULL;
		}
	}
	for(loop = 0;loop < 1024;loop++)
	{
		if(title_box[loop] != NULL)
		{
			Fl::delete_widget(title_box[loop]);
			title_box[loop] = NULL;
		}
	}
	my_win->review_button->show();
}

int	ReviewWin::AdvanceToTrim(int fdx)
{
int	loop;

	int min_distance = 100000000;
	int save_frame = -1;
	for(loop = 0;loop < scrub->trim_cnt;loop++)
	{
		int distance = scrub->start_trim[loop] - current_frame;
		if(distance > 0)
		{
			if(distance < min_distance)
			{
				min_distance = distance;
				save_frame = scrub->start_trim[loop];
			}
		}
	}
	if(save_frame > -1)
	{
		current_frame = save_frame;
		off_t nn = (off_t)((off_t)current_frame * (off_t)(sz + sizeof(long int))) + (off_t)(sizeof(int) * 4);
		lseek(fdx, nn, SEEK_SET);
	}
	return(save_frame);
}

void	ReviewWin::RenderTitles()
{
int	loop;
int	inner;

	if(title_box_cnt > 0)
	{
		int local_fd = open("encode_video.bin", O_RDONLY);
		if(local_fd > -1)
		{
			uchar *data_p = (uchar *)malloc(w() * h() * 3);
			if(data_p != NULL)
			{
				Fl_Offscreen off = fl_create_offscreen(w(), h());
				fl_begin_offscreen(off);
				for(loop = 0;loop < title_box_cnt;loop++)
				{
					if(title_box[loop] != NULL)
					{
						title_box[loop]->hide();
						title_box[loop]->draw_mode = 1;
						int start = title_box[loop]->start_frame;
						int end = title_box[loop]->end_frame;
						for(inner = start;inner < end;inner++)
						{
							long int ts = 0;
							off_t nn = (off_t)((off_t)inner * (off_t)(sz + sizeof(long int))) + (off_t)(sizeof(int) * 4);
							lseek(local_fd, nn, SEEK_SET);
							if(read_frame(local_fd, frame, sz, &ts) == sz)
							{
								fl_draw_image((unsigned char *)frame, 0, 0, w(), h(), 3);
								char *str = (char *)title_box[loop]->text_in->value();
								int xx = title_box[loop]->x();
								int yy = title_box[loop]->y();
								int ww = title_box[loop]->w();
								int hh = title_box[loop]->h();
								int tb_color = title_box[loop]->my_color;
								int fs = title_box[loop]->font_size;
								int fn = title_box[loop]->font_num;
								fl_color(tb_color);
								fl_font(fn, fs);
								fl_draw(str, xx, yy, ww, hh, FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_WRAP);
								uchar *p = fl_read_image(data_p, 0, 0, w(), h(), 0);
								if(p != NULL)
								{
									lseek(local_fd, nn, SEEK_SET);
									write_frame(local_fd, data_p, sz, ts);
								}
							}
						}
					}
				}
				fl_end_offscreen();
				free(data_p);
			}
			close(local_fd);
		}
	}
}

int	ReviewWin::AdjustToTrim(int check_only)
{
int	loop;

	int min_distance = 100000000;
	int save_frame = -1;
	int flag = 0;
	if(check_only == 0)
	{
		for(loop = 0;((loop < scrub->trim_cnt) && (flag == 0));loop++)
		{
			if((current_frame >= scrub->start_trim[loop]) && (current_frame <= scrub->end_trim[loop]))
			{
				flag = 1;
			}
			if(flag == 0)
			{
				int distance = scrub->start_trim[loop] - current_frame;
				if(distance > 0)
				{
					if(distance < min_distance)
					{
						min_distance = distance;
						save_frame = scrub->start_trim[loop];
					}
				}
			}
		}
		if(flag == 0)
		{
			if(save_frame > -1)
			{
				current_frame = save_frame;
				flag = 1;
			}
		}
		if(flag == 0)
		{
			current_frame = 0;
			playing = 0;
			playing_trimmed = 0;
			play_trim->copy_label("@->");
			encode->activate();
			frames_shown = 0;
		}
	}
	else
	{
		for(loop = 0;((loop < scrub->trim_cnt) && (flag == 0));loop++)
		{
			if((current_frame >= scrub->start_trim[loop]) && (current_frame <= scrub->end_trim[loop]))
			{
				flag = 1;
			}
		}
	}
	return(flag);
}

int	ReviewWin::handle(int event)
{
int	loop;

	int flag = 0;
	switch(event)
	{
		case(FL_FOCUS):
		case(FL_UNFOCUS):
		{
			flag = 1;
		}
		break;
		case(FL_KEYBOARD):
		{
			int key = Fl::event_key();
			if((key == '.') || (key == FL_Up))
			{
				if(current_frame < (frame_cnt - 1))
				{
					single_frame = 1;
					playing = 1;
					current_frame++;
					redraw();
				}
				flag = 1;
			}
			if((key == ',') || (key == FL_Down))
			{
				if(current_frame > 0)
				{
					single_frame = 1;
					playing = 1;
					current_frame--;
					redraw();
				}
				flag = 1;
			}
			if(key == ' ')
			{
				if(playing == 1)
				{
					playing = 0;
				}
				else
				{
					playing = 1;
				}
				flag = 1;
			}
		}
		break;
		case(FL_PUSH):
		{
			if(crop_activated == 1)
			{
				if((current_frame > -1) && (current_frame < frame_cnt))
				{
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					if(yy < (h() - 52))
					{
						xx -= 360;
						yy -= 240;
						if(xx < 0) xx = 0;
						if(yy < 0) yy = 0;
						if((xx + 360) > w()) xx = w() - 640;
						if((yy + 240) > h()) yy = h() - 480;
						for(loop = current_frame;loop < frame_cnt;loop++)
						{
							crop_x[loop] = xx;
							crop_y[loop] = yy;
						}
						flag = 1;
						redraw();
					}
				}
			}
			else if(add_text == 1)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if(yy < (h() - 52))
				{
					for(loop = 0;loop < title_box_cnt;loop++)
					{
						if(title_box[loop] != NULL)
						{
							flag = title_box[loop]->handle(event);
						}
					}
					if(flag == 0)
					{
						if(title_box_cnt < 1023)
						{
							TitleBox *title = new TitleBox(this, xx, yy, current_frame);
							add(title);
							title->show();
							int done = 0;
							for(loop = 0;((loop < title_box_cnt) && (done == 0));loop++)
							{
								if(title_box[loop] == NULL)
								{
									title_box[loop] = title;
									done = 1;
								}
							}
							if(done == 0)
							{
								title_box[title_box_cnt] = title;
								title_box_cnt++;
							}
							add_text = 2;
							add_text_button->color(BLACK);
							add_text_button->labelcolor(WHITE);
						}
						flag = 1;
					}
				}
			}
		}
		break;
		case(FL_MOUSEWHEEL):
		{
			if(add_text == 0)
			{
				int amount = 1;
				char *text = (char *)Fl::event_text();
				if(text != NULL)
				{
					char key = *text;
					if(key == 'S')
					{
						amount = (int)fps;
					}
					else if(key == 'M')
					{
						amount = (int)(fps * 60);
					}
				}
				int direction = Fl::event_dy();
				if(direction > 0)
				{
					if(current_frame < (frame_cnt - amount))
					{
						single_frame = 1;
						playing = 1;
						current_frame += amount;
						redraw();
					}
					flag = 1;
				}
				else if(direction < 0)
				{
					if(current_frame >= amount)
					{
						single_frame = 1;
						playing = 1;
						current_frame -= amount;
						redraw();
					}
					flag = 1;
				}
			}
		}
		break;
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

void	ReviewWin::draw()
{
static char buf[256];
int	loop;

	Camera *cam = main->camera[main->displayed_source];
	Fl_Double_Window::draw();
	if((fd != -1) && ((playing > 0) || (scrubbing == 1)))
	{
		if(single_frame == 0)
		{
			if(speed >= 1.0)
			{
				frame_advance = (int)speed;
			}
			else
			{
				frame_advance = 1.0;
			}
		}
		long int ts = 0;
		off_t nn = (off_t)((off_t)current_frame * (off_t)(sz + sizeof(long int))) + (off_t)(sizeof(int) * 4);
		lseek(fd, nn, SEEK_SET);
		if(read_frame(fd, frame, sz, &ts) == sz)
		{
			int go_ahead = 1;
			if(playing_trimmed == 1)
			{
				go_ahead = AdjustToTrim(0);
			}
			if(go_ahead == 1)
			{
				fl_draw_image((unsigned char *)frame, 0, 0, w(), h(), 3);
			}
			if(single_frame == 0)
			{
				if(playing == 1)
				{
					current_frame += (int)frame_advance;
				}
			}
			else
			{
				playing = 0;
				single_frame = 0;
			}
			if((playing > 0) && (scrubbing == 0))
			{
				frames_shown++;
			}
		}
		else
		{
			lseek(fd, sizeof(int) * 4, SEEK_SET);
			playing = 0;
			play->copy_label("@>");
			current_frame = 0;
			frames_shown = 0;
		}
		if(scrubbing == 1)
		{
			scrubbing = 0;
		}
	}
	else
	{
		if(alt_frame != NULL)
		{
			fl_draw_image((unsigned char *)alt_frame, 0, 0, w(), h(), 3);
		}
		else
		{
			off_t nn = (off_t)((off_t)current_frame * (off_t)(sz + sizeof(long int))) + (off_t)(sizeof(int) * 4);
			lseek(fd, nn, SEEK_SET);
			long int ts = 0;
			if(read_frame(fd, frame, sz, &ts) == sz)
			{
				fl_draw_image((unsigned char *)frame, 0, 0, w(), h(), 3);
			}
		}
		frames_shown = 0;
	}
	time_t current_time = time(0);
	int time_diff = current_time - start_time;
	fps = cam->fps;
	if(time_diff > 0)
	{
		double d_fps = (double)frames_shown / (double)time_diff;
		if(speed == 1.0)
		{
			if(d_fps < cam->fps)
			{
				if(delay > 0.00001)
				{
					delay -= 0.00001;
				}
			}
			else if(d_fps > cam->fps)
			{
				delay += 0.00001;
			}
		}
	}
	if(crop_activated == 1)
	{
		if((crop_x[current_frame] > -1) && (crop_y[current_frame] > -1))
		{
			fl_color(YELLOW);
			fl_rect(crop_x[current_frame], crop_y[current_frame], 640, 480);
		}
	}
	if(add_text == 0)
	{
		for(loop = 0;loop < title_box_cnt;loop++)
		{
			if(title_box[loop] != NULL)
			{
				if((current_frame >= title_box[loop]->start_frame)
				&& (current_frame <= title_box[loop]->end_frame))
				{
					title_box[loop]->draw_mode = 1;
					title_box[loop]->hide();
					title_box[loop]->draw();
				}
				else
				{
					title_box[loop]->draw_mode = 0;
					title_box[loop]->hide();
				}
			}
		}
	}
	sprintf(buf, "(%06d of %06d) %0.2f FPS", current_frame, frame_cnt, fps);
	frame_box->copy_label(buf);
	scrub->current = current_frame;
	scrub->redraw();
}

void	ReviewWin::RemoveTitle(TitleBox *tb)
{
int	loop;

	int done = 0;
	for(loop = 0;((loop < title_box_cnt) && (done == 0));loop++)
	{
		if(title_box[loop] == tb)
		{
			Fl::delete_widget(title_box[loop]);
			title_box[loop] = NULL;
			done = 1;
		}
	}
}

void	ReviewWin::ScrubTo(int nn)
{
	if(fd > -1)
	{
		if(nn != current_frame)
		{
			long int ts = 0;
			int nnn = nn * sz;
			current_frame = nn;
			if(read_frame(fd, frame, sz, &ts) == sz)
			{
				if(playing == 0)
				{
					scrubbing = 1;
				}
				redraw();
			}
			frames_shown = 0;
		}
	}
}

void	read_video_header(int fdx, int *uw, int *uh, int *depth, int *ufps)
{
	read(fdx, uw, sizeof(int));
	read(fdx, uh, sizeof(int));
	read(fdx, depth, sizeof(int));
	read(fdx, ufps, sizeof(int));
}

void	write_video_header(int fdx, int uw, int uh, int depth, int ufps)
{
	write(fdx, &uw, sizeof(int));
	write(fdx, &uh, sizeof(int));
	write(fdx, &depth, sizeof(int));
	write(fdx, &ufps, sizeof(int));
}

long int	ReviewWin::EditToTrim(int *used_frames)
{
int	loop, outer, inner;
long int	start_tc[1024];
long int	end_tc[1024];

	my_win->dump_type = "Extracting";
	my_win->dumped_frames = 0;
	my_win->dumped_limit = 0;
	my_win->redraw();
	Fl::check();

	int retained_frames = 0;
	long int last_used_ts = 0;
	scrub->SortTrim();
	int total_trim = scrub->CountTrim();
	if((scrub->trim_cnt > 0) && (scrub->trim_cnt < 1024))
	{
		for(loop = 0;loop < 1024;loop++)
		{
			start_tc[loop] = 0;
			end_tc[loop] = 0;
		}
		int fdi = open("encode_video.bin", O_RDONLY);
		if(fdi < 0)
		{
			fdi = open("video.bin", O_RDONLY);
		}
		if(fdi > -1)
		{
			long int length = filelength(fdi);
			length -= (sizeof(int) * 4);
			int dumped_frame_cnt = length / sz;
		
			my_win->dump_type = "Extracting";
			my_win->dumped_frames = 0;
			my_win->dumped_limit = total_trim;
			my_win->redraw();
			Fl::check();
			int fdo = open("video_output.bin", O_WRONLY | O_CREAT | O_TRUNC, 0666);
			if(fdo > -1)
			{
				int uw;
				int uh;
				int depth;
				int ufps;
				long int length = filelength(fdi);
				read_video_header(fdi, &uw, &uh, &depth, &ufps);
				write_video_header(fdo, uw, uh, depth, ufps);
				int in_frame = 0;
				int sz = uw * uh * depth;
				void *ptr = malloc(sz);
				void *last_frame = malloc(sz);
				if((ptr != NULL) && (last_frame != NULL))
				{
					memset(last_frame, 0, sz);
					int flag = 0;
					int done = 0;
					off_t seek_it = -1;
					long int accum_ts = 0;
					long int start_gap = 0;
					long int end_gap = 0;
					int *new_crop_x = NULL;
					int *new_crop_y = NULL;
					if(crop_activated == 1)
					{
						new_crop_x = (int *)malloc(frame_cnt * sizeof(int));
						new_crop_y = (int *)malloc(frame_cnt * sizeof(int));
					}
					for(outer = 0;outer < scrub->trim_cnt;outer++)
					{
						long int ts = 0;
						double transition_cnt = 0.0;
						if(my_win->transition > 0)
						{
							transition_cnt = 1.0;
						}
						for(inner = scrub->start_trim[outer];inner < scrub->end_trim[outer];inner++)
						{
							my_win->redraw();
							Fl::check();

							off_t nn = (off_t)((off_t)inner * (off_t)(sz + sizeof(long int))) + (off_t)(sizeof(int) * 4);
							seek_it = lseek(fdi, nn, SEEK_SET);
							nn = read_frame(fdi, ptr, sz, &ts);
							if(nn == sz)
							{
								if((new_crop_x != NULL) && (new_crop_y != NULL)
								&& (crop_x != NULL) && (crop_y != NULL))
								{
									new_crop_x[in_frame] = crop_x[inner];
									new_crop_y[in_frame] = crop_y[inner];
								}
								retained_frames++;
								if(inner == scrub->start_trim[outer])
								{
									start_tc[outer] = ts;
									end_gap = ts;
									accum_ts += (end_gap - start_gap);
								}
								long int use_ts = ts - accum_ts;

								if(transition_cnt > 0.0)
								{
									Mat image1(Size(w(), h()), CV_8UC3, ptr);
									Mat image2(Size(w(), h()), CV_8UC3, last_frame);

									addWeighted(image2, transition_cnt, image1, 1.0 - transition_cnt, 0.0, image1);
									transition_cnt -= 0.1;
								}
								write_frame(fdo, ptr, sz, use_ts);
								last_used_ts = use_ts;
								in_frame++;

								my_win->dumped_frames = in_frame;
								my_win->dump_type = "Extracting Video";
								my_win->dumped_limit = total_trim;
							}
						}
						memcpy(last_frame, ptr, sz);
						end_tc[outer] = ts;
						start_gap = ts;
					}
					if(my_win->transition > 0)
					{
						memset(last_frame, 0, sz);
						double transition_cnt = 1.0;
						for(loop = 0;loop < 100;loop++)
						{
							if(transition_cnt > 0.0)
							{
								Mat image1(Size(w(), h()), CV_8UC3, ptr);
								Mat image2(Size(w(), h()), CV_8UC3, last_frame);

								addWeighted(image1, transition_cnt, image2, 1.0 - transition_cnt, 0.0, image1);
								transition_cnt -= 0.01;
							}
							write_frame(fdo, ptr, sz, last_used_ts);
						}
					}
					if((new_crop_x != NULL) && (new_crop_y != NULL)
					&& (crop_x != NULL) && (crop_y != NULL))
					{
						free(crop_x);
						free(crop_y);
						crop_x = new_crop_x;
						crop_y = new_crop_y;
					}
					free(ptr);
					free(last_frame);
				}
				close(fdo);
			}
			close(fdi);
			if(access("encode_audio.bin", 0) == 0)
			{
				my_win->dumped_limit = -1;
				my_win->dump_type = "Extracting Audio";
				my_win->dumped_frames = 0;
				my_win->redraw();
				Fl::check();
				int fdi = open("encode_audio.bin", O_RDONLY);
				if(fdi > -1)
				{
					long int length = filelength(fdi);
					length -= sizeof(int);
					int dumped_frame_cnt = length / sizeof(short int);

					int fdo = open("audio_output.bin", O_WRONLY | O_CREAT | O_TRUNC, 0666);
					if(fdo > -1)
					{
						int hz;
						int channels;
						read(fdi, &channels, sizeof(int));
						read(fdi, &hz, sizeof(int));
						if(hz <= 0)
						{
							hz = my_win->audio_sample_rate;
						}
						write(fdo, &channels, sizeof(int));
						write(fdo, &hz, sizeof(int));
						int done = 0;
						double calc_time = 0.0;
						short int sample;
						int sample_cnt = 0;

						while(done == 0)
						{
							int nn = read(fdi, &sample, sizeof(short int));
							if(nn == sizeof(short int))
							{
								calc_time += ((1.0 / (double)hz) * 1000.0);
								int flag = 0;
								for(loop = 0;((loop < scrub->trim_cnt) && (flag == 0));loop++)
								{
									if((calc_time >= start_tc[loop]) && (calc_time <= end_tc[loop]))
									{
										flag = 1;
									}
								}
								if(flag == 1)
								{
									write(fdo, &sample, sizeof(short int));
									my_win->dumped_frames++;
									my_win->dumped_limit = dumped_frame_cnt;
									if((sample_cnt % 10000) == 0)
									{
										my_win->redraw();
										Fl::check();
									}
								}
								sample_cnt++;
							}
							else
							{
								done = 1;
							}
						}
						close(fdo);
					}
					close(fdi);
				}
			}
		}
	}
	my_win->dumped_frames = 0;
	my_win->dumped_limit = -1;
	my_win->dump_type = NULL;
	my_win->redraw();
	Fl::check();
	*used_frames = retained_frames;
	return(last_used_ts);
}

// SECTION ************************************** THUMB BUTTON AND THUMB GROUP ***************************************************

VideoThumbnailGroup::VideoThumbnailGroup(MyWin *in_win, int xx, int yy, int ww, int hh) : SlidingElement(in_win, OPEN_RIGHT, xx, yy, ww, hh)
{
	my_window = in_win;
	hovering = 0;
	start_thumbgroup = 0;
}

VideoThumbnailGroup::~VideoThumbnailGroup()
{
}

int	VideoThumbnailGroup::handle(int event)
{
	int flag = 0;
	if(event == FL_ENTER)
	{
		hovering = 1;
	}
	else if(event == FL_LEAVE)
	{
		hovering = 0;
	}
	else if(event == FL_MOUSEWHEEL)
	{
		if(hovering == 1)
		{
			int direction = Fl::event_dy();
			if(direction > 0)
			{
				ScrollDownThumbgroup();
			}
			else
			{
				ScrollUpThumbgroup();
			}
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = SlidingElement::handle(event);
	}
	return(flag);
}

void	VideoThumbnailGroup::CycleDownThumbgroup()
{
	int nn = my_window->displayed_source;
	nn++;
	if(nn >= my_window->source_cnt)
	{
		nn = 0;
		start_thumbgroup = 0;
	}
	if(nn >= (start_thumbgroup + DISPLAYED_THUMB_CNT))
	{
		start_thumbgroup++;
		if(start_thumbgroup >= my_window->source_cnt)
		{
			start_thumbgroup = 0;
		}
	}
	my_window->DisplayCamera(nn);
}

void	VideoThumbnailGroup::CycleUpThumbgroup()
{
	int nn = my_window->displayed_source;
	nn--;
	if(nn < 0)
	{
		nn = my_window->source_cnt - 1;
		while(nn >= (start_thumbgroup + DISPLAYED_THUMB_CNT))
		{
			start_thumbgroup++;
		}
	}
	if(nn < start_thumbgroup)
	{
		start_thumbgroup = nn;
	}
	my_window->DisplayCamera(nn);
}

void	VideoThumbnailGroup::ScrollDownThumbgroup()
{
	start_thumbgroup++;
	if(start_thumbgroup >= my_window->source_cnt)
	{
		start_thumbgroup = my_window->source_cnt - 1;
	}
}

void	VideoThumbnailGroup::ScrollUpThumbgroup()
{
	start_thumbgroup--;
	if(start_thumbgroup <= 0)
	{
		start_thumbgroup = 0;
	}
}

int	VideoThumbnailGroup::DisplayThumbgroup(int nn)
{
	int flag = 0;
	if((nn >= 0) && (nn < my_window->source_cnt))
	{
		while(nn < start_thumbgroup)
		{
			start_thumbgroup--;
		}
		while(nn >= (start_thumbgroup + DISPLAYED_THUMB_CNT))
		{
			start_thumbgroup++;
		}
		my_window->DisplayCamera(nn);
		flag = 1;
	}
	return(flag);
}

void	VideoThumbnailGroup::ScrollToDisplayed()
{
	MyWin *win = my_window;
	while(win->displayed_source >= (start_thumbgroup + DISPLAYED_THUMB_CNT))
	{
		start_thumbgroup++;
	}
}

void	thumb_remove_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	for(loop = 0;loop < 128;loop++)
	{
		if(tg == win->thumbnail[loop])
		{
			tg->hide();
			ThumbButton *tb = tg->thumb_button;
			int idx = tb->index;
			if(idx > -1)
			{
				Camera *cam = win->camera[idx];
				if(cam != NULL)
				{
					win->RemoveCamera(cam);
					int done = 0;
					while(done == 0)
					{
						Camera *new_cam = win->camera[win->displayed_source];
						if((new_cam != NULL) || (win->displayed_source == 0))
						{
							done = 1;
						}
						else
						{
							win->displayed_source--;
						}
					}
				}
				tb->index = -1;
			}
		}
	}
}

void	thumb_place_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		Camera *dest = win->DisplayedCamera();
		if(dest != NULL)
		{
			if(cam != dest)
			{
				if(dest->type == CAMERA_TYPE_SPLIT)
				{
					if(dest->my_window->dragging_thumb != NULL)
					{
						int nx = dest->my_window->dragging_thumb_x - dest->image_sx;
						int ny = dest->my_window->dragging_thumb_y - dest->image_sy;
						int nnx = ((double)dest->split_cols / (double)dest->width) * nx;
						int nny = ((double)dest->split_rows / (double)dest->height) * ny;
						int nn = (dest->split_cols * nny) + nnx;
						if((nn > -1) && (nn < 128))
						{
							if(dest->split_source[nn] != NULL)
							{
								free(dest->split_source[nn]);
							}
							dest->split_source[nn] = strdup(cam->alias);
						}
					}
				}
				else
				{
					if(cam->source_camera != dest)
					{
						if(dest->CheckRecurseChildren(cam, dest) == 0)
						{
							dest->AddImageWindow(cam);
							if(win != NULL)
							{
								if(win->immediate_drawing_window != NULL)
								{
									win->immediate_drawing_window->redraw();
								}
							}
						}
					}
				}
			}
		}
	}
}

void	thumb_record_button_cb(Fl_Widget *w, void *v)
{
void	record_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();

	int save_index = win->displayed_source;
	win->DisplayCamera(tg->index);
	record_button_cb(w, v);
}

void	thumb_motion_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	int save_index = win->displayed_source;
	win->DisplayCamera(tg->index);
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		cam->record_trigger |= ON_DETECT_MOTION;
	}
	win->DisplayCamera(save_index);
}

void	thumb_instrument_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		if(cam->instrument_window == NULL)
		{
			cam->instrument_window = new InstrumentWindow(win, cam, 600, 1000);
		}
		else
		{
			cam->instrument_window->PopulateFromCamera();
		}
		if(cam->instrument_window != NULL)
		{
			cam->instrument_window->show();
		}
	}
}

void	thumb_object_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();

	int save_index = win->displayed_source;
	win->DisplayCamera(tg->index);
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		cam->record_trigger |= ON_DETECT_OBJECT;
	}
	win->DisplayCamera(save_index);
}

void	thumb_background_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	int red = 200;
	int green = 200;
	int blue = 200;
	int alpha = 255;
	if(my_color_chooser("Background Color", red, green, blue, alpha))
	{
		Camera *cam = win->camera[tg->index];
		if(cam != NULL)
		{
			cam->red = red;
			cam->green = green;
			cam->blue = blue;
			if((cam->type != CAMERA_TYPE_TEXT) 
			&& (cam->type != CAMERA_TYPE_DYNAMIC_TEXT)
			&& (cam->type != CAMERA_TYPE_ALERT)
			&& (cam->type != CAMERA_TYPE_PIPED)
			&& (cam->type != CAMERA_TYPE_CLOCK)
			&& (cam->type != CAMERA_TYPE_TIMER))
			{
				cam->mat.setTo(cv::Scalar(red, green, blue));
				cam->reserve_mat.setTo(cv::Scalar(red, green, blue));
			}
			cam->static_initialized = 0;
		}
	}
}

void	thumb_text_color_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	int red = 200;
	int green = 200;
	int blue = 200;
	int alpha = 255;
	if(my_color_chooser("Text Color", red, green, blue, alpha))
	{
		Camera *cam = win->camera[tg->index];
		if(cam != NULL)
		{
			cam->text_red = red;
			cam->text_green = green;
			cam->text_blue = blue;
			cam->static_initialized = 0;
		}
	}
}

void	thumb_pause_av_button_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)b->parent();
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		if(cam->av_window != NULL)
		{
			if(cam->av_window->paused == 1)
			{
				cam->av_window->Resume();
				b->copy_label("Pause");
			}
			else
			{
				cam->av_window->Pause();
				b->copy_label("Resume");
			}
		}
	}
}

void	thumb_mute_av_button_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)b->parent();
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		if(cam->av_window != NULL)
		{
			if(cam->av_window->muted == 1)
			{
				cam->av_window->UnMute();
				b->copy_label("Mute");
			}
			else
			{
				cam->av_window->Mute();
				b->copy_label("Unmute");
			}
		}
	}
}

void	thumbnail_cb(Fl_Widget *w, void *v)
{
int		loop;

	MyWin *win = (MyWin *)v;
	int done = 0;
	for(loop = 0;((loop < 128) && (done == 0));loop++)
	{
		if((w == win->thumbnail[loop]->thumb_button)
		|| (w == win->trigger_window->thumbnail[loop]))
		{
			Camera *cam = win->camera[loop];
			win->DisplayCamera(cam);
			done = 1;
		}
	}
}

void	thumbgroup_change_alias_cb(Fl_Widget *w, void *v)
{
int	loop;

	ThumbGroup *tg = (ThumbGroup *)v;
	tg->alias_button->hide();
	tg->alias_input->value(tg->alias_button->label());
	tg->alias_input->take_focus();
	tg->alias_input->show();
	Fl::focus(tg->alias_input);
}

void	thumbgroup_edit_alias_cb(Fl_Widget *w, void *v)
{
int	loop;

	ThumbGroup *tg = (ThumbGroup *)v;
	char *str = (char *)tg->alias_input->value();
	tg->alias_input->hide();
	tg->alias_button->show();
	Camera *cam = tg->my_win->camera[tg->index];
	if(cam != NULL)
	{
		MyWin *my_win = cam->my_window;
		strcpy(cam->alias, str);
		if(my_win->ptz_mode != 0)
		{
			for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
			{
				if(my_win->ptz_window[loop] != NULL)
				{
					if(my_win->ptz_window[loop]->bound_camera == cam)
					{
						my_win->ptz_window[loop]->ptz_bound_name_box->value(cam->alias);
					}
				}
			}
		}
	}
	tg->alias_button->copy_label(cam->alias);
}

ThumbGroup::ThumbGroup(MyWin *win, int idx, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_win = win;
	index = idx;
	Camera *cam = NULL;
	displayed = 0;
	if(idx > -1)
	{
		cam = win->camera[index];
	}
	align(FL_ALIGN_BOTTOM | FL_ALIGN_CENTER);
	labelcolor(YELLOW);
	labelsize(16);
	color(BLACK);
	if(my_win->transparent_interface == 0)
	{
		box(FL_FLAT_BOX);
	}
	else
	{
		box(FL_NO_BOX);
	}
	thumb_button = new ThumbButton(my_win, idx, 2, 2, 153, 86);
	thumb_button->box(FL_NO_BOX);
	thumb_button->copy_tooltip("Select to view this camera");
	thumb_button->callback(thumbnail_cb, win);

	char *str = "";
	if(cam != NULL)
	{
		str = cam->alias;
	}
	alias_button = new MyButton(2, 90, 153, 20);
	alias_button->box(FL_NO_BOX);
	alias_button->color(BLACK);
	alias_button->labelcolor(YELLOW);
	alias_button->labelsize(11);
	alias_button->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
	alias_button->copy_label(str);
	alias_button->copy_tooltip("Edit the camera alias");
	alias_button->callback(thumbgroup_change_alias_cb, this);
	alias_button->show();

	alias_input = new Fl_Input(2, 90, 153, 20);
	alias_input->box(FL_NO_BOX);
	alias_input->color(BLACK);
	alias_input->textcolor(WHITE);
	alias_input->textsize(11);
	alias_input->cursor_color(WHITE);
	alias_input->copy_tooltip("Edit the camera alias");
	alias_input->when(FL_WHEN_ENTER_KEY);
	alias_input->callback(thumbgroup_edit_alias_cb, this);
	alias_input->hide();

	remove = new MyButton(4, 4, 16, 16, "X");
	remove->box(FL_BORDER_FRAME);
	remove->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	remove->color(YELLOW);
	remove->labelcolor(WHITE);
	remove->labelsize(8);
	remove->copy_tooltip("Remove the camera");
	remove->callback(thumb_remove_button_cb, win);

	place = new MyButton(20, 4, 16, 16);
	place->box(FL_BORDER_FRAME);
	place->color(YELLOW);
	place->align(FL_ALIGN_RIGHT);
	place->labelcolor(WHITE);
	place->labelsize(8);
	place->labelsize(8);
	place->copy_tooltip("Place the camera on the currently viewed video");
	place->callback(thumb_place_button_cb, win);

	int cy = 2;
	record = new MyButton(157, cy, 16, 16, "Recording");
	record->box(FL_BORDER_FRAME);
	record->color(YELLOW);
	record->align(FL_ALIGN_RIGHT);
	record->labelcolor(WHITE);
	record->labelsize(8);
	record->copy_tooltip("Record indicator and button");
	record->callback(thumb_record_button_cb, win);
	cy += 18;

	detect_motion = new MyButton(157, 20, 16, 16, "Detecting Motion");
	detect_motion->box(FL_BORDER_FRAME);
	detect_motion->color(YELLOW);
	detect_motion->align(FL_ALIGN_RIGHT);
	detect_motion->labelcolor(WHITE);
	detect_motion->labelsize(8);
	detect_motion->copy_tooltip("Detecting motion");
	detect_motion->callback(thumb_motion_button_cb, win);
	detect_motion->hide();
	
	detect_object = new MyButton(157, 38, 16, 16, "Detecting Objects");
	detect_object->box(FL_BORDER_FRAME);
	detect_object->color(YELLOW);
	detect_object->align(FL_ALIGN_RIGHT);
	detect_object->labelcolor(WHITE);
	detect_object->labelsize(8);
	detect_object->copy_tooltip("Detect and recognize objects");
	detect_object->callback(thumb_object_button_cb, win);
	detect_object->hide();

	instrument = new MyButton(157, 20, 16, 16, "Instrument");
	instrument->box(FL_BORDER_FRAME);
	instrument->color(YELLOW);
	instrument->align(FL_ALIGN_RIGHT);
	instrument->labelcolor(WHITE);
	instrument->labelsize(8);
	instrument->copy_tooltip("Instrument this camera for use with OSG");
	instrument->callback(thumb_instrument_button_cb, win);
	instrument->hide();
	
	set_color = new MyButton(157, 20, 16, 16, "Background");
	set_color->box(FL_FRAME_BOX);
	set_color->color(YELLOW);
	set_color->align(FL_ALIGN_RIGHT);
	set_color->labelcolor(WHITE);
	set_color->labelsize(8);
	set_color->copy_tooltip("Set the background color");
	set_color->callback(thumb_background_button_cb, win);
	set_color->hide();
	
	set_text_color = new MyButton(157, 38, 16, 16, "Text");
	set_text_color->box(FL_FRAME_BOX);
	set_text_color->color(YELLOW);
	set_text_color->align(FL_ALIGN_RIGHT);
	set_text_color->labelcolor(WHITE);
	set_text_color->labelsize(8);
	set_text_color->copy_tooltip("Set the text color");
	set_text_color->callback(thumb_text_color_button_cb, win);
	set_text_color->hide();

	pause_av = new MyButton(157, 20, 16, 16, "Pause");
	pause_av->box(FL_FRAME_BOX);
	pause_av->color(YELLOW);
	pause_av->align(FL_ALIGN_RIGHT);
	pause_av->labelcolor(WHITE);
	pause_av->labelsize(8);
	pause_av->copy_tooltip("Pause an AV camera");
	pause_av->callback(thumb_pause_av_button_cb, win);
	pause_av->hide();

	mute_av = new MyButton(157, 38, 16, 16, "Mute");
	mute_av->box(FL_FRAME_BOX);
	mute_av->color(YELLOW);
	mute_av->align(FL_ALIGN_RIGHT);
	mute_av->labelcolor(WHITE);
	mute_av->labelsize(8);
	mute_av->copy_tooltip("Muta an A/V camera");
	mute_av->callback(thumb_mute_av_button_cb, win);
	mute_av->hide();

	V4L_Window = new Fl_Group(157, 56, 90, 35);
	V4L_Window->box(FL_NO_BOX);
		int cx = 2 + 157;
		cy = 2 + 56;
		up_left = new V4L_Button(this, cx, cy, 10, 10, "");
		up_left->box(FL_BORDER_FRAME);
		up_left->color(YELLOW);
		up_left->copy_tooltip("Move up and left using v4l controls");
		cx += 11;
		up = new V4L_Button(this, cx, cy, 10, 10, "");
		up->box(FL_BORDER_FRAME);
		up->color(YELLOW);
		up->copy_tooltip("Move up using v4l controls");
		cx += 11;
		up_right = new V4L_Button(this, cx, cy, 10, 10, "");
		up_right->box(FL_BORDER_FRAME);
		up_right->color(YELLOW);
		up_right->copy_tooltip("Move up and right using v4l controls");
		cx = 2 + 157;
		cy += 11;
		left = new V4L_Button(this, cx, cy, 10, 10, "");
		left->box(FL_BORDER_FRAME);
		left->color(YELLOW);
		left->copy_tooltip("Move left using v4l controls");
		cx += 22;
		right = new V4L_Button(this, cx, cy, 10, 10, "");
		right->box(FL_BORDER_FRAME);
		right->color(YELLOW);
		right->copy_tooltip("Move right using v4l controls");
		cx = 2 + 157;
		cy += 11;
		down_left = new V4L_Button(this, cx, cy, 10, 10, "");
		down_left->box(FL_BORDER_FRAME);
		down_left->color(YELLOW);
		down_left->copy_tooltip("Move down and left using v4l controls");
		cx += 11;
		down = new V4L_Button(this, cx, cy, 10, 10, "");
		down->box(FL_BORDER_FRAME);
		down->color(YELLOW);
		down->copy_tooltip("Move down using v4l controls");
		cx += 11;
		down_right = new V4L_Button(this, cx, cy, 10, 10, "");
		down_right->box(FL_BORDER_FRAME);
		down_right->color(YELLOW);
		down_right->copy_tooltip("Move down and right using v4l controls");

		cx = 42 + 157;
		cy = 12 + 56;
		zoom_in = new V4L_Button(this, cx, cy, 11, 11, "Zoom");
		zoom_in->box(FL_BORDER_FRAME);
		zoom_in->color(YELLOW);
		zoom_in->align(FL_ALIGN_TOP | FL_ALIGN_CENTER);
		zoom_in->labelcolor(WHITE);
		zoom_in->labelsize(5);
		zoom_in->copy_tooltip("Zoom in using v4l controls");
		cy += 12;
		zoom_out = new V4L_Button(this, cx, cy, 11, 11, "");
		zoom_out->box(FL_BORDER_FRAME);
		zoom_out->color(YELLOW);
		zoom_out->copy_tooltip("Zoom out using v4l controls");

		cx = 60 + 157;
		cy = 12 + 56;
		focus_far = new V4L_Button(this, cx, cy, 11, 11, "Focus");
		focus_far->box(FL_BORDER_FRAME);
		focus_far->color(YELLOW);
		focus_far->align(FL_ALIGN_TOP | FL_ALIGN_CENTER);
		focus_far->labelcolor(WHITE);
		focus_far->labelsize(5);
		focus_far->copy_tooltip("Focus far using v4l controls");
		cy += 12;
		focus_near = new V4L_Button(this, cx, cy, 11, 11, "");
		focus_near->box(FL_BORDER_FRAME);
		focus_near->color(YELLOW);
		focus_near->copy_tooltip("Focus near using v4l controls");

	V4L_Window->end();
	V4L_Window->color(BLACK);
	V4L_Window->hide();

	UpdateButtons(cam);

	end();
	hide();
}

void	ThumbGroup::resize(int xx, int yy, int ww, int hh)
{
	Fl_Group::resize(xx, yy, ww, hh);
}

int	ThumbGroup::handle(int event)
{
	int flag = 0;
	if((event == FL_FOCUS)
	|| (event == FL_UNFOCUS))
	{
		flag = 1;
	}
	else if(event == FL_PUSH)
	{
		if(Fl::event_button() == FL_RIGHT_MOUSE)
		{
			if(my_win->alt_displayed_source != index)
			{
				my_win->AltDisplay(index);
			}
			else
			{
				my_win->alt_displayed_source = -1;
			}
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Group::handle(event);
	}
	return(flag);
}

void	ThumbGroup::draw()
{
	Fl_Group::draw();
	if(displayed == 1)
	{
		fl_color(YELLOW);
		fl_rect(x(), y(), w(), h() - 19);
	}
	else
	{
		if(my_win->alt_displayed_source == index)
		{
			fl_color(BLUE);
			fl_rect(x(), y(), w(), h() - 19);
		}
	}
}

void	ThumbGroup::UpdateButtons(Camera *cam)
{
	if(cam != NULL)
	{
		detect_object->hide();
		detect_motion->hide();
		instrument->hide();
		set_color->hide();
		set_text_color->hide();
		pause_av->hide();
		mute_av->hide();
		V4L_Window->hide();

		if((cam->type != CAMERA_TYPE_IMAGE)
		&& (cam->type != CAMERA_TYPE_BLANK)
		&& (cam->type != CAMERA_TYPE_TEXT)
		&& (cam->type != CAMERA_TYPE_DYNAMIC_TEXT)
		&& (cam->type != CAMERA_TYPE_ALERT)
		&& (cam->type != CAMERA_TYPE_TIMER)
		&& (cam->type != CAMERA_TYPE_CLOCK)
		&& (cam->type != CAMERA_TYPE_PIPED)
		&& (cam->type != CAMERA_TYPE_OSG))
		{
			if(cam->my_window != NULL)
			{
				if(cam->my_window->init_detect == 1)
				{
					detect_object->show();
				}
			}
			detect_motion->show();
		}
		if(cam->type == CAMERA_TYPE_OSG)
		{
			instrument->show();
		}
		if((cam->type == CAMERA_TYPE_IMAGE)
		|| (cam->type == CAMERA_TYPE_BLANK))
		{
			detect_motion->hide();
			detect_object->hide();
			set_color->show();
		}
		if((cam->type == CAMERA_TYPE_TEXT) 
		|| (cam->type == CAMERA_TYPE_DYNAMIC_TEXT)
		|| (cam->type == CAMERA_TYPE_ALERT)
		|| (cam->type == CAMERA_TYPE_PIPED)
		|| (cam->type == CAMERA_TYPE_CLOCK)
		|| (cam->type == CAMERA_TYPE_TIMER))
		{
			detect_motion->hide();
			detect_object->hide();
			set_color->show();
			set_text_color->show();
		}
		if(cam->type == CAMERA_TYPE_AV) 
		{
			pause_av->show();
			mute_av->show();
		}
		if(cam->type == CAMERA_TYPE_CAMERA)
		{
			if(cam->V4L_Test() == 1)
			{
				if(cam->V4L_Test2() == 1)
				{
					V4L_Window->show();
					cam->v4l_capable = 1;
				}
			}
		}
	}
}

ThumbButton::ThumbButton(MyWin *in_win, int in_idx, int xx, int yy, int ww, int hh, char *lbl) : MyButton(xx, yy, ww, hh, lbl)
{
	my_window = in_win;
	index = in_idx;
	dragging = 0;
	push_x = 0;
	push_y = 0;
}

ThumbButton::~ThumbButton()
{
	index = -1;
}

int	ThumbButton::handle(int event)
{
int	loop;
int	inner;

	int flag = 0;
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(event == FL_ENTER)
		{
			if(my_window->dragging_thumb == NULL)
			{
				if(cam->keep_pip == 0)
				{
					for(loop = 0;loop < 128;loop++)
					{
						if(this == my_window->thumbnail[loop]->thumb_button)
						{
							cam->pip_idx = loop;
						}
					}
					flag = 1;
				}
			}
		}
		else if(event == FL_LEAVE)
		{
			if(cam->keep_pip == 0)
			{
				cam->pip_idx = -1;
				flag = 1;
			}
		}
		else if(event == FL_PUSH)
		{
			push_x = Fl::event_x();
			push_y = Fl::event_y();
			if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
			{
				if(my_window->multipip > 0)
				{
					Camera *camera = NULL;
					for(loop = 0;loop < 128;loop++)
					{
						if(this == my_window->thumbnail[loop]->thumb_button)
						{
							camera = my_window->camera[loop];
						}
					}
					if(cam != NULL)
					{
						cam->AddPIPByCamera(camera, 0);
					}
				}
				else
				{
					if(cam->keep_pip == 0)
					{
						cam->keep_pip = 1;
					}
					else
					{
						cam->pip_idx = -1;
						cam->keep_pip = 0;
					}
				}
				flag = 1;
			}
		}
		else if(event == FL_DRAG)
		{
			int dx = abs(push_x - Fl::event_x());
			int dy = abs(push_y - Fl::event_y());
			if((dx > 5) || (dy > 5))
			{
				my_window->dragging_thumb = this;
				dragging = 1;
				if(cam->keep_pip == 0)
				{
					cam->pip_idx = -1;
				}
				redraw();
				flag = 1;
			}
		}
		else if(event == FL_RELEASE)
		{
			if(dragging == 1)
			{
				if(my_window->dragging_thumb != NULL)
				{
					int dtx = my_window->dragging_thumb_x;
					int dty = my_window->dragging_thumb_y;
					if((dtx > cam->image_sx) && (dtx < cam->image_sx + cam->mat.cols)
					&& (dty > cam->image_sy) && (dty < cam->image_sy + cam->mat.rows))
					{
						thumb_place_button_cb(this, my_window);
					}
					my_window->dragging_thumb = NULL;
				}
				dragging = 0;
				flag = 1;
			}
		}
		else if(event == FL_KEYBOARD)
		{
			int key = Fl::event_key();
			if(key == ' ')
			{
				flag = -1;
			}
		}
	}
	if(flag == 0)
	{
		flag = MyButton::handle(event);
	}
	if(flag == -1)
	{
		flag = 0;
	}
	return(flag);
}

void	ThumbButton::draw()
{
int	loop;

	if(my_window->video_thumbnail_group->visible())
	{
		if(index > -1)
		{
			if(!mat.empty())
			{
				Camera *cam = my_window->DisplayedCamera();
				MyWin *win = my_window;
				int b_sz = 16;
				Camera *my_cam = win->camera[index];
				if(my_cam != NULL)
				{
					if(my_cam->power == 1)
					{
						use_mat = mat.clone();
						fl_draw_image((unsigned char *)use_mat.ptr(), x(), y(), w(), h(), use_mat.channels());
					}
					else
					{
						fl_color(BLACK);
						fl_rectf(x(), y(), w(), h());
					}
					if(win->trigger_select_mode == 0)
					{
						ThumbGroup *grp = (ThumbGroup *)parent();
						if(my_cam->record == 1)
						{
							int xx = grp->record->x();
							int yy = grp->record->y();
							fl_color(RED);
							fl_rectf(xx, yy, b_sz, b_sz);
						}
						if((grp->detect_motion != NULL)
						&& (grp->detect_object != NULL))
						{
							if((my_cam->record_trigger & ON_DETECT_MOTION) == ON_DETECT_MOTION)
							{
								int xx = grp->detect_motion->x();
								int yy = grp->detect_motion->y();
								fl_color(RED);
								fl_rectf(xx, yy, b_sz, b_sz);
							}
							if((my_cam->record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
							{
								int xx = grp->detect_object->x();
								int yy = grp->detect_object->y();
								fl_color(RED);
								fl_rectf(xx, yy, b_sz, b_sz);
							}
						}
					}
					if(cam != NULL)
					{
						for(loop = 0;loop < cam->trigger_cnt;loop++)
						{
							if(cam->trigger[loop] == index)
							{
								fl_color(CYAN);
								fl_rect(x(), y(), w(), h());
							}
						}
					}
				}
			}
		}
	}
}

// SECTION ************************************** STANDALONE DISPLAY *******************************************************

void	update_standalone_cb(void *v)
{
	StandaloneDisplay *sd = (StandaloneDisplay *)v;
	sd->redraw();
	Fl::repeat_timeout(0.01, update_standalone_cb, v);
}

StandaloneDisplay::StandaloneDisplay(Camera *in_cam, int ww, int hh, char *lbl) : Fl_Double_Window(ww, hh, lbl)
{
	cam = in_cam;
	resizable(this);
	ratio_w = (double)ww / (double)hh;
	ratio_h = (double)hh / (double)ww;
	Fl::add_timeout(0.1, update_standalone_cb, this);
}

StandaloneDisplay::~StandaloneDisplay()
{
	if(cam != NULL)
	{
		cam->standalone_display = NULL;
	}
}

void	StandaloneDisplay::draw()
{
	Fl_Double_Window::draw();
	if(cam != NULL)
	{
		Mat use_mat = cam->mat.clone();
		int ww = (int)((double)h() * ratio_w);
		int hh = (int)((double)w() * ratio_h);
		if(w() > h())
		{
			cv::resize(use_mat, use_mat, cv::Size(ww, h()));
		}
		else
		{
			cv::resize(use_mat, use_mat, cv::Size(w(), hh));
		}
		fl_draw_image((unsigned char *)use_mat.ptr(), 0, 0, use_mat.cols, use_mat.rows, use_mat.channels());
	}
}

// SECTION ************************************** MY SCRUBBER *******************************************************

MyScrubber::MyScrubber(int xx, int yy, int ww, int hh) : Fl_Window(xx - 2, yy - 2, ww + 4, hh + 4)
{
	box(FL_FRAME_BOX);
	range = 0;
	current = 0;
	trim_cnt = 0;
	mode = 0;
	selected_trim = -1;
	hot_trim = -1;
	current_trim = -1;
	start_trim = NULL;
	end_trim = NULL;
	end();
	my_callback = NULL;
	my_callback_value = NULL;
}

MyScrubber::~MyScrubber()
{
	ClearTrims();
}

void	MyScrubber::Callback(void (*cb)(void *, void *), void *p)
{
	my_callback = cb;
	my_callback_value = p;
}

void	MyScrubber::draw()
{
int	loop;
char	buf[256];

	Fl_Window::draw();
	if(range > 0)
	{
		fl_color(WHITE);
		fl_rectf(4, 4, Scale(current) - 4, h() - 8);
		sprintf(buf, "%d", current);
		fl_font(FL_HELVETICA, 9);
		if(Scale(current) < w() - 50)
		{
			fl_draw(buf, Scale(current) + 6, 14);
		}
		else
		{
			fl_color(BLACK);
			fl_draw(buf, Scale(current) - 50, 14);
		}
		if(trim_cnt > 0)
		{
			for(loop = 0;loop < trim_cnt;loop++)
			{
				if(loop == hot_trim)
				{
					fl_color(DARK_RED);
				}
				else
				{
					fl_color(DARK_BLUE);
				}
				int sx1 = start_trim[loop];
				if(sx1 > -1)
				{
					fl_rectf(Scale(sx1) - 3, 10, 6, 10);
					sprintf(buf, "%d", sx1);
					if(sx1 > current)
					{
						fl_color(WHITE);
					}
					else
					{
						fl_color(BLACK);
					}
					fl_font(FL_HELVETICA, 9);
					fl_draw(buf, Scale(sx1) + 6, 14);
				}
				if(loop == hot_trim)
				{
					fl_color(DARK_RED);
				}
				else
				{
					fl_color(DARK_BLUE);
				}
				int sx2 = end_trim[loop];
				if((sx2 > -1) && (sx2 != sx1))
				{
					fl_rectf(Scale(sx2) - 3, 10, 6, 10);
					int diff = abs(sx2 - sx1);
					fl_rectf(Scale(sx1) + 3, 17, Scale(diff) - 3, 3);
					sprintf(buf, "%d", sx2);
					if(sx2 > current)
					{
						fl_color(WHITE);
					}
					else
					{
						fl_color(BLACK);
					}
					fl_font(FL_HELVETICA, 9);
					fl_draw(buf, Scale(sx2) - 32, 14);
				}
			}
		}
	}
}

int	MyScrubber::handle(int event)
{
int	loop;

	int flag = 0;
	switch(event)
	{
		case(FL_PUSH):
		{
			int nx = Descale(Fl::event_x());
			int ny = Fl::event_y();
			if(ny < 10)
			{
				Value(nx);
				mode = 0;
			}
			else if(trim_cnt > 0)
			{
				int flag = -1;
				selected_trim = -1;
				for(loop = 0;((loop < trim_cnt) && (flag == -1));loop++)
				{
					if((nx >= start_trim[loop] - 5) && (nx <= start_trim[loop] + 5))
					{
						flag = loop;
						mode = 1;
					}
					else if((nx >= end_trim[loop] - 5) && (nx <= end_trim[loop] + 5))
					{
						flag = loop;
						mode = 2;
					}
				}
				if(flag > -1)
				{
					selected_trim = flag;
				}
				if(selected_trim == -1)
				{
					Value(nx);
					mode = 0;
				}
			}
			redraw();
			flag = 1;
		}
		break;
		case(FL_DRAG):
		{
			int nx = Fl::event_x();
			int ny = Fl::event_y();
			if((nx > 0) && (nx < w()))
			{
				nx = Descale(nx);
				if(mode == 0)
				{
					Value(nx);
				}
				else if((mode == 1) || (mode == 2))
				{
					if(selected_trim > -1)
					{
						int ok = CheckTrim(selected_trim, nx);
						if(ok == 1)
						{
							if(mode == 1)
							{
								if(nx < end_trim[selected_trim] - 6)
								{
									start_trim[selected_trim] = nx;
								}
							}
							else if(mode == 2)
							{
								if(nx > start_trim[selected_trim] + 6)
								{
									end_trim[selected_trim] = nx;
								}
							}
						}
					}
				}
			}
			redraw();
			flag = 1;
		}
		break;
		case(FL_MOVE):
		{
			int nx = Fl::event_x();
			int ny = Fl::event_y();
			if((nx > 0) && (nx < w()))
			{
				nx = Descale(nx);
				hot_trim = -1;
				for(loop = 0;loop < trim_cnt;loop++)
				{
					if((nx >= start_trim[loop] - 5) && (nx <= start_trim[loop] + 5))
					{
						hot_trim = loop;
					}
					else if((nx >= end_trim[loop] - 5) && (nx <= end_trim[loop] + 5))
					{
						hot_trim = loop;
					}
				}
				redraw();
			}
			flag = 1;
		}
		break;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

int	MyScrubber::Scale(int nn)
{
	int r = 0;
	if(range > 0)
	{
		r = (int)((double)nn * ((double)(w() - 4) / (double)range));
	}
	return(r);
}

int	MyScrubber::Descale(int nn)
{
	int r = (int)((double)nn * ((double)range / (double)(w() - 4)));
	return(r);
}

int	MyScrubber::CheckTrim(int selected, int pos)
{
int	loop;

	int okay = 1;
	for(loop = 0;loop < trim_cnt;loop++)
	{
		if(loop != selected)
		{
			if((pos >= (start_trim[loop] - 6)) && (pos <= (end_trim[loop]) + 6))
			{
				okay = 0;
			}
		}
	}
	return(okay);
}

int	MyScrubber::CountTrim()
{
int	loop;

	int total = 0;
	for(loop = 0;loop < trim_cnt;loop++)
	{
		total += (end_trim[loop] - start_trim[loop]);
	}
	return(total);
}

void	MyScrubber::SortTrim()
{
int	inner, outer;

	for(outer = 0;outer < trim_cnt;outer++)
	{
		for(inner = 0;inner < trim_cnt;inner++)
		{
			if(start_trim[outer] < start_trim[inner])
			{
				if(inner != outer)
				{
					int tmp  = start_trim[outer];
					start_trim[outer] = start_trim[inner];
					start_trim[inner] = tmp;

					tmp  = end_trim[outer];
					end_trim[outer] = end_trim[inner];
					end_trim[inner] = tmp;
				}
			}
		}
	}
}

int	MyScrubber::Value()
{
	return(current);
}

void	MyScrubber::Value(int v)
{
	current = v;
	if(my_callback != NULL)
	{
		(*my_callback)(this, my_callback_value);
	}
}

int	MyScrubber::Range()
{
	return(range);
}

void	MyScrubber::Range(int v)
{
	range = v;
}

void	MyScrubber::AddTrim(int start, int end)
{
	int *tmp1 = (int *)realloc(start_trim, sizeof(int) * (trim_cnt + 1));
	if(tmp1 != NULL)
	{
		int *tmp2 = (int *)realloc(end_trim, sizeof(int) * (trim_cnt + 1));
		if(tmp2 != NULL)
		{
			start_trim = tmp1;
			start_trim[trim_cnt] = start;
			end_trim = tmp2;
			end_trim[trim_cnt] = end;
			current_trim = trim_cnt;
			trim_cnt++;
		}
	}
}

void	MyScrubber::SetStartTrim(int nn)
{
	if(current_trim > -1)
	{
		start_trim[current_trim] = nn;
	}
}

void	MyScrubber::SetEndTrim(int nn)
{
	if(current_trim > -1)
	{
		if(start_trim[current_trim] < nn)
		{
			end_trim[current_trim] = nn;
		}
		else
		{
			int tmp = start_trim[current_trim];
			start_trim[current_trim] = nn;
			end_trim[current_trim] = tmp;
		}
	}
}

void	MyScrubber::ClearTrims()
{
	if(start_trim != NULL)
	{
		free(start_trim);
		start_trim = NULL;
	}
	if(end_trim != NULL)
	{
		free(end_trim);
		end_trim = NULL;
	}
	trim_cnt = 0;
}

void	MyScrubber::RemoveTrim(int idx)
{
int	loop;

	if(trim_cnt > 1)
	{
		if((idx > -1) && (idx < trim_cnt))
		{
			int *tmp1 = (int *)malloc((trim_cnt - 1) * sizeof(int));
			if(tmp1 != NULL)
			{
				int *tmp2 = (int *)malloc((trim_cnt - 1) * sizeof(int));
				if(tmp2 != NULL)
				{
					int cnt = 0;
					for(loop = 0;loop < trim_cnt;loop++)
					{
						if(loop != idx)
						{
							tmp1[cnt] = start_trim[loop];
							tmp2[cnt] = end_trim[loop];
							cnt++;
						}
					}
					free(start_trim);
					free(end_trim);
					start_trim = tmp1;
					end_trim = tmp2;
					trim_cnt--;
				}
			}
		}
	}
	else
	{
		free(start_trim);
		free(end_trim);
		trim_cnt = 0;
	}
}

ProgressScrubber::ProgressScrubber(MyWin *in_win, MuxPreviewWindow *mux, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	my_window = in_win;
	mux_preview = mux;
	position = 0.0;
	playing = 0;
	play_x1 = 0;
	play_y1 = 0;
	play_x2 = 0;
	play_y2 = 0;
}

ProgressScrubber::~ProgressScrubber()
{
}

void	ProgressScrubber::draw()
{
char	text[64];

	fl_color(BLACK);
	if(box() != FL_NO_BOX)
	{
		fl_rectf(x(), y(), w(), h());
	}
	fl_rectf(x(), y(), w(), 10);
	fl_color(WHITE);
	fl_rect(x(), y(), w(), 10);
	int pp = (int)((double)w() * position);
	fl_rectf(x() + pp, y(), 4, 10);
	int nx = x() + ((w() / 2) - 5);
	int ny = y() + h() - 21;
	fl_rect(nx, ny, 20, 20);
	playing = 1;
	if(mux_preview == NULL)
	{
		Camera *cam = my_window->DisplayedCamera();
		if(cam != NULL)
		{
			if(cam->type == CAMERA_TYPE_AV)
			{
				if(cam->av_window->paused == 1)
				{
					playing = 0;
				}
			}
		}
	}
	else
	{
		if(mux_preview->vlc_window->paused == 1)
		{
			playing = 0;
		}
	}
	if(playing == 1)
	{
		strcpy(text, "@#||");
	}
	else
	{
		strcpy(text, "@#>");
	}
	fl_draw(text, nx + 1, ny, 20, 20, FL_ALIGN_CENTER | FL_ALIGN_INSIDE, NULL, 1);
	play_x1 = nx - x();
	play_y1 = ny - y();
	play_x2 = play_x1 + 20;
	play_y2 = play_y1 + 20;
}

int	ProgressScrubber::Handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= x();
		yy -= y();
		if((xx > 0) && (yy > 0)
		&& (xx < w()) && (yy < h()))
		{
			if(mux_preview == NULL)
			{
				Camera *cam = my_window->DisplayedCamera();
				if(cam != NULL)
				{
					if(cam->type == CAMERA_TYPE_AV)
					{
						if(yy < (h() - 30))
						{
							double val = (1.0 / w()) * (double)xx;
							cam->av_window->Position(val);
							flag = 1;
						}
						else if((xx > play_x1) && (yy > play_y1)
						&& (xx < play_x2) && (yy < play_y2))
						{
							if(cam->av_window->paused == 0)
							{
								playing = 0;
								cam->av_window->Pause();
							}
							else
							{
								playing = 1;
								cam->av_window->Resume();
							}
						}
					}
				}
			}
			else
			{
				if(yy < (h() - 30))
				{
					double val = (1.0 / w()) * (double)xx;
					mux_preview->vlc_window->Position(val);
					flag = 1;
				}
				else if((xx > play_x1) && (yy > play_y1)
				&& (xx < play_x2) && (yy < play_y2))
				{
					if(mux_preview->vlc_window->paused == 0)
					{
						playing = 0;
						mux_preview->vlc_window->Pause();
					}
					else
					{
						playing = 1;
						mux_preview->vlc_window->Resume();
					}
				}
			}
		}
	}
	return(flag);
}

void	ProgressScrubber::Position(double in_pos)
{
	position = in_pos;
}

// SECTION ************************************** EMBED APP SETTINGS *******************************************************

void	embed_app_next_cb(Fl_Widget *w, void *v)
{
	EmbedAppSettings *win = (EmbedAppSettings *)v;
	win->Next();
}

void	embed_app_prev_cb(Fl_Widget *w, void *v)
{
	EmbedAppSettings *win = (EmbedAppSettings *)v;
	win->Prev();
}

void	embed_app_accept_cb(Fl_Widget *w, void *v)
{
int	loop;

	EmbedAppSettings *win = (EmbedAppSettings *)v;
	win->Save("external_pgms.txt");
	win->hide();
}

void	embed_app_execute_cb(Fl_Widget *w, void *v)
{
int	loop;

	EmbedAppSettings *win = (EmbedAppSettings *)v;
	if(win->my_window->embedded_app_cnt < 10)
	{
		char *path = (char *)win->path->value();
		if(path != NULL)
		{
			if(strlen(path) > 0)
			{
				int use_w = 450;
				int use_h = 270;
				char *str_w = (char *)win->use_w->value();
				if(str_w != NULL)
				{
					if(strlen(str_w) > 0)
					{
						use_w = atoi(str_w);
						if(use_w < 50)
						{
							use_w = 50;
						}
					}
				}
				char *str_h = (char *)win->use_h->value();
				if(str_h != NULL)
				{
					if(strlen(str_h) > 0)
					{
						use_h = atoi(str_h);
						if(use_h < 50)
						{
							use_h = 50;
						}
					}
				}
				int x_pos = 0;
				int y_pos = 0;
				win->my_window->CalcEmbeddedWindowPosition(use_w, use_h, x_pos, y_pos);
				EmbedAppWindow *embed = new EmbedAppWindow(win->my_window, x_pos, y_pos, use_w, use_h);
				win->my_window->AddEmbeddedWindow(embed);
				embed->set_non_modal();
				embed->show();
				char *arg[10];
				for(loop = 0;loop < 10;loop++)
				{
					arg[loop] = NULL;
					char *str = (char *)win->arg[loop]->value();
					if(str != NULL)
					{
						if(strlen(str) > 0)
						{
							arg[loop] = str;
						}
					}
				}
				int app_w = 0;
				int app_h = 0;
				int succeed = embed->EmbedApp(path, arg, app_w, app_h);
				if(succeed != 1)
				{
					win->my_window->RemoveEmbeddedWindow(embed);
					win->my_window->SetErrorMessage("Command failed to embed.");
				}
			}
		}
	}
}

EmbedAppSettings::EmbedAppSettings(MyWin *in_win) : Dialog(450, 300, 300, 385, "Embed Application")
{
int		loop;
int		inner;
char	buf[256];

	my_window = in_win;
	current = 0;
	int new_yp = 20;
	for(loop = 0;loop < 10;loop++)
	{
		my_path[loop] = strdup("");
		my_w[loop] = 0;
		my_h[loop] = 0;
		for(inner = 0;inner < 10;inner++)
		{
			my_arg[loop][inner] = strdup("");
		}
	}
	resize(x(), y(), w(), h());

	current_index = new Fl_Box(20, 25 + new_yp, w() - 40, 20);
	current_index->box(FL_FLAT_BOX);
	current_index->color(BLACK);
	current_index->labelsize(9);
	current_index->labelcolor(WHITE);
	current_index->align(FL_ALIGN_CENTER);
	sprintf(label_buf, "%d", current + 1);
	current_index->copy_label(label_buf);

	prev = new MyButton(2, 5 + new_yp, 20, 20, "@<");
	prev->box(FL_FLAT_BOX);
	prev->color(BLACK);
	prev->labelsize(12);
	prev->labelcolor(WHITE);
	prev->copy_tooltip("Advance to the next external program definition.");
	prev->callback(embed_app_prev_cb, this);

	next = new MyButton(w() - 21, 5 + new_yp, 20, 20, "@>");
	next->box(FL_FLAT_BOX);
	next->color(BLACK);
	next->labelsize(12);
	next->labelcolor(WHITE);
	next->copy_tooltip("Go back the last external program definition.");
	next->callback(embed_app_next_cb, this);

	int y_pos = 55 + new_yp;
	path = new Fl_Input(75, y_pos, 200, 20, "Path");
	path->textsize(11);
	path->textcolor(BLACK);
	path->color(LIGHT_GRAY);
	path->labelcolor(LIGHT_GRAY);
	path->labelsize(11);
	path->box(FL_FLAT_BOX);
	path->copy_tooltip("The path to the external program. Programs in $PATH can be found without a full path.");
	y_pos += 22;

	use_w = new Fl_Input(75, y_pos, 50, 20, "Width");
	use_w->textsize(11);
	use_w->textcolor(BLACK);
	use_w->color(LIGHT_GRAY);
	use_w->labelcolor(LIGHT_GRAY);
	use_w->labelsize(11);
	use_w->copy_tooltip("The width of the initial window that hold the window of the external program.");
	use_w->box(FL_FLAT_BOX);

	use_h = new Fl_Input(175, y_pos, 50, 20, "Height");
	use_h->textsize(11);
	use_h->textcolor(BLACK);
	use_h->color(LIGHT_GRAY);
	use_h->labelcolor(LIGHT_GRAY);
	use_h->labelsize(11);
	use_h->box(FL_FLAT_BOX);
	use_h->copy_tooltip("The height of the initial window that hold the window of the external program.");
	y_pos += 32;

	for(loop = 0;loop < 10;loop++)
	{
		if(loop == 0)
		{
			strcpy(buf, "Title");
		}
		else
		{
			sprintf(buf, "Argument %d", loop);
		}
		arg[loop] = new Fl_Input(100, y_pos, 175, 20, strdup(buf));
		arg[loop]->color(WHITE);
		arg[loop]->textsize(11);
		arg[loop]->textcolor(BLACK);
		arg[loop]->color(LIGHT_GRAY);
		arg[loop]->labelcolor(LIGHT_GRAY);
		arg[loop]->labelsize(11);
		arg[loop]->box(FL_FLAT_BOX);
		arg[loop]->copy_tooltip("Command line arguments provided to the external program. The first is designated as that program's title.");
		y_pos += 22;
	}
	y_pos += 22;
	execute = new MyButton(10, y_pos, 80, 20, "Execute");
	execute->box(FL_NO_BOX);
	execute->color(WHITE);
	execute->labelcolor(YELLOW);
	execute->labelsize(12);
	execute->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	execute->copy_tooltip("Execute and embed the program specified by this dialog.");
	execute->callback(embed_app_execute_cb, this);

	accept = new MyButton((w() / 2) - 40, y_pos, 80, 20, "Accept");
	accept->box(FL_NO_BOX);
	accept->color(WHITE);
	accept->labelcolor(YELLOW);
	accept->labelsize(12);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->copy_tooltip("Save all of the specifications to a file and close the dialog.");
	accept->callback(embed_app_accept_cb, this);

	cancel = new MyButton(w() - 90, y_pos, 80, 20, "Cancel");
	cancel->box(FL_NO_BOX);
	cancel->color(WHITE);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(12);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->copy_tooltip("Close the dialog with saving the specifications to a file.");
	cancel->callback(hide_window_cb, this);

	end();
	hide();
	Load("external_pgms.txt");
}

EmbedAppSettings::~EmbedAppSettings()
{
	FreeAll();
}

void	EmbedAppSettings::Next()
{
	SaveToArray();
	current++;
	if(current > 9)
	{
		current = 0;
	}
	LoadFromArray();
	sprintf(label_buf, "%d", current + 1);
	current_index->copy_label(label_buf);
	redraw();
}

void	EmbedAppSettings::Prev()
{
	SaveToArray();
	current--;
	if(current < 0)
	{
		current = 9;
	}
	LoadFromArray();
	sprintf(label_buf, "%d", current + 1);
	current_index->copy_label(label_buf);
	redraw();
}

void	EmbedAppSettings::Save(char *filename)
{
int	loop;
int	inner;

	FILE *fp = fopen(filename, "w");
	if(fp != NULL)
	{
		Next();
		for(loop = 0;loop < 10;loop++)
		{
			fprintf(fp, "%s\n", my_path[loop]);
			fprintf(fp, "%d\n", my_w[loop]);
			fprintf(fp, "%d\n", my_h[loop]);
			for(inner = 0;inner < 10;inner++)
			{
				fprintf(fp, "%s\n", my_arg[loop][inner]);
			}
		}
		fclose(fp);
	}
}

void	EmbedAppSettings::Load(char *filename)
{
int		loop;
int		inner;
char	buf[4096];

	FILE *fp = fopen(filename, "r");
	if(fp != NULL)
	{
		for(loop = 0;loop < 10;loop++)
		{
			if(my_path[loop] != NULL)
			{
				free(my_path[loop]);
			}
			for(inner = 0;inner < 10;inner++)
			{
				if(my_arg[loop][inner] != NULL)
				{
					free(my_arg[loop][inner]);
				}
			}
		}
		for(loop = 0;loop < 10;loop++)
		{
			fgets(buf, 4096, fp);
			strip_lf(buf);
			my_path[loop] = strdup(buf);
			fgets(buf, 4096, fp);
			my_w[loop] = atoi(buf);
			fgets(buf, 4096, fp);
			my_h[loop] = atoi(buf);
			for(inner = 0;inner < 10;inner++)
			{
				fgets(buf, 4096, fp);
				strip_lf(buf);
				my_arg[loop][inner] = strdup(buf);
			}
		}
		fclose(fp);
		LoadFromArray();
	}
}

void	EmbedAppSettings::ClearCurrent()
{
int	loop;

	if(my_path[current] != NULL)
	{
		free(my_path[current]);
		my_path[current] = strdup("");
	}
	my_w[current] = 0;
	my_h[current] = 0;
	for(loop = 0;loop < 10;loop++)
	{
		if(my_arg[current][loop] != NULL)
		{
			free(my_arg[current][loop]);
			my_arg[current][loop] = strdup("");
		}
	}
}

void	EmbedAppSettings::FreeAll()
{
int	loop;
int	inner;

	for(loop = 0;loop < 10;loop++)
	{
		if(my_path[loop] != NULL)
		{
			free(my_path[loop]);
		}
		for(inner = 0;inner < 10;inner++)
		{
			if(my_arg[loop][inner] != NULL)
			{
				free(my_arg[loop][inner]);
			}
		}
	}
}

void	EmbedAppSettings::LoadFromArray()
{
int		loop;
char	buf[256];

	path->value("");
	use_w->value("");
	use_h->value("");
	for(loop = 0;loop < 10;loop++)
	{
		arg[loop]->value("");
	}
	path->value(my_path[current]);
	sprintf(buf, "%d", my_w[current]);
	use_w->value(buf);
	sprintf(buf, "%d", my_h[current]);
	use_h->value(buf);
	for(loop = 0;loop < 10;loop++)
	{
		arg[loop]->value(my_arg[current][loop]);
	}
}

void	EmbedAppSettings::SaveToArray()
{
int	loop;

	ClearCurrent();
	my_path[current] = strdup((char *)path->value());
	char *str_w = (char *)use_w->value();
	if(strlen(str_w) > 0)
	{
		my_w[current] = atoi(str_w);
	}
	char *str_h = (char *)use_h->value();
	if(strlen(str_h) > 0)
	{
		my_h[current] = atoi(str_h);
	}
	for(loop = 0;loop < 10;loop++)
	{
		char *str = (char *)arg[loop]->value();
		if(strlen(str) > 0)
		{
			my_arg[current][loop] = strdup(str);
		}
	}
}

// SECTION ************************************** MY SLIDER *******************************************************

void	my_slider_reset_cb(Fl_Widget *w, void *v)
{
	if(v != NULL)
	{
		MySlider *slider = (MySlider *)v;
		slider->value(slider->initial_value);
		slider->do_callback();
		slider->redraw();
	}
}

MySlider::MySlider(int xx, int yy, int ww, int hh, char *lbl, MyButton *in_reset) : Fl_Slider(xx, yy, ww, hh, lbl)
{
	initial_value = 0.0;
	type(FL_HOR_NICE_SLIDER);
	align(FL_ALIGN_LEFT);
	color(BLACK);
	labelcolor(WHITE);
	box(FL_FLAT_BOX);

	int length = 0;
	int height = 0;
	fl_font(labelfont(), labelsize());
	fl_measure(lbl, length, height);
	if(in_reset == NULL)
	{
		if(lbl != NULL)
		{
			if(strlen(lbl) > 0)
			{
				int lx = 0;
				int ly = 0;
				int lw = 0;
				int lh = 0;
				int	rr = find_label_position(this, lx, ly, lw, lh);
				if(rr == 1)
				{
					reset = new MyButton(lx, ly, lw, lh);
					reset->box(FL_NO_BOX);
					reset->callback(my_slider_reset_cb, this);
					reset->copy_tooltip("Reset to default value");
					labelcolor(YELLOW);
				}
			}
		}
	}
	else
	{
		reset = in_reset;
		reset->callback(my_slider_reset_cb, this);
		reset->copy_tooltip("Reset to default value");
	}
}

MySlider::~MySlider()
{
}

void	MySlider::draw()
{
char	buf[256];

	int sub = h() / 3;
	fl_push_clip(x(), y(), w(), h());
	fl_color(BLACK);
	fl_rectf(x(), y(), w(), h());
	fl_color(fl_rgb_color(64, 64, 64));
	fl_rect(x(), y() + sub, w(), h() - (sub * 2));
	fl_color(WHITE);
	double min = minimum();
	double max = maximum();
	double rng = abs(max - min);
	double val = value();
	int pos = (int)((((double)w() / rng) * val) - ((w() / rng) * min));
	fl_rect(x() + pos - 2, y() + 4, 4, h() - 8);
	fl_font(FL_HELVETICA, 9);
	sprintf(buf, "%.2f", val);
	int use_x = 0;
	int use_y = 0;
	fl_measure(buf, use_x, use_y);
	if(pos > (w() / 2))
	{
		fl_draw(buf, x() + pos - (use_x + 5), y() + (use_y + 2));
	}
	else
	{
		fl_draw(buf, x() + pos + 5, y() + (use_y + 2));
	}
	fl_pop_clip();
}

// SECTION ************************************** VIDEO SETTINGS WINDOW *******************************************************


void	fps_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		MySlider *slide = (MySlider *)w;
		if(slide != NULL)
		{
			double nn = slide->value();
			double rr = nn;
			win->forced_fps = (int)rr;
		}
	}
}
void	encode_fps_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		MySlider *slide = (MySlider *)w;
		if(slide != NULL)
		{
			double nn = slide->value();
			win->speed_factor = nn;
		}
	}
}

void	minimum_fps_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		MySlider *slide = (MySlider *)w;
		if(slide != NULL)
		{
			double nn = slide->value();
			win->minimum_fps = nn;
		}
	}
}

void	settings_close_cb(Fl_Widget *w, void *v)
{
	if(v != NULL)
	{
		VideoSettingsWindow *sw = (VideoSettingsWindow *)v;
		MyWin *win = sw->main_win;
		win->SaveVideoSettings();
		sw->hide();
	}
}

void	MyWin::SaveVideoSettings()
{
	FILE *fp = fopen("video_settings.json", "w");
	if(fp != NULL)
	{
		fprintf(fp, "{\n");
		fprintf(fp, "\t\"output width\": %d,\n", output_width);
		fprintf(fp, "\t\"output height\": %d,\n", output_height);
		fprintf(fp, "\t\"forced fps\": %d,\n", forced_fps);
		fprintf(fp, "\t\"speed factor\": %f,\n", speed_factor);
		fprintf(fp, "\t\"minimum fps\": %f,\n", minimum_fps);
		fprintf(fp, "\t\"stream only\": %d,\n", stream_only);
		fprintf(fp, "\t\"audio\": %d,\n", audio);
		fprintf(fp, "\t\"muxing\": %d,\n", muxing);
		fprintf(fp, "\t\"embed pip\": %d,\n", embed_pip);
		fprintf(fp, "\t\"tag recognized\": %d,\n", tag_recognized);
		fprintf(fp, "\t\"record all\": %d,\n", record_all);
		fprintf(fp, "\t\"frame scaling\": %d,\n", frame_scaling);
		fprintf(fp, "\t\"crop scaling\": %d,\n", crop_scaling);
		fprintf(fp, "\t\"crop output\": %d,\n", crop_output);
		fprintf(fp, "\t\"crop output x\": %d,\n", crop_output_x);
		fprintf(fp, "\t\"crop output y\": %d,\n", crop_output_y);
		fprintf(fp, "\t\"single stream\": %d,\n", single_stream);
		fprintf(fp, "\t\"timestamp\": %d,\n", timestamp);
		fprintf(fp, "\t\"timestamp format\": \"%s\",\n", timestamp_format);
		fprintf(fp, "\t\"timestamp rr\": %d,\n", timestamp_rr);
		fprintf(fp, "\t\"timestamp gg\": %d,\n", timestamp_gg);
		fprintf(fp, "\t\"timestamp bb\": %d,\n", timestamp_bb);
		fprintf(fp, "\t\"timestamp aa\": %d,\n", timestamp_aa);
		fprintf(fp, "\t\"timestamp font sz\": %d,\n", timestamp_font_sz);
		fprintf(fp, "\t\"timestamp position x\": %d,\n", timestamp_position_x);
		fprintf(fp, "\t\"timestamp position y\": %d,\n", timestamp_position_y);
		fprintf(fp, "\t\"html background\": %d\n", html_background);
		fprintf(fp, "}\n");
		fclose(fp);
	}
}

void	load_system_video_settings_from_file(MyWin *win)
{
	if(win != NULL)
	{
		char *buf = ReadWholeFile("video_settings.json");
		if(buf != NULL)
		{
			cJSON *json = cJSON_Parse(buf);
			if(json == NULL)
			{
				const char *error_ptr = cJSON_GetErrorPtr();
				if(error_ptr != NULL)
				{
					fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
				}
			}
			else
			{
				int success = json_parse_int(json, "output width", win->output_width);
				success = json_parse_int(json, "output height", win->output_height);
				success = json_parse_int(json, "forced fps", win->forced_fps);
				success = json_parse_double(json, "speed factor", win->speed_factor);
				success = json_parse_double(json, "minimum fps", win->minimum_fps);
				success = json_parse_int(json, "stream only", win->stream_only);
				success = json_parse_int(json, "audio", win->audio);
				success = json_parse_int(json, "muxing", win->muxing);
				success = json_parse_int(json, "embed pip", win->embed_pip);
				success = json_parse_int(json, "tag recognized", win->tag_recognized);
				success = json_parse_int(json, "record all", win->record_all);
				success = json_parse_int(json, "frame scaling", win->frame_scaling);
				success = json_parse_int(json, "frame output", win->crop_output);
				success = json_parse_int(json, "frame output x", win->crop_output_x);
				success = json_parse_int(json, "frame output y", win->crop_output_y);
				success = json_parse_int(json, "crop scaling", win->crop_scaling);
				success = json_parse_int(json, "crop output", win->crop_output);
				success = json_parse_int(json, "crop output x", win->crop_output_x);
				success = json_parse_int(json, "crop output y", win->crop_output_y);
				success = json_parse_int(json, "single stream", win->single_stream);
				success = json_parse_int(json, "timestamp", win->timestamp);
				char *str = json_parse_string(json, "timestamp_format");
				if(str != NULL)
				{
					strcpy(win->timestamp_format, str);
				}
				success = json_parse_int(json, "timestamp rr", win->timestamp_rr);
				success = json_parse_int(json, "timestamp gg", win->timestamp_gg);
				success = json_parse_int(json, "timestamp bb", win->timestamp_bb);
				success = json_parse_int(json, "timestamp aa", win->timestamp_aa);
				success = json_parse_int(json, "timestamp background rr", win->timestamp_background_rr);
				success = json_parse_int(json, "timestamp background gg", win->timestamp_background_gg);
				success = json_parse_int(json, "timestamp background bb", win->timestamp_background_bb);
				success = json_parse_int(json, "timestamp background aa", win->timestamp_background_aa);
				success = json_parse_int(json, "timestamp font sz", win->timestamp_font_sz);
				success = json_parse_int(json, "timestamp position x", win->timestamp_position_x);
				success = json_parse_int(json, "timestamp position y", win->timestamp_position_y);
				success = json_parse_int(json, "html background", win->html_background);
				cJSON_Delete(json);
			}
		}
	}
}

void	realtime_encoding_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyLightButton *b = (MyLightButton *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->muxing = b->value();
		for(loop = 0;loop < win->source_cnt;loop++)
		{
			if(win->camera[loop] != NULL)
			{
				Camera *cam = win->camera[loop];
				cam->starting_time = 0;
			}
		}
		if(win->muxing == 0)
		{
			win->stream_only = 0;
		}
		else
		{
			win->audio = 1;
		}
	}
}

void	record_all_cb(Fl_Widget *w, void *v)
{
	MyLightButton *b = (MyLightButton *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		if(b->value() == 1)
		{
			if(win->record_all == 0)
			{
				win->record_all_start = time(0);
				win->all_fd = open("global.bin", O_CREAT | O_WRONLY | O_TRUNC, 0777);
				int uw = win->original_w;
				int uh = win->original_h;
				int depth = 4;
				int ufps = 25;
				write(win->all_fd, &uw, sizeof(int));
				write(win->all_fd, &uh, sizeof(int));
				write(win->all_fd, &depth, sizeof(int));
				write(win->all_fd, &ufps, sizeof(int));
				win->record_all = 1;
			}
		}
		else
		{
			if(win->record_all == 1)
			{
				win->record_all = 0;
				if(win->all_fd > -1)
				{
					win->SetCodec();
					close(win->all_fd);
					double fps = 25.0;
					int total_time = (int)(time(0) - win->record_all_start);
					if(total_time > 0)
					{
						fps = (double)win->record_all_cnt / (double)total_time;
					}
					char out_filename[4096];
					sprintf(out_filename, "global.%s", win->use_extension);
					Muxer *use_muxer = new Muxer(win, NULL, 1);
					int err = use_muxer->InitMux(win->audio, win->use_video_codec, win->use_audio_codec, "global.bin", NULL, out_filename, NULL, win->desktop_monitor, win->pulse_mixer, -1, win->original_w, win->original_h, fps, win->audio_sample_rate, win->audio_channels, -1, NULL, NULL);
					if(err == 0)
					{
						win->AddLastMuxed(out_filename);
					}
					else
					{
						win->SetErrorMessage("Encoding Error: Not recording.");
					}
					delete use_muxer;
				}
			}
		}
	}
}

void	embed_pip_cb(Fl_Widget *w, void *v)
{
	MyLightButton *b = (MyLightButton *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->embed_pip = b->value();
	}
}

void	frame_scaling_cb(Fl_Widget *w, void *v)
{
	MyLightButton *b = (MyLightButton *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->frame_scaling = b->value();
	}
}

void	crop_scaling_cb(Fl_Widget *w, void *v)
{
	MyLightButton *b = (MyLightButton *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->crop_scaling = b->value();
	}
}

void	crop_output_cb(Fl_Widget *w, void *v)
{
	MyLightButton *b = (MyLightButton *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->crop_output = b->value();
	}
}

void	create_tag_file_cb(Fl_Widget *w, void *v)
{
	MyLightButton *b = (MyLightButton *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->tag_recognized = b->value();
	}
}

void	html_background_transparent_cb(Fl_Widget *w, void *v)
{
	MyLightButton *b = (MyLightButton *)w;
	VideoSettingsWindow *vsw = (VideoSettingsWindow *)v;
	MyWin *win = (MyWin *)vsw->main_win;
	if(win != NULL)
	{
		win->html_background = b->value();
	}
}

void	follow_mode_cb(Fl_Widget *w, void *v)
{
	MyLightButton *b = (MyLightButton *)w;
	VideoSettingsWindow *vsw = (VideoSettingsWindow *)v;
	MyWin *win = (MyWin *)vsw->main_win;
	if(win != NULL)
	{
		if(b == vsw->display_recording_button)
		{
			if(b->value() == 1)
			{
				win->follow_mode = FOLLOW_MODE_DISPLAY_RECORDING_CAMERA;
				vsw->recording_follow_display_button->value(0);
			}
			else
			{
				win->follow_mode = FOLLOW_MODE_NONE;
			}
		}
		else
		{
			if(b->value() == 1)
			{
				win->follow_mode = FOLLOW_MODE_RECORDING_FOLLOWS_DISPLAY;
				vsw->display_recording_button->value(0);
			}
			else
			{
				win->follow_mode = FOLLOW_MODE_NONE;
			}
		}
	}
}

void	single_stream_cb(Fl_Widget *w, void *v)
{
	MyLightButton *b = (MyLightButton *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		if(win->recording == 0)
		{
			if(b->value() == 1)
			{
				win->single_stream = 0;
			}
			else
			{
				win->single_stream = 1;
			}
		}
		else
		{
			if(win->single_stream == 1)
			{
				b->value(0);
			}
			else
			{
				b->value(1);
			}
			b->redraw();
		}
	}
}

void	out_function(char *ptr)
{
	if(global_log_window != NULL)
	{
		Fl_Browser *browser = (Fl_Browser *)global_log_window->child(0);
		if(!global_log_window->visible())
		{
			browser->clear();
		}
		browser->add(ptr);
		int num = browser->size();
		browser->bottomline(num);
		global_log_window->show();
		global_log_window->redraw();
		if((num % 100) == 0)
		{
			Fl::check();
		}
	}
}

void	gather_codecs_cb(Fl_Widget *w, void *v)
{
void	enumerate_codecs();
void	enumerate_test(void (*output_cb)(char *), int test_w, int test_h, int test_fps, int test_hz);
int		loop;

	MyButton *b = (MyButton *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		for(loop = 0;loop < global_my_format_cnt;loop++)
		{
			MyFormat *mf = global_my_format[loop];
			delete mf;
			global_my_format[loop] = NULL;
		}
		global_my_format_cnt = 0;
		if(global_my_format_cnt == 0)
		{
			enumerate_codecs();
			enumerate_test(out_function, win->output_width, win->output_height, win->minimum_fps, win->streaming_audio_quality);
		}
		out_function("@bDONE");
	}
}

void	timestamp_default_cb(Fl_Widget *w, void *v)
{
	VideoSettingsWindow *sw = (VideoSettingsWindow *)v;
	MyWin *win = sw->main_win;
	int val = sw->timestamp_default->value();
	win->timestamp = val;
}

void	timestamp_format_cb(Fl_Widget *w, void *v)
{
	VideoSettingsWindow *sw = (VideoSettingsWindow *)v;
	MyWin *win = sw->main_win;
	Camera *cam = win->DisplayedCamera();
	char *str = (char *)sw->timestamp_format->value();
	if(str != NULL)
	{
		strncpy(win->timestamp_format, str, 4096);
	}
}

void	timestamp_color_cb(Fl_Widget *w, void *v)
{
	VideoSettingsWindow *sw = (VideoSettingsWindow *)v;
	MyWin *win = sw->main_win;
	Camera *cam = win->DisplayedCamera();
	int rr = 255;
	int gg = 240;
	int bb = 128;
	int aa = 255;
	my_color_chooser("Timestamp Text Color", rr, gg, bb, aa);
	win->timestamp_rr = rr;
	win->timestamp_gg = gg;
	win->timestamp_bb = bb;
	win->timestamp_aa = aa;
	sw->timestamp_color_button->color(fl_rgb_color(rr, gg, bb));
	sw->redraw();
}

void	timestamp_background_color_cb(Fl_Widget *w, void *v)
{
	VideoSettingsWindow *sw = (VideoSettingsWindow *)v;
	MyWin *win = sw->main_win;
	Camera *cam = win->DisplayedCamera();
	int rr = 0;
	int gg = 0;
	int bb = 0;
	int aa = 0;
	my_color_chooser("Timestamp Background Color", rr, gg, bb, aa);
	win->timestamp_background_rr = rr;
	win->timestamp_background_gg = gg;
	win->timestamp_background_bb = bb;
	win->timestamp_background_aa = aa;
	sw->timestamp_background_color_button->color(fl_rgb_color(rr, gg, bb));
	sw->redraw();
}

void	timestamp_font_size_cb(Fl_Widget *w, void *v)
{
	VideoSettingsWindow *sw = (VideoSettingsWindow *)v;
	MyWin *win = sw->main_win;
	char *str = (char *)sw->timestamp_font_size->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->timestamp_font_sz = nn;
		}
	}
}

void	timestamp_position_cb(Fl_Widget *w, void *v)
{
	VideoSettingsWindow *sw = (VideoSettingsWindow *)v;
	MyWin *win = sw->main_win;
	char *str = (char *)sw->timestamp_position_x->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->timestamp_position_x = nn;
		}
	}
	str = (char *)sw->timestamp_position_y->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->timestamp_position_y = nn;
		}
	}
}

void	video_settings_resolution_cb(Fl_Widget *w, void *v)
{
	VideoSettingsWindow *sw = (VideoSettingsWindow *)v;
	MyWin *win = sw->main_win;
	Camera *cam = win->DisplayedCamera();
	char *str = (char *)sw->output_w->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->output_width = nn;
		}
	}
	str = (char *)sw->output_h->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->output_height = nn;
		}
	}
}

void	camera_settings_alias_cb(Fl_Widget *w, void *v)
{
	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	Camera *cam = win->DisplayedCamera();
	char *str = (char *)sw->cam_alias->value();
	if(str != NULL)
	{
		strcpy(cam->alias, str);
	}
}

void	camera_settings_resolution_cb(Fl_Widget *w, void *v)
{
int	loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(sw->apply_to_all_button->value())
	{
		for(loop = 0;loop < win->source_cnt;loop++)
		{
			Camera *cam = win->camera[loop];
			if(cam != NULL)
			{
				char *str = (char *)sw->display_w->value();
				if(str != NULL)
				{
					int nn = atoi(str);
					if(nn > 0)
					{
						cam->display_width = nn;
					}
				}
				str = (char *)sw->display_h->value();
				if(str != NULL)
				{
					int nn = atoi(str);
					if(nn > 0)
					{
						cam->display_height = nn;
					}
				}
			}
		}
	}
	else
	{
		Camera *cam = win->DisplayedCamera();
		char *str = (char *)sw->display_w->value();
		if(str != NULL)
		{
			int nn = atoi(str);
			if(nn > 0)
			{
				cam->display_width = nn;
			}
		}
		str = (char *)sw->display_h->value();
		if(str != NULL)
		{
			int nn = atoi(str);
			if(nn > 0)
			{
				cam->display_height = nn;
			}
		}
	}
}

VideoSettingsWindow::VideoSettingsWindow(MyWin *in_win) : Dialog(360, 200, 800, 455, "Video Settings")
{
char	buf[256];

	main_win = in_win;
	Camera *cam = main_win->DisplayedCamera();
	int new_yp = 20;

	if(main_win->disregard_settings == 0)
	{
		load_system_video_settings_from_file(main_win);
	}
	last_x = 0;
	last_y = 0;
	resize(x(), y(), w(), h());

	int yp = new_yp + 20;

	output_w = new Fl_Int_Input(200, yp, 60, 20, "Output Size");
	output_w->box(FL_FRAME_BOX);
	output_w->color(BLACK);
	output_w->labelcolor(YELLOW);
	output_w->textcolor(WHITE);
	output_w->labelsize(12);
	output_w->textsize(11);
	output_w->cursor_color(WHITE);
	sprintf(buf, "%d", main_win->output_width);
	output_w->value(buf);
	output_w->when(FL_WHEN_CHANGED);
	output_w->copy_tooltip("Width of the outout stream");
	output_w->callback(video_settings_resolution_cb, this);

	output_h = new Fl_Int_Input(262, yp, 60, 20, "");
	output_h->box(FL_FRAME_BOX);
	output_h->color(BLACK);
	output_h->labelcolor(YELLOW);
	output_h->textcolor(WHITE);
	output_h->labelsize(12);
	output_h->textsize(11);
	output_h->cursor_color(WHITE);
	sprintf(buf, "%d", main_win->output_height);
	output_h->value(buf);
	output_h->when(FL_WHEN_CHANGED);
	output_h->copy_tooltip("Height of the outout stream");
	output_h->callback(video_settings_resolution_cb, this);
	yp += 25;

	timestamp_default = new MyToggleButton(200, yp + 2, 16, 16, "Timestamp");
	timestamp_default->box(FL_FRAME_BOX);
	timestamp_default->color(BLACK);
	timestamp_default->down_color(WHITE);
	timestamp_default->align(FL_ALIGN_LEFT);
	timestamp_default->labelcolor(YELLOW);
	timestamp_default->labelsize(12);
	timestamp_default->value(main_win->timestamp);
	timestamp_default->copy_tooltip("Embed a timestamp on the output");
	timestamp_default->callback(timestamp_default_cb, this);

	timestamp_format = new Fl_Input(218, yp, 462, 20, "Format");
	timestamp_format->box(FL_FRAME_BOX);
	timestamp_format->color(BLACK);
	timestamp_format->textcolor(WHITE);
	timestamp_format->labelsize(12);
	timestamp_format->textsize(11);
	timestamp_format->cursor_color(WHITE);
	timestamp_format->labelcolor(YELLOW);
	timestamp_format->align(FL_ALIGN_TOP | FL_ALIGN_CENTER);
	timestamp_format->value(main_win->timestamp_format);
	timestamp_format->copy_tooltip("Format of the timestamp");
	timestamp_format->callback(timestamp_format_cb, this);

	timestamp_color_button = new MyButton(681, yp, 20, 20, "F");
	timestamp_color_button->box(FL_FRAME_BOX);
	int rr = main_win->timestamp_rr;
	int gg = main_win->timestamp_gg;
	int bb = main_win->timestamp_bb;
	timestamp_color_button->color(fl_rgb_color(rr, gg, bb));
	timestamp_color_button->labelcolor(YELLOW);
	timestamp_color_button->labelsize(9);
	timestamp_color_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	timestamp_color_button->callback(timestamp_color_cb, this);

	timestamp_background_color_button = new MyButton(702, yp, 20, 20, "B");
	timestamp_background_color_button->box(FL_FRAME_BOX);
	rr = main_win->timestamp_background_rr;
	gg = main_win->timestamp_background_gg;
	bb = main_win->timestamp_background_bb;
	timestamp_background_color_button->color(fl_rgb_color(rr, gg, bb));
	timestamp_background_color_button->labelcolor(YELLOW);
	timestamp_background_color_button->labelsize(9);
	timestamp_background_color_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	timestamp_background_color_button->copy_tooltip("Change the background color of the timestamp");
	timestamp_background_color_button->callback(timestamp_background_color_cb, this);
	yp += 40;

	Fl_Box *tf_box = new Fl_Box(200, yp, 500, 20,
		"%Y = current year\t"
		"%M = current month\t"
		"%D = current day\n"
		"%h = hour\t"
		"%m = minute\t"
		"%s = second\n"
		"%u = microsecond\t"
		"%U = millisecond\n"
		"%S = current time in seconds\t"
		"%d = duration\n"
		"%frame = recorded frames\t"
		"%source = path to video source");

	tf_box->box(FL_FLAT_BOX);
	tf_box->color(BLACK);
	tf_box->labelcolor(WHITE);
	tf_box->labelsize(9);
	tf_box->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	yp += 40;

	timestamp_font_size = new Fl_Int_Input(200, yp, 60, 20, "Timestamp Font Size");
	timestamp_font_size->box(FL_FRAME_BOX);
	timestamp_font_size->color(BLACK);
	timestamp_font_size->textcolor(WHITE);
	timestamp_font_size->labelsize(12);
	timestamp_font_size->textsize(11);
	timestamp_font_size->cursor_color(WHITE);
	sprintf(buf, "%d", (int)main_win->timestamp_font_sz);
	timestamp_font_size->value(buf);
	timestamp_font_size->labelcolor(YELLOW);
	timestamp_font_size->copy_tooltip("Change the font size of the timestamp");
	timestamp_font_size->callback(timestamp_font_size_cb, this);

	timestamp_position_x = new Fl_Int_Input(400, yp, 60, 20, "Timestamp Position");
	timestamp_position_x->box(FL_FRAME_BOX);
	timestamp_position_x->color(BLACK);
	timestamp_position_x->textcolor(WHITE);
	timestamp_position_x->labelsize(12);
	timestamp_position_x->textsize(11);
	timestamp_position_x->cursor_color(WHITE);
	sprintf(buf, "%d", (int)main_win->timestamp_position_x);
	timestamp_position_x->value(buf);
	timestamp_position_x->labelcolor(YELLOW);
	timestamp_position_x->copy_tooltip("Horizontal position of the timestamp");
	timestamp_position_x->callback(timestamp_position_cb, this);

	timestamp_position_y = new Fl_Int_Input(470, yp, 60, 20, "");
	timestamp_position_y->box(FL_FRAME_BOX);
	timestamp_position_y->color(BLACK);
	timestamp_position_y->textcolor(WHITE);
	timestamp_position_y->labelsize(12);
	timestamp_position_y->textsize(11);
	timestamp_position_y->cursor_color(WHITE);
	sprintf(buf, "%d", (int)main_win->timestamp_position_y);
	timestamp_position_y->value(buf);
	timestamp_position_y->labelcolor(YELLOW);
	timestamp_position_y->copy_tooltip("Vertical position of the timestamp");
	timestamp_position_y->callback(timestamp_position_cb, this);

	yp += 25;
	fps_slider = new MySlider(200, yp, 500, 25, "FPS");
	fps_slider->range(0.0, 100.0);
	fps_slider->value(0.0);
	fps_slider->step(0.5);
	fps_slider->initial_value = 0.0;
	fps_slider->labelsize(12);
	fps_slider->copy_tooltip("Target FPS of the output");
	fps_slider->callback(fps_slider_cb, main_win);

	yp += 25;
	encode_fps_slider = new MySlider(200, yp, 500, 25, "Encode FPS (factor)");
	encode_fps_slider->range(0.01, 25.0);
	encode_fps_slider->value(1.0);
	encode_fps_slider->step(0.01);
	encode_fps_slider->initial_value = 1.0;
	encode_fps_slider->labelsize(12);
	encode_fps_slider->copy_tooltip("Encoding FPS of the output");
	encode_fps_slider->callback(encode_fps_cb, main_win);

	yp += 25;
	minimum_fps_slider = new MySlider(200, yp, 500, 25, "Minimum FPS");
	minimum_fps_slider->range(0.01, 60.0);
	minimum_fps_slider->value(20.0);
	minimum_fps_slider->step(1.0);
	minimum_fps_slider->initial_value = 20.0;
	minimum_fps_slider->labelsize(12);
	minimum_fps_slider->copy_tooltip("Set a minimum FPS for the output");
	minimum_fps_slider->callback(minimum_fps_cb, main_win);

	yp += 30;
	int row_start = yp;
	realtime_encoding_button = new MyLightButton(200, yp, 120, 20, "Realtime Encoding");
	realtime_encoding_button->box(FL_FRAME_BOX);
	realtime_encoding_button->color(BLACK);
	realtime_encoding_button->labelcolor(YELLOW);
	realtime_encoding_button->labelsize(9);
	realtime_encoding_button->align(FL_ALIGN_CENTER);
	realtime_encoding_button->value(main_win->muxing);
	realtime_encoding_button->copy_tooltip("Encode while recording");
	realtime_encoding_button->callback(realtime_encoding_cb, main_win);
	yp += 22;
	embed_pip_button = new MyLightButton(200, yp, 120, 20, "Embed PIP");
	embed_pip_button->box(FL_FRAME_BOX);
	embed_pip_button->color(BLACK);
	embed_pip_button->labelcolor(YELLOW);
	embed_pip_button->labelsize(9);
	embed_pip_button->align(FL_ALIGN_CENTER);
	embed_pip_button->value(main_win->embed_pip);
	embed_pip_button->copy_tooltip("Embed a picture in picture window onto the main video recording");
	embed_pip_button->callback(embed_pip_cb, main_win);
	yp += 22;
	gather_codecs_button = new MyButton(200, yp, 120, 20, "Gather Codecs");
	gather_codecs_button->box(FL_FRAME_BOX);
	gather_codecs_button->color(BLACK);
	gather_codecs_button->labelcolor(YELLOW);
	gather_codecs_button->labelsize(9);
	gather_codecs_button->align(FL_ALIGN_CENTER);
	gather_codecs_button->copy_tooltip("Query and test codec combinations");
	gather_codecs_button->callback(gather_codecs_cb, main_win);
	yp += 22;
	create_tag_file_button = new MyLightButton(200, yp, 120, 20, "Create Tag File");
	create_tag_file_button->box(FL_FRAME_BOX);
	create_tag_file_button->color(BLACK);
	create_tag_file_button->labelcolor(YELLOW);
	create_tag_file_button->labelsize(9);
	create_tag_file_button->align(FL_ALIGN_CENTER);
	create_tag_file_button->value(main_win->tag_recognized);
	create_tag_file_button->copy_tooltip("Create an ASCII file with recognized objects found in the video");
	create_tag_file_button->callback(create_tag_file_cb, main_win);

	yp = row_start;
	record_all_button = new MyLightButton(330, yp, 120, 20, "Record Main Window");
	record_all_button->box(FL_FRAME_BOX);
	record_all_button->color(BLACK);
	record_all_button->labelcolor(YELLOW);
	record_all_button->labelsize(9);
	record_all_button->align(FL_ALIGN_CENTER);
	record_all_button->value(main_win->record_all);
	record_all_button->copy_tooltip("Record the entire main window rather than only the selected cameras");
	record_all_button->callback(record_all_cb, main_win);
	yp += 22;
	frame_scaling_button = new MyLightButton(330, yp, 120, 20, "Frame Scaled Output");
	frame_scaling_button->box(FL_FRAME_BOX);
	frame_scaling_button->color(BLACK);
	frame_scaling_button->labelcolor(YELLOW);
	frame_scaling_button->labelsize(9);
	frame_scaling_button->align(FL_ALIGN_CENTER);
	frame_scaling_button->value(main_win->frame_scaling);
	frame_scaling_button->copy_tooltip("Rather than stretching the recorded camera, place frames around it to meet output size");
	frame_scaling_button->callback(frame_scaling_cb, main_win);
	yp += 22;
	crop_scaling_button = new MyLightButton(330, yp, 120, 20, "Crop Scaling");
	crop_scaling_button->box(FL_FRAME_BOX);
	crop_scaling_button->color(BLACK);
	crop_scaling_button->labelcolor(YELLOW);
	crop_scaling_button->labelsize(9);
	crop_scaling_button->align(FL_ALIGN_CENTER);
	crop_scaling_button->value(main_win->crop_scaling);
	crop_scaling_button->copy_tooltip("Rather than stretching the recorded camera, crop it to the output size");
	crop_scaling_button->callback(crop_scaling_cb, main_win);
	yp += 22;
	crop_output_button = new MyLightButton(330, yp, 120, 20, "Crop Output");
	crop_output_button->box(FL_FRAME_BOX);
	crop_output_button->color(BLACK);
	crop_output_button->labelcolor(YELLOW);
	crop_output_button->labelsize(9);
	crop_output_button->align(FL_ALIGN_CENTER);
	crop_output_button->value(main_win->crop_output);
	crop_output_button->copy_tooltip("Crop the output video");
	crop_output_button->callback(crop_output_cb, main_win);
	yp += 22;

	yp = row_start;
	single_stream_button = new MyLightButton(460, yp, 120, 20, "Multistream Output");
	single_stream_button->box(FL_FRAME_BOX);
	single_stream_button->color(BLACK);
	single_stream_button->labelcolor(YELLOW);
	single_stream_button->labelsize(9);
	single_stream_button->align(FL_ALIGN_CENTER);
	single_stream_button->value(!main_win->single_stream);
	single_stream_button->copy_tooltip("Output multiple streams at once");
	single_stream_button->callback(single_stream_cb, main_win);
	yp += 22;
	display_recording_button = new MyLightButton(460, yp, 120, 20, "Display Recording");
	display_recording_button->box(FL_FRAME_BOX);
	display_recording_button->color(BLACK);
	display_recording_button->labelcolor(YELLOW);
	display_recording_button->labelsize(9);
	display_recording_button->align(FL_ALIGN_CENTER);
	display_recording_button->value(0);
	display_recording_button->copy_tooltip("Always display the recording camera");
	if(main_win->follow_mode == FOLLOW_MODE_DISPLAY_RECORDING_CAMERA)
	{
		display_recording_button->value(1);
	}
	display_recording_button->callback(follow_mode_cb, this);
	yp += 22;
	recording_follow_display_button = new MyLightButton(460, yp, 120, 20, "Record Displayed");
	recording_follow_display_button->box(FL_FRAME_BOX);
	recording_follow_display_button->color(BLACK);
	recording_follow_display_button->labelcolor(YELLOW);
	recording_follow_display_button->labelsize(9);
	recording_follow_display_button->align(FL_ALIGN_CENTER);
	recording_follow_display_button->value(0);
	recording_follow_display_button->copy_tooltip("Always display the recording camera");
	if(main_win->follow_mode == FOLLOW_MODE_RECORDING_FOLLOWS_DISPLAY)
	{
		recording_follow_display_button->value(1);
	}
	recording_follow_display_button->callback(follow_mode_cb, this);
	yp += 22;

	html_background_transparent = new MyLightButton(460, yp, 120, 20, "HTML Transparent");
	html_background_transparent->box(FL_FRAME_BOX);
	html_background_transparent->color(BLACK);
	html_background_transparent->labelcolor(YELLOW);
	html_background_transparent->labelsize(9);
	html_background_transparent->align(FL_ALIGN_CENTER);
	html_background_transparent->value(main_win->html_background);
	html_background_transparent->copy_tooltip("Make the background of HTML sources transparent");
	html_background_transparent->callback(html_background_transparent_cb, this);
	yp += 25;

	yp += 32;
	MyButton *close = new MyButton(70, yp, 100, 30, "Close");
	close->box(FL_FRAME_BOX);
	close->color(BLACK);
	close->labelcolor(YELLOW);
	close->labelsize(12);
	close->callback(settings_close_cb, this);
	close->copy_tooltip("Close this window, saving settings");
	end();
	resize(x(), y(), w(), yp + 50);
}

VideoSettingsWindow::~VideoSettingsWindow()
{
}

void	VideoSettingsWindow::draw()
{
	fl_color(BLACK);
	fl_rectf(40, 40, 160, h() - 80);
	Fl_Window::draw();
}

int	VideoSettingsWindow::handle(int event)
{
	int flag = 0;
	flag = Dialog::handle(event);
	if(flag == 0)
	{
		if((event == FL_FOCUS)
		|| (event == FL_UNFOCUS))
		{
			flag = 1;
		}
		else if(event == FL_KEYBOARD)
		{
			int key = Fl::event_key();
			if(key == FL_Escape)
			{
				hide();
				flag = 1;
			}
		}
	}
	return(flag);
}

void	VideoSettingsWindow::Update()
{
	if(main_win != NULL)
	{
		Camera *cam = main_win->DisplayedCamera();
		if(cam != NULL)
		{
			fps_slider->value(cam->fps);
		}
		if(main_win->recorded_frames > 0)
		{
			output_w->deactivate();
			output_h->deactivate();
			fps_slider->deactivate();
			encode_fps_slider->deactivate();
			minimum_fps_slider->deactivate();
			realtime_encoding_button->deactivate();
			single_stream_button->deactivate();
		}
		else
		{
			output_w->activate();
			output_h->activate();
			fps_slider->activate();
			encode_fps_slider->activate();
			minimum_fps_slider->activate();
			realtime_encoding_button->activate();
			single_stream_button->activate();
		}
	}
}

// SECTION ************************************** MISC VIDEO SETTINGS WINDOW *******************************************************

void	misc_slider_cb(Fl_Widget *w, void *v)
{
	MiscVideoSettingsWindow *misc_window = (MiscVideoSettingsWindow *)v;
	MySlider *slide = (MySlider *)w;
	if(slide != NULL)
	{
		double nn = slide->value();
		if(slide == misc_window->contrast_slider)
		{
			misc_window->contrast = nn;
		}
		else if(slide == misc_window->brightness_slider)
		{
			misc_window->brightness = nn;
		}
		else if(slide == misc_window->saturation_slider)
		{
			misc_window->saturation = nn;
		}
		else if(slide == misc_window->hue_slider)
		{
			misc_window->hue = nn;
		}
		else if(slide == misc_window->intensity_slider)
		{
			misc_window->intensity = nn;
		}
	}
}

MiscVideoSettingsWindow::MiscVideoSettingsWindow(MyWin *in_win) : Dialog(360, 200, 800, 795, "Video Settings")
{
	my_window = in_win;

	contrast = 0.5;
	brightness = 0.5;
	saturation = 1.0;
	hue = 1.0;
	intensity = 1.0;

	int new_yp = 20;

	last_x = 0;
	last_y = 0;
	resize(x(), y(), w(), h());
	int font_sz = 9;

	int yp = 20 + new_yp;

	contrast_slider = new MySlider(200, yp, 500, 25, "Contrast");
	contrast_slider->range(0.0, 1.0);
	contrast_slider->value(0.5);
	contrast_slider->initial_value = 0.5;
	contrast_slider->labelsize(font_sz + 1);
	contrast_slider->labelcolor(YELLOW);
	contrast_slider->callback(misc_slider_cb, this);
	contrast_slider->copy_tooltip("Contrast applied to the image after it is received from the camera.");
	yp += 25;
	brightness_slider = new MySlider(200, yp, 500, 25, "Brightness");
	brightness_slider->range(0.0, 1.0);
	brightness_slider->value(0.5);
	brightness_slider->initial_value = 0.5;
	brightness_slider->labelsize(font_sz + 1);
	brightness_slider->labelcolor(YELLOW);
	brightness_slider->copy_tooltip("Brightness applied to the image after it is received from the camera.");
	brightness_slider->callback(misc_slider_cb, this);
	yp += 25;
	saturation_slider = new MySlider(200, yp, 500, 25, "Saturation");
	saturation_slider->range(0.0, 2.0);
	saturation_slider->value(1.0);
	saturation_slider->initial_value = 1.0;
	saturation_slider->labelsize(font_sz + 1);
	saturation_slider->labelcolor(YELLOW);
	saturation_slider->copy_tooltip("Color saturation applied to the image after it is received from the camera.");
	saturation_slider->callback(misc_slider_cb, this);
	yp += 25;
	hue_slider = new MySlider(200, yp, 500, 25, "Hue");
	hue_slider->range(0.0, 2.0);
	hue_slider->value(1.0);
	hue_slider->initial_value = 1.0;
	hue_slider->labelsize(font_sz + 1);
	hue_slider->labelcolor(YELLOW);
	hue_slider->copy_tooltip("Hue adjustment applied to the image after it is received from the camera.");
	hue_slider->callback(misc_slider_cb, this);
	yp += 25;
	intensity_slider = new MySlider(200, yp, 500, 25, "Value");
	intensity_slider->range(0.0, 2.0);
	intensity_slider->value(1.0);
	intensity_slider->initial_value = 1.0;
	intensity_slider->labelsize(font_sz + 1);
	intensity_slider->labelcolor(YELLOW);
	intensity_slider->copy_tooltip("Color intensity applied to the image after it is received from the camera.");
	intensity_slider->callback(misc_slider_cb, this);
	yp += 50;

	MyButton *close = new MyButton(70, yp, 100, 22, "Close");
	close->box(FL_FRAME_BOX);
	close->color(BLACK);
	close->labelcolor(YELLOW);
	close->labelsize(font_sz + 1);
	close->copy_tooltip("Close the dialog.");
	close->callback(hide_window_cb, this);
	end();
	resize(x(), y(), w(), yp + 55);
}

MiscVideoSettingsWindow::~MiscVideoSettingsWindow()
{
}

int	MiscVideoSettingsWindow::handle(int event)
{
	int flag = 0;
	flag = Dialog::handle(event);
	if(flag == 0)
	{
		if((event == FL_FOCUS)
		|| (event == FL_UNFOCUS))
		{
			flag = 1;
		}
		else if(event == FL_KEYBOARD)
		{
			int key = Fl::event_key();
			if(key == FL_Escape)
			{
				hide();
				flag = 1;
			}
		}
		else if(event == FL_PUSH)
		{
			last_x = Fl::event_x_root();
			last_y = Fl::event_y_root();
			flag = 1;
		}
		else if(event == FL_RELEASE)
		{
			flag = 1;
		}
		else if(event == FL_DRAG)
		{
			int xx = Fl::event_x_root();
			int yy = Fl::event_y_root();
			int dx = last_x - xx;
			int dy = last_y - yy;
			resize(x() - dx, y() - dy, w(), h());
			last_x = xx;
			last_y = yy;
			flag = 1;
		}
	}
	return(flag);
}

// SECTION ************************************** CAMERA SETTINGS WINDOW *******************************************************

void	capture_interval_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->capture_interval = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->capture_interval = nn;
				}
			}
		}
	}

}

void	retrieve_interval_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->hot_delay = (int)nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->hot_delay = (int)nn;
				}
			}
		}
	}
}

void	load_from_saved_camera_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			char filename[4096];
			int nn = my_file_chooser("Select a camera file", "*.json", "./Cameras", filename);
			if(nn > 0)
			{
				win->LoadJSONCamera(filename, cam);
				sw->Update();
			}
		}
	}
}

void	motion_threshold_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->motion_threshold = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->motion_threshold = nn;
				}
			}
		}
	}
}

void	threshold_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->recognition_threshold = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->recognition_threshold = nn;
				}
			}
		}
	}
}

void	recognition_interval_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->recognize_interval = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->recognize_interval = nn;
				}
			}
		}
	}
}

void	contrast_slider_cb(Fl_Widget *w, void *v)
{
int	loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->contrast = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)
				{
					double nn = slide->value();
					cam->contrast = nn;
				}
			}
		}
	}
}

void	brightness_slider_cb(Fl_Widget *w, void *v)
{
int	loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->brightness = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)
				{
					double nn = slide->value();
					cam->brightness = nn;
				}
			}
		}
	}
}

void	saturation_slider_cb(Fl_Widget *w, void *v)
{
int	loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->saturation = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)
				{
					double nn = slide->value();
					cam->saturation = nn;
				}
			}
		}
	}
}

void	hue_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->hue = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)
				{
					double nn = slide->value();
					cam->hue = nn;
				}
			}
		}
	}

}

void	intensity_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->intensity = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)
				{
					double nn = slide->value();
					cam->intensity = nn;
				}
			}
		}
	}
}

void	red_intensity_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->red_intensity = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->red_intensity = nn;
				}
			}
		}
	}

}

void	green_intensity_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->green_intensity = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->green_intensity = nn;
				}
			}
		}
	}
}

void	blue_intensity_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->blue_intensity = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->blue_intensity = nn;
				}
			}
		}
	}
}

void	alpha_intensity_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->alpha_intensity = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->alpha_intensity = nn;
				}
			}
		}
	}
}

void	aspect_x_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->forced_aspect_x = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->forced_aspect_x = nn;
				}
			}
		}
	}
}

void	aspect_y_slider_cb(Fl_Widget *w, void *v)
{
int loop;

	CameraSettingsWindow *sw = (CameraSettingsWindow *)v;
	MyWin *win = sw->main_win;
	if(win != NULL)
	{
		if(sw->apply_to_all_button->value())
		{
			for(loop = 0;loop < win->source_cnt;loop++)
			{
				Camera *cam = win->camera[loop];
				if(cam != NULL)
				{
					MySlider *slide = (MySlider *)w;
					if(slide != NULL)
					{
						double nn = slide->value();
						cam->forced_aspect_y = nn;
					}
				}
			}
		}
		else
		{
			Camera *cam = win->DisplayedCamera();
			if(cam != NULL)
			{
				MySlider *slide = (MySlider *)w;
				if(slide != NULL)  
				{
					double nn = slide->value();
					cam->forced_aspect_y = nn;
				}
			}
		}
	}
}

CameraSettingsWindow::CameraSettingsWindow(MyWin *in_win) : Dialog(360, 200, 800, 795, "Camera Settings")
{
char	buf[256];

	main_win = in_win;
	Camera *cam = main_win->DisplayedCamera();

	int new_yp = 20;

	if(main_win->disregard_settings == 0)
	{
		load_system_video_settings_from_file(main_win);
	}
	last_x = 0;
	last_y = 0;
	resize(x(), y(), w(), h());
	int font_sz = 9;

	int yp = 25 + new_yp;;

	cam_alias = new Fl_Input(200, yp, 200, 20, "Alias");
	cam_alias->box(FL_FRAME_BOX);
	cam_alias->color(BLACK);
	cam_alias->textcolor(WHITE);
	cam_alias->labelsize(font_sz);
	cam_alias->textsize(font_sz);
	cam_alias->textsize(font_sz);
	cam_alias->cursor_color(WHITE);
	cam_alias->labelcolor(YELLOW);
	cam_alias->copy_tooltip("Alias is used to identify a camera and should be unique and human readable.\n");
	cam_alias->when(FL_WHEN_CHANGED);
	char *str = "";
	if(cam != NULL)
	{
		str = cam->alias;
	}
	cam_alias->value(str);
	cam_alias->callback(camera_settings_alias_cb, this);
	yp += 25;

	display_w = new Fl_Int_Input(200, yp, 60, 20, "Display Size");
	display_w->box(FL_FRAME_BOX);
	display_w->color(BLACK);
	display_w->textcolor(WHITE);
	display_w->labelsize(font_sz + 1);
	display_w->textsize(font_sz);
	display_w->cursor_color(WHITE);
	display_w->labelcolor(YELLOW);
	display_w->copy_tooltip("The resolution of the displayed image from this camera.");
	if(cam != NULL)
	{
		sprintf(buf, "%d", (int)cam->display_width);
		display_w->value(buf);
	}
	display_w->callback(camera_settings_resolution_cb, this);

	display_h = new Fl_Int_Input(262, yp, 60, 20, "");
	display_h->box(FL_FRAME_BOX);
	display_h->color(BLACK);
	display_h->textcolor(WHITE);
	display_h->labelsize(font_sz + 1);
	display_h->textsize(font_sz);
	display_h->cursor_color(WHITE);
	display_h->labelcolor(YELLOW);
	display_h->copy_tooltip("The resolution of the displayed image from this camera.");
	if(cam != NULL)
	{
		sprintf(buf, "%d", (int)cam->display_height);
		display_h->value(buf);
	}
	display_h->callback(camera_settings_resolution_cb, this);

	yp += 35;
	contrast_slider = new MySlider(200, yp, 500, 25, "Contrast");
	contrast_slider->range(0.0, 1.0);
	contrast_slider->value(0.5);
	contrast_slider->initial_value = 0.5;
	contrast_slider->labelsize(font_sz + 1);
	contrast_slider->labelcolor(YELLOW);
	contrast_slider->callback(contrast_slider_cb, this);
	contrast_slider->copy_tooltip("Contrast applied to the image after it is received from the camera.");
	yp += 25;
	brightness_slider = new MySlider(200, yp, 500, 25, "Brightness");
	brightness_slider->range(0.0, 1.0);
	brightness_slider->value(0.5);
	brightness_slider->initial_value = 0.5;
	brightness_slider->labelsize(font_sz + 1);
	brightness_slider->labelcolor(YELLOW);
	brightness_slider->copy_tooltip("Brightness applied to the image after it is received from the camera.");
	brightness_slider->callback(brightness_slider_cb, this);
	yp += 25;
	saturation_slider = new MySlider(200, yp, 500, 25, "Saturation");
	saturation_slider->range(0.0, 2.0);
	saturation_slider->value(1.0);
	saturation_slider->initial_value = 1.0;
	saturation_slider->labelsize(font_sz + 1);
	saturation_slider->labelcolor(YELLOW);
	saturation_slider->copy_tooltip("Color saturation applied to the image after it is received from the camera.");
	saturation_slider->callback(saturation_slider_cb, this);
	yp += 25;
	hue_slider = new MySlider(200, yp, 500, 25, "Hue");
	hue_slider->range(0.0, 2.0);
	hue_slider->value(1.0);
	hue_slider->initial_value = 1.0;
	hue_slider->labelsize(font_sz + 1);
	hue_slider->labelcolor(YELLOW);
	hue_slider->copy_tooltip("Hue adjustment applied to the image after it is received from the camera.");
	hue_slider->callback(hue_slider_cb, this);
	yp += 25;
	intensity_slider = new MySlider(200, yp, 500, 25, "Value");
	intensity_slider->range(0.0, 2.0);
	intensity_slider->value(1.0);
	intensity_slider->initial_value = 1.0;
	intensity_slider->labelsize(font_sz + 1);
	intensity_slider->labelcolor(YELLOW);
	intensity_slider->copy_tooltip("Color intensity applied to the image after it is received from the camera.");
	intensity_slider->callback(intensity_slider_cb, this);
	yp += 25;
	red_intensity_slider = new MySlider(200, yp, 500, 25, "Red Value");
	red_intensity_slider->range(0.0, 2.0);
	red_intensity_slider->value(1.0);
	red_intensity_slider->initial_value = 1.0;
	red_intensity_slider->labelsize(font_sz + 1);
	red_intensity_slider->labelcolor(YELLOW);
	red_intensity_slider->copy_tooltip("Red intensity applied to the image after it is received from the camera.");
	red_intensity_slider->callback(red_intensity_slider_cb, this);
	yp += 25;
	green_intensity_slider = new MySlider(200, yp, 500, 25, "Green Value");
	green_intensity_slider->range(0.0, 2.0);
	green_intensity_slider->value(1.0);
	green_intensity_slider->initial_value = 1.0;
	green_intensity_slider->labelsize(font_sz + 1);
	green_intensity_slider->labelcolor(YELLOW);
	green_intensity_slider->copy_tooltip("Green intensity applied to the image after it is received from the camera.");
	green_intensity_slider->callback(green_intensity_slider_cb, this);
	yp += 25;
	blue_intensity_slider = new MySlider(200, yp, 500, 25, "Blue Value");
	blue_intensity_slider->range(0.0, 2.0);
	blue_intensity_slider->value(1.0);
	blue_intensity_slider->initial_value = 1.0;
	blue_intensity_slider->labelsize(font_sz + 1);
	blue_intensity_slider->labelcolor(YELLOW);
	blue_intensity_slider->copy_tooltip("Blue intensity applied to the image after it is received from the camera.");
	blue_intensity_slider->callback(blue_intensity_slider_cb, this);
	yp += 25;
	alpha_intensity_slider = new MySlider(200, yp, 500, 25, "Alpha Value");
	alpha_intensity_slider->range(0.0, 2.0);
	alpha_intensity_slider->value(1.0);
	alpha_intensity_slider->initial_value = 1.0;
	alpha_intensity_slider->labelsize(font_sz + 1);
	alpha_intensity_slider->labelcolor(YELLOW);
	alpha_intensity_slider->copy_tooltip("Alpha intensity applied to the image after it is received from the camera.");
	alpha_intensity_slider->callback(alpha_intensity_slider_cb, this);
	yp += 25;
	aspect_x_slider = new MySlider(200, yp, 500, 25, "Aspect Width");
	aspect_x_slider->range(0.0, 2.0);
	aspect_x_slider->value(1.0);
	aspect_x_slider->initial_value = 1.0;
	aspect_x_slider->labelsize(font_sz + 1);
	aspect_x_slider->labelcolor(YELLOW);
	aspect_x_slider->copy_tooltip("Aspect ratio adjustment. This will stretch the image is cropping is not applied.");
	aspect_x_slider->callback(aspect_x_slider_cb, this);
	yp += 25;
	aspect_y_slider = new MySlider(200, yp, 500, 25, "Aspect Height");
	aspect_y_slider->range(0.0, 2.0);
	aspect_y_slider->value(1.0);
	aspect_y_slider->initial_value = 1.0;
	aspect_y_slider->labelsize(font_sz + 1);
	aspect_y_slider->labelcolor(YELLOW);
	aspect_y_slider->copy_tooltip("Aspect ratio adjustment. This will stretch the image is cropping is not applied.");
	aspect_y_slider->callback(aspect_y_slider_cb, this);

	yp += 25;
	motion_threshold_slider = new MySlider(200, yp, 500, 25, "Motion Threshold");
	motion_threshold_slider->range(10.0, 10000.0);
	motion_threshold_slider->value(100.0);
	motion_threshold_slider->initial_value = 100.0;
	motion_threshold_slider->labelsize(font_sz + 1);
	motion_threshold_slider->labelcolor(YELLOW);
	motion_threshold_slider->copy_tooltip("The amount of change required to trigger the motion sensor.");
	motion_threshold_slider->callback(motion_threshold_slider_cb, this);

	yp += 25;
	recognition_threshold_slider = new MySlider(200, yp, 500, 25, "Object Recog. Threshold");
	recognition_threshold_slider->range(0.0, 1.0);
	recognition_threshold_slider->value(0.5);
	recognition_threshold_slider->initial_value = 0.5;
	recognition_threshold_slider->labelsize(font_sz + 1);
	recognition_threshold_slider->labelcolor(YELLOW);
	recognition_threshold_slider->copy_tooltip("The certainty of recognition necessary to trigger recording.");
	recognition_threshold_slider->callback(threshold_slider_cb, this);

	yp += 25;
	recognition_interval_slider = new MySlider(200, yp, 500, 25, "Object Recog. Interval");
	recognition_interval_slider->range(1, 100);
	recognition_interval_slider->value(10);
	recognition_interval_slider->step(1);
	recognition_interval_slider->initial_value = 10;
	recognition_interval_slider->labelsize(font_sz + 1);
	recognition_interval_slider->labelcolor(YELLOW);
	recognition_interval_slider->copy_tooltip("How often the object recognition looks at a frame.");
	recognition_interval_slider->callback(recognition_interval_cb, this);

	yp += 25;
	capture_interval_slider = new MySlider(200, yp, 500, 25, "Capture Interval");
	capture_interval_slider->range(0.1, 60.0);
	capture_interval_slider->value(0.0);
	capture_interval_slider->step(0.1);
	capture_interval_slider->initial_value = 0.0;
	capture_interval_slider->labelsize(font_sz + 1);
	capture_interval_slider->labelcolor(YELLOW);
	capture_interval_slider->copy_tooltip("How frequently recording samples the frames arriving from this camera.");
	capture_interval_slider->callback(capture_interval_cb, this);

	yp += 25;
	retrieve_interval_slider = new MySlider(200, yp, 500, 25, "Retrieve Interval");
	retrieve_interval_slider->range(1.0, 1000000.0);
	retrieve_interval_slider->value(10000.0);
	retrieve_interval_slider->step(10000.0);
	retrieve_interval_slider->initial_value = 10000.0;
	retrieve_interval_slider->labelsize(font_sz + 1);
	retrieve_interval_slider->labelcolor(YELLOW);
	retrieve_interval_slider->copy_tooltip("How often this camera is sampled at all.");
	retrieve_interval_slider->callback(retrieve_interval_cb, this);
	yp += 25;

	yp += 44;
	apply_to_all_button = new MyToggleButton(70, yp, 100, 22, "Apply to All");
	apply_to_all_button->box(FL_FRAME_BOX);
	apply_to_all_button->color(BLACK);
	apply_to_all_button->labelcolor(YELLOW);
	apply_to_all_button->labelsize(font_sz + 1);
	apply_to_all_button->copy_tooltip("Apply subsequent changes to all active cameras.");

	load_from = new MyButton(170, yp, 100, 22, "Load");
	load_from->box(FL_FRAME_BOX);
	load_from->color(BLACK);
	load_from->labelcolor(YELLOW);
	load_from->labelsize(font_sz + 1);
	load_from->copy_tooltip("Load settings from a camera file. This may change all settings other than source and alias. If the incoming resolution is changed, the camera may be reset.");
	load_from->callback(load_from_saved_camera_cb, this);
	yp += 24;

	MyButton *close = new MyButton(70, yp, 100, 22, "Close");
	close->box(FL_FRAME_BOX);
	close->color(BLACK);
	close->labelcolor(YELLOW);
	close->labelsize(font_sz + 1);
	close->copy_tooltip("Close the dialog.");
	close->callback(hide_window_cb, this);
	end();
	resize(x(), y(), w(), yp + 60);
}

CameraSettingsWindow::~CameraSettingsWindow()
{
}

void	CameraSettingsWindow::draw()
{
	fl_color(BLACK);
	fl_rectf(40, 40, 160, h() - 80);
	Fl_Window::draw();
}

int	CameraSettingsWindow::handle(int event)
{
	int flag = 0;
	flag = Dialog::handle(event);
	if(flag == 0)
	{
		if((event == FL_FOCUS)
		|| (event == FL_UNFOCUS))
		{
			flag = 1;
		}
		else if(event == FL_KEYBOARD)
		{
			int key = Fl::event_key();
			if(key == FL_Escape)
			{
				hide();
				flag = 1;
			}
		}
		else if(event == FL_PUSH)
		{
			last_x = Fl::event_x_root();
			last_y = Fl::event_y_root();
			flag = 1;
		}
		else if(event == FL_RELEASE)
		{
			flag = 1;
		}
		else if(event == FL_DRAG)
		{
			int xx = Fl::event_x_root();
			int yy = Fl::event_y_root();
			int dx = last_x - xx;
			int dy = last_y - yy;
			resize(x() - dx, y() - dy, w(), h());
			last_x = xx;
			last_y = yy;
			flag = 1;
		}
	}
	return(flag);
}

void	CameraSettingsWindow::Update()
{
char	buf[256];

	if(main_win != NULL)
	{
		Camera *cam = main_win->DisplayedCamera();
		if(cam != NULL)
		{
			char *str = "";
			if(cam != NULL)
			{
				str = cam->alias;
				cam_alias->value(str);

				sprintf(buf, "%d", (int)cam->display_width);
				display_w->value(buf);

				sprintf(buf, "%d", (int)cam->display_height);
				display_h->value(buf);
			}
			contrast_slider->value(cam->contrast);
			brightness_slider->value(cam->brightness);
			saturation_slider->value(cam->saturation);
			hue_slider->value(cam->hue);
			intensity_slider->value(cam->intensity);
			red_intensity_slider->value(cam->red_intensity);
			green_intensity_slider->value(cam->green_intensity);
			blue_intensity_slider->value(cam->blue_intensity);
			alpha_intensity_slider->value(cam->alpha_intensity);
			aspect_x_slider->value(cam->forced_aspect_x);
			aspect_y_slider->value(cam->forced_aspect_y);
			motion_threshold_slider->value(cam->motion_threshold);
			recognition_threshold_slider->value(cam->recognition_threshold);
			recognition_interval_slider->value(cam->recognize_interval);
			capture_interval_slider->value(cam->capture_interval);
			retrieve_interval_slider->value(cam->hot_delay);
		}
	}
}

// SECTION ************************************** SNAPSHOT SETTINGS WINDOW *******************************************************

void	snapshot_filename_format_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			strcpy(cam->snapshot_filename_format, win->filename_format->value());
		}
	}
}

void	snapshot_initial_delay_slider_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			cam->snapshot_initial_delay = (int)win->initial_delay_slider->value();
		}
	}
}

void	snapshot_repeat_delay_slider_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			int seconds = (int)win->repeat_seconds_delay_slider->value();
			int minutes = (int)win->repeat_minutes_delay_slider->value();
			cam->snapshot_repeat_delay = (minutes * 60) + seconds;
		}
	}
}

void	snapshot_scale_slider_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			double scale = win->scale_slider->value();
			cam->snapshot_scale = scale;
		}
	}
}

void	snapshot_trigger_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			if(win->snapshot_trigger_on_button->value() == 1)
			{
				cam->snapshot_trigger_condition = SNAPSHOT_TRIGGER_BUTTON;
			}
			else if(win->snapshot_trigger_on_start->value() == 1)
			{
				cam->snapshot_trigger_condition = SNAPSHOT_TRIGGER_START;
			}
			else if(win->snapshot_trigger_on_record->value() == 1)
			{
				cam->snapshot_trigger_condition = SNAPSHOT_TRIGGER_RECORD;
			}
			else if(win->snapshot_continuous->value() == 1)
			{
				cam->snapshot_trigger_condition = SNAPSHOT_TRIGGER_CONTINUOUS;
			}
		}
	}
}

SnapshotSettingWindow::SnapshotSettingWindow(MyWin *in_win) : Dialog(360, 200, 600, 370, "Snapshot Settings")
{
char	buf[256];

	main_win = in_win;
	Camera *cam = main_win->DisplayedCamera();

	int new_yp = 20;
	int yp = 22 + new_yp;
	if(cam != NULL)
	{
		last_x = 0;
		last_y = 0;
		resize(x(), y(), w(), h());

		filename_format = new Fl_Input(100, yp, 462, 20, "Filename");
		filename_format->box(FL_FRAME_BOX);
		filename_format->color(BLACK);
		filename_format->textcolor(WHITE);
		filename_format->labelsize(11);
		filename_format->textsize(11);
		filename_format->cursor_color(WHITE);
		filename_format->labelcolor(YELLOW);
		filename_format->when(FL_WHEN_CHANGED);
		filename_format->value(cam->snapshot_filename_format);
		filename_format->copy_tooltip("The filename for the image file. Special codes (see below) can be inserted in the path to create dynamic filenames.");
		filename_format->callback(snapshot_filename_format_cb, this);
		yp += 32;

		Fl_Box *instruction = new Fl_Box(10, yp, 560, 100);
		instruction->box(FL_FLAT_BOX);
		instruction->color(BLACK);
		instruction->labelsize(9);
		instruction->labelcolor(WHITE);
		instruction->labelfont(FL_SCREEN);
		instruction->align(FL_ALIGN_TOP | FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		instruction->label(
			"Insert into the path:\n\n"
			"%home = home directory\t\t\t"
			"%cwd = current working directory\n"
			"%Y = current year\t\t\t"
			"%M = current month\t\t\t"
			"%D = current day\n"
			"%h = hour\t\t\t\t"
			"%m = minute\t\t\t\t"
			"%s = second\n"
			"%u = microsecond\t\t\t"
			"%U = millisecond\t\t\t"
			"%S = current time in seconds\n"
			"%frame = recorded frames\t\t"
			"%source = path to video source\n\n"
			"So: \"snapshot_%Y_%M_%D_%h_%m_%s.flv\" will produce \"snapshot_2024_1_22_13_6_31.flv\" on January 22nd, 2024");
		yp += 120;

		initial_delay_slider = new MySlider(100, yp, 450, 20, "Initial Delay");
		initial_delay_slider->range(0.0, 60.0);
		initial_delay_slider->value(0.0);
		initial_delay_slider->step(1.0);
		initial_delay_slider->initial_value = 0.0;
		initial_delay_slider->labelsize(11);
		initial_delay_slider->labelcolor(YELLOW);
		initial_delay_slider->copy_tooltip("How long to wait before the snapshot is triggered.");
		initial_delay_slider->callback(snapshot_initial_delay_slider_cb, this);
		yp += 30;

		repeat_seconds_delay_slider = new MySlider(100, yp, 450, 20, "Repeat (sec.)");
		repeat_seconds_delay_slider->range(0.0, 60.0);
		repeat_seconds_delay_slider->value(0.0);
		repeat_seconds_delay_slider->step(1.0);
		repeat_seconds_delay_slider->initial_value = 0.0;
		repeat_seconds_delay_slider->labelsize(11);
		repeat_seconds_delay_slider->labelcolor(YELLOW);
		repeat_seconds_delay_slider->copy_tooltip("For a repeating snapshot, how long to wait in seconds between each.");
		repeat_seconds_delay_slider->callback(snapshot_repeat_delay_slider_cb, this);
		yp += 22;

		repeat_minutes_delay_slider = new MySlider(100, yp, 450, 20, "Repeat (min.)");
		repeat_minutes_delay_slider->range(0.0, 60.0);
		repeat_minutes_delay_slider->value(0.0);
		repeat_minutes_delay_slider->step(1.0);
		repeat_minutes_delay_slider->initial_value = 0.0;
		repeat_minutes_delay_slider->labelsize(11);
		repeat_minutes_delay_slider->labelcolor(YELLOW);
		repeat_minutes_delay_slider->copy_tooltip("For a repeating snapshot, how long to wait in minutes between each.");
		repeat_minutes_delay_slider->callback(snapshot_repeat_delay_slider_cb, this);
		yp += 30;

		int xp = 50;
		MyGroup *radio = new MyGroup(xp, yp, 500, 20);
		snapshot_trigger_on_button = new MyLightButton(xp, yp, 120, 20, "Trigger on Button");
		snapshot_trigger_on_button->box(FL_FRAME_BOX);
		snapshot_trigger_on_button->color(BLACK);
		snapshot_trigger_on_button->labelcolor(YELLOW);
		snapshot_trigger_on_button->labelsize(9);
		snapshot_trigger_on_button->type(FL_RADIO_BUTTON);
		snapshot_trigger_on_button->align(FL_ALIGN_CENTER);
		snapshot_trigger_on_button->value(1);
		snapshot_trigger_on_button->copy_tooltip("Trigger the snapshot when the Snapshot button is selected.");
		snapshot_trigger_on_button->callback(snapshot_trigger_cb, this);
		xp += 125;

		snapshot_trigger_on_start = new MyLightButton(xp, yp, 120, 20, "Trigger on Start");
		snapshot_trigger_on_start->box(FL_FRAME_BOX);
		snapshot_trigger_on_start->color(BLACK);
		snapshot_trigger_on_start->labelcolor(YELLOW);
		snapshot_trigger_on_start->labelsize(9);
		snapshot_trigger_on_start->type(FL_RADIO_BUTTON);
		snapshot_trigger_on_start->align(FL_ALIGN_CENTER);
		snapshot_trigger_on_start->copy_tooltip("Trigger a snapshot as soon as the displayed camera is ready.");
		snapshot_trigger_on_start->callback(snapshot_trigger_cb, this);
		xp += 125;

		snapshot_trigger_on_record = new MyLightButton(xp, yp, 120, 20, "Trigger on Record");
		snapshot_trigger_on_record->box(FL_FRAME_BOX);
		snapshot_trigger_on_record->color(BLACK);
		snapshot_trigger_on_record->labelcolor(YELLOW);
		snapshot_trigger_on_record->labelsize(9);
		snapshot_trigger_on_record->align(FL_ALIGN_CENTER);
		snapshot_trigger_on_record->type(FL_RADIO_BUTTON);
		snapshot_trigger_on_record->copy_tooltip("Trigger the snapshot when the Record button is selected.");
		snapshot_trigger_on_record->callback(snapshot_trigger_cb, this);
		xp += 125;

		snapshot_continuous = new MyLightButton(xp, yp, 120, 20, "Continuous");
		snapshot_continuous->box(FL_FRAME_BOX);
		snapshot_continuous->color(BLACK);
		snapshot_continuous->labelcolor(YELLOW);
		snapshot_continuous->labelsize(9);
		snapshot_continuous->align(FL_ALIGN_CENTER);
		snapshot_continuous->type(FL_RADIO_BUTTON);
		snapshot_continuous->copy_tooltip("Trigger the snapshot continuously.");
		snapshot_continuous->callback(snapshot_trigger_cb, this);
		radio->end();
		yp += 30;
		if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_BUTTON)
		{
			snapshot_trigger_on_button->value(1);
		}
		else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_START)
		{
			snapshot_trigger_on_start->value(1);
		}
		else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
		{
			snapshot_trigger_on_record->value(1);
		}
		else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_CONTINUOUS)
		{
			snapshot_continuous->value(1);
		}
		scale_slider = new MySlider(100, yp, 450, 20, "Scale");
		scale_slider->range(0.05, 1.0);
		scale_slider->value(cam->snapshot_scale);
		scale_slider->step(0.05);
		scale_slider->initial_value = 1.0;
		scale_slider->labelsize(11);
		scale_slider->labelcolor(YELLOW);
		scale_slider->copy_tooltip("Scale the resulting image.");
		scale_slider->callback(snapshot_scale_slider_cb, this);
		yp += 40;
	}
	MyButton *close = new MyButton(70, yp, 60, 22, "Close");
	close->box(FL_FRAME_BOX);
	close->color(BLACK);
	close->labelcolor(YELLOW);
	close->labelsize(11);
	close->copy_tooltip("Close this dialog.");
	close->callback(hide_window_cb, this);
	end();
}

SnapshotSettingWindow::~SnapshotSettingWindow()
{
}

void	SnapshotSettingWindow::draw()
{
	fl_color(BLACK);
	fl_rectf(40, 40, 160, h() - 80);
	Fl_Window::draw();
}

int	SnapshotSettingWindow::handle(int event)
{
	int flag = 0;
	flag = Dialog::handle(event);
	if(flag == 0)
	{
		if((event == FL_FOCUS)
		|| (event == FL_UNFOCUS))
		{
			flag = 1;
		}
		else if(event == FL_KEYBOARD)
		{
			int key = Fl::event_key();
			if(key == FL_Escape)
			{
				hide();
				flag = 1;
			}
		}
		else if(event == FL_PUSH)
		{
			last_x = Fl::event_x_root();
			last_y = Fl::event_y_root();
			flag = 1;
		}
		else if(event == FL_RELEASE)
		{
			flag = 1;
		}
		else if(event == FL_DRAG)
		{
			int xx = Fl::event_x_root();
			int yy = Fl::event_y_root();
			int dx = last_x - xx;
			int dy = last_y - yy;
			resize(x() - dx, y() - dy, w(), h());
			last_x = xx;
			last_y = yy;
			flag = 1;
		}
	}
	return(flag);
}

void	SnapshotSettingWindow::Update()
{
	if(main_win != NULL)
	{
		Camera *cam = main_win->DisplayedCamera();
		if(cam != NULL)
		{
			filename_format->value(cam->snapshot_filename_format);
			initial_delay_slider->value(cam->snapshot_initial_delay);

			int nn = cam->snapshot_repeat_delay;
			int minutes = nn / 60;
			int seconds = nn - (minutes * 60);
			repeat_seconds_delay_slider->value(seconds);
			repeat_minutes_delay_slider->value(minutes);

			scale_slider->value(cam->snapshot_scale);

			if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_BUTTON)
			{
				snapshot_trigger_on_button->value(1);
			}
			else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_START)
			{
				snapshot_trigger_on_start->value(1);
			}
			else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
			{
				snapshot_trigger_on_record->value(1);
			}
			else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_CONTINUOUS)
			{
				snapshot_continuous->value(1);
			}
		}
	}
}

// SECTION ************************************** GUI SETTINGS WINDOW *******************************************************

void	gui_settings_cb(Fl_Widget *w, void *v)
{
int		loop;
char	buf[256];

	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	gsw->my_window->hide_status = gsw->hide_status_button->value();
	gsw->my_window->retain_commands = gsw->retain_commands_button->value();
	gsw->my_window->retain_cameras = gsw->retain_cameras_button->value();
	gsw->my_window->retain_audio = gsw->retain_audio_button->value();
	gsw->my_window->retain_ptz = gsw->retain_ptz_button->value();
	if(gsw->reverse_panels_button->value() == 1)
	{
		gsw->my_window->button_group_side = SIDE_LEFT;
	}
	else
	{
		gsw->my_window->button_group_side = SIDE_RIGHT;
	}
	if(gsw->retain_all_button->value())
	{
		gsw->my_window->retain_commands = 1;
		gsw->my_window->retain_cameras = 1;
		gsw->my_window->retain_audio = 1;
		gsw->my_window->retain_ptz = 1;
	}
	gsw->my_window->use_tooltips = gsw->use_tooltips_button->value();
	if(gsw->my_window->use_tooltips == 1)
	{
		Fl_Tooltip::enable();
	}
	else
	{
		Fl_Tooltip::disable();
	}
	gsw->my_window->button_group->animated = gsw->animate_panels_button->value();
	gsw->my_window->video_thumbnail_group->animated = gsw->animate_panels_button->value();
	gsw->my_window->audio_thumbnail_group->animated = gsw->animate_panels_button->value();
	for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
	{
		if(gsw->my_window->ptz_window[loop] != NULL)
		{
			gsw->my_window->ptz_window[loop]->animated = gsw->animate_panels_button->value();
		}
	}
	gsw->my_window->animate_panels = gsw->animate_panels_button->value();

	Fl::set_color(BLACK, gsw->background_color_r, gsw->background_color_g, gsw->background_color_b, gsw->background_color_a);
	Fl::set_color(WHITE, gsw->text_color_r, gsw->text_color_g, gsw->text_color_b, gsw->text_color_a);
	Fl::set_color(YELLOW, gsw->highlight_color_r, gsw->highlight_color_g, gsw->highlight_color_b, gsw->highlight_color_a);
	Fl::set_color(GRAY, gsw->gray_color_r, gsw->gray_color_g, gsw->gray_color_b, gsw->gray_color_a);
	Fl::set_color(DARK_GRAY, gsw->dark_gray_color_r, gsw->dark_gray_color_g, gsw->dark_gray_color_b, gsw->dark_gray_color_a);
	Fl::set_color(RED, gsw->red_color_r, gsw->red_color_g, gsw->red_color_b, gsw->red_color_a);
	Fl::set_color(DARK_RED, gsw->dark_red_color_r, gsw->dark_red_color_g, gsw->dark_red_color_b, gsw->dark_red_color_a);
	Fl::set_color(BLUE, gsw->blue_color_r, gsw->blue_color_g, gsw->blue_color_b, gsw->blue_color_a);
	Fl::set_color(DARK_BLUE, gsw->dark_blue_color_r, gsw->dark_blue_color_g, gsw->dark_blue_color_b, gsw->dark_blue_color_a);
	Fl::set_color(CYAN, gsw->cyan_color_r, gsw->cyan_color_g, gsw->cyan_color_b, gsw->cyan_color_a);

	char *font_name = "sans";
	Fl_Hold_Browser *hold = (Fl_Hold_Browser *)gsw->font_browser;
	char *str = (char *)hold->text(hold->value());
	if(str != NULL)
	{
		if(strlen(str) > 7)
		{
			char *cp = str;
			cp += 7;
			Fl::set_font(FL_HELVETICA, cp);
			font_name = cp;
		}
	}
	MyWin *win = gsw->my_window;
	win->redraw();
	for(loop = 0;loop < win->children();loop++)
	{
		Fl_Widget *chld = win->child(loop);
		if(chld != NULL)
		{
			chld->redraw();
		}
	}
	if(win->video_thumbnail_group->visible())
	{
		for(loop = 0;loop < 128;loop++)
		{
			ThumbGroup *tb = win->thumbnail[loop];
			if(tb != NULL)
			{
				if(tb->V4L_Window != NULL)
				{
					tb->V4L_Window->redraw();
				}
			}
		}
	}
	gsw->my_window->PlaceButtonGroup(gsw->my_window->button_group_side);
	FILE *fp = fopen("GUI_settings.json", "w");
	if(fp != NULL)
	{
		MyWin *win = gsw->my_window;
		fprintf(fp, "{\n");
		fprintf(fp, "\t\"hide status\": %d,\n", win->hide_status);
		fprintf(fp, "\t\"retain commands\": %d,\n", win->retain_commands);
		fprintf(fp, "\t\"retain cameras\": %d,\n", win->retain_cameras);
		fprintf(fp, "\t\"retain audio\": %d,\n", win->retain_audio);
		fprintf(fp, "\t\"retain ptz\": %d,\n", win->retain_ptz);
		fprintf(fp, "\t\"button group side\": %d,\n", win->button_group_side);
		fprintf(fp, "\t\"transparent interface\": %d,\n", win->transparent_interface);
		fprintf(fp, "\t\"animate panels\": %d,\n", win->animate_panels);
		fprintf(fp, "\t\"exclude directories\": %d,\n", win->file_selector_exclude_directories);
		fprintf(fp, "\t\"use tooltips\": %d,\n", win->use_tooltips);
		fprintf(fp, "\t\"button group x\": %d,\n", win->button_group->x());
		fprintf(fp, "\t\"button group y\": %d,\n", win->button_group->y());
		fprintf(fp, "\t\"video thumbnail group x\": %d,\n", win->video_thumbnail_group->x());
		fprintf(fp, "\t\"video thumbnail group y\": %d,\n", win->video_thumbnail_group->y());
		fprintf(fp, "\t\"audio thumbnail group x\": %d,\n", win->audio_thumbnail_group->x());
		fprintf(fp, "\t\"audio thumbnail group y\": %d,\n", win->audio_thumbnail_group->y());
		fprintf(fp, "\t\"current fps window x\": %d,\n", win->current_fps_window->x());
		fprintf(fp, "\t\"current fps window y\": %d,\n", win->current_fps_window->y());
		fprintf(fp, "\t\"initial video out x\": %d,\n", win->initial_video_out_x);
		fprintf(fp, "\t\"initial video out y\": %d,\n", win->initial_video_out_y);
		fprintf(fp, "\t\"PTZ Window Position\": [");
		int nn = PTZ_WINDOW_LIMIT - 1;
		for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
		{
			if(gsw->my_window->ptz_window[loop] != NULL)
			{
				int xx = gsw->my_window->ptz_window[loop]->x();
				int yy = 0;
				if(gsw->my_window->ptz_window[loop]->contracted == 1)
				{
					yy = gsw->my_window->ptz_window[loop]->y() - 300;
				}
				else
				{
					yy = gsw->my_window->ptz_window[loop]->y();
				}
				fprintf(fp, "%d,%d", xx, yy);
				if(loop != nn)
				{
					fprintf(fp, ",");
				}
			}
		}
		fprintf(fp, "],\n");
		fprintf(fp, "\t\"status color r\": %d,\n", win->status_color_r);
		fprintf(fp, "\t\"status color g\": %d,\n", win->status_color_g);
		fprintf(fp, "\t\"status color b\": %d,\n", win->status_color_b);
		uchar red, green, blue;
		Fl::get_color(BLACK, red, green, blue);
		fprintf(fp, "\t\"color black\": [%d,%d,%d],\n", red, green, blue);
		Fl::get_color(WHITE, red, green, blue);
		fprintf(fp, "\t\"color white\": [%d,%d,%d],\n", red, green, blue);
		Fl::get_color(YELLOW, red, green, blue);
		fprintf(fp, "\t\"color yellow\": [%d,%d,%d],\n", red, green, blue);
		Fl::get_color(GRAY, red, green, blue);
		fprintf(fp, "\t\"color gray\": [%d,%d,%d],\n", red, green, blue);
		Fl::get_color(DARK_GRAY, red, green, blue);
		fprintf(fp, "\t\"color dark gray\": [%d,%d,%d],\n", red, green, blue);
		Fl::get_color(RED, red, green, blue);
		fprintf(fp, "\t\"color red\": [%d,%d,%d],\n", red, green, blue);
		Fl::get_color(DARK_RED, red, green, blue);
		fprintf(fp, "\t\"color dark red\": [%d,%d,%d],\n", red, green, blue);
		Fl::get_color(BLUE, red, green, blue);
		fprintf(fp, "\t\"color blue\": [%d,%d,%d],\n", red, green, blue);
		Fl::get_color(DARK_BLUE, red, green, blue);
		fprintf(fp, "\t\"color dark blue\": [%d,%d,%d],\n", red, green, blue);
		Fl::get_color(CYAN, red, green, blue);
		fprintf(fp, "\t\"color cyan\": [%d,%d,%d],\n", red, green, blue);
		fprintf(fp, "\t\"font\": \"%s\"\n", font_name);
		fprintf(fp, "}\n");
		fclose(fp);
	}
	gsw->hide();
}

void	gui_setting_status_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->my_window->status_color_r;
	int green = gsw->my_window->status_color_g;
	int blue = gsw->my_window->status_color_b;
	int alpha = gsw->my_window->status_color_a;
	if(my_color_chooser("Status Color", red, green, blue, alpha))
	{
		gsw->my_window->status_color_r = red;
		gsw->my_window->status_color_g = green;
		gsw->my_window->status_color_b = blue;
		gsw->my_window->status_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_background_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->background_color_r;
	int green = gsw->background_color_g;
	int blue = gsw->background_color_b;
	int alpha = gsw->background_color_a;
	if(my_color_chooser("Background Color", red, green, blue, alpha))
	{
		gsw->background_color_r = red;
		gsw->background_color_g = green;
		gsw->background_color_b = blue;
		gsw->background_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_text_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->text_color_r;
	int green = gsw->text_color_g;
	int blue = gsw->text_color_b;
	int alpha = gsw->text_color_a;
	if(my_color_chooser("Text Color", red, green, blue, alpha))
	{
		gsw->text_color_r = red;
		gsw->text_color_g = green;
		gsw->text_color_b = blue;
		gsw->text_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_highlight_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->highlight_color_r;
	int green = gsw->highlight_color_g;
	int blue = gsw->highlight_color_b;
	int alpha = gsw->highlight_color_a;
	if(my_color_chooser("Highlight Color", red, green, blue, alpha))
	{
		gsw->highlight_color_r = red;
		gsw->highlight_color_g = green;
		gsw->highlight_color_b = blue;
		gsw->highlight_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_gray_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->gray_color_r;
	int green = gsw->gray_color_g;
	int blue = gsw->gray_color_b;
	int alpha = gsw->gray_color_a;
	if(my_color_chooser("Gray Color", red, green, blue, alpha))
	{
		gsw->gray_color_r = red;
		gsw->gray_color_g = green;
		gsw->gray_color_b = blue;
		gsw->gray_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_dark_gray_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->dark_gray_color_r;
	int green = gsw->dark_gray_color_g;
	int blue = gsw->dark_gray_color_b;
	int alpha = gsw->dark_gray_color_a;
	if(my_color_chooser("Dark Gray Color", red, green, blue, alpha))
	{
		gsw->dark_gray_color_r = red;
		gsw->dark_gray_color_g = green;
		gsw->dark_gray_color_b = blue;
		gsw->dark_gray_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_red_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->red_color_r;
	int green = gsw->red_color_g;
	int blue = gsw->red_color_b;
	int alpha = gsw->red_color_a;
	if(my_color_chooser("Red Color", red, green, blue, alpha))
	{
		gsw->red_color_r = red;
		gsw->red_color_g = green;
		gsw->red_color_b = blue;
		gsw->red_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_dark_red_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->dark_red_color_r;
	int green = gsw->dark_red_color_g;
	int blue = gsw->dark_red_color_b;
	int alpha = gsw->dark_red_color_a;
	if(my_color_chooser("Dark Red Color", red, green, blue, alpha))
	{
		gsw->dark_red_color_r = red;
		gsw->dark_red_color_g = green;
		gsw->dark_red_color_b = blue;
		gsw->dark_red_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_blue_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->blue_color_r;
	int green = gsw->blue_color_g;
	int blue = gsw->blue_color_b;
	int alpha = gsw->blue_color_a;
	if(my_color_chooser("Blue Color", red, green, blue, alpha))
	{
		gsw->blue_color_r = red;
		gsw->blue_color_g = green;
		gsw->blue_color_b = blue;
		gsw->blue_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_dark_blue_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->dark_blue_color_r;
	int green = gsw->dark_blue_color_g;
	int blue = gsw->dark_blue_color_b;
	int alpha = gsw->dark_blue_color_a;
	if(my_color_chooser("Dark Blue Color", red, green, blue, alpha))
	{
		gsw->dark_blue_color_r = red;
		gsw->dark_blue_color_g = green;
		gsw->dark_blue_color_b = blue;
		gsw->dark_blue_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_cyan_color_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int red = gsw->cyan_color_r;
	int green = gsw->cyan_color_g;
	int blue = gsw->cyan_color_b;
	int alpha = gsw->cyan_color_a;
	if(my_color_chooser("Cyan Color", red, green, blue, alpha))
	{
		gsw->cyan_color_r = red;
		gsw->cyan_color_g = green;
		gsw->cyan_color_b = blue;
		gsw->cyan_color_a = alpha;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	generic_cancel_cb(Fl_Widget *w, void *v)
{
	Fl_Window *win = (Fl_Window *)v;
	win->hide();
}

void	transparent_interface_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	MyToggleButton *b = (MyToggleButton *)w;
	if(b->value() == 1)
	{
		win->Transparent(1);
	}
	else
	{
		win->Transparent(0);
	}
}

void	reverse_initial_panel_positions_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	win->initial_button_group_x = -1;
	win->initial_button_group_y = -1;
	win->initial_thumbnail_group_x = -1;
	win->initial_thumbnail_group_y = -1;
	win->initial_audio_thumbnail_group_x = -1;
	win->initial_audio_thumbnail_group_y = -1;
	win->initial_current_fps_x = -1;
	win->initial_current_fps_y = -1;
	win->initial_video_out_x = -1000000;
	win->initial_video_out_y = -1000000;
	for(loop = 0;loop < PTZ_WINDOW_LIMIT;loop++)
	{
		win->initial_ptz_x[loop] = -1;
		win->initial_ptz_y[loop] = -1;
	}
}

void	GUI_font_sample_cb(Fl_Widget *w, void *v)
{
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	int font = gsw->font_browser->value();
	font--;
	gsw->sample->textfont(font);
	gsw->sample->redraw();
}

GUI_SettingsWindow::GUI_SettingsWindow(MyWin *in_win) : Dialog(400, 100, 320, 905, "GUI Settings")
{
int	loop;

	my_window = in_win;
	int new_yp = 20;
	resize(x(), y(), w(), h());
	clear_visible_focus();
	set_modal();

	Fl::get_color(BLACK, background_color_r, background_color_g, background_color_b, background_color_a);
	Fl::get_color(WHITE, text_color_r, text_color_g, text_color_b, text_color_a);
	Fl::get_color(YELLOW, highlight_color_r, highlight_color_g, highlight_color_b, highlight_color_a);
	Fl::get_color(GRAY, gray_color_r, gray_color_g, gray_color_b, gray_color_a);
	Fl::get_color(DARK_GRAY, dark_gray_color_r, dark_gray_color_g, dark_gray_color_b, dark_gray_color_a);
	Fl::get_color(RED, red_color_r, red_color_g, red_color_b, red_color_a);
	Fl::get_color(DARK_RED, dark_red_color_r, dark_red_color_g, dark_red_color_b, dark_red_color_a);
	Fl::get_color(BLUE, blue_color_r, blue_color_g, blue_color_b, blue_color_a);
	Fl::get_color(DARK_BLUE, dark_blue_color_r, dark_blue_color_g, dark_blue_color_b, dark_blue_color_a);
	Fl::get_color(CYAN, cyan_color_r, cyan_color_g, cyan_color_b, cyan_color_a);

	int yp = new_yp + 10;

	hide_status_button = new MyLightButton(10, yp, 160, 20, "Hide Status");
	hide_status_button->box(FL_FRAME_BOX);
	hide_status_button->color(BLACK);
	hide_status_button->labelcolor(YELLOW);
	hide_status_button->labelsize(9);
	hide_status_button->align(FL_ALIGN_CENTER);
	hide_status_button->value(my_window->hide_status);
	yp += 22;
	retain_commands_button = new MyLightButton(10, yp, 160, 20, "Retain Commands");
	retain_commands_button->box(FL_FRAME_BOX);
	retain_commands_button->color(BLACK);
	retain_commands_button->labelcolor(YELLOW);
	retain_commands_button->labelsize(9);
	retain_commands_button->align(FL_ALIGN_CENTER);
	retain_commands_button->value(my_window->retain_commands);
	yp += 22;
	retain_cameras_button = new MyLightButton(10, yp, 160, 20, "Retain Cameras");
	retain_cameras_button->box(FL_FRAME_BOX);
	retain_cameras_button->color(BLACK);
	retain_cameras_button->labelcolor(YELLOW);
	retain_cameras_button->labelsize(9);
	retain_cameras_button->align(FL_ALIGN_CENTER);
	retain_cameras_button->value(my_window->retain_cameras);
	yp += 22;
	retain_audio_button = new MyLightButton(10, yp, 160, 20, "Retain Audio Devices");
	retain_audio_button->box(FL_FRAME_BOX);
	retain_audio_button->color(BLACK);
	retain_audio_button->labelcolor(YELLOW);
	retain_audio_button->labelsize(9);
	retain_audio_button->align(FL_ALIGN_CENTER);
	retain_audio_button->value(my_window->retain_audio);
	yp += 22;
	retain_ptz_button = new MyLightButton(10, yp, 160, 20, "Retain PTZ");
	retain_ptz_button->box(FL_FRAME_BOX);
	retain_ptz_button->color(BLACK);
	retain_ptz_button->labelcolor(YELLOW);
	retain_ptz_button->labelsize(9);
	retain_ptz_button->align(FL_ALIGN_CENTER);
	retain_ptz_button->value(my_window->retain_ptz);
	yp += 22;
	retain_all_button = new MyLightButton(10, yp, 160, 20, "Retain All Panels");
	retain_all_button->box(FL_FRAME_BOX);
	retain_all_button->color(BLACK);
	retain_all_button->labelcolor(YELLOW);
	retain_all_button->labelsize(9);
	retain_all_button->align(FL_ALIGN_CENTER);
	retain_all_button->value(0);
	yp += 26;
	animate_panels_button = new MyLightButton(10, yp, 160, 20, "Animate Panels");
	animate_panels_button->box(FL_FRAME_BOX);
	animate_panels_button->color(BLACK);
	animate_panels_button->labelcolor(YELLOW);
	animate_panels_button->labelsize(9);
	animate_panels_button->align(FL_ALIGN_CENTER);
	animate_panels_button->value(my_window->button_group->animated);
	yp += 26;
	use_tooltips_button = new MyLightButton(10, yp, 160, 20, "Use Tooltips");
	use_tooltips_button->box(FL_FRAME_BOX);
	use_tooltips_button->color(BLACK);
	use_tooltips_button->labelcolor(YELLOW);
	use_tooltips_button->labelsize(9);
	use_tooltips_button->align(FL_ALIGN_CENTER);
	use_tooltips_button->value(my_window->use_tooltips);
	yp += 26;
	transparent_interface_button = new MyLightButton(10, yp, 160, 20, "Transparent Interface");
	transparent_interface_button->box(FL_FRAME_BOX);
	transparent_interface_button->color(BLACK);
	transparent_interface_button->labelcolor(YELLOW);
	transparent_interface_button->labelsize(9);
	transparent_interface_button->align(FL_ALIGN_CENTER);
	transparent_interface_button->callback(transparent_interface_cb, my_window);
	transparent_interface_button->value(my_window->transparent_interface);
	yp += 26;
	reverse_panels_button = new MyLightButton(10, yp, 160, 20, "Reverse Panels");
	reverse_panels_button->box(FL_FRAME_BOX);
	reverse_panels_button->color(BLACK);
	reverse_panels_button->labelcolor(YELLOW);
	reverse_panels_button->labelsize(9);
	reverse_panels_button->align(FL_ALIGN_CENTER);
	reverse_panels_button->value(my_window->button_group_side);
	reverse_panels_button->callback(reverse_initial_panel_positions_cb, my_window);
	yp += 26;
	status_color_box = new Fl_Box(10, yp, 160, 20, "Status Color");
	status_color_box->box(FL_FRAME_BOX);
	status_color_box->color(BLACK);
	status_color_box->labelcolor(YELLOW);
	status_color_box->labelsize(9);
	status_color_box->align(FL_ALIGN_CENTER);
	status_color_button = new MyButton(180, yp, 20, 20);
	status_color_button->box(FL_FRAME_BOX);
	status_color_button->color(fl_rgb_color(my_window->status_color_r, my_window->status_color_g, my_window->status_color_b));
	status_color_button->callback(gui_setting_status_color_cb, this);
	yp += 22;
	background_color_box = new Fl_Box(10, yp, 160, 20, "Background Color");
	background_color_box->box(FL_FRAME_BOX);
	background_color_box->color(BLACK);
	background_color_box->labelcolor(YELLOW);
	background_color_box->labelsize(9);
	background_color_box->align(FL_ALIGN_CENTER);
	background_color_button = new MyButton(180, yp, 20, 20);
	background_color_button->box(FL_FRAME_BOX);
	background_color_button->color(fl_rgb_color(background_color_r, background_color_g, background_color_b));
	background_color_button->callback(gui_setting_background_color_cb, this);
	yp += 22;
	text_color_box = new Fl_Box(10, yp, 160, 20, "Text Color");
	text_color_box->box(FL_FRAME_BOX);
	text_color_box->color(BLACK);
	text_color_box->labelcolor(YELLOW);
	text_color_box->labelsize(9);
	text_color_box->align(FL_ALIGN_CENTER);
	text_color_button = new MyButton(180, yp, 20, 20);
	text_color_button->box(FL_FRAME_BOX);
	text_color_button->color(fl_rgb_color(text_color_r, text_color_g, text_color_b));
	text_color_button->callback(gui_setting_text_color_cb, this);
	yp += 22;
	highlight_color_box = new Fl_Box(10, yp, 160, 20, "Highlight Color");
	highlight_color_box->box(FL_FRAME_BOX);
	highlight_color_box->color(BLACK);
	highlight_color_box->labelcolor(YELLOW);
	highlight_color_box->labelsize(9);
	highlight_color_box->align(FL_ALIGN_CENTER);
	highlight_color_button = new MyButton(180, yp, 20, 20);
	highlight_color_button->box(FL_FRAME_BOX);
	highlight_color_button->color(fl_rgb_color(highlight_color_r, highlight_color_g, highlight_color_b));
	highlight_color_button->callback(gui_setting_highlight_color_cb, this);
	yp += 22;
	gray_color_box = new Fl_Box(10, yp, 160, 20, "Gray Color");
	gray_color_box->box(FL_FRAME_BOX);
	gray_color_box->color(BLACK);
	gray_color_box->labelcolor(YELLOW);
	gray_color_box->labelsize(9);
	gray_color_box->align(FL_ALIGN_CENTER);
	gray_color_button = new MyButton(180, yp, 20, 20);
	gray_color_button->box(FL_FRAME_BOX);
	gray_color_button->color(fl_rgb_color(gray_color_r, gray_color_g, gray_color_b));
	gray_color_button->callback(gui_setting_gray_color_cb, this);
	yp += 22;
	dark_gray_color_box = new Fl_Box(10, yp, 160, 20, "Dark Gray Color");
	dark_gray_color_box->box(FL_FRAME_BOX);
	dark_gray_color_box->color(BLACK);
	dark_gray_color_box->labelcolor(YELLOW);
	dark_gray_color_box->labelsize(9);
	dark_gray_color_box->align(FL_ALIGN_CENTER);
	dark_gray_color_button = new MyButton(180, yp, 20, 20);
	dark_gray_color_button->box(FL_FRAME_BOX);
	dark_gray_color_button->color(fl_rgb_color(dark_gray_color_r, dark_gray_color_g, dark_gray_color_b));
	dark_gray_color_button->callback(gui_setting_dark_gray_color_cb, this);
	yp += 22;
	red_color_box = new Fl_Box(10, yp, 160, 20, "Red Color");
	red_color_box = new Fl_Box(10, yp, 160, 20, "Red Color");
	red_color_box->box(FL_FRAME_BOX);
	red_color_box->color(BLACK);
	red_color_box->labelcolor(YELLOW);
	red_color_box->labelsize(9);
	red_color_box->align(FL_ALIGN_CENTER);
	red_color_button = new MyButton(180, yp, 20, 20);
	red_color_button->box(FL_FRAME_BOX);
	red_color_button->color(fl_rgb_color(red_color_r, red_color_g, red_color_b));
	red_color_button->callback(gui_setting_red_color_cb, this);
	yp += 22;
	dark_red_color_box = new Fl_Box(10, yp, 160, 20, "Dark Red Color");
	dark_red_color_box->box(FL_FRAME_BOX);
	dark_red_color_box->color(BLACK);
	dark_red_color_box->labelcolor(YELLOW);
	dark_red_color_box->labelsize(9);
	dark_red_color_box->align(FL_ALIGN_CENTER);
	dark_red_color_button = new MyButton(180, yp, 20, 20);
	dark_red_color_button->box(FL_FRAME_BOX);
	dark_red_color_button->color(fl_rgb_color(dark_red_color_r, dark_red_color_g, dark_red_color_b));
	dark_red_color_button->callback(gui_setting_dark_red_color_cb, this);
	yp += 22;
	blue_color_box = new Fl_Box(10, yp, 160, 20, "Blue Color");
	blue_color_box->box(FL_FRAME_BOX);
	blue_color_box->color(BLACK);
	blue_color_box->labelcolor(YELLOW);
	blue_color_box->labelsize(9);
	blue_color_box->align(FL_ALIGN_CENTER);
	blue_color_button = new MyButton(180, yp, 20, 20);
	blue_color_button->box(FL_FRAME_BOX);
	blue_color_button->color(fl_rgb_color(blue_color_r, blue_color_g, blue_color_b));
	blue_color_button->callback(gui_setting_blue_color_cb, this);
	yp += 22;
	dark_blue_color_box = new Fl_Box(10, yp, 160, 20, "Dark Blue Color");
	dark_blue_color_box->box(FL_FRAME_BOX);
	dark_blue_color_box->color(BLACK);
	dark_blue_color_box->labelcolor(YELLOW);
	dark_blue_color_box->labelsize(9);
	dark_blue_color_box->align(FL_ALIGN_CENTER);
	dark_blue_color_button = new MyButton(180, yp, 20, 20);
	dark_blue_color_button->box(FL_FRAME_BOX);
	dark_blue_color_button->color(fl_rgb_color(dark_blue_color_r, dark_blue_color_g, dark_blue_color_b));
	dark_blue_color_button->callback(gui_setting_dark_blue_color_cb, this);
	yp += 22;
	cyan_color_box = new Fl_Box(10, yp, 160, 20, "Cyan Color");
	cyan_color_box->box(FL_FRAME_BOX);
	cyan_color_box->color(BLACK);
	cyan_color_box->labelcolor(YELLOW);
	cyan_color_box->labelsize(9);
	cyan_color_box->align(FL_ALIGN_CENTER);
	cyan_color_button = new MyButton(180, yp, 20, 20);
	cyan_color_button->box(FL_FRAME_BOX);
	cyan_color_button->color(fl_rgb_color(cyan_color_r, cyan_color_g, cyan_color_b));
	cyan_color_button->callback(gui_setting_cyan_color_cb, this);
	yp += 42;

	sample = new MyInput(60, yp, 245, 20, "Sample");
	sample->textsize(11);
	sample->labelsize(9);
	sample->box(FL_FRAME_BOX);
	sample->color(BLACK);
	sample->textcolor(WHITE);
	sample->value("This is sample text");
	yp += 42;

	font_browser = new Fl_Hold_Browser(10, yp, 300, 180, "Font");
	font_browser->color(BLACK);
	font_browser->box(FL_FRAME_BOX);
	font_browser->textcolor(WHITE);
	font_browser->labelcolor(WHITE);
	font_browser->labelsize(11);
	font_browser->textsize(9);
	font_browser->selection_color(YELLOW);
	font_browser->scrollbar.color(BLACK);
	font_browser->align(FL_ALIGN_TOP);
	font_browser->callback(GUI_font_sample_cb, this);

	int nn = my_window->number_of_fonts;
	for(loop = 0;loop < nn;loop++)
	{
		char *str = (char *)Fl::get_font_name(loop);
		char buf[256];
		sprintf(buf, "@F%05d%s", loop, str);
		font_browser->add(buf);
	}
	font_browser->select(1);
	yp += 184;
	int bottom = yp + 12;

	yp = new_yp + 10;
	MyButton *accept = new MyButton(180, yp, 60, 20, "Accept");
	accept->box(FL_FRAME_BOX);
	accept->color(BLACK);
	accept->labelcolor(YELLOW);
	accept->labelsize(9);
	accept->align(FL_ALIGN_CENTER);
	accept->callback(gui_settings_cb, this);
	yp += 22;
	MyButton *cancel = new MyButton(180, yp, 60, 20, "Cancel");
	cancel->box(FL_FRAME_BOX);
	cancel->color(BLACK);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(9);
	cancel->align(FL_ALIGN_CENTER);
	cancel->callback(generic_cancel_cb, this);
	yp += 22;
	end();
	resize(x(), y(), w(), bottom);
}

GUI_SettingsWindow::~GUI_SettingsWindow()
{
}

// SECTION ************************************** FILTER PLUGINS BUTTON AND WINDOW *******************************************************

FilterButton::FilterButton(FilterPluginsWindow *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Box(xx, yy, ww, hh, lbl)
{
void	move_filter_button_cb(Fl_Widget *w, void *v);

	my_window = in_win;
	dragging = 0;

	box(FL_NO_BOX);
	color(BLACK);
	labelcolor(WHITE);
	labelsize(11);
	align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	callback(move_filter_button_cb, this);

	filter_dialog = my_window->my_window->MakeFilterDialog(lbl);
}

FilterButton::~FilterButton()
{
	if(filter_dialog != NULL)
	{
		filter_dialog->hide();
		MyGroup *grp = (MyGroup *)filter_dialog->parent();
		if(grp != NULL)
		{
			grp->remove(filter_dialog);
			Fl::delete_widget(filter_dialog);
		}
	}
}

int	FilterButton::handle(int event)
{
int		loop;

	int flag = 0;
	if(event == FL_PUSH)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		offset_x = xx - x();
		offset_y = yy - y();
		dragging = 1;
		flag = 1;
	}
	else if((event == FL_MOVE) || (event == FL_DRAG))
	{
		if(dragging == 1)
		{
			int xx = Fl::event_x();
			int yy = Fl::event_y();
			int pyy = yy - my_window->use->y();
			int py = pyy / 20;
			int col_flag = 1;
			if(x() < 100)
			{
				col_flag = 2;
				my_window->available->box(FL_FRAME);
				my_window->use->box(FL_NO_BOX);
			}
			else
			{
				my_window->available->box(FL_NO_BOX);
				my_window->use->box(FL_FRAME);
			}
			my_window->Arrange(col_flag, py);
			window()->add(this);
			resize(xx - offset_x, yy - offset_y, w(), h());
			redraw();
			window()->redraw();
		}
	}
	else if(event == FL_RELEASE)
	{
		int yy = Fl::event_y();
		int pyy = yy - my_window->use->y();
		int py = pyy / 20;
		if(x() > 100)
		{
			if(parent() == my_window)
			{
				my_window->use->insert(*this, py);
				if(my_window->filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
				{
					int cnt = my_window->available->children();
					int do_not_add = 0;
					for(loop = 0;loop < cnt;loop++)
					{
						Fl_Widget *b = my_window->available->child(loop);
						if(b != NULL)
						{
							char *lbl = (char *)b->label();
							if(lbl != NULL)
							{
								if(strcmp(label(), lbl) == 0)
								{
									do_not_add = 1;
								}
							}
						}
					}
					if(do_not_add == 0)
					{
						FilterButton *filter_button = new FilterButton(my_window, my_window->available->x(), my_window->available->y() + (cnt * 20), 120, 20, (char *)label());
						my_window->available->add(filter_button);
					}
				}
			}
		}
		else
		{
			if(my_window->filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
			{
				if(parent() == my_window)
				{
					my_window->use->remove(this);
					hide();
				}
			}
			else
			{
				if(parent() == my_window)
				{
					my_window->available->insert(*this, py);
				}
			}
		}
		my_window->Arrange();
		my_window->available->box(FL_NO_BOX);
		my_window->use->box(FL_NO_BOX);
		window()->redraw();
		dragging = 0;
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Box::handle(event);
	}
	return(flag);
}

void	move_filter_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	FilterPluginsWindow *fpw = (FilterPluginsWindow *)v;
	MyButton *b = (MyButton *)w;
	if(b->parent() == fpw->available)
	{
		fpw->available->remove(b);
		fpw->use->add(b);
	}
	else
	{
		fpw->available->add(b);
		fpw->use->remove(b);
	}
	fpw->redraw();
}

void	use_no_filters_cb(Fl_Widget *w, void *v)
{
	FilterPluginsWindow *fpw = (FilterPluginsWindow *)v;
	while(fpw->use->children() > 0)
	{
		Fl_Widget *b = fpw->use->child(0);
		fpw->use->remove(b);
		fpw->available->add(b);
	}
	fpw->Arrange();
	fpw->redraw();
}

void	filters_accept_cb(Fl_Widget *w, void *v)
{
int	loop;
int	inner;
int	inner2;
char	buf[256];

	FilterPluginsWindow *fpw = (FilterPluginsWindow *)v;
	Camera *cam = fpw->my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(fpw->filter_type == FILTER_TYPE_VIDEO)
		{
			for(loop = 0;loop < 128;loop++)
			{
				cam->filter_plugin[loop] = NULL;
				if(cam->filter_plugin_name[loop] != NULL)
				{
					free(cam->filter_plugin_name[loop]);
					cam->filter_plugin_name[loop] = NULL;
				}
			}
		}
		else if(fpw->filter_type == FILTER_TYPE_AUDIO)
		{
			for(inner2 = 0;inner2 < fpw->my_window->pulse_microphone_cnt;inner2++)
			{
				PulseMicrophone *mic = fpw->my_window->pulse_microphone[inner2];
				if(mic != NULL)
				{
					for(loop = 0;loop < 128;loop++)
					{
						mic->filter_plugin[loop] = NULL;
					}
					mic->filter_plugin_cnt = 0;
				}
			}
		}
		else if(fpw->filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
		{
			for(loop = 0;loop < 128;loop++)
			{
				if(cam->filter_name[loop] != NULL)
				{
					free(cam->filter_name[loop]);
					cam->filter_name[loop] = NULL;
				}
				if(cam->filter_dialog[loop] != NULL)
				{
					cam->filter_dialog[loop]->hide();
					cam->my_window->remove(cam->filter_dialog[loop]);
					cam->filter_dialog[loop] = NULL;
				}
			}
		}
		for(loop = 0;loop < fpw->use->children();loop++)
		{
			Fl_Widget *b = fpw->use->child(loop);
			if(b != NULL)
			{
				if(b->label() != NULL)
				{
					if(fpw->filter_type == FILTER_TYPE_VIDEO)
					{
						sprintf(buf, "filter_%s", b->label());
						for(inner = 0;inner < global_potential_filter_cnt;inner++)
						{
							if((global_potential_filter[inner] != NULL) && (global_potential_filter_handle[inner] != NULL))
							{
								if(strcmp(buf, global_potential_filter[inner]) == 0)
								{
									if(cam->filter_plugin_cnt < 128)
									{
										cam->filter_plugin[cam->filter_plugin_cnt] = (void *)dlsym(global_potential_filter_handle[inner], global_potential_filter[inner]);
										if(cam->filter_plugin[cam->filter_plugin_cnt] != NULL)
										{
											cam->filter_plugin_name[cam->filter_plugin_cnt] = strdup(buf);
											cam->filter_plugin_cnt++;
										}
									}
								}
							}
						}
					}
					else if(fpw->filter_type == FILTER_TYPE_AUDIO)
					{
						sprintf(buf, "audio_filter_%s", b->label());
						for(inner = 0;inner < global_potential_audio_filter_cnt;inner++)
						{
							if((global_potential_audio_filter[inner] != NULL) && (global_potential_filter_handle[inner] != NULL))
							{
								if(strcmp(buf, global_potential_audio_filter[inner]) == 0)
								{
									for(inner2 = 0;inner2 < fpw->my_window->pulse_microphone_cnt;inner2++)
									{
										PulseMicrophone *mic = fpw->my_window->pulse_microphone[inner2];
										if(mic != NULL)
										{
											if(mic->stop == 0)
											{
												mic->filter_plugin[mic->filter_plugin_cnt] = (void *)dlsym(global_potential_audio_filter_handle[inner], global_potential_audio_filter[inner]);
												if(mic->filter_plugin[mic->filter_plugin_cnt] != NULL)
												{
													mic->filter_plugin_name[mic->filter_plugin_cnt] = strdup(buf);
													mic->filter_plugin_cnt++;
												}
											}
										}
									}
								}
							}
						}
					}
					else if(fpw->filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
					{
						FilterButton *filter_button = (FilterButton *)b;
						cam->filter_name[cam->filter_cnt] = strdup(filter_button->label());
						cam->filter_dialog[cam->filter_cnt] = filter_button->filter_dialog;
						cam->filter_cnt++;
						cam->my_window->add(filter_button->filter_dialog);
						filter_button->filter_dialog->show();
					}
				}
			}
		}
	}
	fpw->hide();
}

FilterPluginsWindow::FilterPluginsWindow(MyWin *in_win, int in_filter_type) : Dialog(400, 300, 280, 400, "Filter Plugins")
{
int	loop;

	my_window = in_win;
	Camera *cam = my_window->DisplayedCamera();

	int new_yp = 20;

	last_x = 0;
	last_y = 0;
	filter_type = in_filter_type;

	clear_visible_focus();
	set_non_modal();

	Fl_Box *available_label = new Fl_Box(10, new_yp + 5, 120, 20, "Available");
	available_label->box(FL_NO_BOX);
	available_label->labelcolor(GRAY);
	available_label->labelsize(12);
	available_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	
	Fl_Box *use_label = new Fl_Box(130, new_yp + 5, 120, 20, "Use");
	use_label->box(FL_NO_BOX);
	use_label->labelcolor(GRAY);
	use_label->labelsize(12);
	use_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	int use_cnt = 0;
	if((filter_type == FILTER_TYPE_VIDEO)
	|| (filter_type == FILTER_TYPE_AUDIO))
	{
		use_cnt = global_potential_filter_cnt;
	}
	else
	{
		use_cnt = 9;
	}
	available = new Fl_Pack(10, new_yp + 25, 120, (use_cnt * 20));
	available->box(FL_NO_BOX);
	available->color(WHITE);
	available->copy_tooltip("The list of available filters. Drag filters from here to the Use bin to use that filter.");
	available->end();

	use = new Fl_Pack(140, new_yp + 25, 120, (use_cnt * 20));
	use->box(FL_NO_BOX);
	use->color(WHITE);
	use->copy_tooltip("The list of filters in use appearing in the order they will be called. Drag filters up and down to change the order. Drag them back to the Avilable bin to remove the filter from use.");
	use->end();

	int cnt = 0;
	if(filter_type == FILTER_TYPE_VIDEO)
	{
		for(loop = 0;loop < global_potential_filter_cnt;loop++)
		{
			if((global_potential_filter[loop] != NULL) && (global_potential_filter_handle[loop] != NULL))
			{
				char *str = global_potential_filter[loop] + strlen("filter_");
				FilterButton *filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, str);
				filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
				available->add(filter_button);
				cnt++;
			}
		}
	}
	else if(filter_type == FILTER_TYPE_AUDIO)
	{
		for(loop = 0;loop < global_potential_audio_filter_cnt;loop++)
		{
			if((global_potential_audio_filter[loop] != NULL) && (global_potential_audio_filter_handle[loop] != NULL))
			{
				char *str = global_potential_audio_filter[loop] + strlen("audio_filter_");
				FilterButton *filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, str);
				filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
				available->add(filter_button);
				cnt++;
			}
		}
	}
	else if(filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
	{
		FilterButton *filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Grayscale");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Threshold");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Invert");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Edge Detect");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Brightness");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Contrast");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Saturation");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Hue");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "CLAHE");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Color Intensity");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Blur");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Crop");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Scale");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Blend");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Bevel");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20)), 120, 20, "Gradient");
		filter_button->copy_tooltip("Drag this button over from the Available bin to the Use bin to install. Drag it back to the available bin to cease using it.");
		available->add(filter_button);
		cnt++;
	}
	my_accept = new MyButton(10, new_yp + (35 + (22 * cnt)), 80, 18, "Accept");
	my_accept->box(FL_NO_BOX);
	my_accept->color(WHITE);
	my_accept->labelcolor(YELLOW);
	my_accept->labelsize(12);
	my_accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	my_accept->copy_tooltip("Accept the selected filters in the order in which they appear.");
	my_accept->callback(filters_accept_cb, this);

	my_cancel = new MyButton(100, new_yp + (35 + (22 * cnt)), 80, 18, "Cancel");
	my_cancel->box(FL_NO_BOX);
	my_cancel->color(WHITE);
	my_cancel->labelcolor(YELLOW);
	my_cancel->labelsize(12);
	my_cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	my_cancel->copy_tooltip("Cancel any changes to the filters in use.");
	my_cancel->callback(hide_window_cb, this);

	use_none = new MyButton(w() - 90, new_yp + (35 + (22 * cnt)), 80, 18, "Use None");
	use_none->box(FL_NO_BOX);
	use_none->color(WHITE);
	use_none->labelcolor(YELLOW);
	use_none->labelsize(12);
	use_none->copy_tooltip("Remove all filters from the Use bin.");
	use_none->callback(use_no_filters_cb, this);
	cnt++;
	end();
	resize(x(), y(), w(), (65 + (cnt * 22)));
}

FilterPluginsWindow::~FilterPluginsWindow()
{
}

int		FilterPluginsWindow::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	FilterPluginsWindow::Arrange(int flag, int py)
{
int	loop;

	int cnt = 0;
	int max1 = 0;
	int max2 = 0;
	for(loop = 0;loop < use->children();loop++)
	{
		Fl_Widget *child = use->child(loop);
		if(child != NULL)
		{
			if(flag == 1)
			{
				if(py == loop)
				{
					cnt++;
				}
			}
			child->resize(use->x(), use->y() + (cnt * 20), child->w(), child->h());
			max1 = use->y() + (cnt * 20) + child->h();
			cnt++;
		}
	}
	cnt = 0;
	for(loop = 0;loop < available->children();loop++)
	{
		Fl_Widget *child = available->child(loop);
		if(child != NULL)
		{
			if(flag == 2)
			{
				if(py == loop)
				{
					cnt++;
				}
			}
			child->resize(available->x(), available->y() + (cnt * 20), child->w(), child->h());
			max2 = use->y() + (cnt * 20) + child->h();
			cnt++;
		}
	}
	int max = 0;
	if(max2 > max1) max = max2;
	else max = max1;
	resize(x(), y(), w(), max + 65);
	my_accept->resize(my_accept->x(), h() - 30, my_accept->w(), my_accept->h());
	my_cancel->resize(my_cancel->x(), h() - 30, my_cancel->w(), my_cancel->h());
	use_none->resize(use_none->x(), h() - 30, use_none->w(), use_none->h());
}

// SECTION **************************************************** SELECT AUDIO WINDOW *******************************************************

class	SelectAudioButton : public MyButton
{
public:
			SelectAudioButton(int xx, int yy, int ww, int hh, char *lbl, char *in_use_str) : MyButton(xx, yy, ww, hh, lbl) 
			{
				use_str = strdup(in_use_str);
			};
			~SelectAudioButton() 
			{
				if(use_str != NULL)
				{
					free(use_str);
				}
			};
	char	*use_str;
};

void	select_audio_cb(Fl_Widget *w, void *v)
{
	SelectAudioButton *b = (SelectAudioButton *)w;
	SelectAudioWindow *saw = (SelectAudioWindow *)v;
	if(saw->my_window->audio_thumbnail_cnt < 128)
	{
		int started_here = 0;
		if(saw->my_window->pulse_mixer == NULL)
		{
			saw->my_window->pulse_mixer = new PulseMixer(saw->my_window, FRAMES_PER_BUFFER, saw->my_window->audio_channels);
			started_here = 1;
		}
		char *str = strdup(b->use_str);
		char *use_str = strdup(b->label());
		if((str != NULL) && (use_str != NULL))
		{
			if((strcmp(str, "File") == 0)
			&& (strcmp(use_str, "Audio File") == 0))
			{
				char filename[4096];
				int r = my_file_chooser("Select an audio file", "*.{mp3,wav,flac}", "./", filename);
				if(r > 0)
				{
					if(strlen(filename) > 0)
					{
						free(str);
						str = strdup(filename);
						free(use_str);
						use_str = strdup(filename);
					}
					else
					{
						free(use_str);
						use_str = strdup("");
					}
				}
				else
				{
					free(use_str);
					use_str = strdup("");
				}
			}
			else if(strcmp(str, "NDI") == 0)
			{
				char buf[256];
				sprintf(buf, "ndi://%s", use_str);
				free(str);
				str = strdup(buf);
			}
		}
		if(strlen(use_str) > 0)
		{
			char *cp = use_str;
			int cnt = 0;
			char last_cp = '\0';
			while(*cp != '\0')
			{
				if(isalnum(*cp))
				{
					use_str[cnt] = *cp;
					cnt++;
					last_cp = *cp;
				}
				else
				{
					if(last_cp != ' ')
					{
						use_str[cnt] = ' ';
						cnt++;
					}
					last_cp = ' ';
				}
				cp++;
			}
			use_str[cnt] = '\0';
			char final_buf[4096];
			sprintf(final_buf, "audio://%s", str);
			saw->my_window->new_source_window->source->value(final_buf);
			saw->my_window->new_source_window->alias->value(use_str);
		}
		else
		{
			saw->my_window->new_source_window->source->value("");
		}
		free(str);
		free(use_str);
	}
	saw->hide();
	Fl::delete_widget(saw);
}

SelectAudioWindow::SelectAudioWindow(MyWin *in_win) : Dialog(800, 320, 460, 180, "Select Audio")
{
int	loop;
char *list[128];
char *description[128];
int index[128];
char	def_source[4096];
char	def_sink[4096];
int		channels[128];
int		rate[128];

	int new_yp = 20;
	ndi_find = NULL;
	my_window = in_win;
	clear_visible_focus();
	set_non_modal();
	int nn = pulse_list_devices(def_source, def_sink, 1, 128, list, description, index, channels, rate);
	int max = -1;
	fl_font(FL_HELVETICA, 11);
	for(loop = 0;loop < nn;loop++)
	{
		int mx = 0;
		int my = 0;
		fl_measure(list[loop], mx, my);
		if(mx > max) max = mx;
	}
	if(max < 460) max = 460;
	int y_cnt = 10 + new_yp;
	for(loop = 0;loop < nn;loop++)
	{
		SelectAudioButton *b = new SelectAudioButton(10, y_cnt, max + 5, 20, strdup(description[loop]), strdup(list[loop]));
		b->box(FL_FLAT_BOX);
		b->color(DARK_BLUE);
		b->labelcolor(YELLOW);
		b->labelsize(11);
		b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		b->callback(select_audio_cb, this);
		y_cnt += 21;
		free(list[loop]);
		free(description[loop]);
	}
	SelectAudioButton *b = new SelectAudioButton(10, y_cnt, max + 5, 20, "Audio File", "File");
	b->box(FL_FLAT_BOX);
	b->color(fl_lighter(DARK_BLUE));
	b->labelcolor(YELLOW);
	b->labelsize(11);
	b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	b->callback(select_audio_cb, this);
	y_cnt += 23;

	if(NDILib != NULL)
	{
		uint32_t num_sources = 0;
		const NDIlib_source_t *sources = NULL;
		const NDIlib_find_create_t NDI_find_create_desc;
		NDIlib_find_instance_t ndi_find = NDILib->NDIlib_find_create_v2(&NDI_find_create_desc);
		NDILib->NDIlib_find_wait_for_sources(ndi_find, 1000);
		sources = NDILib->NDIlib_find_get_current_sources(ndi_find, &num_sources);
		for(loop = 0;loop < num_sources;loop++)
		{
			char *name = (char *)sources[loop].p_ndi_name;
			if(name != NULL)
			{
				SelectAudioButton *b = new SelectAudioButton(10, y_cnt, max + 5, 20, strdup(name), "NDI");
				b->box(FL_FLAT_BOX);
				b->color(fl_darker(DARK_BLUE));
				b->labelcolor(YELLOW);
				b->labelsize(11);
				b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
				b->callback(select_audio_cb, this);
				y_cnt += 23;
			}
		}
		NDILib->NDIlib_find_destroy(ndi_find);
	}
	MyButton *close = new MyButton(10, y_cnt, max + 5, 20, "Close");
	close->box(FL_FLAT_BOX);
	close->color(BLACK);
	close->labelcolor(YELLOW);
	close->labelsize(12);
	close->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	close->callback(hide_window_cb, this);
	y_cnt += 21;

	end();
	resize(x(), y(), max + 25, 10 + y_cnt);
}

SelectAudioWindow::~SelectAudioWindow()
{
	if(ndi_find != NULL)
	{
		if(NDILib != NULL)
		{
			NDILib->NDIlib_find_destroy(ndi_find);
		}
	}
	if(my_window->new_source_window->select_audio_window != NULL)
	{
		my_window->new_source_window->select_audio_window = NULL;
	}
}

void	SelectAudioWindow::draw()
{
	Fl_Window::draw();
}

// SECTION **************************************************** SELECT CAMERA WINDOW *******************************************************

void	plugin_camera_cancel_cb(Fl_Widget *w, void *v)
{
	PseudoCameraWindow *pcw = (PseudoCameraWindow *)v;
	pcw->hide();
}

void	select_plugin_camera_cb(Fl_Widget *w, void *v)
{
char	buf[4096];
char	use[8192];
int	loop;

	PseudoCameraWindow *pcw = (PseudoCameraWindow *)v;
	NewSourceWindow *nsw = pcw->my_window->new_source_window;
	MyButton *b = (MyButton *)w;
	if(b->label() != NULL)
	{
		sprintf(buf, "camera_%s", b->label());
		for(loop = 0;loop < global_potential_camera_cnt;loop++)
		{
			if((global_potential_camera[loop] != NULL) && (global_potential_camera_handle[loop] != NULL))
			{
				if(strcmp(global_potential_camera[loop], buf) == 0)
				{ 
					sprintf(use, "plugin://%s", buf);
					nsw->source->value(use);
				}
			}
		}
	}
	pcw->hide();
}

class	CameraFormatButton : public MyButton
{
public:
			CameraFormatButton(int xx, int yy, int ww, int hh, char *lbl) : MyButton(xx, yy, ww, hh, lbl) {};
			~CameraFormatButton() {};
	char	*path;
	char	*alias;
	int		fmt;
};

void	select_camera_format_cb(Fl_Widget *w, void *v)
{
char buf[4096];
char fourcc[5];

	CameraFormatButton *b = (CameraFormatButton *)w;
	SelectCameraWindow *scw = (SelectCameraWindow *)v;
	char *alias_str = b->alias;
	char *alias = (char *)scw->my_window->new_source_window->alias->value();
	if(strlen(alias) > 0)
	{
		alias_str = alias;
	}
	int tmp = b->fmt;
	if(tmp != 0)
	{
		sprintf(fourcc, "%c%c%c%c", tmp & 0xff, (tmp >> 8) & 0xff, (tmp >> 16) & 0xff, (tmp >> 24) & 0xff);
		sprintf(buf, "camera://%s::V4L2:%s", b->path, fourcc);
	}
	else
	{
		if(strcmp(b->alias, "NDI") == 0)
		{
			sprintf(buf, "ndi://%s", b->path);
		}
		else if(strcmp(b->alias, "UYVY") == 0)
		{
			sprintf(buf, "ndi_uyvy://%s", b->path);
		}
		else if(strcmp(b->alias, "P216") == 0)
		{
			sprintf(buf, "ndi_p216://%s", b->path);
		}
		else if(strcmp(b->alias, "RGBX") == 0)
		{
			sprintf(buf, "ndi_rgbx://%s", b->path);
		}
		else if(strcmp(b->alias, "BGRX") == 0)
		{
			sprintf(buf, "ndi_bgrx://%s", b->path);
		}
	}
	scw->my_window->new_source_window->source->value(buf);

	scw->hide();
	Fl::delete_widget(scw);
}

SelectCameraWindow::SelectCameraWindow(MyWin *in_win) : Dialog(800, 320, 460, 180, "Select Camera")
{
int	loop, inner;

	int new_yp = 20;
	my_window = in_win;
	clear_visible_focus();
	set_non_modal();
	int cnt = my_window->PopulateCameraCaps();

	MyButton *close = new MyButton(700, new_yp + 2, 50, 18, "Close");
	close->box(FL_FLAT_BOX);
	close->color(BLACK);
	close->labelcolor(YELLOW);
	close->labelsize(11);
	close->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	close->callback(hide_window_cb, this);

	int y_cnt = new_yp + 25;
	for(loop = 0;loop < cnt;loop++)
	{
		int inner;
		char *path = my_window->camera_caps[loop]->path;
		char *alias = my_window->camera_caps[loop]->alias;

		Fl_Box *b = new Fl_Box(10, y_cnt, 300, 20, alias);
		b->box(FL_NO_BOX);
		b->color(BLACK);
		b->labelcolor(WHITE);
		b->labelsize(11);
		b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		y_cnt += 21;

		for(inner = 0;inner < my_window->camera_caps[loop]->fourcc_cnt;inner++)
		{
			int tmp = my_window->camera_caps[loop]->fourcc[inner];
			char *desc = my_window->camera_caps[loop]->fourcc_description[inner];
			char buf[4092];
			sprintf(buf, "%c%c%c%c %s", tmp & 0xff, (tmp >> 8) & 0xff, (tmp >> 16) & 0xff, (tmp >> 24) & 0xff, desc);

			CameraFormatButton *b = new CameraFormatButton(150, y_cnt, 300, 20, strdup(buf));
			b->path = path;
			b->alias = alias;
			b->fmt = tmp;

			b->box(FL_FLAT_BOX);
			b->color(DARK_BLUE);
			b->labelcolor(YELLOW);
			b->labelsize(11);
			b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
			b->callback(select_camera_format_cb, this);
			y_cnt += 21;
		}
	}
	if(NDILib != NULL)
	{
		char *list[256];
		int final_total = 0;
		ndi_source_list(list, final_total);
		for(loop = 0;loop < final_total;loop++)
		{
			if(list[loop] != NULL)
			{
				char *cp = NULL;
				char *use = NULL;
				if(strncmp(list[loop], "ndi://", strlen("ndi://")) == 0)
				{
					cp = list[loop] + strlen("ndi://");

					Fl_Box *b = new Fl_Box(10, y_cnt, 300, 20);
					b->copy_label(cp);
					b->box(FL_NO_BOX);
					b->color(BLACK);
					b->labelcolor(WHITE);
					b->labelsize(11);
					b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					y_cnt += 21;

					use = "NDI";
				}
				else if(strncmp(list[loop], "ndi_uyvy://", strlen("ndi_uyvy://")) == 0)
				{
					cp = list[loop] + strlen("ndi_uyvy://");
					use = "UYVY";
				}
				else if(strncmp(list[loop], "ndi_p216://", strlen("ndi_p216://")) == 0)
				{
					cp = list[loop] + strlen("ndi_p216://");
					use = "P216";
				}
				else if(strncmp(list[loop], "ndi_rgbx://", strlen("ndi_rgbx://")) == 0)
				{
					cp = list[loop] + strlen("ndi_rgbx://");
					use = "RGBX";
				}
				else if(strncmp(list[loop], "ndi_bgrx://", strlen("ndi_bgrx://")) == 0)
				{
					cp = list[loop] + strlen("ndi_bgrx://");
					use = "BGRX";
				}
				if(cp != NULL)
				{
					CameraFormatButton *b = new CameraFormatButton(150, y_cnt, 300, 20, use);
					b->path = strdup(cp);
					b->alias = use;
					b->fmt = 0;
					b->box(FL_FLAT_BOX);
					b->color(DARK_BLUE);
					b->labelcolor(YELLOW);
					b->labelsize(11);
					b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					b->callback(select_camera_format_cb, this);
					y_cnt += 21;
				}
				free(list[loop]);
			}
		}
	}
	end();
	resize(x(), y(), w(), 10 + y_cnt);
	close->resize(w() - 52, new_yp + 2, 50, 18);
}

SelectCameraWindow::~SelectCameraWindow()
{
	if(my_window->new_source_window->select_camera_window == this)
	{
		my_window->new_source_window->select_camera_window = NULL;
	}
}

void	SelectCameraWindow::draw()
{
	Fl_Window::draw();
}

// SECTION **************************************************** PSEUDO CAMERA WINDOW *******************************************************

PseudoCameraWindow::PseudoCameraWindow(MyWin *in_win) : Dialog(1075, 300, 140, 180, "Pseudo Camera")
{
int	loop;

	int new_yp = 20;
	my_window = in_win;
	clear_visible_focus();
	set_non_modal();
	int cnt = 0;
	for(loop = 0;loop < global_potential_camera_cnt;loop++)
	{
		if((global_potential_camera[loop] != NULL) && (global_potential_camera_handle[loop] != NULL))
		{
			char *str = global_potential_camera[loop] + strlen("camera_");
			pseudo[cnt] = new MyButton(10, new_yp + 10 + (22 * cnt), 120, 20, str);
			pseudo[cnt]->box(FL_FLAT_BOX);
			pseudo[cnt]->color(BLACK);
			pseudo[cnt]->labelcolor(WHITE);
			pseudo[cnt]->labelsize(11);
			pseudo[cnt]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			pseudo[cnt]->callback(select_plugin_camera_cb, this);
			cnt++;
		}
	}
	pseudo[cnt] = new MyButton(10, new_yp + 10 + (22 * cnt), 120, 20, "Cancel");
	pseudo[cnt]->box(FL_FLAT_BOX);
	pseudo[cnt]->color(BLACK);
	pseudo[cnt]->labelcolor(YELLOW);
	pseudo[cnt]->labelsize(11);
	pseudo[cnt]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	pseudo[cnt]->callback(plugin_camera_cancel_cb, this);
	cnt++;
	end();
	resize(x(), y(), w(), new_yp + 20 + (cnt * 22));
}

PseudoCameraWindow::~PseudoCameraWindow()
{
}

void	PseudoCameraWindow::draw()
{
	Fl_Window::draw();
}

// SECTION **************************************************** TRANSITION WINDOW *******************************************************

void	transitions_close_cb(Fl_Widget *w, void *v)
{
	if(v != NULL)
	{
		TransitionWindow *win = (TransitionWindow *)v;
		win->hide();
	}
}

void	transition_select_cb(Fl_Widget *w, void *v)
{
	MyButton *b = (MyButton *)w;
	TransitionWindow *win = (TransitionWindow *)v;
	if(b == win->none_button)
	{
		win->my_window->transition = TRANSITION_NONE;
	}
	else if(b == win->blend_button)
	{
		win->my_window->transition = TRANSITION_BLEND;
	}
	else if(b == win->to_black_button)
	{
		win->my_window->transition = TRANSITION_FADE_TO_BLACK;
	}
	else if(b == win->wipe_l2r_button)
	{
		win->my_window->transition = TRANSITION_L2R_WIPE;
	}
	else if(b == win->wipe_r2l_button)
	{
		win->my_window->transition = TRANSITION_R2L_WIPE;
	}
	else if(b == win->wipe_t2b_button)
	{
		win->my_window->transition = TRANSITION_T2B_WIPE;
	}
	else if(b == win->wipe_b2t_button)
	{
		win->my_window->transition = TRANSITION_B2T_WIPE;
	}
	win->ClearPluginSelection();
	win->Update();
	win->my_window->SaveTransition();
}

void	transition_plugin_cb(Fl_Widget *w, void *v)
{
	TransitionWindow *tw = (TransitionWindow *)v;
	tw->my_window->transition = TRANSITION_PLUGIN;
	char *name = (char *)w->label();
	tw->my_window->LoadPluginTransition(name);
	tw->my_window->SaveTransition();
}

TransitionWindow::TransitionWindow(MyWin *in_win) : Dialog(780, 180, "Transitions")
{
int	loop;

	my_window = in_win;
	int new_yp = 20;
	resize(x(), y(), w(), h());

	int x_pos = 10;
	Fl_PNG_Image *none = new Fl_PNG_Image("Images/transition_none.png");
	none_button = new MyButton(x_pos, new_yp + 20, 100, 100);
	none_button->image(none);
	none_button->type(FL_RADIO_BUTTON);
	none_button->copy_tooltip("Abruptly transition from camera to camera");
	none_button->callback(transition_select_cb, this);
	x_pos += 110;

	Fl_PNG_Image *blend = new Fl_PNG_Image("Images/transition_blend.png");
	blend_button = new MyButton(x_pos, new_yp + 20, 100, 100);
	blend_button->image(blend);
	blend_button->type(FL_RADIO_BUTTON);
	blend_button->copy_tooltip("Dissolve images from one camera into the next");
	blend_button->callback(transition_select_cb, this);
	x_pos += 110;

	Fl_PNG_Image *to_black = new Fl_PNG_Image("Images/transition_2black.png");
	to_black_button = new MyButton(x_pos, new_yp + 20, 100, 100);
	to_black_button->image(to_black);
	to_black_button->type(FL_RADIO_BUTTON);
	to_black_button->copy_tooltip("Fade to black");
	to_black_button->callback(transition_select_cb, this);
	x_pos += 110;

	Fl_PNG_Image *wipe_l2r = new Fl_PNG_Image("Images/transition_wipe_l2r.png");
	wipe_l2r_button = new MyButton(x_pos, new_yp + 20, 100, 100);
	wipe_l2r_button->image(wipe_l2r);
	wipe_l2r_button->type(FL_RADIO_BUTTON);
	wipe_l2r_button->copy_tooltip("Wipe from left to right");
	wipe_l2r_button->callback(transition_select_cb, this);
	x_pos += 110;

	Fl_PNG_Image *wipe_r2l = new Fl_PNG_Image("Images/transition_wipe_r2l.png");
	wipe_r2l_button = new MyButton(x_pos, new_yp + 20, 100, 100);
	wipe_r2l_button->image(wipe_r2l);
	wipe_r2l_button->type(FL_RADIO_BUTTON);
	wipe_r2l_button->copy_tooltip("Wipe from right to left");
	wipe_r2l_button->callback(transition_select_cb, this);
	x_pos += 110;

	Fl_PNG_Image *wipe_t2b = new Fl_PNG_Image("Images/transition_wipe_t2b.png");
	wipe_t2b_button = new MyButton(x_pos, new_yp + 20, 100, 100);
	wipe_t2b_button->image(wipe_t2b);
	wipe_t2b_button->type(FL_RADIO_BUTTON);
	wipe_t2b_button->copy_tooltip("Wipe from the top to the bottom");
	wipe_t2b_button->callback(transition_select_cb, this);
	x_pos += 110;

	Fl_PNG_Image *wipe_b2t = new Fl_PNG_Image("Images/transition_wipe_b2t.png");
	wipe_b2t_button = new MyButton(x_pos, new_yp + 20, 100, 100);
	wipe_b2t_button->image(wipe_b2t);
	wipe_b2t_button->type(FL_RADIO_BUTTON);
	wipe_b2t_button->copy_tooltip("Wipe from the bottom to the top");
	wipe_b2t_button->callback(transition_select_cb, this);

	selection = new Fl_Box(0, 0, 48, 28, "@#+88->");
	selection->box(FL_NO_BOX);
	selection->labelcolor(YELLOW);
	selection->hide();

	for(loop = 0;loop < 128;loop++)
	{
		transition_plugin_button[loop] = NULL;
	}
	if(global_potential_transition_cnt > 0)
	{
		int x_pos = 10;
		int y_pos = new_yp + 180;
		int amount = ((global_potential_transition_cnt / 7) * 20) + 40;
		resize(x(), y(), w(), h() + amount);
		Fl_Group *grp = new Fl_Group(2, new_yp + 180, w() - 4, amount - 2);
		grp->box(FL_FLAT_BOX);
		grp->color(BLACK);
		for(loop = 0;loop < global_potential_transition_cnt;loop++)
		{
			char *lbl = global_potential_transition[loop];
			if(lbl != NULL)
			{
				if(strncmp(lbl, "transition_", strlen("transition_")) == 0)
				{
					lbl += strlen("transition_");
				}
				transition_plugin_button[loop] = new MyLightButton(x_pos, y_pos, 100, 20, lbl);
				transition_plugin_button[loop]->box(FL_THIN_UP_FRAME);
				transition_plugin_button[loop]->color(DARK_BLUE);
				transition_plugin_button[loop]->labelcolor(YELLOW);
				transition_plugin_button[loop]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
				transition_plugin_button[loop]->type(FL_RADIO_BUTTON);
				transition_plugin_button[loop]->labelsize(11);
				transition_plugin_button[loop]->copy_tooltip("A custom transition");
				transition_plugin_button[loop]->callback(transition_plugin_cb, this);
				if(strcmp(global_potential_transition[loop], my_window->transition_plugin) == 0)
				{
					transition_plugin_button[loop]->value(1);
				}
				x_pos += 110;
				if((x_pos + 110) > w())
				{
					x_pos = 10;
					y_pos += 20;
				}
			}
		}
		grp->end();
	}
	end();
	hide();
	Update();
}

TransitionWindow::~TransitionWindow()
{
}

void	TransitionWindow::draw()
{
	Fl_Window::draw();
}

void	TransitionWindow::ClearPluginSelection()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(transition_plugin_button[loop] != NULL)
		{
			transition_plugin_button[loop]->value(0);
		}
	}
}

void	TransitionWindow::Update()
{
	selection->show();
	if(my_window->transition == TRANSITION_NONE)
	{
		none_button->value(1);
		selection->resize(none_button->x() + 36, none_button->y() + 100, 24, 24);
	}
	else if(my_window->transition == TRANSITION_BLEND)
	{
		blend_button->value(1);
		selection->resize(blend_button->x() + 36, blend_button->y() + 100, 24, 24);
	}
	else if(my_window->transition == TRANSITION_L2R_WIPE)
	{
		wipe_l2r_button->value(1);
		selection->resize(wipe_l2r_button->x() + 36, wipe_l2r_button->y() + 100, 24, 24);
	}
	else if(my_window->transition == TRANSITION_R2L_WIPE)
	{
		wipe_r2l_button->value(1);
		selection->resize(wipe_r2l_button->x() + 36, wipe_r2l_button->y() + 100, 24, 24);
	}
	else if(my_window->transition == TRANSITION_T2B_WIPE)
	{
		wipe_t2b_button->value(1);
		selection->resize(wipe_t2b_button->x() + 36, wipe_t2b_button->y() + 100, 24, 24);
	}
	else if(my_window->transition == TRANSITION_B2T_WIPE)
	{
		wipe_b2t_button->value(1);
		selection->resize(wipe_b2t_button->x() + 36, wipe_b2t_button->y() + 100, 24, 24);
	}
	else if(my_window->transition == TRANSITION_FADE_TO_BLACK)
	{
		to_black_button->value(1);
		selection->resize(to_black_button->x() + 36, to_black_button->y() + 100, 24, 24);
	}
	else if(my_window->transition == TRANSITION_PLUGIN)
	{
		selection->hide();
	}
	redraw();
}

// SECTION **************************************************** TRIGGER WINDOW *******************************************************

void	trigger_window_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	trigger_camera_button_cb(NULL, win);
}

void	trigger_window_clear_cb(Fl_Widget *w, void *v)
{
int	loop;

	TriggerWindow *tw = (TriggerWindow *)v;
	Camera *cam = tw->main_win->DisplayedCamera();
	if(cam != NULL)
	{
		cam->schedule_day = 0;
		for(loop = 0;loop < 7;loop++)
		{
			tw->day[loop]->value(0);
			tw->day[loop]->color(BLACK);
			tw->day[loop]->labelcolor(YELLOW);
		}
		tw->start_time->value("00:00");
		tw->stop_time->value("00:00");
		cam->schedule_start = 0;
		cam->schedule_stop = 0;
		cam->darkness_trigger = 0.5;
		tw->darkness_slider->value(0.5);
		cam->record_trigger = 0;
		tw->trigger[BUTTON_ON_RECORD_BUTTON]->value(1);
		for(loop = 1;loop < 7;loop++)
		{
			tw->trigger[loop]->value(0);
		}
		for(loop = 0;loop < 128;loop++)
		{
			cam->trigger[loop] = -1;
		}
		cam->trigger_cnt = 0;
		tw->Update();
		tw->redraw();
	}
}

void	trigger_day_cb(Fl_Widget *b, void *v)
{
int	loop;

	MyToggleButton *button = (MyToggleButton *)b;
	TriggerWindow *tw = (TriggerWindow *)v;
	Camera *cam = tw->main_win->DisplayedCamera();
	if(cam != NULL)
	{
		cam->schedule_day = 0;
		if(button->value())
		{
			button->color(WHITE);
			button->labelcolor(BLACK);
			button->redraw();
		}
		else
		{
			button->color(BLACK);
			button->labelcolor(YELLOW);
			button->redraw();
		}
		for(loop = 0;loop < 7;loop++)
		{
			if(tw->day[loop]->value())
			{
				cam->schedule_day |= (1 << loop);
			}
		}
	}
}

void	schedule_trigger_cb(Fl_Widget *b, void *v)
{
int	loop;

	MyLightButton *button = (MyLightButton *)b;
	TriggerWindow *tw = (TriggerWindow *)v;
	Camera *cam = tw->main_win->DisplayedCamera();
	if(cam != NULL)
	{
		cam->schedule_start = 0;
		cam->schedule_stop = 0;
		int start_hour = 0;
		int start_minute = 0;
		int stop_hour = 0;
		int stop_minute = 0;
		char *start = (char *)tw->start_time->value();
		if(start != NULL)
		{
			start_hour = atoi(start);
			char *cp = start;
			while((*cp != ':') && (*cp != '\0')) cp++;
			if(*cp == ':')
			{
				cp++;
				start_minute = atoi(cp);
			}
		}
		char *stop = (char *)tw->stop_time->value();
		if(stop != NULL)
		{
			stop_hour = atoi(stop);
			char *cp = stop;
			while((*cp != ':') && (*cp != '\0')) cp++;
			if(*cp == ':')
			{
				cp++;
				stop_minute = atoi(cp);
			}
		}
		int test_start = (start_hour * 60) + start_minute;
		int test_stop = (stop_hour * 60) + stop_minute;
		if(test_stop > test_start)
		{
			cam->schedule_start = test_start;
			cam->schedule_stop = test_stop;
		}
	}
}

void	darkness_slider_cb(Fl_Widget *b, void *v)
{
	MyLightButton *button = (MyLightButton *)b;
	TriggerWindow *tw = (TriggerWindow *)v;
	Camera *cam = tw->main_win->DisplayedCamera();
	if(cam != NULL)
	{
		double val = tw->darkness_slider->value();
		cam->darkness_trigger = val;
	}
}

void	record_trigger_cb(Fl_Widget *b, void *v)
{
int	loop;

	MyLightButton *button = (MyLightButton *)b;
	TriggerWindow *tw = (TriggerWindow *)v;
	Camera *cam = tw->main_win->DisplayedCamera();
	if(cam != NULL)
	{
		cam->record_trigger = 0;
		if(tw->trigger[BUTTON_ON_RECORD_BUTTON]->value())
		{
			cam->record_trigger = ON_RECORD_BUTTON;
			if(button == tw->trigger[BUTTON_ON_RECORD_BUTTON])
			{
				for(loop = 1;loop < 7;loop++)
				{
					tw->trigger[loop]->value(0);
				}
			}
		}
		if(tw->trigger[BUTTON_ON_DETECT_OBJECT]->value())
		{
			cam->record_trigger |= ON_DETECT_OBJECT;
			tw->trigger[BUTTON_ON_RECORD_BUTTON]->value(0);
		}
		if(tw->trigger[BUTTON_ON_DETECT_MOTION]->value())
		{
			cam->record_trigger |= ON_DETECT_MOTION;
			tw->trigger[BUTTON_ON_RECORD_BUTTON]->value(0);
		}
		if(tw->trigger[BUTTON_ON_DETECT_LIGHT]->value())
		{
			cam->record_trigger |= ON_DETECT_LIGHT;
			cam->record_trigger &= ~ON_DETECT_DARK;
			tw->trigger[BUTTON_ON_RECORD_BUTTON]->value(0);
			tw->trigger[BUTTON_ON_DETECT_DARK]->value(0);
		}
		if(tw->trigger[BUTTON_ON_DETECT_DARK]->value())
		{
			cam->record_trigger |= ON_DETECT_DARK;
			cam->record_trigger &= ~ON_DETECT_LIGHT;
			tw->trigger[BUTTON_ON_RECORD_BUTTON]->value(0);
			tw->trigger[BUTTON_ON_DETECT_LIGHT]->value(0);
		}
		if(tw->trigger[BUTTON_ON_TRIGGER_CAMERA]->value())
		{
			cam->record_trigger |= ON_TRIGGER_CAMERA;
			tw->trigger[BUTTON_ON_RECORD_BUTTON]->value(0);
		}
		if(tw->trigger[BUTTON_ON_SCHEDULE]->value())
		{
			cam->record_trigger |= ON_SCHEDULE;
			tw->trigger[BUTTON_ON_RECORD_BUTTON]->value(0);
		}
	}
	tw->redraw();
}

TriggerWindow::TriggerWindow(MyWin *in_win) : Dialog(400, 300, 430, 450, "Triggers")
{
int	loop;

	static char *day_label[7] = { "S", "M", "T", "W", "T", "F", "S" }; 
	static char *trigger_label[7] = { 
		"On Record Button",
		"On Schedule",
		"On Detect Light",
		"On Detect Dark",
		"On Detect Motion",
		"On Detect Object",
		"On Trigger Camera"
	};
	main_win = in_win;
	int new_yp = 20;
	last_x = 0;
	last_y = 0;

	int xp = 20;
	int yp = 20 + new_yp;
	Fl_Box *weekday = new Fl_Box(xp, yp, 140, 20, "Weekday");
	weekday->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	weekday->box(FL_FLAT_BOX);
	weekday->labelsize(11);
	weekday->color(BLACK);
	weekday->labelcolor(WHITE);
	yp += 21;
	for(loop = 0;loop < 7;loop++)
	{
		day[loop] = new MyToggleButton(xp, yp, 20, 20, day_label[loop]);
		day[loop]->color(BLACK);
		day[loop]->labelcolor(YELLOW);
		day[loop]->labelsize(11);
		day[loop]->box(FL_FRAME_BOX);
		day[loop]->copy_tooltip("Set the days for triggering a scheduled record.");
		day[loop]->callback(trigger_day_cb, this);
		xp += 21;
	}
	xp = 20;
	yp += 30;
	Fl_Box *period = new Fl_Box(xp, yp, 140, 20, "Period (hh:mm)");
	period->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	period->box(FL_FLAT_BOX);
	period->labelsize(11);
	period->color(BLACK);
	period->labelcolor(WHITE);
	yp += 21;
	start_time = new Fl_Input(xp, yp, 60, 20, "");
	start_time->box(FL_FRAME_BOX);
	start_time->color(BLACK);
	start_time->textcolor(WHITE);
	start_time->labelsize(11);
	start_time->textsize(11);
	start_time->cursor_color(WHITE);
	start_time->labelcolor(YELLOW);
	start_time->when(FL_WHEN_CHANGED);
	start_time->value("13:01");
	start_time->copy_tooltip("Schedule the start time for triggering record.");
	start_time->callback(schedule_trigger_cb, this);

	stop_time = new Fl_Input(xp + 80, yp, 60, 20, " - ");
	stop_time->box(FL_FRAME_BOX);
	stop_time->color(BLACK);
	stop_time->textcolor(WHITE);
	stop_time->labelsize(11);
	stop_time->textsize(11);
	stop_time->cursor_color(WHITE);
	stop_time->labelcolor(YELLOW);
	stop_time->when(FL_WHEN_CHANGED);
	stop_time->value("14:00");
	stop_time->copy_tooltip("Schedule the stop time for triggering record.");
	stop_time->callback(schedule_trigger_cb, this);
	yp += 30;

	MyButton *darkness = new MyButton(xp, yp, 140, 20, "Light/Dark");
	darkness->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	darkness->box(FL_FLAT_BOX);
	darkness->labelsize(11);
	darkness->color(BLACK);
	darkness->labelcolor(YELLOW);
	yp += 21;
	darkness_slider = new MySlider(xp, yp, 150, 20, "", darkness);
	darkness_slider->range(0.0, 1.0);
	darkness_slider->value(0.5);
	darkness_slider->initial_value = 0.5;
	darkness_slider->labelsize(11);
	darkness_slider->labelcolor(YELLOW);
	darkness_slider->copy_tooltip("Set the trigger point for recording based on light/dark");
	darkness_slider->callback(darkness_slider_cb, this);
	yp += 34;

	xp = 20;
	Fl_Box *condition = new Fl_Box(xp, yp, 140, 20, "Conditions");
	condition->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	condition->box(FL_FLAT_BOX);
	condition->labelsize(11);
	condition->color(BLACK);
	condition->labelcolor(WHITE);
	yp += 21;
	for(loop = 0;loop < 7;loop++)
	{
		trigger[loop] = new MyLightButton(xp, yp, 150, 20, trigger_label[loop]);
		trigger[loop]->box(FL_FRAME_BOX);
		trigger[loop]->color(BLACK);
		trigger[loop]->labelcolor(YELLOW);
		trigger[loop]->labelsize(9);
		trigger[loop]->align(FL_ALIGN_CENTER);
		trigger[loop]->copy_tooltip("Trigger recording based on the named condition. If more than one conditions is set, all selected conditions must be met.");
		trigger[loop]->callback(record_trigger_cb, this);
		if(loop == BUTTON_ON_DETECT_OBJECT)
		{
			if(main_win->net.empty()) 
			{
				trigger[loop]->deactivate();
			}
		}
		yp += 22;
	}
	int nxx = 250;
	int nyy = 50 + new_yp;
	for(loop = 0;loop < 128;loop++)
	{
		thumbnail[loop] = NULL;
	}
	for(loop = 0;loop < 128;loop++)
	{
		if((nyy + 86) > h())
		{
			nyy = 50 + new_yp;
			nxx += 160;
		}
		thumbnail[loop] = new ThumbButton(in_win, loop, nxx, nyy, 153, 86);
		thumbnail[loop]->box(FL_NO_BOX);
		thumbnail[loop]->callback(thumbnail_cb, in_win);
		thumbnail[loop]->copy_tooltip("Trigger the displayed camera based on the trigger state of the selected camera.");
		thumbnail[loop]->hide();
		nyy += 90;
	}
	clear = new MyButton(w() - 170, 10 + new_yp, 70, 20, "Clear");
	clear->box(FL_NO_BOX);
	clear->labelcolor(YELLOW);
	clear->labelsize(11);
	clear->copy_tooltip("Clear selected record trigger conditions.");
	clear->callback(trigger_window_clear_cb, this);

	done = new MyButton(w() - 100, 10 + new_yp, 70, 20, "Done");
	done->box(FL_NO_BOX);
	done->labelcolor(YELLOW);
	done->labelsize(11);
	done->copy_tooltip("Close the dialog. Trigger conditions will be tested after Record is selected.");
	done->callback(trigger_window_cb, main_win);

	end();
	Update();
}

TriggerWindow::~TriggerWindow()
{
}

int	TriggerWindow::handle(int event)
{
	int flag = 0;
	if((event == FL_FOCUS) || (event == FL_UNFOCUS))
	{
		flag = 1;
	}
	else if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == FL_Escape)
		{
			main_win->trigger_select_mode = 0;
			main_win->trigger_button->copy_label("Trigger Conditions");
			hide();
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	if((flag == 0) && (event == FL_PUSH))
	{
		flag = 1;
	}
	return(flag);
}

void	TriggerWindow::show()
{
	Update();
	start_time->take_focus();
	Fl_Window::show();
}

void	TriggerWindow::Update()
{
int		loop;
char	buf[256];

	Camera *cam = main_win->DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < 7;loop++)
		{
			day[loop]->value(0);
			int num = (1 << loop);
			if((cam->schedule_day & num) == num)
			{
				day[loop]->value(1);
			}
		}
		int start_hour = cam->schedule_start / 60;
		int start_minute = cam->schedule_start - (start_hour * 60);
		int stop_hour = cam->schedule_stop / 60;
		int stop_minute = cam->schedule_stop - (stop_hour * 60);
		sprintf(buf, "%02d:%02d", start_hour, start_minute);
		start_time->value(buf);
		sprintf(buf, "%02d:%02d", stop_hour, stop_minute);
		stop_time->value(buf);
		trigger[0]->value(0);
		if(cam->record_trigger == 0)
		{
			trigger[0]->value(1);
		}
		for(loop = 0;loop < 6;loop++)
		{
			trigger[loop + 1]->value(0);
			int num = (1 << loop);
			if((cam->record_trigger & num) == num)
			{
				trigger[loop + 1]->value(1);
			}
			if(loop == BUTTON_ON_DETECT_OBJECT)
			{
				if(main_win->net.empty()) 
				{
					trigger[loop]->deactivate();
				}
				else
				{
					trigger[loop]->activate();
				}
			}
		}
		for(loop = 0;loop < 128;loop++)
		{
			if(thumbnail[loop]->visible())
			{
				int xx = thumbnail[loop]->x() + 180;
				if(xx > w())
				{
					resize(x(), y(), xx, h());
				}
			}
		}
		clear->resize(w() - 170, clear->y(), clear->w(), clear->h());
		done->resize(w() - 100, done->y(), done->w(), done->h());
	}
}

// SECTION **************************************************** DETAIL WINDOW *******************************************************

DetailWin::DetailWin(int ww, int hh, char *lbl) : Fl_Double_Window(ww, hh, lbl)
{
}

DetailWin::~DetailWin()
{
}

void	DetailWin::draw()
{
struct tm *tm;
Mat	display_mat;

	Fl_Double_Window::draw();
	fl_draw_image((unsigned char *)mat.ptr(), 0, 0, mat.cols, mat.rows, mat.channels());
}

// SECTION **************************************************** IMAGE WINDOW *******************************************************

ImageWindow::ImageWindow(int in_index, MyWin *win, Camera *cam, Camera *in_dest, int xx, int yy, int ww, int hh) : MyGroup(xx, yy, ww, hh)
{
	end();

	index = in_index;
	my_window = win;
	camera = cam;
	dest_camera = in_dest;
	layer = 0;
	if(dest_camera != NULL)
	{
		layer = dest_camera->edit_layer;
	}
	dragging = 0;
	transform = 0;
	start_drag_x = -1;
	start_drag_y = -1;
	width = ww;
	height = hh;
	orig_w = ww;
	orig_h = hh;
	dx = xx;
	dy = yy;
	dw = ww;
	dh = hh;
	if(dest_camera != NULL)
	{
		relative_x = xx - dest_camera->image_sx;
		relative_y = yy - dest_camera->image_sy;
	}
	angle = 0.0;
	parent_scale_width = 1.0;
	parent_scale_height = 1.0;
	displayed_x = xx;
	displayed_y = yy;
	displayed_w = ww;
	displayed_h = hh;
	buttonize = 0;
	buttonized_x = -1;
	buttonized_y = -1;
	buttonized_w = -1;
	buttonized_h = -1;
	crop_x = 0;
	crop_y = 0;
	crop_w = 0;
	crop_h = 0;
	trim_x = 0;
	trim_y = 0;
	frame = 0;
	drag_mode = DRAG_MODE_MOVE;
	popup = NULL;
	overall_alpha = 1.0;
	use_as_mask = 0;
	mw_mode = MW_MODE_NONE;
	angle = 0.0;
	flip_horizontal = 0;
	flip_vertical = 0;
	box(FL_NO_BOX);
	hide();
}

ImageWindow::~ImageWindow()
{
	if(my_window->resize_frame != NULL)
	{
		if(my_window->resize_frame->use == this)
		{
			my_window->resize_frame->use = NULL;
			my_window->resize_frame->hide();
		}
	}
	if(popup != NULL)
	{
		popup->hide();
		Fl::delete_widget(popup);
		popup = NULL;
	}
}

void	ImageWindow::resize(int xx, int yy, int ww, int hh)
{
	if(dest_camera != NULL)
	{
		relative_x = xx - dest_camera->image_sx;
		relative_y = yy - dest_camera->image_sy;
	}
	MyGroup::resize(xx, yy, ww, hh);
}

int	ImageWindow::AsButton(int xx, int yy)
{
	int flag = 0;
	if((xx > buttonized_x)
	&& (yy > buttonized_y)
	&& (xx < buttonized_x + buttonized_w)
	&& (yy < buttonized_y + buttonized_h))
	{
		buttonize = 0;
		show();
		flag = 1;
	}
	return(flag);
}

void	ImageWindow::Draw(Camera *dest_camera)
{
int	loop;

	if(visible())
	{
		if(camera != NULL)
		{
			camera->Capture();
			Camera *dest = my_window->DisplayedCamera();
			if(dest_camera != NULL)
			{
				dest = dest_camera;
			}
			if(dest != camera)
			{
				if((camera->mat.rows > 0) && (camera->mat.cols > 0))
				{
					cairo_t *dest_context = dest->cairo_context;
					cairo_surface_t *dest_surface = dest->cairo_surface;
					Mat mask;
					if(use_as_mask == 1)
					{
						Mat dest_mat = dest_camera->mat;
						mask = cv::Mat(dest_mat.rows, dest_mat.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
						dest_surface = cairo_image_surface_create_for_data(mask.ptr(), CAIRO_FORMAT_ARGB32, mask.cols, mask.rows, mask.step);
						dest_context = cairo_create(dest_surface);
						cairo_set_antialias(dest_context, CAIRO_ANTIALIAS_BEST);
					}
					int sx = relative_x;
					int sy = relative_y;
					cv::resize(camera->mat, mat, cv::Size(w(), h()), 0, 0, cv::INTER_AREA);
					if((crop_w > 0) && (crop_h > 0))
					{
						crop_section(mat, mat, crop_x, crop_y, crop_w, crop_h);
					}
					int use_w = w();
					int use_h = h();

					blend_two(dest->mat, mat, sx, sy, overall_alpha);
					parent_scale_width = (double)my_window->display_width / (double)dest->width;
					parent_scale_height = (double)my_window->display_height / (double)dest->height;
					
					if(angle != 0.0)
					{
						rotate_mat(angle, mat);
					}
					if((flip_vertical == 1) && (flip_horizontal == 0))
					{
						flip(mat, mat, 0);
					}
					else if((flip_vertical == 0) && (flip_horizontal == 1))
					{
						flip(mat, mat, 1);
					}
					else if((flip_vertical == 1) && (flip_horizontal == 1))
					{
						flip(mat, mat, -1);
					}
					if(dest->cairo_context != NULL)
					{
						int half_w = mat.cols / 2;
						int half_h = mat.rows / 2;
						cairo_save(dest_context);
						cairo_translate(dest_context, sx + half_w, sy + half_h);
						cairo_rotate(dest_context, angle);

						cairo_surface_t *surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
						if((surface != NULL) && (dest_surface != NULL))
						{
							cairo_set_source_surface(dest_context, surface, -half_w, -half_h);
							cairo_paint(dest_context);
							cairo_surface_destroy(surface);
							if(frame == 1)
							{
								cairo_set_dash(dest_context, NULL, 0, 1);
								cairo_set_line_width(dest_context, 2);
								my_cairo_set_source_rgba(dest_context, camera->text_red, camera->text_green, camera->text_blue, camera->text_alpha);
								cairo_rectangle(dest_context, -half_w, -half_h, mat.cols, mat.rows);
								cairo_stroke(dest_context);
							}
						}
						cairo_restore(dest_context);
						resize(sx + dest->image_sx, sy + dest->image_sy, use_w, use_h);
						if(dragging == 1)
						{
							if(transform == MODE_TRIMMING)
							{
								my_cairo_set_source_rgb(dest_context, 255, 255, 128);
								int nx1 = start_drag_x - dest->image_sx;
								int ny1 = start_drag_y - dest->image_sy;
								int nx2 = trim_x - start_drag_x;
								int ny2 = trim_y - start_drag_y;
								cairo_rectangle(dest_context, nx1, ny1, nx2, ny2);
								cairo_stroke(dest_context);
							}
						}
					}
					if(use_as_mask == 1)
					{
						cv::bitwise_and(dest->mat, mask, dest->mat);
						if(dest_surface != NULL)
						{
							cairo_destroy(dest_context);
							cairo_surface_destroy(dest_surface);
						}
					}
				}
			}
		}
	}
	else if(buttonize == 1)
	{
		Camera *cam = my_window->DisplayedCamera();
		char buf[4096];
		strcpy(buf, "Source");
		if(camera != NULL)
		{
			if(strlen(camera->alias) > 0)
			{
				sprintf(buf, "%s", camera->alias);
			}
			else
			{
				sprintf(buf, "%s", camera->path);
			}
		}
		int sw = 0;
		int sh = 0;
		int out_x = 0;
		int out_y = 0;
		fl_measure(buf, sw, sh);
		buttonized_w = sw + 8;
		buttonized_h = sh + 4;
		cam->PositionAllButtonized();
		if((buttonized_w > 0) && (buttonized_h > 0))
		{
			fl_color(YELLOW);
			fl_draw(buf, buttonized_x, buttonized_y + sh);
			fl_rect(buttonized_x - 4, buttonized_y, sw + 8, sh + 4);
		}
	}
}

void	ImageWindow::ZipLeft()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindLeft(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			resize(val, y(), w(), h());
		}
		else
		{
			resize(dest->image_sx, y(), w(), h());
		}
	}
}

void	ImageWindow::GrowLeft()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindLeft(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			int diff = abs(x() - val);
			resize(val, y(), w() + diff, h());
		}
		else
		{
			int diff = abs(x() - dest->image_sx);
			resize(dest->image_sx, y(), w() + diff, h());
		}
	}
}

void	ImageWindow::ZipRight()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindRight(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			resize(val - w(), y(), w(), h());
		}
		else
		{
			resize((dest->image_sx + dest->mat.cols) - w(), y(), w(), h());
		}
	}
}

void	ImageWindow::GrowRight()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindRight(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			int diff = abs((x() + w()) - val);
			resize(x(), y(), w() + diff, h());
		}
		else
		{
			int diff = abs((x() + w()) - (dest->image_sx + dest->mat.cols));
			resize(x(), y(), w() + (diff - 1), h());
		}
	}
}

void	ImageWindow::ZipUp()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindTop(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			resize(x(), val, w(), h());
		}
		else
		{
			resize(x(), dest->image_sy, w(), h());
		}
	}
}

void	ImageWindow::GrowUp()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindTop(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			int diff = abs(y() - val);
			resize(x(), val, w(), h() + diff);
		}
		else
		{
			int diff = abs(y() - dest->image_sy);
			resize(x(), dest->image_sy, w(), h() + diff);
		}
	}
}

void	ImageWindow::ZipDown()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindBottom(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			resize(x(), val - h(), w(), h());
		}
		else
		{
			resize(x(), (dest->image_sy + dest->mat.rows) - h(), w(), h());
		}
	}
}

void	ImageWindow::GrowDown()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindBottom(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			int diff = abs((y() + h()) - val);
			resize(x(), y(), w(), h() + diff);
		}
		else
		{
			int diff = abs((y() + h()) - (dest->image_sy + dest->mat.rows));
			resize(x(), y(), w(), h() + (diff - 1));
		}
	}
}

void	ImageWindow::FillFrame()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int ww = dest->mat.cols;
		int hh = dest->mat.rows;
		resize(0, 0, ww, hh);
	}
}

void	image_window_popup_cb(Fl_Widget *w, void *v)
{
	ImageWindow *iw = (ImageWindow *)v;
	if(iw != NULL)
	{
		Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
		char *str = (char *)browser->text(browser->value());
		if(str != NULL)
		{
			if(strcmp(str, "Move") == 0)
			{
				iw->drag_mode = DRAG_MODE_MOVE;
			}
			else if(strcmp(str, "Resize") == 0)
			{
				iw->drag_mode = DRAG_MODE_RESIZE;
			}
			else if(strcmp(str, "Crop") == 0)
			{
				iw->drag_mode = DRAG_MODE_CROP;
			}
			else if(strcmp(str, "Rotate") == 0)
			{
				iw->drag_mode = DRAG_MODE_ROTATE;
			}
			else if(strcmp(str, "Restore") == 0)
			{
				iw->Restore();
			}
			else if(strcmp(str, "Delete") == 0)
			{
				iw->Delete();
			}
			else if(strcmp(str, "Hide") == 0)
			{
				iw->Buttonize();
			}
			else if(strcmp(str, "Zip Left") == 0)
			{
				iw->ZipLeft();
			}
			else if(strcmp(str, "Grow Left") == 0)
			{
				iw->GrowLeft();
			}
			else if(strcmp(str, "Zip Right") == 0)
			{
				iw->ZipRight();
			}
			else if(strcmp(str, "Grow Right") == 0)
			{
				iw->GrowRight();
			}
			else if(strcmp(str, "Zip Up") == 0)
			{
				iw->ZipUp();
			}
			else if(strcmp(str, "Grow Up") == 0)
			{
				iw->GrowUp();
			}
			else if(strcmp(str, "Zip Down") == 0)
			{
				iw->ZipDown();
			}
			else if(strcmp(str, "Grow Down") == 0)
			{
				iw->GrowDown();
			}
			else if(strcmp(str, "Toggle Frame") == 0)
			{
				if(iw->frame == 0)
				{
					iw->frame = 1;
				}
				else
				{
					iw->frame = 0;
				}
			}
			else if(strcmp(str, "MW Frame") == 0)
			{
				iw->mw_mode = MW_MODE_NONE;
			}
			else if(strcmp(str, "MW Transparency") == 0)
			{
				iw->mw_mode = MW_MODE_TRANSPARENCY;
			}
			else if(strcmp(str, "MW Stacking Order") == 0)
			{
				iw->mw_mode = MW_MODE_STACKING_ORDER;
			}
			else if(strcmp(str, "Make Transparent") == 0)
			{
				iw->overall_alpha = 0.0;
			}
			else if(strcmp(str, "Make Opaque") == 0)
			{
				iw->overall_alpha = 1.0;
			}
			else if(strcmp(str, "MW Rotate") == 0)
			{
				iw->mw_mode = MW_MODE_ROTATION;
			}
			else if(strcmp(str, "Flip Horizontal") == 0)
			{
				if(iw->flip_horizontal == 0)
				{
					iw->flip_horizontal = 1;
				}
				else
				{
					iw->flip_horizontal = 0;
				}
			}
			else if(strcmp(str, "Flip Vertical") == 0)
			{
				if(iw->flip_vertical == 0)
				{
					iw->flip_vertical = 1;
				}
				else
				{
					iw->flip_vertical = 0;
				}
			}
			else if(strcmp(str, "Fill Frame") == 0)
			{
				iw->FillFrame();
			}
			else if(strcmp(str, "Mask") == 0)
			{
				iw->use_as_mask = 1;
			}
		}
		if(iw->popup != NULL)
		{
			iw->popup->hide();
		}
	}
}

void	ImageWindow::Restore()
{
	drag_mode = DRAG_MODE_MOVE;
	width = orig_w;
	height = orig_h;
	crop_x = 0;
	crop_y = 0;
	crop_w = 0;
	crop_h = 0;
	int xx = x();
	int yy = x();
	overall_alpha = 1.0;
	use_as_mask = 0;
	angle = 0.0;
	if(dest_camera != NULL)
	{
		xx = dest_camera->image_sx + ((dest_camera->mat.cols / 2) - (width / 2));
		yy = dest_camera->image_sy + ((dest_camera->mat.rows / 2) - (height / 2));
	}
	resize(xx, yy, width, height);
}

void	ImageWindow::Delete()
{
	my_window->use_mousewheel = 1;
	if(my_window->resize_frame->use == this)
	{
		my_window->resize_frame->use = NULL;
		my_window->resize_frame->hide();
	}
	hide();
	my_window->remove(this);
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		dest->image_window[index] = NULL;
		dest->CompressImageWindowList();
	}
	Fl::delete_widget(this);
	fl_cursor(FL_CURSOR_DEFAULT);
}

void	ImageWindow::Buttonize()
{
	my_window->use_mousewheel = 1;
	buttonize = 1;
	hide();
	fl_cursor(FL_CURSOR_DEFAULT);
}

int	ImageWindow::handle(int event)
{
int	loop;

	int flag = 0;
	if(my_window != NULL)
	{
		Camera *cam = my_window->DisplayedCamera();
		if(cam != NULL)
		{
			if(dest_camera == cam)
			{
				if(cam->edit_layer == layer)
				{
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					switch(event)
					{
						case(FL_PUSH):
						{
							if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
							{
								if((xx >= displayed_x) && (xx < (displayed_x + displayed_w))
								&& (yy >= displayed_y) && (yy < (displayed_y + displayed_h)))
								{
									if(popup == NULL)
									{
										popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 160, 300);
										popup->browser->callback(image_window_popup_cb, this);
									}
									else
									{
										popup->resize(Fl::event_x_root(), Fl::event_y_root(), popup->w(), popup->h());
									}
									if(popup != NULL)
									{
										popup->browser->clear();
										popup->browser->add("Restore");
										popup->browser->add("Hide");
										popup->browser->add("Delete");
										popup->browser->add("");
										popup->browser->add("Zip Left");
										popup->browser->add("Grow Left");
										popup->browser->add("Zip Right");
										popup->browser->add("Grow Right");
										popup->browser->add("Zip Up");
										popup->browser->add("Grow Up");
										popup->browser->add("Zip Down");
										popup->browser->add("Grow Down");
										popup->browser->add("");
										popup->browser->add("Toggle Frame");
										popup->browser->add("MW Frame");
										popup->browser->add("MW Transparency");
										popup->browser->add("MW Stacking Order");
										popup->browser->add("MW Rotate");
										popup->browser->add("Make Transparent");
										popup->browser->add("Make Opaque");
										popup->browser->add("Flip Horizontal");
										popup->browser->add("Flip Vertical");
										popup->browser->add("Fill Frame");
										popup->browser->add("Mask");
										popup->set_non_modal();
										popup->Fit();
										popup->show();
									}
									flag = 1;
								}
							}
							else
							{
								if((drag_mode != DRAG_MODE_MOVE)
								&& (drag_mode != DRAG_MODE_RESIZE))
								{
									dragging = 1;
									start_drag_x = xx;
									start_drag_y = yy;
									flag = 1;
								}
							}
						}
						break;
						case(FL_RELEASE):
						{
							fl_cursor(FL_CURSOR_DEFAULT);
							dragging = 0;
							int grid_sz = my_window->grid_size;
							if(transform == MODE_MOVING)
							{
								if(grid_sz > 1)
								{
									Camera *cam = my_window->DisplayedCamera();
									int cam_x = cam->image_sx;
									int cam_y = cam->image_sy;
									int use_x = x() - cam_x;
									int use_y = y() - cam_y;
									use_x = force_to_grid(grid_sz, use_x);
									use_y = force_to_grid(grid_sz, use_y);
									resize(use_x + cam_x, use_y + cam_y, w(), h());
								}
							}
							else if(transform == MODE_TRIMMING)
							{
								Mat cropped;
								int x1 = start_drag_x;
								int x2 = xx;
								if(start_drag_x > xx)
								{
									x1 = xx;
									x2 = start_drag_x;
								}
								int y1 = start_drag_y;
								int y2 = yy;
								if(start_drag_y > yy)
								{
									y1 = yy;
									y2 = start_drag_y;
								}
								crop_x = x1 - x();
								crop_y = y1 - y();
								crop_w = abs(x2 - x1);
								crop_h = abs(y2 - y1);
								flag = 1;
							}
							transform = 0;
						}
						break;
						case(FL_ENTER):
						{
							my_window->resize_frame->Use(FRAME_OBJECT_TYPE_IMAGE_WINDOW, this);
							my_window->resize_frame->show();
							take_focus();
							my_window->use_mousewheel = 0;
							flag = 1;
						}
						break;
						case(FL_LEAVE):
						{
							my_window->resize_frame->hide();
							fl_cursor(FL_CURSOR_DEFAULT);
							my_window->use_mousewheel = 1;
						}
						break;
						case(FL_DRAG):
						case(FL_MOVE):
						{
							if(my_window->resize_frame->use == this)
							{
								my_window->resize_frame->handle(event);
							}
							if(dragging == 1)
							{
								if(Fl::event_state(FL_BUTTON1) == FL_BUTTON1)
								{
									if(drag_mode == DRAG_MODE_CROP)
									{
										transform = MODE_TRIMMING;
										trim_x = xx;
										trim_y = yy;
										flag = 1;
									}
									else if(drag_mode == DRAG_MODE_ROTATE)
									{
										if(yy > start_drag_y)
										{
											angle += 1.0;
											if(angle >= 360.0)
											{
												angle = 0.0;
											}
										}
										else
										{
											angle -= 1.0;
											if(angle < 0.0)
											{
												angle = 359.0;
											}
										}
										transform = MODE_ROTATING;
										flag = 1;
									}
								}
								else if(Fl::event_state(FL_BUTTON2) == FL_BUTTON2)
								{
									if((crop_w == 0) && (crop_h == 0))
									{
										if((xx > (x() + w() - 50))
										&& (yy < (y() + h() - 50)))
										{
											Rescale(cam, xx, yy, 0);
										}
										else if((xx < (x() + w() - 50))
										&& (yy > (y() + h() - 50)))
										{
											Rescale(cam, xx, yy, 0);
										}
										else
										{
											Rescale(cam, xx, yy, 1);
										}
										transform = MODE_RESIZING;
										flag = 1;
									}
								}
							}
						}
						break;
						case(FL_FOCUS):
						case(FL_UNFOCUS):
						{
							flag = 1;
						}
						break;
						case(FL_KEYBOARD):
						{
							int key = Fl::event_key();
							if(key == FL_Delete)
							{
								Delete();
								flag = 1;
							}
							else if(key == FL_Home)
							{
								Restore();
								flag = 1;
							}
							else if(key == FL_End)
							{
								Buttonize();
								flag = 1;
							}
							else if(key == FL_Left)
							{
								if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
								{
									GrowLeft();
								}
								else
								{
									ZipLeft();
								}
								flag = 1;
							}
							else if(key == FL_Right)
							{
								if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
								{
									GrowRight();
								}
								else
								{
									ZipRight();
								}
								flag = 1;
							}
							else if(key == FL_Up)
							{
								if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
								{
									GrowUp();
								}
								else
								{
									ZipUp();
								}
								flag = 1;
							}
							else if(key == FL_Down)
							{
								if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
								{
									GrowDown();
								}
								else
								{
									ZipDown();
								}
								flag = 1;
							}
						}
						break;
						case(FL_MOUSEWHEEL):
						{
							if(mw_mode != MW_MODE_NONE)
							{
								int nn = Fl::event_dy();
								if(nn > 0)
								{
									if(mw_mode == MW_MODE_ROTATION)
									{
										angle += 1.0;
										if(angle >= 360.0)
										{
											angle = 0.0;
										}
									}
									else if(mw_mode == MW_MODE_TRANSPARENCY)
									{
										if(overall_alpha < 1.0)
										{
											overall_alpha += 0.01;
										}
									}
									else if(mw_mode == MW_MODE_STACKING_ORDER)
									{
										if(index < 127)
										{
											Camera *dest = my_window->DisplayedCamera();
											if(dest != NULL)
											{
												dest->CompressImageWindowList();
												ImageWindow *tmp = dest->image_window[index + 1];
												if(tmp != NULL)
												{
													dest->image_window[index + 1] = this;
													dest->image_window[index] = tmp;
													tmp->index--;
													index++;
												}
											}
										}
									}
								}
								else
								{
									if(mw_mode == MW_MODE_ROTATION)
									{
										angle -= 1.0;
										if(angle < 0.0)
										{
											angle = 359.0;
										}
									}
									else if(mw_mode == MW_MODE_TRANSPARENCY)
									{
										if(overall_alpha > 0.0)
										{
											overall_alpha -= 0.01;
										}
									}
									else if(mw_mode == MW_MODE_STACKING_ORDER)
									{
										if(index > 0)
										{
											Camera *dest = my_window->DisplayedCamera();
											if(dest != NULL)
											{
												dest->CompressImageWindowList();
												ImageWindow *tmp = dest->image_window[index - 1];
												if(tmp != NULL)
												{
													dest->image_window[index - 1] = this;
													dest->image_window[index] = tmp;
													tmp->index++;
													index--;
												}
											}
										}
									}
								}
								flag = 1;
							}
						}
						break;
					}
				}
			}
		}
	}
	if(flag == 0)
	{
		flag = MyGroup::handle(event);
	}
	return(flag);
}

void	ImageWindow::Rescale(Camera *cam, int xx, int yy, int proportional)
{
	int do_it = 0;
	int ddx = xx - start_drag_x;
	int ddy = yy - start_drag_y;
	double factor = 1.0;
	if((xx > (x() + w() - 50))
	&& (yy < (y() + h() - 50)))
	{
		fl_cursor(FL_CURSOR_WE);
		factor = (double)(width + ddx) / (double)width;
		do_it = 1;
	}
	else if((xx < (x() + w() - 50))
	&& (yy > (y() + h() - 50)))
	{
		fl_cursor(FL_CURSOR_NS);
		factor = (double)(height + ddy) / (double)height;
		do_it = 2;
	}
	else
	{
		factor = (double)(width + ddx) / (double)width;
		fl_cursor(FL_CURSOR_MOVE);
		do_it = 1;
	}
	if(do_it != 0)
	{
		if(proportional == 1)
		{
			double use_x = (double)width * factor;
			double use_y = (double)height * factor;
			if((use_x > 50) && (use_y > 50))
			{
				if((x() + use_x < cam->image_sx + cam->width)
				&& (y() + use_y < cam->image_sy + cam->height))
				{
					resize(x(), y(), use_x, use_y);
					width = use_x;
					height = use_y;
				}
			}
			start_drag_x = xx;
			start_drag_y = yy;
			transform = MODE_RESIZING;
		}
		else
		{
			if(do_it == 1)
			{
				double use_x = (double)width * factor;
				if(use_x > 50)
				{
					if(x() + use_x < cam->image_sx + cam->width)
					{
						resize(x(), y(), use_x, h());
						width = use_x;
					}
				}
				start_drag_x = xx;
			}
			else if(do_it == 2)
			{
				double use_y = (double)height * factor;
				if(use_y > 50)
				{
					if(y() + use_y < cam->image_sy + cam->height)
					{
						resize(x(), y(), w(), use_y);
						height = use_y;
					}
				}
				start_drag_y = yy;
			}
		}
	}
}

// SECTION **************************************************** FLTK PLUGIN *******************************************************

void	fltk_plugin_accept_cb(Fl_Widget *w, void *v)
{
int	loop;

	FltkPluginWindow *fpw = (FltkPluginWindow *)v;
	fpw->hide();
	for(loop = 0;loop < global_potential_fltk_cnt;loop++)
	{
		if(fpw->plug_in[loop] != NULL)
		{
			int val = fpw->plug_in[loop]->value();
			if(val)
			{
				char *str = global_potential_fltk[loop];
				void *handle = global_potential_fltk_handle[loop];
				void *void_ptr = (void *)dlsym(handle, str);
				if(void_ptr != NULL)
				{
					void (*fltk)(Fl_Window *);
					fltk = (void (*)(Fl_Window *))void_ptr;
					fltk(fpw->my_window);
				}
			}
		}
	}
}

FltkPluginWindow::FltkPluginWindow(MyWin *in_win) : Dialog(260, 300, 200, 600, "FLTK Plugins")
{
	my_window = in_win;
	last_x = 0;
	last_y = 0;
	int new_yp = 20;
	vertical_offset = new_yp;
	Populate();
	end();
}

FltkPluginWindow::~FltkPluginWindow()
{
}

int		FltkPluginWindow::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Dialog::handle(event);
	}
	return(flag);
}

void	FltkPluginWindow::Populate()
{
int	loop;

	int y_pos = vertical_offset + 5;
	for(loop = 0;loop < 128;loop++)
	{
		plug_in[loop] = NULL;
	}
	for(loop = 0;loop < global_potential_fltk_cnt;loop++)
	{
		char *cp = global_potential_fltk[loop] + strlen("fltk_");
		plug_in[loop] = new MyLightButton(10, y_pos, 180, 20, cp);
		plug_in[loop]->box(FL_FLAT_BOX);
		plug_in[loop]->color(BLACK);
		plug_in[loop]->labelcolor(YELLOW);
		plug_in[loop]->labelsize(11);
		plug_in[loop]->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
		plug_in[loop]->copy_tooltip("A FLTK function in the plug_in.so file. This plug-in will be passed the primary class for the program. From this class it gains access to nearly every class in the program.");
		plug_in[loop]->visible_focus(0);
		y_pos += 20;
	}
	y_pos += 10;
	accept = new MyButton(10, y_pos, 80, 20, "Accept");
	accept->box(FL_NO_BOX);
	accept->color(WHITE);
	accept->labelcolor(YELLOW);
	accept->labelsize(12);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->copy_tooltip("Accept the list of activated plug-ins. Selected plug-ins begin execution.");
	accept->callback(fltk_plugin_accept_cb, this);

	cancel = new MyButton(110, y_pos, 80, 20, "Cancel");
	cancel->box(FL_NO_BOX);
	cancel->color(WHITE);
	cancel->labelcolor(YELLOW);
	cancel->labelsize(12);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->copy_tooltip("Close the dialog.");
	cancel->callback(hide_window_cb, this);

	y_pos += 30;
	resize(x(), y(), w(), y_pos);
}

void	FltkPluginWindow::Reset()
{
int	loop;

	for(loop = 0;loop < global_potential_fltk_cnt;loop++)
	{
		if(plug_in[loop] != NULL)
		{
			plug_in[loop]->value(0);
		}
	}
}

// SECTION **************************************************** CURRENT FPS *******************************************************

CurrentFPSWindow::CurrentFPSWindow(MyWin *in_win, int xx, int yy, int ww, int hh) : DragGroup(xx, yy, ww, hh)
{
	my_window = in_win;
	box(FL_FLAT_BOX);
	color(BLACK);
	starting_time = 0;
	running_time = 0;
	showing = 0;
}

CurrentFPSWindow::~CurrentFPSWindow()
{
}

void	CurrentFPSWindow::draw()
{
int		loop;
char	buf[32768];
double	calc_fps = 0.0;
static long int last_time_here = 0;

	if((my_window->split == 0) && (showing == 1))
	{
		Camera *cam = my_window->DisplayedCamera();
		if(cam != NULL)
		{
			if(my_window->single_stream == 1)
			{
				Camera *test_cam = my_window->RecordingCamera();
				if(test_cam != NULL)
				{
					cam = test_cam;
				}
			}
			time_t now = precise_time();
			double frac = (double)(now - cam->last_time) / 1000000.0;
			calc_fps = 0.0;
			if(frac > 0.0)
			{
				calc_fps = 1.0 / frac;
			}
			cam->last_time = precise_time();
			cam->elapsed = time(0) - cam->since_time;
			cam->since_frames++;
			if(cam->elapsed != cam->old_elapsed)
			{
				cam->current_fps = (double)cam->since_frames;
				cam->old_elapsed = cam->elapsed;
				cam->since_frames = 0;
			}
			my_window->all_frames = 0;
			int minutes = 0;
			int seconds = 0;
			long int now_here = local_timestamp();
			long int use_here = now_here - last_time_here;
			last_time_here = now_here;
			if(cam->record == 1)
			{
				if(my_window->single_stream == 0)
				{
					if(cam->record == 1)
					{
						if(cam->starting_time == 0)
						{
							cam->starting_time = local_timestamp();
						}
						else
						{
							cam->running_time += (local_timestamp() - cam->starting_time);
							cam->starting_time = local_timestamp();
						}
					}
				}
				else
				{
					if(starting_time == 0)
					{
						starting_time = local_timestamp();
					}
					else
					{
						running_time += (local_timestamp() - starting_time);
						starting_time = local_timestamp();
					}
				}
			}
			else
			{
				if(my_window->single_stream == 0)
				{
					cam->starting_time = 0;
				}
			}
			if(cam->current_fps > 0)
			{
				int use_fps = cam->current_fps;
				if(my_window->muxing == 1)
				{
					if(use_fps < 24) use_fps = 24;
					if(use_fps > 30) use_fps = 30;
				}
				else
				{
					if(use_fps < 1) use_fps = 1;
				}
				int total_seconds = cam->running_time / 1000;
				if(my_window->single_stream == 1)
				{
					total_seconds = running_time / 1000;
				}
				minutes = total_seconds / 60;
				seconds = total_seconds % 60;
			}
			if(my_window->hide_status == 0)
			{
				int status_r = my_window->status_color_r;
				int status_g = my_window->status_color_g;
				int status_b = my_window->status_color_b;
				int xx = x();
				int yy = y();
				fl_color(WHITE);
				fl_rect(xx + 1, yy + 1, 22, 22);
				if(my_window->recording == 1)
				{
					fl_color(RED);
					fl_rectf(xx + 3, yy + 3, 18, 18);
				}
				sprintf(buf, "%06d %03d:%02d [%06.02f : %06.02f] %6.2f %03d (%d x %d) [%03ld]", my_window->recorded_frames, minutes, seconds, cam->current_fps, calc_fps, cam->fps, cam->hot_fps, cam->width, cam->height, use_here);
				if(cam->hot_fps < my_window->minimum_fps)
				{
					fl_color(fl_lighter(RED));
				}
				else
				{
					fl_color(fl_rgb_color(status_r, status_g, status_b));
				}
				fl_font(FL_HELVETICA, 14);
				fl_draw(buf, xx + 30, yy + 2, w(), h(), FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
				if((strlen(my_window->video_codec_name) > 0)
				&& (strlen(my_window->audio_codec_name) > 0)
				&& (strlen(my_window->use_container) > 0))
				{
					char use_filename[4096];
					strcpy(use_filename, "");
					if(my_window->last_muxed_list[0] != NULL)
					{
						strcpy(use_filename, my_window->last_muxed_list[0]);
					}
					fl_font(FL_HELVETICA, 10);
					sprintf(buf, "%s (%s, %s) %s", my_window->use_container, my_window->video_codec_name, my_window->audio_codec_name, use_filename);
					fl_draw(buf, xx + 30, yy + 18, w(), h(), FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					int x_pos = xx + 30;
					if((cam->record_trigger & ON_SCHEDULE) == ON_SCHEDULE)
					{
						char day_buf[10];
						char *day_label[7] = { "Su", "M", "T", "W", "Th", "F", "S" }; 
						int day = cam->schedule_day;
						strcpy(day_buf, "");
						for(int day_bit = 0;day_bit < 7;day_bit++)
						{
							int dd = (1 << day_bit);
							if((day & dd) == dd)
							{
								if(strlen(day_buf) > 0)
								{
									strcat(day_buf, "|");
								}
								strcat(day_buf, day_label[day_bit]);
							}
						}
						int start = cam->schedule_start;
						int stop = cam->schedule_stop;
						int hour_start = start / 60;
						int minute_start = start - (hour_start * 60);
						int hour_stop = stop / 60;
						int minute_stop = stop - (hour_stop * 60);
						sprintf(buf, "Schedule: [%s] %02d:%02d - %02d:%02d | %02d:%02d\n", day_buf, hour_start, minute_start, hour_stop, minute_stop, my_window->hour, my_window->minute);
						if((cam->result_trigger & ON_SCHEDULE) == ON_SCHEDULE)
						{
							fl_color(fl_rgb_color(status_r, status_g, status_b));
						}
						else
						{
							fl_color(CYAN);
						}
						fl_draw(buf, x_pos, yy + 32, w(), h(), FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
						x_pos += 170;
					}
					if((cam->record_trigger & ON_DETECT_LIGHT) == ON_DETECT_LIGHT)
					{
						sprintf(buf, "Light: %0.4f > %0.4f\n", cam->darkness_score, cam->darkness_trigger);
						if((cam->result_trigger & ON_DETECT_LIGHT) == ON_DETECT_LIGHT)
						{
							fl_color(fl_rgb_color(status_r, status_g, status_b));
						}
						else
						{
							fl_color(CYAN);
						}
						fl_draw(buf, x_pos, yy + 32, w(), h(), FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
						x_pos += 120;
					}
					else if((cam->record_trigger & ON_DETECT_DARK) == ON_DETECT_DARK)
					{
						sprintf(buf, "Dark: %0.4f < %0.4f\n", cam->darkness_score, cam->darkness_trigger);
						if((cam->result_trigger & ON_DETECT_DARK) == ON_DETECT_DARK)
						{
							fl_color(fl_rgb_color(status_r, status_g, status_b));
						}
						else
						{
							fl_color(CYAN);
						}
						fl_draw(buf, x_pos, yy + 32, w(), h(), FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
						x_pos += 120;
					}
					if((cam->record_trigger & ON_DETECT_MOTION) == ON_DETECT_MOTION)
					{
						sprintf(buf, "Motion: %04d > %04d\n", cam->motion_score, cam->motion_threshold);
						if((cam->result_trigger & ON_DETECT_MOTION) == ON_DETECT_MOTION)
						{
							fl_color(fl_rgb_color(status_r, status_g, status_b));
						}
						else
						{
							fl_color(CYAN);
						}
						fl_draw(buf, x_pos, yy + 32, w(), h(), FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
						x_pos += 120;
					}
					if((cam->record_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
					{
						sprintf(buf, "Object: %04d\n", cam->detected_object_cnt);
						if((cam->result_trigger & ON_DETECT_OBJECT) == ON_DETECT_OBJECT)
						{
							fl_color(fl_rgb_color(status_r, status_g, status_b));
						}
						else
						{
							fl_color(CYAN);
						}
						fl_draw(buf, x_pos, yy + 32, w(), h(), FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
						x_pos += 120;
					}
				}
			}
		}
	}
}

// SECTION **************************************** AUDIO LIBRARY WINDOW *******************************************************

void	save_audio_library_cb(Fl_Widget *w, void *v)
{
	AudioLibrary *al = (AudioLibrary *)v;
	al->Save("audio_library.json");
	al->hide();
}

void	audio_library_name_change_cb(Fl_Widget *w, void *v)
{
int	loop;

	Fl_Input *in = (Fl_Input *)w;
	AudioLibrary *al = (AudioLibrary *)v;
	int nn = al->number_of_entries;
	char *str = (char *)in->value();
	for(loop = 0;loop < nn;loop++)
	{
		if(al->name_input[loop] == in)
		{
			if(al->name[loop] != NULL)
			{
				free(al->name[loop]);
			}
			al->name[loop] = strdup(str);
		}
	}
}

void	audio_library_filename_change_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyButton *b = (MyButton *)w;
	AudioLibrary *al = (AudioLibrary *)v;
	int nn = al->number_of_entries;
	for(loop = 0;loop < nn;loop++)
	{
		if(al->path_button[loop] == b)
		{
			char filename[4096];
			strcpy(filename, "");
			int nn = my_file_chooser("Select an audio file", "*.{wav,mp3,flac}", "./AudioLibrary", filename);
			if(nn > 0)
			{
				if(al->filename[loop] != NULL)
				{
					free(al->filename[loop]);
					al->filename[loop] = NULL;
				}
				al->filename[loop] = strdup(filename);
				b->copy_label(al->filename[loop]);
				b->redraw();
				if(al->play_button[loop] != NULL)
				{
					al->play_button[loop]->show();
				}
			}
		}
	}
	al->scroll->redraw();
	al->redraw();
}

void	audio_library_play_cb(Fl_Widget *w, void *v)
{
int		loop;

	MyButton *b = (MyButton *)w;
	AudioLibrary *al = (AudioLibrary *)v;
	int nn = al->number_of_entries;
	for(loop = 0;loop < nn;loop++)
	{
		if(al->play_button[loop] == b)
		{
			char *path = al->filename[loop];
			if(access(path, 0) == 0)
			{
				play_audio_file(al->my_window, path);
			}
		}
	}
	al->scroll->redraw();
	al->redraw();
}

void	audio_library_add_cb(Fl_Widget *w, void *v)
{
	AudioLibrary *al = (AudioLibrary *)v;
	al->Add("Name", "Path");
}

void	audio_library_list_play_cb(Fl_Widget *w, void *v)
{
	PlayAudioButton *b = (PlayAudioButton *)w;
	b->Play();
}

PlayAudioButton::PlayAudioButton(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : MyButton(xx, yy, ww, hh, lbl)
{
	my_window = in_win;
	path = NULL;
}

PlayAudioButton::~PlayAudioButton()
{
}

void	PlayAudioButton::Play()
{
	if(path != NULL)
	{
		if(access(path, 0) == 0)
		{
			play_audio_file(my_window, path);
		}
	}
}

AudioLibraryList::AudioLibraryList(MyWin *in_win) : Dialog(120, 500, "Audio Library List")
{
	my_window = in_win;
	int new_yp = 20;
	vertical_offset = new_yp;
	box(FL_FLAT_BOX);

	scroll = new Fl_Scroll(5, new_yp, w() - 10, h() - 40);
	scroll->box(FL_FLAT_BOX);
	scroll->color(BLACK);
	scroll->type(Fl_Scroll::VERTICAL);
	scroll->end();

	close_button = new MyButton(0, h() - 20, w(), 20, "Close");
	close_button->box(FL_FLAT_BOX);
	close_button->color(BLACK);
	close_button->labelcolor(YELLOW);
	close_button->labelsize(9);
	close_button->copy_tooltip("Close the dialog.");
	close_button->callback(hide_window_cb, this);

	end();
}

AudioLibraryList::~AudioLibraryList()
{
}

void	AudioLibraryList::show()
{
int	loop;

	set_non_modal();
	scroll->clear();
	if(my_window->audio_library_window != NULL)
	{
		my_window->audio_library_window->Load("audio_library.json");
		int yp = 0;
		int nn = my_window->audio_library_window->number_of_entries;
		for(loop = 0;loop < nn;loop++)
		{
			char *str = (char *)my_window->audio_library_window->name[loop];
			if(str != NULL)
			{
				if(strlen(str) > 0)
				{
					PlayAudioButton *b = new PlayAudioButton(my_window, scroll->x(), yp + 20, scroll->w(), 20, str);
					b->box(FL_FLAT_BOX);
					b->color(BLACK);
					b->labelcolor(YELLOW);
					b->labelsize(9);
					b->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
					b->copy_tooltip("Play this audio file from the library.");
					b->path = my_window->audio_library_window->filename[loop];
					b->callback(audio_library_list_play_cb, this);
					scroll->add(b);
					yp += 20;
				}
			}
		}
	}
	Dialog::show();
}

AudioLibrary::AudioLibrary(MyWin *in_win) : Dialog(560, 500, "Audio Library")
{
int	loop;

	my_window = in_win;
	int new_yp = 20;
	number_of_entries = 0;
	for(loop = 0;loop < 1024;loop++)
	{
		name[loop] = NULL;
		filename[loop] = NULL;
		name_input[loop] = NULL;
		path_button[loop] = NULL;
	}
	scroll = new Fl_Scroll(10, 10 + new_yp, w() - 20, 450);
	scroll->box(FL_FRAME_BOX);
	scroll->color(DARK_GRAY);
	scroll->type(Fl_Scroll::VERTICAL);
	scroll->end();

	add_button = new MyButton(10, 470 + new_yp, 70, 20, "Add");
	add_button->box(FL_FLAT_BOX);
	add_button->color(BLACK);
	add_button->labelcolor(YELLOW);
	add_button->labelsize(9);
	add_button->copy_tooltip("Add a new blank entry to the library.");
	add_button->callback(audio_library_add_cb, this);

	save_button = new MyButton((w() / 2) - 35, 470 + new_yp, 70, 20, "Save");
	save_button->box(FL_FLAT_BOX);
	save_button->color(BLACK);
	save_button->labelcolor(YELLOW);
	save_button->labelsize(9);
	save_button->copy_tooltip("Save library and close the dialog. Entries with a blank name will not be saved.");
	save_button->callback(save_audio_library_cb, this);

	cancel_button = new MyButton(w() - 80, 470 + new_yp, 70, 20, "Cancel");
	cancel_button->box(FL_FLAT_BOX);
	cancel_button->color(BLACK);
	cancel_button->labelcolor(YELLOW);
	cancel_button->labelsize(9);
	cancel_button->copy_tooltip("Close the dialog without saving.");
	cancel_button->callback(hide_window_cb, this);

	end();
}

AudioLibrary::~AudioLibrary()
{
int	loop;

	for(loop = 0;loop < number_of_entries;loop++)
	{
		if(name[loop] != NULL)
		{
			free(name[loop]);
			name[loop] = NULL;
		}
		if(filename[loop] != NULL)
		{
			free(filename[loop]);
			filename[loop] = NULL;
		}
	}
}

void	AudioLibrary::show()
{
	set_non_modal();
	Load("audio_library.json");
	Dialog::show();
}

void	AudioLibrary::Add(char *in_name, char *in_path)
{
	int nn = number_of_entries;
	int xx = scroll->x() + 4;
	int yy = scroll->y() + (nn * 20);

	if((in_name != NULL) && (in_path != NULL))
	{
		MyButton *local_play_button = new MyButton(xx + 2, yy + 2, 18, 18, "@>");
		local_play_button->box(FL_FLAT_BOX);
		local_play_button->color(BLACK);
		local_play_button->labelcolor(YELLOW);
		local_play_button->labelsize(8);
		local_play_button->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
		local_play_button->callback(audio_library_play_cb, this);
		local_play_button->copy_tooltip("Play the audio file.");
		scroll->add(local_play_button);
		play_button[number_of_entries] = local_play_button;
		local_play_button->hide();
		if(access(in_path, 0) == 0)
		{
			local_play_button->show();
		}
		Fl_Input *name_in = new Fl_Input(xx + 21, yy, 120, 20);
		name_in->box(FL_FLAT_BOX);
		name_in->color(BLACK);
		name_in->textcolor(WHITE);
		name_in->textsize(9);
		name_in->value(in_name);
		name_in->cursor_color(WHITE);
		name_in->when(FL_WHEN_CHANGED);
		name_in->copy_tooltip("Edit the name of this audio library entry. Entries will blank names will not be saved.");
		name_in->callback(audio_library_name_change_cb, this);
		scroll->add(name_in);
		name_input[number_of_entries] = name_in;

		MyButton *local_path_button = new MyButton(xx + 140, yy, 420, 20, in_path);
		local_path_button->box(FL_FLAT_BOX);
		local_path_button->color(BLACK);
		local_path_button->labelcolor(YELLOW);
		local_path_button->labelsize(9);
		local_path_button->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		local_path_button->copy_tooltip("Edit the path to the audio file. Currently .wav files are supported.");
		local_path_button->callback(audio_library_filename_change_cb, this);
		scroll->add(local_path_button);
		path_button[number_of_entries] = local_path_button;
		number_of_entries++;
	}
	scroll->redraw();
	redraw();
}

void	AudioLibrary::Load(char *path)
{
struct	stat sz;
int		loop;
char	local_name[128];
char	local_path[4096];

	scroll->clear();
	int cnt = 0;
	for(loop = 0;loop < number_of_entries;loop++)
	{
		if(name[loop] != NULL)
		{
			free(name[loop]);
			name[loop] = NULL;
		}
		if(filename[loop] != NULL)
		{
			free(filename[loop]);
			filename[loop] = NULL;
		}
		name_input[loop] = NULL;
		path_button[loop] = NULL;
		play_button[loop] = NULL;
	}
	number_of_entries = 0;
	char *buf = ReadWholeFile(path);
	if(buf != NULL)
	{
		cJSON *json = cJSON_Parse(buf);
		if(json == NULL)
		{
			const char *error_ptr = cJSON_GetErrorPtr();
			if(error_ptr != NULL)
			{
				fprintf(stderr, "Error: JSON Error before: %s\n", error_ptr);
			}
		}
		else
		{
			cJSON *item = NULL;
			cJSON *items = json_parse_array(json, "Audio Library");
			if(items != NULL)
			{
				int cnt = 0;
				int a_cnt = 0;
				cJSON_ArrayForEach(item, items)
				{
					if(item->valuestring != NULL)
					{
						if((cnt % 2) == 0)
						{
							name[a_cnt] = strdup(item->valuestring);
						}
						else
						{
							filename[a_cnt] = strdup(item->valuestring);
							Add(name[a_cnt], filename[a_cnt]);
							a_cnt++;
						}
						cnt++;
					}
				}
			}
			cJSON_Delete(json);
		}
		free(buf);
	}
}

void	AudioLibrary::Save(char *path)
{
int	loop;

	FILE *fp = fopen(path, "w");
	if(fp != NULL)
	{
		fprintf(fp, "{\n");
		fprintf(fp, "\t\"Audio Library\": [");
		int nn = number_of_entries - 1;
		for(loop = 0;loop < number_of_entries;loop++)
		{
			if((name[loop] != NULL) && (filename[loop] != NULL))
			{
				if((strlen(name[loop]) > 0) && (strlen(filename[loop]) > 0))
				{
					fprintf(fp, "\"%s\",", name[loop]);
					fprintf(fp, "\"%s\"", filename[loop]);
					if(loop != nn)
					{
						fprintf(fp, ",\n");
					}
					else
					{
						fprintf(fp, "]\n");
					}
				}
			}
		}
		fprintf(fp, "}\n");
		fclose(fp);
	}
}

// SECTION **************************************************** START UP *******************************************************

int	list_shared_exports(char *dir_name)
{
dirent	**list;
char	buf[4096];

	int numOfFiles = fl_filename_list(dir_name, &list);
	for(int i = 0; i < numOfFiles; i++)
	{
		char *library_filename = list[i]->d_name;
		char *ext = (char *)fl_filename_ext(library_filename);
		if(strcmp(ext, ".so") == 0)
		{
			sprintf(buf, "%s/%s", dir_name, library_filename);
			void *library = dlopen(buf, RTLD_LAZY);
			if(library != NULL)
			{
				int found = 0;
				struct link_map *map = nullptr;
				dlinfo(library, RTLD_DI_LINKMAP, &map);
				if(map != NULL)
				{
					Elf64_Sym *symtab = nullptr;
					char *strtab = nullptr;
					int symentries = 0;
					for(auto section = map->l_ld; section->d_tag != DT_NULL; ++section)
					{
						if(section->d_tag == DT_SYMTAB)
						{
							symtab = (Elf64_Sym *)section->d_un.d_ptr;
						}
						if(section->d_tag == DT_STRTAB)
						{
							strtab = (char*)section->d_un.d_ptr;
						}
						if(section->d_tag == DT_SYMENT)
						{
							symentries = section->d_un.d_val;
						}
					}
					int size = strtab - (char *)symtab;
					for(int k = 0; k < size / symentries; ++k)
					{
						auto sym = &symtab[k];
						// if sym is function
						if(ELF64_ST_TYPE(symtab[k].st_info) == STT_FUNC)
						{
							// str is name of each symbol
							char *str = &strtab[sym->st_name];
							if(strncmp(str, "filter_", strlen("filter_")) == 0)
							{
								if(global_potential_filter_cnt < 1024)
								{
									printf("FILTER: %s\n", str);
									global_potential_filter[global_potential_filter_cnt] = strdup(str);
									global_potential_filter_handle[global_potential_filter_cnt] = library;
									global_potential_filter_cnt++;
								}
								found = 1;
							}
							if(strncmp(str, "audio_filter_", strlen("audio_filter_")) == 0)
							{
								if(global_potential_audio_filter_cnt < 1024)
								{
									printf("AUDIO FILTER: %s\n", str);
									global_potential_audio_filter[global_potential_audio_filter_cnt] = strdup(str);
									global_potential_audio_filter_handle[global_potential_audio_filter_cnt] = library;
									global_potential_audio_filter_cnt++;
								}
								found = 1;
							}
							if(strncmp(str, "camera_", strlen("camera_")) == 0)
							{
								if(global_potential_camera_cnt < 1024)
								{
									printf("CAMERA: %s %p\n", str, library);
									global_potential_camera[global_potential_camera_cnt] = strdup(str);
									global_potential_camera_handle[global_potential_camera_cnt] = library;
									global_potential_camera_cnt++;
								}
								found = 1;
							}
							if(strncmp(str, "transition_", strlen("transition_")) == 0)
							{
								if(global_potential_transition_cnt < 1024)
								{
									printf("TRANSITION: %s %p\n", str, library);
									global_potential_transition[global_potential_transition_cnt] = strdup(str);
									global_potential_transition_handle[global_potential_transition_cnt] = library;
									global_potential_transition_cnt++;
								}
								found = 1;
							}
							if(strncmp(str, "fltk_", strlen("fltk_")) == 0)
							{
								if(global_potential_fltk_cnt < 1024)
								{
									printf("FLTK: %s %p\n", str, library);
									global_potential_fltk[global_potential_fltk_cnt] = strdup(str);
									global_potential_fltk_handle[global_potential_fltk_cnt] = library;
									global_potential_fltk_cnt++;
								}
								found = 1;
							}
						}
					}
				}
				if(found == 0)
				{
					dlclose(library);
				}
			}
		}
	}
	return(0);
}

void handler(int signal_number, siginfo_t *aa, void *bb)
{
	exit(0);
}

void	show_help()
{
	printf("cowcam [--source=[N|URL[::BACKEND[:FOURCC]]][--width=n][--height=n][--help]\n");
	printf("examples:\n\n");
	printf("# Use the default USB cowcam\n");
	printf("cowcam\n\n");
	printf("# Specify a device\n");
	printf("cowcam --source=/dev/video0\n\n");
	printf("# Specify a device and a backend\n");
	printf("cowcam --source=/dev/video0::V4L\n\n");
	printf("# Specify a device and an alias\n");
	printf("cowcam --source=/dev/video0[alias=Sony]\n\n");
	printf("# Specify a device and a backend with fourcc code (must be 4 characters long)\n");
	printf("cowcam --source=/dev/video0::V4L:MJPG\n\n");
	printf("# Specify an audio input device\n");
	printf("cowcam --audio_source=alsa_input.usb-audio-technica____AT2020_USB-00.analog-stereo\n\n");
	printf("# Use an IP camera at a RTSP URL with login and password\n");
	printf("cowcam --source=rtsp://your_login:your_password@url_for_your_webcam.org/live\n\n");
	printf("# Use USB camera number 4\n");
	printf("cowcam --source=4\n\n");
	printf("# Load a setup file at startup.\n");
	printf("cowcam --load_setup=Setups/sample.json\n\n");
	printf("# Set main window width to 1920, Defaults to fullscreen.\n");
	printf("cowcam --main_width=1920\n\n");
	printf("# Set main window height to 1080, Defaults to fullscreen.\n");
	printf("cowcam --main_width=1080\n\n");
	printf("# Set preferred video width to 640\n");
	printf("cowcam --width=640\n\n");
	printf("# Set preferred video height to 480\n");
	printf("cowcam --height=480\n\n");
	printf("# Scale the interface to system wide screen scaling.\n");
	printf("cowcam --auto_scale\n\n");
	printf("# Force a scaling factor to the interface.\n");
	printf("cowcam --forced_scale=2.0\n\n");
	printf("# Set preferred output video width to 1280. Output defaults to input.\n");
	printf("cowcam --output_width=1280\n\n");
	printf("# Set preferred output video height to 720. Output defaults to input.\n");
	printf("cowcam --output_height=720\n\n");
	printf("# Set preferred display video width to 1280. Display defaults to input.\n");
	printf("cowcam --display_width=1280\n\n");
	printf("# Set preferred display video height to 720. Display defaults to input.\n");
	printf("cowcam --display_height=720\n\n");
	printf("# Set the FPS to a specific value, avoiding testing\n");
	printf("cowcam --fps=18\n\n");
	printf("# Sets the interval between frames to a rigid length. Specified in seconds.\n");
	printf("cowcam --interval=0.01\n\n");
	printf("# Split the main screen between all the video sources\n");
	printf("cowcam --split\n\n");
	printf("# Record audio and video to raw files (unmuxed) and mux as a separate step.\n");
	printf("cowcam --buffered\n\n");
	printf("# Flip horizontally or vertically or both\n");
	printf("cowcam --flip=horizontal --flip=vertical\n\n");
	printf("# Do not record audio.\n");
	printf("cowcam --no_audio\n\n");
	printf("# Reopen old .bin (temporary files) to encode. Record is turned off.\n");
	printf("cowcam --old\n\n");
	printf("# Do not scan for USB cameras.\n");
	printf("cowcam --no_scan\n\n");
	printf("# Do not scan for input audio devices.\n");
	printf("cowcam --no_audio_scan\n\n");
	printf("# Scan for PTZ serial ports.\n");
	printf("cowcam --scan_for_ptz\n\n");
	printf("# Record entire main window, encoding on exit. Usually used to make tutorial videos for the program itself.\n");
	printf("cowcam --record_main_window\n\n");
	printf("# Record the desktop as another camera.\n");
	printf("cowcam --record_desktop\n\n");
	printf("# Record the desktop as another camera, specifying area to record as x,y,w,h.\n");
	printf("cowcam --record_desktop=20,40,640,360\n\n");
	printf("# Record each recording camera to its own file.\n");
	printf("cowcam --multi_stream\n\n");
	printf("# Display the camera that is currently recording.\n");
	printf("cowcam --display_recording_camera\n\n");
	printf("# Recording follows the displayed camera.\n");
	printf("cowcam --recording_follows_display\n\n");
	printf("# Blend automatically between cuts when editing with the previewer.\n");
	printf("# Also fades in and out from black at the beginning and end.\n");
	printf("cowcam --transition=blend\n\n");
	printf("# Allows for PTZ camera control using VISCA over the specified serial port. A colon following the path\n");
	printf("# followed by a 1, indicates that this interface does not reply.\n");
	printf("cowcam --ptz=/dev/ttyUSB0:1\n\n");
	printf("# Reset PTZ cameras to home position on launch.\n");
	printf("cowcam --ptz_home.\n\n");
	printf("# Initialize object detection. Without this object detection is not offered.\n");
	printf("cowcam --object_detect\n\n");
	printf("# Use alternate DNN/YOLO files for recognition. If anyone one of these is provided,\n");
	printf("# the other two must also be present. The default values are:\n");
	printf("# \t\"yolov3-openimages.cfg\"\n");
	printf("# \t\"yolov3-openimages.weights\"\n");
	printf("# \t\"openimages.names\"\n");
	printf("# Or, depending on the value of --yolo_model=\n");
	printf("# \t\"yolov3.cfg\"\n");
	printf("# \t\"yolov3.weights\"\n");
	printf("# \t\"coco.names\"\n");
	printf("cowcam --yolo_cfg=cfg_filename --yolo_weights=weights_filename --yolo_names=names_filename\n\n");
	printf("# Use the default YOLO filenames for COCO or OpenImages. This defaults to OpenImages.\n");
	printf("cowcam --yolo_model=coco\n\n");
	printf("# If JPEG streaming is turned on, stream the current camera's image to\n");
	printf("# a custom server running at www.example.com on port 20000. Port 20001\n");
	printf("# will be used as the PTZ control port. If port 10000 was selected\n");
	printf("# port 10001 would be the control port.\n");
	printf("cowcam --jpeg_streaming=www.example.com:20000\n\n");
	printf("# Stream to a streaming server like Twitch or YouTube Live.\n");
	printf("# The entire URL must be specifed, including the protocol specifier\n");
	printf("# i.e.: smpt:// or rtmp://, etc. and any other URL embedded arguments\n");
	printf("# like your key\n");
	printf("cowcam --streaming=rtmp://www.streaming_server.com/your_key\n\n");
	printf("# Stream to the server specified in --streaming= or save to a muxed file if no server is specified.\n");
	printf("cowcam --streaming_only\n\n");
	printf("# Streaming audio quality expressed as a factor. The default is best. Base value is 11025 hz, so.\n");
	printf("# cowcam --streaming_audio_quality=good would be 11025 hz.\n");
	printf("# cowcam --streaming_audio_quality=better would be 22050 hz.\n");
	printf("# cowcam --streaming_audio_quality=best would be 44100 hz.\n");
	printf("cowcam --streaming_audio_quality=good\n\n");
	printf("# Embed the picture in picture stream into the recorded output.\n");
	printf("cowcam --embed_pip\n\n");
	printf("# Set the position of the picture in picture.\n");
	printf("cowcam --pip_position=0.8,0.1\n\n");
	printf("# Set the rgb color of the border around the pip. Set it to -1,-1,-1 for no border.\n");
	printf("cowcam --pip_highlight=255,128,64\n\n");
	printf("# Set the size of pip as fraction of its real size. The default is 1/4th (ie: 0.25)\n");
	printf("cowcam --pip_size=0.35\n\n");
	printf("# Allows for more than one pip.\n");
	printf("cowcam --multipip=right\n\n");
	printf("# Set the grid size for placement of sources. Default is 1 for no grid.\n");
	printf("cowcam --grid_size=10\n\n");
	printf("# Set the desktop audio monitor device (a null sink in pulseaudio).\n");
	printf("cowcam --desktop_monitor=my_null_sink\n\n");
	printf("# Do not query the system for available codecs and offer a menu of options.\n");
	printf("cowcam --no_query_codecs\n\n");
	printf("# Test the codecs found at current settings to determing if they are usable,\n");
	printf("# eliminating those that are not from the offered options.\n");
	printf("cowcam --test_codecs\n\n");
	printf("# Timestamp video images.\n");
	printf("cowcam --timestamp\n\n");
	printf("# Disregard video setting when starting, using defaults and command line arguments instead.\n");
	printf("cowcam --disregard_settings\n\n");
	printf("# Cause the primary interface elements to have a transparent background.\n");
	printf("cowcam --transparent_interface\n\n");
	printf("# When scaling input images to output, keep aspect ratio and border excess.\n");
	printf("cowcam --no_frame_scaling\n\n");
	printf("# Crop image to display size rather than scaling it.\n");
	printf("cowcam --crop_display\n\n");
	printf("# Crop image to output size rather than scaling it.\n");
	printf("cowcam --crop_output\n\n");
	printf("# Add a plugin transition library file to be searched.\n");
	printf("cowcam --transition=filename.so\n\n");
	printf("# Add a plugin transition from the library specified in --transition_plugin_file=...\n");
	printf("cowcam --transition_plugin=transition_name\n\n");
	printf("# Add a plugin filter library file to be searched.\n");
	printf("cowcam --filter_plugin_file=filename.so\n\n");
	printf("# Add a plugin filter from the library specified in --filter_plugin_file=...\n");
	printf("cowcam --filter_plugin=filter_name\n\n");
	printf("# Add a screen capture plugin library file to be searched.\n");
	printf("cowcam --capture_plugin_file=filename.so\n\n");
	printf("# Force GUI elements to persist on the screen rather than appearing when the mouse approaches.\n");
	printf("cowcam --retain_commands\n");
	printf("cowcam --retain_cameras\n");
	printf("cowcam --retain_audio\n");
	printf("cowcam --retain_ptz\n\n");
	printf("# Force all GUI elements to persist on the screen rather than appearing when the mouse approaches.\n");
	printf("cowcam --lock_panels\n\n");
	printf("# Animate (slide) the GUI elements when the mouse approaches.\n");
	printf("cowcam --animate_panels\n\n");
	printf("# Do not allow the user to change directories in the file selection dialog.\n");
	printf("cowcam --exclude_directories\n\n");
	printf("# Hide the status message.\n");
	printf("cowcam --hide_status\n\n");
	printf("# Select a camera to be active.\n");
	printf("cowcam --select_camera=camera_name\n\n");
	printf("# Select an audio source to be active.\n");
	printf("cowcam --select_audio=audio_device_name\n\n");
}

int StartMain(int updates)
{
void	enumerate_codecs();
void	enumerate_test(void (*output_cb)(char *), int test_w, int test_h, int test_fps, int test_hz);
int	xx, yy;
int	loop;
int	inner;
int	outer;
char	*source[128];
char	*audio_source[128];
extern int	global_my_format_cnt;

	start_win->use_updates = updates;
	sleep(2);
	start_win->Update("Starting...");
	sleep(1);
	int argc = global_argc;
	int source_cnt = 0;
	int audio_source_cnt = 0;
	int new_width = 1920;
	int new_height = 1080;
	int new_output_width = -1;
	int new_output_height = -1;
	int new_display_width = -1;
	int new_display_height = -1;
	int new_fps = 30.0;
	double new_interval = 0.01;
	int new_split = 0;
	int new_main = 1;

	int new_muxing = 1;
	int use_audio = 1;

	int use_single_stream = 1;

	int new_flip = 0;
	int use_no_scan = 0;
	int use_no_audio_scan = 0;
	int use_old = 0;
	int use_record_all = 0;
	int use_record_desktop = 0;
	int use_desktop_x = -1;
	int use_desktop_y = -1;
	int use_desktop_w = -1;
	int use_desktop_h = -1;
	int	use_follow_mode = 0;
	int use_transition = 0;
	int use_ptz_home_on_launch = 0;
	char *use_yolo_cfg = NULL;
	char *use_yolo_weights = NULL;
	char *use_yolo_names = NULL;
	int use_yolo_model = USE_YOLO_MODEL_OPEN_IMAGES;
	char *use_ptz_device_path[NUMBER_OF_INTERFACES];
	char *use_ptz_lock_alias[NUMBER_OF_INTERFACES][NUMBER_OF_CAMERAS];
	char *use_ptz_alias[NUMBER_OF_INTERFACES];
	char *use_ptz_bind_alias[NUMBER_OF_INTERFACES];
	int	use_ptz_prefer_ndi[NUMBER_OF_INTERFACES];
	int	use_ptz_prefer_v4l[NUMBER_OF_INTERFACES];
	char *use_jpeg_streaming = NULL;
	int use_streaming = 0;
	char *use_stream_url = NULL;
	int use_stream_only = 0;
	int use_streaming_audio_quality = 44100;
	char *forced_setup = NULL;
	for(loop = 0;loop < NUMBER_OF_INTERFACES;loop++)
	{
		for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
		{
			use_ptz_lock_alias[loop][inner] = NULL;
		}
		use_ptz_device_path[loop] = NULL;
		use_ptz_alias[loop] = NULL;
		use_ptz_bind_alias[loop] = NULL;
		use_ptz_prefer_ndi[loop] = 0;
		use_ptz_prefer_v4l[loop] = 0;
	}
	int use_ptz_device_path_cnt = 0;
	char new_mux_format[256];
	strcpy(new_mux_format, "mov");
	int use_embed_pip = 0;
	double use_pip_x_position = 0.74;
	double use_pip_y_position = 0.73;
	int use_pip_red = 255;
	int use_pip_green = 255;
	int use_pip_blue = 255;
	double use_pip_size = 0.25;
	double use_grid_size = 0;
	int use_multipip = 0;
	int use_multipip_side = MULTIPIP_SIDE_RIGHT;
	char *use_desktop_monitor = NULL;
	int use_detect = 0;
	int test_codecs = 0;
	int query_codecs = 1;
	int timestamp = 0;
	int frame_scaling = 1;
	int crop_output = 0;
	int crop_display = 0;
	int auto_scale = 0;
	double screen_scaling = 1.0;
	int default_window_width = -1;
	int default_window_height = -1;
	int scan_for_ptz = 0;
	int use_retain_commands = 0;
	int use_retain_cameras = 0;
	int use_retain_audio = 0;
	int use_retain_ptz = 0;
	int use_hide_status = 0;
	int use_disregard_settings = 0;
	int use_transparent_interface = 0;
	char use_transition_plugin[256];
	strcpy(use_transition_plugin, "");
	char *use_select_audio[128];
	int select_audio_cnt = 0;
	int record_on_start = 0;
	char *record_on_start_alias = NULL;
	for(loop = 0;loop < 128;loop++)
	{
		use_select_audio[loop] = NULL;
	}
	char *use_select_camera = NULL;
	int use_animate_panels = 0;
	int use_exclude_directories = 0;
	if(argc > 1)
	{
		char *argv[1024];
		for(loop = 1;loop < argc;loop++)
		{
			argv[loop] = global_argv[loop];
			if(argv[loop] != NULL)
			{
				if(strncmp(argv[loop], "--source=", strlen("--source=")) == 0)
				{
					if(source_cnt < 128)
					{
						source[source_cnt] = strdup(argv[loop] + strlen("--source="));
						source_cnt++;
					}
				}
				else if(strncmp(argv[loop], "--audio_source=", strlen("--audio_source=")) == 0)
				{
					if(audio_source_cnt < 128)
					{
						audio_source[audio_source_cnt] = strdup(argv[loop] + strlen("--audio_source="));
						audio_source_cnt++;
					}
				}
				else if(strncmp(argv[loop], "--width=", strlen("--width=")) == 0)
				{
					new_width = atoi(argv[loop] + strlen("--width="));
					new_output_width = new_width;
					new_display_width = new_width;
				}
				else if(strncmp(argv[loop], "--height=", strlen("--height=")) == 0)
				{
					new_height = atoi(argv[loop] + strlen("--height="));
					new_output_height = new_height;
					new_display_height = new_height;
				}
				else if(strncmp(argv[loop], "--output_width=", strlen("--output_width=")) == 0)
				{
					new_output_width = atoi(argv[loop] + strlen("--output_width="));
				}
				else if(strncmp(argv[loop], "--output_height=", strlen("--output_height=")) == 0)
				{
					new_output_height = atoi(argv[loop] + strlen("--output_height="));
				}
				else if(strncmp(argv[loop], "--display_width=", strlen("--display_width=")) == 0)
				{
					new_display_width = atoi(argv[loop] + strlen("--display_width="));
				}
				else if(strncmp(argv[loop], "--display_height=", strlen("--display_height=")) == 0)
				{
					new_display_height = atoi(argv[loop] + strlen("--display_height="));
				}
				else if(strncmp(argv[loop], "--fps=", strlen("--fps=")) == 0)
				{
					new_fps = atoi(argv[loop] + strlen("--fps="));
				}
				else if(strncmp(argv[loop], "--interval=", strlen("--interval=")) == 0)
				{
					new_interval = atof(argv[loop] + strlen("--interval="));
				}
				else if(strncmp(argv[loop], "--split", strlen("--split")) == 0)
				{
					new_split = 1;
				}
				else if(strncmp(argv[loop], "--container=", strlen("--container=")) == 0)
				{
					char *cp = argv[loop] + strlen("--container=");
					strcpy(new_mux_format, cp);
				}
				else if(strncmp(argv[loop], "--buffered", strlen("--buffered")) == 0)
				{
					new_muxing = 0;
				}
				else if(strncmp(argv[loop], "--no_audio", strlen("--no_audio")) == 0)
				{
					if(new_muxing == 0)
					{
						use_audio = 0;
					}
				}
				else if(strncmp(argv[loop], "--flip=", strlen("--flip=")) == 0)
				{
					char *cp = argv[loop] + strlen("--flip=");
					if(strcmp(cp, "horizontal") == 0)
					{
						new_flip |= 1;
					}
					if(strcmp(cp, "vertical") == 0)
					{
						new_flip |= 2;
					}
				}
				else if(strncmp(argv[loop], "--old", strlen("--old")) == 0)
				{
					use_old = 1;
				}
				else if(strncmp(argv[loop], "--no_scan", strlen("--no_scan")) == 0)
				{
					use_no_scan = 1;
				}
				else if(strncmp(argv[loop], "--no_audio_scan", strlen("--no_audio_scan")) == 0)
				{
					use_no_audio_scan = 1;
				}
				else if(strncmp(argv[loop], "--scan_for_ptz", strlen("--scan_for_ptz")) == 0)
				{
					scan_for_ptz = 1;
				}
				else if(strncmp(argv[loop], "--record_main_window", strlen("--record_main_window")) == 0)
				{
					use_record_all = 1;
				}
				else if(strncmp(argv[loop], "--record_on_start=", strlen("--record_on_start=")) == 0)
				{
					char *cp = argv[loop];
					cp += strlen("--record_on_start=");
					if(strlen(cp) > 0)
					{
						record_on_start_alias = strdup(cp);
					}
					record_on_start = 1;
				}
				else if(strncmp(argv[loop], "--record_on_start", strlen("--record_on_start")) == 0)
				{
					record_on_start = 1;
				}
				else if(strncmp(argv[loop], "--record_desktop", strlen("--record_desktop")) == 0)
				{
					use_record_desktop = 1;
					if(strncmp(argv[loop], "--record_desktop=", strlen("--record_desktop=")) == 0)
					{
						char *cp = argv[loop] + strlen("--record_desktop=");
						use_desktop_x = atoi(cp);
						while((*cp != ',') && (*cp != '\0')) cp++;
						if(*cp == ',')
						{
							cp++;
							use_desktop_y = atoi(cp);
							while((*cp != ',') && (*cp != '\0')) cp++;
							if(*cp == ',')
							{
								cp++;
								use_desktop_w = atoi(cp);
								while((*cp != ',') && (*cp != '\0')) cp++;
								if(*cp == ',')
								{
									cp++;
									use_desktop_h = atoi(cp);
								}
							}
						}
					}
				}
				else if(strncmp(argv[loop], "--multi_stream", strlen("--multi_stream")) == 0)
				{
					use_single_stream = 0;
				}
				else if(strncmp(argv[loop], "--display_recording_camera", strlen("--display_recording_camera")) == 0)
				{
					use_follow_mode = FOLLOW_MODE_DISPLAY_RECORDING_CAMERA;
				}
				else if(strncmp(argv[loop], "--recording_follows_display", strlen("--recording_follows_display")) == 0)
				{
					use_follow_mode = FOLLOW_MODE_RECORDING_FOLLOWS_DISPLAY;
				}
				else if(strncmp(argv[loop], "--transition=", strlen("--transition=")) == 0)
				{
					char *cp = argv[loop] + strlen("--transition=");
					if(strcmp(cp, "blend") == 0)
					{
						use_transition = TRANSITION_BLEND;
					}
					else if(strcmp(cp, "wipe_l2r") == 0)
					{
						use_transition = TRANSITION_L2R_WIPE;
					}
					else if(strcmp(cp, "wipe_r2l") == 0)
					{
						use_transition = TRANSITION_R2L_WIPE;
					}
					else if(strcmp(cp, "wipe_t2b") == 0)
					{
						use_transition = TRANSITION_T2B_WIPE;
					}
					else if(strcmp(cp, "wipe_b2t") == 0)
					{
						use_transition = TRANSITION_B2T_WIPE;
					}
					else if(strcmp(cp, "fade2black") == 0)
					{
						use_transition = TRANSITION_FADE_TO_BLACK;
					}
					else
					{
						use_transition = TRANSITION_PLUGIN;
						strcpy(use_transition_plugin, cp);
					}
				}
				else if(strncmp(argv[loop], "--ptz=", strlen("--ptz=")) == 0)
				{
					if(use_ptz_device_path_cnt < NUMBER_OF_INTERFACES)
					{
						char lock_alias[4092];
						char bind_alias[4092];
						char alias[4092];
						char tmp[4092];
						strcpy(tmp, argv[loop]);
						int prefer_ndi_ptz = 0;
						int prefer_v4l = 0;
						int lock_number;
						strcpy(lock_alias, "");
						strcpy(bind_alias, "");
						strcpy(alias, "");
						char *orig_cp = tmp + strlen("--ptz=");
						char *cp = orig_cp;
						while(*cp != '\0')
						{
							if(strncmp(cp, "[lock", strlen("[lock")) == 0)
							{
								*cp = '\0';
								cp += strlen("[lock");
								lock_number = 0;
								if(isdigit(*cp))
								{
									lock_number = atoi(cp);
									if(lock_number > 0)
									{
										lock_number--;
									}
									if(lock_number >= NUMBER_OF_CAMERAS)
									{
										lock_number = 0;
									}
									cp++;
								}
								if(*cp == '=')
								{
									cp++;
									char *cp2 = cp;
									while((*cp != '\0') && (*cp != ']'))
									{
										cp++;
									}
									if(*cp == ']')
									{
										*cp = '\0';
									}
									strcpy(lock_alias, cp2);
									cp++;
								}
							}
							else if(strncmp(cp, "[bind", strlen("[bind")) == 0)
							{
								*cp = '\0';
								cp += strlen("[bind");
								if(*cp == '=')
								{
									cp++;
									char *cp2 = cp;
									while((*cp != '\0') && (*cp != ']'))
									{
										cp++;
									}
									if(*cp == ']')
									{
										*cp = '\0';
									}
									strcpy(bind_alias, cp2);
									cp++;
								}
							}
							else if(strncmp(cp, "[alias=", strlen("[alias=")) == 0)
							{
								*cp = '\0';
								cp += strlen("[alias=");
								char *cp2 = cp;
								while((*cp != '\0') && (*cp != ']'))
								{
									cp++;
								}
								if(*cp == ']')
								{
									*cp = '\0';
								}
								strcpy(alias, cp2);
								cp++;
							}
							else if(strncmp(cp, "[ndi]", strlen("[ndi]")) == 0)
							{
								cp += strlen("[ndi]");
								prefer_ndi_ptz = 1;
							}
							else if(strncmp(cp, "[v4l]", strlen("[v4l]")) == 0)
							{
								cp += strlen("[v4l]");
								prefer_v4l = 1;
							}
							else
							{
								cp++;
							}
						}
						int rr = TestPTZPort(orig_cp);
						if(rr == 1)
						{
							use_ptz_lock_alias[use_ptz_device_path_cnt][lock_number] = strdup(lock_alias);
							use_ptz_alias[use_ptz_device_path_cnt] = strdup(alias);
							use_ptz_device_path[use_ptz_device_path_cnt] = strdup(orig_cp);
							use_ptz_bind_alias[use_ptz_device_path_cnt] = strdup(bind_alias);
							use_ptz_prefer_ndi[use_ptz_device_path_cnt] = prefer_ndi_ptz;
							use_ptz_prefer_v4l[use_ptz_device_path_cnt] = prefer_v4l;
							use_ptz_device_path_cnt++;
						}
					}
				}
				else if(strncmp(argv[loop], "--object_detect", strlen("--object_detect")) == 0)
				{
					use_detect = 1;
				}
				else if(strncmp(argv[loop], "--ptz_home", strlen("--ptz_home")) == 0)
				{
					use_ptz_home_on_launch = 1;
				}
				else if(strncmp(argv[loop], "--yolo_cfg=", strlen("--yolo_cfg=")) == 0)
				{
					use_yolo_cfg = argv[loop] + strlen("--yolo_cfg=");
				}
				else if(strncmp(argv[loop], "--yolo_weights=", strlen("--yolo_weights=")) == 0)
				{
					use_yolo_weights = argv[loop] + strlen("--yolo_weights=");
				}
				else if(strncmp(argv[loop], "--yolo_names=", strlen("--yolo_names=")) == 0)
				{
					use_yolo_names = argv[loop] + strlen("--yolo_names=");
				}
				else if(strncmp(argv[loop], "--yolo_model=", strlen("--yolo_model=")) == 0)
				{
					char *cp = argv[loop] + strlen("--yolo_model=");
					if(strcasecmp(cp, "coco") == 0)
					{
						use_yolo_model = USE_YOLO_MODEL_COCO;
					}
				}
				else if(strncmp(argv[loop], "--jpeg_streaming=", strlen("--jpeg_streaming=")) == 0)
				{
					char *cp = argv[loop] + strlen("--jpeg_streaming=");
					use_jpeg_streaming = strdup(cp);
				}
				else if(strncmp(argv[loop], "--streaming=", strlen("--streaming=")) == 0)
				{
					char *cp = argv[loop] + strlen("--streaming=");
					use_stream_url = strdup(cp);
					use_streaming = 1;
					new_muxing = 1;
					use_audio = 1;
				}
				else if(strncmp(argv[loop], "--streaming_only", strlen("--streaming_only")) == 0)
				{
					use_stream_only = 1;
				}
				else if(strncmp(argv[loop], "--streaming_audio_quality=", strlen("--streaming_audio_quality=")) == 0)
				{
					char *cp = argv[loop] + strlen("--streaming_audio_quality=");
					if(strcmp(cp, "good") == 0)
					{
						use_streaming_audio_quality = 11025;
					}
					else if(strcmp(cp, "better") == 0)
					{
						use_streaming_audio_quality = 22050;
					}
					else if(strcmp(cp, "best") == 0)
					{
						use_streaming_audio_quality = 44100;
					}
				}
				else if(strncmp(argv[loop], "--embed_pip", strlen("--embed_pip")) == 0)
				{
					use_embed_pip = 1;
				}
				else if(strncmp(argv[loop], "--pip_position=", strlen("--pip_position=")) == 0)
				{
					char *cp = argv[loop] + strlen("--pip_position=");
					use_pip_x_position = atof(cp);
					while((*cp != ',') && (*cp != '\0'))
					{
						cp++;
					}
					if(*cp == ',')
					{
						cp++;
						use_pip_y_position = atof(cp);
					}
				}
				else if(strncmp(argv[loop], "--pip_highlight=", strlen("--pip_highlight=")) == 0)
				{
					char *cp = argv[loop] + strlen("--pip_highlight=");
					use_pip_red = atof(cp);
					while((*cp != ',') && (*cp != '\0'))
					{
						cp++;
					}
					if(*cp == ',')
					{
						cp++;
						use_pip_green = atof(cp);
						while((*cp != ',') && (*cp != '\0'))
						{
							cp++;
						}
						if(*cp == ',')
						{
							cp++;
							use_pip_blue = atof(cp);
						}
					}
				}
				else if(strncmp(argv[loop], "--pip_size=", strlen("--pip_size=")) == 0)
				{
					char *cp = argv[loop] + strlen("--pip_size=");
					use_pip_size = atof(cp);
				}
				else if(strncmp(argv[loop], "--main_width=", strlen("--main_width=")) == 0)
				{
					char *cp = argv[loop] + strlen("--main_width=");
					default_window_width = atof(cp);
				}
				else if(strncmp(argv[loop], "--main_height=", strlen("--main_height=")) == 0)
				{
					char *cp = argv[loop] + strlen("--main_height=");
					default_window_height = atof(cp);
				}
				else if(strncmp(argv[loop], "--grid_size=", strlen("--grid_size=")) == 0)
				{
					char *cp = argv[loop] + strlen("--grid_size=");
					use_grid_size = atof(cp);
				}
				else if(strncmp(argv[loop], "--desktop_monitor=", strlen("--desktop_monitor=")) == 0)
				{
					char *cp = argv[loop] + strlen("--desktop_monitor=");
					use_desktop_monitor = strdup(cp);
				}
				else if(strncmp(argv[loop], "--multipip=", strlen("--multipip=")) == 0)
				{
					use_multipip = MULTIPIP_SIDE_RIGHT;
					char *cp = argv[loop] + strlen("--multipip=");
					if(strcmp(cp, "right") == 0)
					{
						use_multipip = MULTIPIP_SIDE_RIGHT;
					}
					else if(strcmp(cp, "left") == 0)
					{
						use_multipip = MULTIPIP_SIDE_LEFT;
					}
					else if(strcmp(cp, "top") == 0)
					{
						use_multipip = MULTIPIP_SIDE_TOP;
					}
					else if(strcmp(cp, "bottom") == 0)
					{
						use_multipip = MULTIPIP_SIDE_BOTTOM;
					}
				}
				else if(strncmp(argv[loop], "--test_codecs", strlen("--test_codecs")) == 0)
				{
					test_codecs = 1;
				}
				else if(strncmp(argv[loop], "--no_query_codecs", strlen("--no_query_codecs")) == 0)
				{
					query_codecs = 0;
				}
				else if(strncmp(argv[loop], "--timestamp", strlen("--timestamp")) == 0)
				{
					timestamp = 1;
				}
				else if(strncmp(argv[loop], "--disregard_settings", strlen("--disregard_settings")) == 0)
				{
					use_disregard_settings = 1;
				}
				else if(strncmp(argv[loop], "--transparent_interface", strlen("--transparent_interface")) == 0)
				{
					use_transparent_interface = 1;
				}
				else if(strncmp(argv[loop], "--no_frame_scaling", strlen("--no_frame_scaling")) == 0)
				{
					frame_scaling = 0;
				}
				else if(strncmp(argv[loop], "--crop_output", strlen("--crop_output")) == 0)
				{
					crop_output = 1;
				}
				else if(strncmp(argv[loop], "--crop_display", strlen("--crop_display")) == 0)
				{
					crop_display = 1;
				}
				else if(strncmp(argv[loop], "--auto_scale", strlen("--auto_scale")) == 0)
				{
					auto_scale = 1;
				}
				else if(strncmp(argv[loop], "--retain_commands", strlen("--retain_commands")) == 0)
				{
					use_retain_commands = 1;
				}
				else if(strncmp(argv[loop], "--retain_cameras", strlen("--retain_cameras")) == 0)
				{
					use_retain_cameras = 1;
				}
				else if(strncmp(argv[loop], "--retain_audio", strlen("--retain_audio")) == 0)
				{
					use_retain_audio = 1;
				}
				else if(strncmp(argv[loop], "--retain_ptz", strlen("--retain_ptz")) == 0)
				{
					use_retain_ptz = 1;
				}
				else if(strncmp(argv[loop], "--lock_panels", strlen("--lock_panels")) == 0)
				{
					use_retain_commands = 1;
					use_retain_cameras = 1;
					use_retain_audio = 1;
					use_retain_ptz = 1;
				}
				else if(strncmp(argv[loop], "--animate_panels", strlen("--animate_panels")) == 0)
				{
					use_animate_panels = 1;
				}
				else if(strncmp(argv[loop], "--hide_status", strlen("--hide_status")) == 0)
				{
					use_hide_status = 1;
				}
				else if(strncmp(argv[loop], "--forced_scale=", strlen("--forced_scale=")) == 0)
				{
					char *cp = argv[loop] + strlen("--forced_scale=");
					screen_scaling = atof(cp);
					if((screen_scaling < 0.01) || (screen_scaling > 100.0)) screen_scaling = 1.0;
				}
				else if(strncmp(argv[loop], "--load_setup=", strlen("--load_setup=")) == 0)
				{
					char *cp = argv[loop] + strlen("--load_setup=");
					forced_setup = strdup(cp);
					use_no_audio_scan = 1;
					use_no_scan = 1;
				}
				else if(strncmp(argv[loop], "--transition_plugin=", strlen("--transition_plugin=")) == 0)
				{
					char *cp = argv[loop] + strlen("--transition_plugin=");
					global_transition_plugin = strdup(cp);
				}
				else if(strncmp(argv[loop], "--filter_plugin=", strlen("--filter_plugin=")) == 0)
				{
					if(global_filter_plugin_cnt < 1024)
					{
						char *cp = argv[loop] + strlen("--filter_plugin=");
						global_filter_plugin[global_filter_plugin_cnt] = strdup(cp);
						global_filter_plugin_cnt++;
					}
				}
				else if(strncmp(argv[loop], "--audio_filter_plugin=", strlen("--audio_filter_plugin=")) == 0)
				{
					if(global_audio_filter_plugin_cnt < 1024)
					{
						char *cp = argv[loop] + strlen("--audio_filter_plugin=");
						global_filter_plugin[global_audio_filter_plugin_cnt] = strdup(cp);
						global_audio_filter_plugin_cnt++;
					}
				}
				else if(strncmp(argv[loop], "--filter_plugin_file=", strlen("--filter_plugin_file=")) == 0)
				{
					if(global_filter_plugin_file_cnt < 1024)
					{
						char *cp = argv[loop] + strlen("--filter_plugin_file=");
						global_filter_plugin_file[global_filter_plugin_file_cnt] = strdup(cp);
						global_filter_plugin_file_cnt++;
					}
				}
				else if(strncmp(argv[loop], "--transition_plugin_file=", strlen("--transition_plugin_file=")) == 0)
				{
					if(global_transition_plugin_file_cnt < 1024)
					{
						char *cp = argv[loop] + strlen("--transition_plugin_file=");
						global_transition_plugin_file[global_transition_plugin_file_cnt] = strdup(cp);
						global_transition_plugin_file_cnt++;
					}
				}
				else if(strncmp(argv[loop], "--capture_plugin_file=", strlen("--capture_plugin_file=")) == 0)
				{
					char *cp = argv[loop] + strlen("--capture_plugin_file=");
					strcpy(global_capture_plugin_file, cp);
				}
				else if(strncmp(argv[loop], "--select_audio=", strlen("--select_audio=")) == 0)
				{
					char *cp = argv[loop] + strlen("--select_audio=");
					use_select_audio[select_audio_cnt] = strdup(cp);
					select_audio_cnt++;
				}
				else if(strncmp(argv[loop], "--select_camera=", strlen("--select_camera=")) == 0)
				{
					char *cp = argv[loop] + strlen("--select_camera=");
					use_select_camera = strdup(cp);
				}
				else if(strncmp(argv[loop], "--exclude_directories", strlen("--exclude_directories")) == 0)
				{
					use_exclude_directories = 1;
				}
				else if(strncmp(argv[loop], "--message_delay=", strlen("--message_delay=")) == 0)
				{
				}
				else if(strncmp(argv[loop], "--auto_scale", strlen("--auto_scale")) == 0)
				{
				}
				else if(strncmp(argv[loop], "--help", strlen("--help")) == 0)
				{
				}
				else if(strncmp(argv[loop], "--no_html_renderer", strlen("--no_html_renderer")) == 0)
				{
				}
				else if(strncmp(argv[loop], "--dark_mode", strlen("--dark_mode")) == 0)
				{
				}
				else if(strncmp(argv[loop], "--light_mode", strlen("--light_mode")) == 0)
				{
				}
				else if(strncmp(argv[loop], "--no_placard", strlen("--no_placard")) == 0)
				{
				}
				else
				{
					static char buf[4096];
					fprintf(stderr, "Error: Unknown option \"%s\".\n", argv[loop]);
					sprintf(buf, "Error: Unknown option \"%s\".\n", argv[loop]);
					start_win->Update(buf);
				}
			}
		}
	}
	start_win->Update("Opening plugins");
	global_capture_plugin_handle = dlopen(global_capture_plugin_file, RTLD_NOW);
	if(global_capture_plugin_handle != NULL)
	{
		void_capture_init_capture = (void *)dlsym(global_capture_plugin_handle, "init_capture");
		void_capture_capture = (void *)dlsym(global_capture_plugin_handle, "capture");
		void_capture_finish_capture = (void *)dlsym(global_capture_plugin_handle, "finish_capture");
		if((void_capture_init_capture != NULL)
		&& (void_capture_capture != NULL)	
		&& (void_capture_finish_capture != NULL))
		{
			int (*capture_init)();
			capture_init = (int (*)())void_capture_init_capture;
			int nn = capture_init();
		}
	}
	int cnt = 0;
	for(outer = 0;outer < global_filter_plugin_file_cnt;outer++)
	{
		global_plugin_handle[outer] = dlopen(global_filter_plugin_file[outer], RTLD_NOW);
		if(global_plugin_handle[outer] != NULL)
		{
			void_pseudo_camera = (void *)dlsym(global_plugin_handle[outer], "pseudo_camera");
			void_handle_events = (void *)dlsym(global_plugin_handle[outer], "handle_events");
			for(loop = 0;loop < global_filter_plugin_cnt;loop++)
			{
				void_filter_plugin[cnt] = (void *)dlsym(global_plugin_handle[outer], global_filter_plugin[loop]);
				if(void_filter_plugin[cnt] != NULL)
				{
					cnt++;
				}
			}
			for(loop = 0;loop < global_audio_filter_plugin_cnt;loop++)
			{
				void_audio_filter_plugin[cnt] = (void *)dlsym(global_plugin_handle[outer], global_audio_filter_plugin[loop]);
				if(void_audio_filter_plugin[cnt] != NULL)
				{
					cnt++;
				}
			}
		}
	}
	global_filter_plugin_cnt = cnt;
	cnt = 0;
	for(outer = 0;outer < global_transition_plugin_file_cnt;outer++)
	{
		global_transition_plugin_handle[outer] = dlopen(global_transition_plugin_file[outer], RTLD_NOW);
		if(global_transition_plugin_handle[outer] != NULL)
		{
			void_transition_plugin = (void *)dlsym(global_transition_plugin_handle[outer], global_transition_plugin);
		}
	}
	if(scan_for_ptz == 1)
	{
		start_win->Update("Scanning for PTZ");
		char *final[256];
		int nn = ScanViableTTYPorts(final);
		for(loop = 0;loop < nn;loop++)
		{
			for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
			{
				use_ptz_lock_alias[use_ptz_device_path_cnt][inner] = strdup("");
			}
			use_ptz_bind_alias[use_ptz_device_path_cnt] = strdup("");
			use_ptz_alias[use_ptz_device_path_cnt] = strdup("");
			use_ptz_device_path[use_ptz_device_path_cnt] = strdup(final[loop]);
			use_ptz_prefer_ndi[use_ptz_device_path_cnt] = 0;
			use_ptz_prefer_v4l[use_ptz_device_path_cnt] = 0;
			use_ptz_device_path_cnt++;
			free(final[loop]);
		}
	}
	list_shared_exports("Plugins");

	if(auto_scale == 1)
	{
		double use_scale = (double)Fl::h() / 1080.0;
		double current_scale = Fl::screen_scale(0);
		double final_scale = use_scale * current_scale;
		Fl::screen_scale(0, final_scale);
	}
	else if(screen_scaling != 1.0)
	{
		Fl::screen_scale(0, screen_scaling);
	}
	if(default_window_width < 960)
	{
		default_window_width = Fl::w();
	}
	if(default_window_height < 540)
	{
		int nn = 64;
		if(start_win->visible())
		{
			nn = get_title_bar_height(start_win);
		}
		default_window_height = Fl::h() - (nn / 2);
	}
	if((global_my_format_cnt == 0) && (query_codecs == 1))
	{
		start_win->Update("Querying CODECS");
		enumerate_codecs();
		if(test_codecs == 1)
		{
			if(new_output_width == -1)
				new_output_width = new_width;
			if(new_output_height == -1)
				new_output_height = new_height;
			enumerate_test(NULL, new_output_width, new_output_height, (int)new_fps, use_streaming_audio_quality);
		}
	}
	MyWin *win = new MyWin(
		default_window_width
		, default_window_height
		, source_cnt
		, source
		, audio_source_cnt
		, audio_source
		, new_width
		, new_height
		, new_output_width
		, new_output_height
		, new_display_width
		, new_display_height
		, new_fps
		, new_interval
		, new_split
		, new_muxing
		, new_flip
		, use_audio
		, new_mux_format
		, use_old
		, use_no_scan
		, use_no_audio_scan
		, use_record_all
		, use_record_desktop
		, use_desktop_x
		, use_desktop_y
		, use_desktop_w
		, use_desktop_h
		, use_single_stream
		, use_follow_mode
		, use_transition
		, use_transition_plugin
		, use_ptz_device_path_cnt
		, use_ptz_device_path
		, use_ptz_lock_alias
		, use_ptz_bind_alias
		, use_ptz_prefer_ndi
		, use_ptz_prefer_v4l
		, use_ptz_alias
		, use_ptz_home_on_launch
		, use_yolo_model
		, use_yolo_cfg
		, use_yolo_weights
		, use_yolo_names
		, use_jpeg_streaming
		, use_streaming
		, use_stream_url
		, use_stream_only
		, use_streaming_audio_quality
		, use_embed_pip
		, use_pip_x_position
		, use_pip_y_position
		, use_pip_red
		, use_pip_green
		, use_pip_blue
		, use_pip_size
		, use_multipip
		, use_grid_size
		, use_desktop_monitor
		, use_detect
		, timestamp
		, frame_scaling
		, use_retain_commands
		, use_retain_cameras
		, use_retain_audio
		, use_retain_ptz
		, use_hide_status
		, auto_scale
		, crop_output
		, crop_display
		, use_disregard_settings
		, use_transparent_interface
		, use_animate_panels
		, use_exclude_directories
		, "Cowcam");
	win->color(WHITE);
	win->end();
	win->hide();
	win->callback(quit_cb, win);

	int	video_found = my_find_codec_by_id(0, win->use_video_codec, win->video_codec_name);
	int	audio_found = my_find_codec_by_id(1, win->use_audio_codec, win->audio_codec_name);

	start_win->Update("Initialize object menu");
	win->object_menu = new ObjectMenu(win);
	win->object_menu->hide();

	win->color_it_window = new ColorItWindow(win);
	win->color_it_window->hide();

	win->pulse_audio_filter_window = new PulseAudioFilterWindow(win);
	win->pulse_audio_filter_window->hide();

	win->record_on_start = record_on_start;
	win->record_on_start_alias = record_on_start_alias;

	for(loop = 0;loop < select_audio_cnt;loop++)
	{
		if(use_select_audio[loop] != NULL)
		{
			win->SelectPulseAudioButton(use_select_audio[loop]);
		}
	}
	if(use_select_camera != NULL)
	{
		win->SelectCamera(use_select_camera);
	}
	start_win->Update("Opening supplemental windows");
	TriggerWindow *tw = new TriggerWindow(win);
	win->trigger_window = tw;
	tw->hide();

	TransitionWindow *transition = new TransitionWindow(win);
	transition->hide();
	win->transitions_window = transition;

	PseudoCameraWindow *pseudo_camera = new PseudoCameraWindow(win);
	pseudo_camera->hide();
	win->pseudo_camera_window = pseudo_camera;

	FilterPluginsWindow *filter_built_in = new FilterPluginsWindow(win, FILTER_TYPE_VIDEO_BUILT_IN);
	filter_built_in->hide();
	win->filter_built_in_window = filter_built_in;

	FilterPluginsWindow *filter_plugins = new FilterPluginsWindow(win, FILTER_TYPE_VIDEO);
	filter_plugins->hide();
	win->filter_plugins_window = filter_plugins;

	FilterPluginsWindow *audio_filter_plugins = new FilterPluginsWindow(win, FILTER_TYPE_AUDIO);
	audio_filter_plugins->hide();
	win->audio_filter_plugins_window = audio_filter_plugins;

	ImmediateDrawingWindow *immediate_drawing_window = new ImmediateDrawingWindow(win, 400, 150, 120, 460, "Immediate Drawing");
	immediate_drawing_window->hide();
	win->immediate_drawing_window = immediate_drawing_window;

	win->fltk_plugin_window = new FltkPluginWindow(win);
	win->fltk_plugin_window->hide();

	global_window = win;

	win->MakeNewSourceWindow();
	win->MakeAliasWindow();

	win->specify_url_window = new SpecifyURLWindow(win);
	win->specify_url_window->hide();

	win->specify_irc_window = new SpecifyIRCWindow(win);
	win->specify_irc_window->hide();

	win->command_key_settings = new CommandKeySettingsWindow(win, 380, 800);
	win->embed_app_settings = new EmbedAppSettings(win);

	win->resize_frame = new ResizeFrame(win, 400, 400, 200, 100);
	win->add(win->resize_frame);
	win->resize_frame->hide();

	start_win->Update("Constructing settings windows");
	VideoSettingsWindow *vsw = new VideoSettingsWindow(win);
	vsw->hide();
	win->video_settings_window = vsw;

	MiscVideoSettingsWindow *mvsw = new MiscVideoSettingsWindow(win);
	mvsw->hide();
	win->misc_video_settings_window = mvsw;

	AudioSettingsWindow *asw = new AudioSettingsWindow(win);
	asw->hide();
	win->audio_settings_window = asw;

	CameraSettingsWindow *csw = new CameraSettingsWindow(win);
	csw->hide();
	win->camera_settings_window = csw;

	SnapshotSettingWindow *ssw = new SnapshotSettingWindow(win);
	ssw->hide();
	win->snapshot_settings_window = ssw;

	PTZ_LockWindow *ptz_lock = new PTZ_LockWindow(win);
	ptz_lock->hide();
	win->ptz_lock_window = ptz_lock;

	start_win->Update("Building select output window");
	win->BuildSelectOutputWindow();

	start_win->Update("Building set output window");
	win->BuildEditOutputWindow();

	start_win->Update("Building GUI settings window");
	win->gui_settings_window = new GUI_SettingsWindow(win);
	win->gui_settings_window->hide();

	start_win->Update("Building NDI Source window");
	win->ndi_source_window = new NDISourceListWindow(win);
	win->ndi_source_window->hide();

	start_win->Update("Building audio library window");
	win->audio_library_window = new AudioLibrary(win);
	win->audio_library_window->hide();

	win->audio_library_list = new AudioLibraryList(win);
	win->audio_library_list->hide();

	win->original_w = win->w();
	win->original_h = win->h();

	if(forced_setup != NULL)
	{
		win->LoadJSON(forced_setup);
	}
	if(start_win->message_delay > 0)
	{
		usleep(start_win->message_delay);
	}
	Fl::add_timeout(0.1, my_window_cb, win);

	return(0);
}

StartWindow::StartWindow(int in_message_delay, int xx, int yy, int ww, int hh, int in_argc, char *lbl) : Fl_Double_Window(xx, yy, ww, hh, lbl)
{
	box(FL_FLAT_BOX);
	color(BLACK);
	argc = in_argc;
	text = new Fl_Box(0, 0, ww, hh, "");
	text->box(FL_FLAT_BOX);
	text->color(BLACK);
	text->labelcolor(WHITE);
	text->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	int nn = 32 * (hh / 1080);
	text->labelsize(nn);
	message_delay = in_message_delay;
	last_time = 0;
	image_mat_cnt = 0;
	use_updates = 0;
	intro_pipe_fp = NULL;
	end();
}

StartWindow::~StartWindow()
{
}

void	StartWindow::draw()
{
int	loop;

	if(use_updates == 1)
	{
		Fl_Double_Window::draw();

		fl_color(FL_WHITE);
		fl_font(FL_HELVETICA, 64);
		fl_draw("CowCam", 0, 0, w(), h() - 400, FL_ALIGN_CENTER);
		fl_font(FL_HELVETICA, 24);
		char buf[256];
		sprintf(buf, "Copyright %c%c 2025, Mark Lasersohn", 0xC2, 0xA9);
		fl_draw(buf, 0, 0, w(), h() - 300, FL_ALIGN_CENTER);

		int start_x = (Fl::w() / 2) - ((image_mat_cnt * 162) / 2);
		int start_y = (Fl::h() / 2) + 140;
		for(loop = 0;loop < image_mat_cnt;loop++)
		{
			fl_draw_image(image_mat[loop].ptr(), start_x + (loop * 162), start_y, image_mat[loop].cols, image_mat[loop].rows, 4);
		}
	}
}

void	StartWindow::Update(char *str)
{
	if(use_updates == 1)
	{
		if(message_delay > -1)
		{
			time_t now = precise_time();
			time_t diff = now - last_time;
			time_t span = 0;
			if(diff < message_delay)
			{
				span = message_delay - diff;
			}
			usleep(span);
			fprintf(stderr, "%s\n", str);
			text->copy_label(str);
			text->redraw();
			redraw();
			Fl::flush();
			Fl::check();
			last_time = precise_time();
			if(image_mat_cnt > 0)
			{
				sleep(1);
			}
		}
	}
	if(intro_pipe_fp != NULL)
	{
		fprintf(intro_pipe_fp, "%s\n", str);
		fflush(intro_pipe_fp);
	}
}

int	x11_handler(Display *d, XErrorEvent *e)
{
#ifdef DEBUG
	fprintf(stderr, "X11 Error: %d\n", e->error_code);
#endif
	return(0);
}

void	start_cb(void *v)
{
	StartWindow *w = (StartWindow *)v;
	XSetErrorHandler(x11_handler);
	StartMain(1);
	global_window->show();
	w->hide();
}

void	DynamicallyLoadNDILibrary(char *library_path)
{
	hNDILib = dlopen(library_path, RTLD_LOCAL | RTLD_LAZY);
	const NDIlib_v3 *(*NDIlib_v3_load)(void) = NULL;
	if(hNDILib)
	{
		*((void**)&NDIlib_v3_load) = dlsym(hNDILib, "NDIlib_v3_load");
		if(!NDIlib_v3_load)
		{
			if(hNDILib)
			{
				dlclose(hNDILib);
				hNDILib = NULL;
			}
		}
		else
		{
			NDILib = (const NDIlib_v3 *)NDIlib_v3_load();
		}
	}
}

void	dump_mat(char *filename, char *name, Mat mat)
{
int	row, col, b;

	FILE *fp = fopen(filename, "w");
	if(fp != NULL)
	{
		int channels = mat.channels();
		fprintf(fp, "#define %s_WIDTH\t%d\n", name, mat.cols);
		fprintf(fp, "#define %s_HEIGHT\t%d\n", name, mat.rows);
		fprintf(fp, "#define %s_DEPTH\t%d\n\n", name, mat.channels());
		fprintf(fp, "uchar %s_bytes[] = {\n", name);
		uchar *cp = mat.ptr();
		for(row = 0;row < mat.rows;row++)
		{
			for(col = 0;col < mat.cols;col++)
			{
				for(b = 0;b < channels;b++)
				{
					uchar cc = *cp;
					fprintf(fp, "%u", cc);
					if((row < mat.rows - 1) || (col < mat.cols - 1) || (b < channels - 1))
					{
						fprintf(fp, ",");
					}
					cp++;
				}
				fprintf(fp, "\n");
			}
		}
		fprintf(fp, "};\n");
		fclose(fp);
	}
}

int	main(int argc, char **argv)
{
int		loop;

	int html = 0;
	int placard = 1;
	int shade_mode = SHADE_MODE_DARK;
	int message_delay = 0;
	int run_it = 1;
	int ndi_notice = 0;;
	for(loop = 0;loop < argc;loop++)
	{
		if(strncmp(argv[loop], "--no_html_renderer", strlen("--no_html_renderer")) == 0)
		{
			global_html = 0;
			run_it = 0;
		}
		if(strncmp(argv[loop], "--dark_mode", strlen("--dark_mode")) == 0)
		{
			shade_mode = SHADE_MODE_DARK;
		}
		if(strncmp(argv[loop], "--light_mode", strlen("--light_mode")) == 0)
		{
			shade_mode = SHADE_MODE_LIGHT;
		}
		if(strncmp(argv[loop], "--no_placard", strlen("--no_placard")) == 0)
		{
			placard = 0;
		}
		global_argv[loop] = strdup(argv[loop]);
		global_argc = argc;
	}
	if(global_html == 1)
	{
		global_cef_handle = dlopen("libhtml_window.so", RTLD_NOW);
		if(global_cef_handle != NULL)
		{
			void_initialize_cef = (void *)dlsym(global_cef_handle, "initialize_cef");
			void_shutdown_cef = (void *)dlsym(global_cef_handle, "shutdown_cef");
			void_MakeHTMLWindow_cef = (void *)dlsym(global_cef_handle, "MakeHTMLWindow");
			void_delete_html_cef = (void *)dlsym(global_cef_handle, "delete_html");
			void_get_image_cef = (void *)dlsym(global_cef_handle, "get_image_cef");

			if(void_initialize_cef != NULL)
			{
				void (*init_cef)(int, int, char **);
				init_cef = (void (*)(int, int, char **))void_initialize_cef;
				init_cef(global_html, argc, argv);
			}
		}
	}
	global_osg_handle = dlopen("libosg_camera.so", RTLD_NOW);
	if(global_osg_handle != NULL)
	{
		void_OSG_get_scene_data = (void *)dlsym(global_osg_handle, "OSG_get_scene_data");
		void_OSG_Translate = (void *)dlsym(global_osg_handle, "OSG_Translate");
		void_OSG_Rotate = (void *)dlsym(global_osg_handle, "OSG_Rotate");
		void_OSG_Scale = (void *)dlsym(global_osg_handle, "OSG_Scale");
		void_OSG_open_osg = (void *)dlsym(global_osg_handle, "OSG_open_osg");
		if((void_OSG_Translate != NULL)
		&& (void_OSG_Rotate != NULL)
		&& (void_OSG_Scale != NULL)
		&& (void_OSG_open_osg != NULL))
		{
			global_osg_enabled = 1;
		}
	}
	NDILib = NULL;
	hNDILib = NULL;
	DynamicallyLoadNDILibrary("libndi.so");
	int no_go = 0;
	if(NDILib != NULL)
	{
		if(!NDILib->NDIlib_initialize())
		{
			fprintf(stderr, "Error: Unable to initialize NDI.\n");
			no_go = 1;
		}
		else
		{
			ndi_notice = 1;
		}
	}
	int do_auto_scale = 0;
	for(loop = 0;loop < global_argc;loop++)
	{
		if(strncmp(global_argv[loop], "--auto_scale", strlen("--auto_scale")) == 0)
		{
			do_auto_scale = 1;
		}
		if(strncmp(global_argv[loop], "--help", strlen("--help")) == 0)
		{
			show_help();
			no_go = 1;
		}
		if(strncmp(global_argv[loop], "--message_delay=", strlen("--message_delay=")) == 0)
		{
			char *cp = global_argv[loop] + strlen("--message_delay=");
			int nn = atoi(cp);
			message_delay = nn;
		}
	}
	if(no_go == 0)
	{
		Fl::option(Fl::OPTION_ARROW_FOCUS, 0);
		Fl::option(Fl::OPTION_VISIBLE_FOCUS, 0);
		Fl::keyboard_screen_scaling(1);
#ifdef NO_GTK
		Fl::option(Fl::OPTION_FNFC_USES_GTK, 0);
#endif
#ifdef NO_ZENITY
		Fl::option(Fl::OPTION_FNFC_USES_ZENITY, 0);
#endif
		Fl::cairo_autolink_context(1);

		fl_register_images();
		Fl_File_Icon::load_system_icons();
		Fl::set_color(DARK_RED, 100, 0, 0);
		Fl::set_color(DARK_BLUE, 0, 0, 100);
		Fl::set_color(GRAY, 128, 128, 128);
		Fl::set_color(RED, 200, 0, 0);
		Fl::set_color(BLUE, 0, 0, 200);
		Fl::set_color(CYAN, 128, 128, 255);

		if(shade_mode == SHADE_MODE_DARK)
		{
			Fl::set_color(DARK_GRAY, 50, 50, 50);
			Fl::set_color(LIGHT_GRAY, 200, 200, 200);
			Fl::set_color(BLACK, 0, 0, 0);
			Fl::set_color(WHITE, 255, 255, 255);
			Fl::set_color(YELLOW, 255, 240, 200);
		}
		else
		{
			Fl::set_color(DARK_GRAY, 255 - 50, 255 - 50, 255 - 50);
			Fl::set_color(LIGHT_GRAY, 255 - 200, 255 - 200, 255 - 200);
			Fl::set_color(BLACK, 255 - 0, 255 - 0, 255 - 0);
			Fl::set_color(WHITE, 255 - 255, 255 - 255, 255 - 255);
			Fl::set_color(YELLOW, 255 - 255, 255 - 240, 255 - 200);
		}
		Fl::scrollbar_size(4);
		int ww = Fl::w();
		int hh = Fl::h();
		if(do_auto_scale == 1)
		{
			double use_scale = (double)Fl::h() / 1080.0;
			double current_scale = Fl::screen_scale(0);
			double final_scale = use_scale * current_scale;
			Fl::screen_scale(0, final_scale);
			ww = 1920;
			hh = 1080;
		}
		Fl_Tooltip::size(9);
		Fl_Tooltip::color(BLACK);
		Fl_Tooltip::textcolor(WHITE);

		global_log_window = new Fl_Window(1200, 800, "Codec Log");
			Fl_Browser *browser = new Fl_Browser(0, 0, 1200, 800);
			browser->color(BLACK);
			browser->textcolor(WHITE);
		global_log_window->end();
		global_log_window->hide();
		if(folder_DEPTH == 3)
		{
			global_folder_mat = Mat(folder_WIDTH, folder_HEIGHT, CV_8UC3, folder_bytes);
		}
		else if(folder_DEPTH == 4)
		{
			global_folder_mat = Mat(folder_WIDTH, folder_HEIGHT, CV_8UC4, folder_bytes);
		}
		if(access("color_palette.json", F_OK) == 0)
		{
			load_global_palette_as_JSON();
		}
		else
		{
			for(loop = 0;loop < 32;loop++)
			{
				global_palette_red[loop] = (int)(drand48() * 255.0);
				global_palette_green[loop] = (int)(drand48() * 255.0);
				global_palette_blue[loop] = (int)(drand48() * 255.0);
				global_palette_alpha[loop] = 255;
			}
			save_global_palette_as_JSON();
		}
		start_win = new StartWindow(message_delay, 0, 0, ww, hh, global_argc + 1, "Starting");
		start_win->box(FL_FLAT_BOX);
		start_win->show();
		if(placard == 1)
		{
			int	pipe_in = -1;
			int	pipe_out = -1;
			int pipe_pid = popen2("intro", &pipe_in, &pipe_out);
			if(pipe_pid != -1)
			{
				start_win->intro_pipe_fp = fdopen(pipe_in, "w");
				if(start_win->intro_pipe_fp != NULL)
				{
					start_win->hide();
					if(ndi_notice == 1)
					{
						fprintf(start_win->intro_pipe_fp, "ndi notice\n");
					}
					StartMain(0);
					fprintf(start_win->intro_pipe_fp, "quit\n");
					fflush(start_win->intro_pipe_fp);
					fclose(start_win->intro_pipe_fp);
					start_win->intro_pipe_fp = NULL;
					global_window->show();
					Fl::run();
				}
				else
				{
					Fl::add_timeout(0.0, start_cb, start_win);
					Fl::run();
				}
			}
			else
			{
				Fl::add_timeout(0.0, start_cb, start_win);
				Fl::run();
			}
		}
		else if(placard == 2)
		{
			Fl::add_timeout(0.0, start_cb, start_win);
			Fl::run();
		}
		else
		{
			start_win->hide();
			StartMain(0);
			global_window->show();
			Fl::run();
		}
		if(void_capture_finish_capture != NULL)
		{
			int (*capture_finish)();
			capture_finish = (int (*)())void_capture_finish_capture;
			capture_finish();
		}
		for(loop = 0;loop < global_filter_plugin_file_cnt;loop++)
		{
			if(global_plugin_handle[loop] != NULL)
			{
				dlclose(global_plugin_handle[loop]);
			}
		}
		for(loop = 0;loop < global_transition_plugin_file_cnt;loop++)
		{
			if(global_transition_plugin_handle[loop] != NULL)
			{
				dlclose(global_transition_plugin_handle[loop]);
			}
		}
		if(NDILib != NULL)
		{
			NDILib->NDIlib_destroy();
		}
	}
	if(hNDILib != NULL)
	{
		dlclose(hNDILib);
	}
	if(global_html == 1)
	{
		if(void_shutdown_cef != NULL)
		{
			void (*shut_cef)();
			shut_cef = (void (*)())void_shutdown_cef;
			shut_cef();
		}
	}
	for(loop = 0;loop < argc;loop++)
	{
		if(global_argv[loop] != NULL)
		{
			free(global_argv[loop]);
		}
	}
}
