#include	<unistd.h>
#include	<time.h>
#include	<sys/time.h>
#include	<fcntl.h>
#include	<semaphore.h>
#include	<sys/sendfile.h>
#include	<signal.h>
#include	<link.h>
#include	<dlfcn.h>

#include <iostream>
#include <string>
#include <memory>
#include <thread>
#include <chrono>

#include	<sys/ioctl.h>
#include	<curl/curl.h>
#include	<linux/videodev2.h>

#include	<argv_split.h>

#include <osg/MatrixTransform>
#include <osgViewer/Viewer>
#include <osgViewer/CompositeViewer>
#include <osgViewer/ViewerEventHandlers>
#include <osgGA/TrackballManipulator>
#include <osgGA/TerrainManipulator>
#include <osgGA/FlightManipulator>
#include <osgGA/DriveManipulator>
#include <osgDB/ReadFile>

extern "C"
{
#include <libavutil/avassert.h>
#include <libavutil/channel_layout.h>
#include <libavutil/opt.h>
#include <libavutil/mathematics.h>
#include <libavutil/timestamp.h>
#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>
#include <libswscale/swscale.h>
#include <libswresample/swresample.h>
}

#include <cef_app.h>
#include <cef_client.h>
#include <cef_parser.h>
#include <cef_render_handler.h>
#include <cef_life_span_handler.h>
#include <cef_load_handler.h>
#include <wrapper/cef_helpers.h>

#include <opencv2/opencv.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <opencv2/dnn.hpp>

#include <opencv2/core/core_c.h>

#include <pulse/simple.h>
#include <pulse/error.h>

#include <vlc/vlc.h>

#include <blend2d.h>

#include	<FL/Fl.H>
#include	<FL/platform.H>
#include	<FL/Fl_Window.H>
#include	<FL/Fl_Double_Window.H>
#include	<FL/Fl_Gl_Window.H>
#include	<FL/Fl_Input.H>
#include	<FL/Fl_Box.H>
#include	<FL/Fl_Button.H>
#include	<FL/Fl_Repeat_Button.H>
#include	<FL/Fl_Slider.H>
#include	<FL/Fl_Hor_Fill_Slider.H>
#include	<FL/Fl_Hor_Slider.H>
#include	<FL/Fl_Value_Slider.H>
#include	<FL/Fl_Hor_Nice_Slider.H>
#include	<FL/Fl_Input.H>
#include	<FL/Fl_Int_Input.H>
#include	<FL/Fl_Float_Input.H>
#include	<FL/Fl_Scroll.H>
#include	<FL/Fl_Pack.H>
#include	<FL/Fl_Menu_Button.H>
#include	<FL/Fl_Light_Button.H>
#include	<FL/Fl_Toggle_Button.H>
#include	<FL/Fl_Chart.H>
#include	<FL/Fl_Shared_Image.H>
#include	<FL/Fl_Choice.H>
#include	<FL/fl_draw.H>
#include	<FL/fl_ask.H>
#include	<FL/Fl_File_Chooser.H>
#include	<FL/Fl_Native_File_Chooser.H>
#include	<FL/Fl_Color_Chooser.H>
#include	<FL/Fl_Output.H>
#include	<FL/Fl_Multiline_Output.H>
#include	<FL/Fl_Multiline_Input.H>
#include	<FL/Fl_Browser.H>
#include	<FL/Fl_Hold_Browser.H>
#include	<FL/Fl_Select_Browser.H>
#include	<FL/Fl_Image_Surface.H>
#include	<FL/Fl_RGB_Image.H>
#include	<FL/Fl_PNG_Image.H>
#include	<FL/Fl_Pack.H>
#include	<FL/Fl_Copy_Surface.H>

#include	<X11/Xlib.h>
#include	<X11/X.h>
#include	<sys/shm.h>
#include	<sys/ipc.h>
#include	<X11/extensions/XShm.h>
#include	<X11/extensions/Xfixes.h>
#include	<X11/extensions/Xcomposite.h>
#include	<X11/extensions/Xrender.h>
#include	<X11/extensions/Xrender.h>
#include	<X11/XKBlib.h>

#include	<visca/libvisca.h>
#include	<cairo.h>

#include	"osg.h"

extern "C"
{
	void merge_av(char *, char *, char *);
}

using namespace cv;
using namespace dnn;
using namespace std;

#include	"image_memory.h"
#include	"PulseAudio.h"
#include	"vlc_window.h"
#include	"html_window.h"
#include	"embed_app.h"
#include	"cowcam.h"
#include	"muxer.h"

#define READ 0
#define WRITE 1

#define MAX_PROPERTY_VALUE_LEN 4096

// X11 Button Masks
#define BUTTON_1_MASK	 (1<<8)
#define BUTTON_2_MASK	 (1<<9)
#define BUTTON_3_MASK	 (1<<10)

#define	DISPLAYED_THUMB_CNT	5

int			pulse_list_devices(int in_or_out, int limit, char **list, char **description, int *index);
void		vlc_window_start_cb(void *);

MyWin			*global_window = NULL;
StartWindow		*start_win = NULL;
char			*global_argv[1024];
int				global_argc;
int				global_html = 0;
ShapeRectangle *global_sr = NULL;

extern MyFormat		*global_my_format[1024];
extern int		global_my_format_cnt;

void			*global_plugin_handle[1024];
void			*void_pseudo_camera = NULL;
void			*void_handle_events = NULL;

void			*void_filter_plugin[1024];
char			*global_filter_plugin[1024];
int				global_filter_plugin_cnt = 0;

void			*void_audio_filter_plugin[1024];
char			*global_audio_filter_plugin[1024];
int				global_audio_filter_plugin_cnt = 0;

char			*global_filter_plugin_file[1024];
int				global_filter_plugin_file_cnt = 0;

char			*global_potential_filter[1024];
void			*global_potential_filter_handle[1024];
int				global_potential_filter_cnt = 0;

char			*global_potential_audio_filter[1024];
void			*global_potential_audio_filter_handle[1024];
int				global_potential_audio_filter_cnt = 0;

char			*global_potential_camera[1024];
void			*global_potential_camera_handle[1024];
int				global_potential_camera_cnt = 0;

char			*global_potential_fltk[1024];
void			*global_potential_fltk_handle[1024];
int				global_potential_fltk_cnt = 0;

void			*global_capture_plugin_handle = NULL;
void			*void_capture_init_capture = NULL;
void			*void_capture_capture = NULL;
void			*void_capture_finish_capture = NULL;
char			global_capture_plugin_file[4096];

Fl_Window		*global_log_window = NULL;

MyViewer *viewer = NULL;

struct	NamedKeys named_key[] = {
	{"Space", 0x20},
	{"Alt L", 0xffe9},
	{"Alt R", 0xffea},
	{"Back", 0xEF26},
	{"BackSpace", 0xff08},
	{"Button", 0xfee8},
	{"Caps Lock", 0xffe5},
	{"Control L", 0xffe3},
	{"Control R", 0xffe4},
	{"Delete", 0xffff},
	{"Down", 0xff54},
	{"Eisu", 0xff2f},
	{"End", 0xff57},
	{"Enter", 0xff0d},
	{"Escape", 0xff1b},
	{"Function 1", 0xffbd},
	{"Function 2", 0xffbd+1},
	{"Function 3", 0xffbd+2},
	{"Function 4", 0xffbd+3},
	{"Function 5", 0xffbd+4},
	{"Function 6", 0xffbd+5},
	{"Function 7", 0xffbd+6},
	{"Function 8", 0xffbd+7},
	{"Function 9", 0xffbd+8},
	{"Function 10", 0xffbd+9},
	{"Function 11", 0xffbd+10},
	{"Function 12", 0xffbd+11},
	{"Favorites", 0xEF30},
	{"Forward", 0xEF27},
	{"Help", 0xff68},
	{"Home", 0xff50},
	{"Home Page", 0xEF18},
	{"Insert", 0xff63},
	{"Iso Key", 0xff0c},
	{"JIS Underscore", 0xff31},
	{"Kana", 0xff2e},
	{"KP 1", 0xff80 + '1'},
	{"KP 2", 0xff80 + '2'},
	{"KP 3", 0xff80 + '3'},
	{"KP 4", 0xff80 + '4'},
	{"KP 5", 0xff80 + '5'},
	{"KP 6", 0xff80 + '6'},
	{"KP 7", 0xff80 + '7'},
	{"KP 8", 0xff80 + '8'},
	{"KP 9", 0xff80 + '9'},
	{"KP 0", 0xff80 + '0'},
	{"KP +", 0xff80 + '+'},
	{"KP -", 0xff80 + '-'},
	{"KP Enter", 0xff8d},
	{"Left", 0xff51},
	{"Mail", 0xEF19},
	{"Media Next", 0xEF17},
	{"Media Play", 0xEF14},
	{"Media Prev", 0xEF16},
	{"Media Stop", 0xEF15},
	{"Menu", 0xff67},
	{"Meta L", 0xffe7},
	{"Meta R", 0xffe8},
	{"Num Lock", 0xff7f},
	{"Page Down", 0xff56},
	{"Page Up", 0xff55},
	{"Pause", 0xff13},
	{"Print", 0xff61},
	{"Refresh", 0xEF29},
	{"Right", 0xff53},
	{"Scroll Lock", 0xff14},
	{"Search", 0xEF1B},
	{"Shift L", 0xffe1},
	{"Shift R", 0xffe2},
	{"Sleep", 0xEF2F},
	{"Stop", 0xEF28},
	{"Tab", 0xff09},
	{"Up", 0xff52},
	{"Volume Down", 0xEF11},
	{"Volume Mute", 0xEF12},
	{"Volume Up", 0xEF13},
	{"Yen", 0xff30},
	{"", 0}
};

#ifdef _WIN32
#include <windows.h>
#else
#include <wordexp.h>
#endif

char	*StrAllocCat(char *one, char *two)
{
	if(two != NULL)
	{
		int n = 0;
		if(one != NULL)
		{
			n = (int)strlen(one);
		}
		one = (char *)realloc(one, n + (int)strlen(two) + 1);
		if(one != NULL)
		{
			if(n > 0)
			{
				strcat(one, two);
			}
			else
			{
				strcpy(one, two);
			}
		}
	}
	return(one);
}

void	blur_it(Camera *cam, int factor, int xx, int yy, int ww, int hh)
{
Mat	CropSection(Mat source, Mat& cropped, int xx, int yy, int ww, int hh);

	Mat use;
	CropSection(cam->mat, use, xx, yy, ww, hh);
	blur(use, use, Size(factor, factor));
	cairo_surface_t *surface = cairo_image_surface_create_for_data(use.ptr(), CAIRO_FORMAT_ARGB32, use.cols, use.rows, use.step);
	if(surface != NULL)
	{
		cairo_set_source_surface(cam->cairo_context, surface, xx, yy);
		cairo_paint(cam->cairo_context);
		cairo_surface_destroy(surface);
	}
}

void	mask_it(Mat mat, Mat &out, int point_cnt, int xx[1024], int yy[1024])
{
int	loop;

	cv::Point corners[1][1024];
	for(loop = 0;loop < point_cnt;loop++)
	{
		corners[0][loop] = Point(xx[loop], yy[loop]);
	}
	const Point *corner_list[1] = { corners[0] };

	int num_points = point_cnt;
	int num_polygons = 1;
	int line_type = 8;
	cv::Mat mask(mat.rows, mat.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
	cv::fillPoly(mask, corner_list, &num_points, num_polygons, cv::Scalar(255, 255, 255, 255), line_type);

	cv::Mat result;
	cv::bitwise_and(mat, mask, out);
}

void	erase_polygon(Mat mat, int point_cnt, int xx[1024], int yy[1024])
{
int	loop;

	cv::Point corners[1][1024];
	for(loop = 0;loop < point_cnt;loop++)
	{
		corners[0][loop] = Point(xx[loop], yy[loop]);
	}
	const Point *corner_list[1] = { corners[0] };

	int num_points = point_cnt;
	int num_polygons = 1;
	int line_type = 8;
	cv::fillPoly(mat, corner_list, &num_points, num_polygons, cv::Scalar(0, 0, 0, 0), line_type);
}

void	combine_on_color(Mat one, Mat two, int rr, int gg, int bb)
{
int	row, col;

	for(row = 0;row < two.rows;row++)
	{
		for(col = 0;col < two.cols;col++)
		{
			unsigned char *color1 = one.ptr(row, col);
			if((color1[0] == rr)
			&& (color1[1] == gg)
			&& (color1[2] == bb))
			{
				unsigned char *color2 = two.ptr(row, col);
				double r2 = (double)color2[0];
				double g2 = (double)color2[1];
				double b2 = (double)color2[2];

				color1[0] = r2;
				color1[1] = g2;
				color1[2] = b2;
			}
		}
	}
}

void	color_gradient(Mat& mat, int direction, Scalar start_color, Scalar end_color)
{
int	loop;
int	inner;

	if(direction == GRADIENT_DIRECTION_VERTICAL)
	{
		double red_inc = (end_color[0] - start_color[0]) / mat.rows;
		double green_inc = (end_color[1] - start_color[1]) / mat.rows;
		double blue_inc = (end_color[2] - start_color[2]) / mat.rows;
		double alpha_inc = (end_color[3] - start_color[3]) / mat.rows;
		for(loop = 0;loop < mat.rows;loop++)
		{
			double alpha = start_color[3] / 255.0;
			double beta = 1.0 - alpha;

			double sr2 = start_color[0];
			double sg2 = start_color[1];
			double sb2 = start_color[2];
			double r2 = sr2 * alpha;
			double g2 = sg2 * alpha;
			double b2 = sb2 * alpha;
			for(inner = 0;inner < mat.cols;inner++)
			{
				unsigned char *color1 = mat.ptr(loop, inner);
				double r1 = (double)color1[0] * beta;
				double g1 = (double)color1[1] * beta;
				double b1 = (double)color1[2] * beta;

				color1[0] = r1 + r2;
				color1[1] = g1 + g2;
				color1[2] = b1 + b2;
			}
			start_color[0] += red_inc;
			start_color[1] += green_inc;
			start_color[2] += blue_inc;
			start_color[3] += alpha_inc;
		}
	}
	else if(direction == GRADIENT_DIRECTION_HORIZONTAL)
	{
		double red_inc = (end_color[0] - start_color[0]) / mat.cols;
		double green_inc = (end_color[1] - start_color[1]) / mat.cols;
		double blue_inc = (end_color[2] - start_color[2]) / mat.cols;
		double alpha_inc = (end_color[3] - start_color[3]) / mat.cols;
		for(loop = 0;loop < mat.cols;loop++)
		{
			double alpha = start_color[3] / 255.0;
			double beta = 1.0 - alpha;

			double sr2 = start_color[0];
			double sg2 = start_color[1];
			double sb2 = start_color[2];
			double r2 = sr2 * alpha;
			double g2 = sg2 * alpha;
			double b2 = sb2 * alpha;
			for(inner = 0;inner < mat.rows;inner++)
			{
				unsigned char *color1 = mat.ptr(inner, loop);
				double r1 = (double)color1[0] * beta;
				double g1 = (double)color1[1] * beta;
				double b1 = (double)color1[2] * beta;

				color1[0] = r1 + r2;
				color1[1] = g1 + g2;
				color1[2] = b1 + b2;
			}
			start_color[0] += red_inc;
			start_color[1] += green_inc;
			start_color[2] += blue_inc;
			start_color[3] += alpha_inc;
		}
	}
}

void rounded_rectangle(Mat& src, Point topLeft, Point bottomRight, const Scalar lineColor, int thickness, const int lineType , const int cornerRadius)
{
	cv::Mat mat(src.rows, src.cols, CV_8UC3, cv::Scalar(0, 0, 0));

	Point p1 = topLeft;
	Point p2 = Point (bottomRight.x, topLeft.y);
	Point p3 = bottomRight;
	Point p4 = Point (topLeft.x, bottomRight.y);

	line(mat, Point(p1.x+cornerRadius,p1.y), Point(p2.x-cornerRadius,p2.y), lineColor, thickness, lineType);
	line(mat, Point(p2.x,p2.y+cornerRadius), Point(p3.x,p3.y-cornerRadius), lineColor, thickness, lineType);
	line(mat, Point(p4.x+cornerRadius,p4.y), Point(p3.x-cornerRadius,p3.y), lineColor, thickness, lineType);
	line(mat, Point(p1.x,p1.y+cornerRadius), Point(p4.x,p4.y-cornerRadius), lineColor, thickness, lineType);

	ellipse(mat, p1+Point(cornerRadius, cornerRadius), Size( cornerRadius, cornerRadius ), 180.0, 0, 90, lineColor, thickness, lineType);
	ellipse(mat, p2+Point(-cornerRadius, cornerRadius), Size( cornerRadius, cornerRadius ), 270.0, 0, 90, lineColor, thickness, lineType);
	ellipse(mat, p3+Point(-cornerRadius, -cornerRadius), Size( cornerRadius, cornerRadius ), 0.0, 0, 90, lineColor, thickness, lineType);
	ellipse(mat, p4+Point(cornerRadius, -cornerRadius), Size( cornerRadius, cornerRadius ), 90.0, 0, 90, lineColor, thickness, lineType);

	Point fillFrom(0, 0);
	floodFill(mat, fillFrom, lineColor);
	cvtColor(mat, mat, COLOR_RGB2RGBA);
	combine_on_color(mat, src, 0, 0, 0);
	src = mat.clone();
}

void	crop_mat(Mat& mat, int xx, int yy, int ww, int hh)
{
	cv::Rect roi;
	roi.x = xx;
	roi.y = yy;
	roi.width = ww;
	roi.height = hh;
	mat = mat(roi).clone();
}

void	brightness_mat(Mat& mat, double brightness)
{
	if(brightness != 0.5)
	{
		cvtColor(mat, mat, COLOR_RGBA2RGB);
		double rr = (400.0 * brightness) - 200.0;
		mat.convertTo(mat, -1, 1, rr);
		cvtColor(mat, mat, COLOR_RGB2RGBA);
	}
}

void	blur_mat(Mat& mat, double radius)
{
	if(radius > 1.0)
	{
		blur(mat, mat, Size(radius, radius));
	}
}

void	contrast_mat(Mat& mat, double contrast)
{
	if(contrast != 0.5)
	{
		double rr = 2.0 * contrast;
		mat.convertTo(mat, -1, rr, 0);
	}
}

void	clahe_mat(Mat& mat, double contrast)
{
	cv::Mat lab_image;
	cv::cvtColor(mat, lab_image, COLOR_BGR2Lab);

	std::vector<cv::Mat> lab_planes(3);
	cv::split(lab_image, lab_planes);  // now we have the L image in lab_planes[0]

	cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE();
	clahe->setClipLimit(contrast);
	cv::Mat dst;
	clahe->apply(lab_planes[0], dst);

	dst.copyTo(lab_planes[0]);
	cv::merge(lab_planes, lab_image);

	cv::Mat image_clahe;
	cv::cvtColor(lab_image, mat, COLOR_Lab2BGR);
}

Mat	change_saturation(Mat frame, double amount)
{
int	i, j;

	Mat hsv;
	cvtColor(frame, hsv, COLOR_RGB2HSV);
	const unsigned char hue_shift = 20;
	for(j = 0; j < frame.rows; j++)
	{
		for(i = 0; i < frame.cols; i++)
		{
			unsigned char h = hsv.at<Vec3b>(j, i)[1];
			double nn = h;
			nn *= amount;
			hsv.at<Vec3b>(j, i)[1] = (unsigned char)nn;
		}
	}
	cvtColor(hsv, frame, COLOR_HSV2RGB);
	cvtColor(frame, frame, COLOR_RGB2RGBA);
	return(frame);
}

Mat	change_hue(Mat frame, double amount)
{
int	i, j;

	Mat hsv;
	cvtColor(frame, hsv, COLOR_RGB2HSV);
	const unsigned char hue_shift = 20;
	for(j = 0; j < frame.rows; j++)
	{
		for(i = 0; i < frame.cols; i++)
		{
			unsigned char h = hsv.at<Vec3b>(j, i)[0];
			double nn = h;
			nn *= amount;
			hsv.at<Vec3b>(j, i)[0] = (unsigned char)nn;
		}
	}
	cvtColor(hsv, frame, COLOR_HSV2RGB);
	cvtColor(frame, frame, COLOR_RGB2RGBA);
	return(frame);
}

Mat	change_intensity(Mat frame, double amount)
{
int	i, j;

	Mat hsv;
	cvtColor(frame, hsv, COLOR_RGB2HSV);
	const unsigned char hue_shift = 20;
	for(j = 0; j < frame.rows; j++)
	{
		for(i = 0; i < frame.cols; i++)
		{
			unsigned char h = hsv.at<Vec3b>(j, i)[2];
			double nn = h;
			nn *= amount;
			hsv.at<Vec3b>(j, i)[2] = (unsigned char)nn;
		}
	}
	cvtColor(hsv, frame, COLOR_HSV2RGB);
	cvtColor(frame, frame, COLOR_RGB2RGBA);
	return(frame);
}

void sharpen2D(double amt, const cv::Mat &image, cv::Mat &result)
{
	Mat kernel(3, 3, CV_32F, cv::Scalar(0));

	kernel.at<float>(0, 0) = -1.0;
	kernel.at<float>(1, 0) = -1.0;
	kernel.at<float>(2, 0) = -1.0;
	kernel.at<float>(0, 1) = -1.0;
	kernel.at<float>(1, 1) = amt;
	kernel.at<float>(2, 1) = -1.0;
	kernel.at<float>(0, 2) = -1.0;
	kernel.at<float>(1, 2) = -1.0;
	kernel.at<float>(2, 2) = -1.0;

	filter2D(image, result, image.depth(), kernel);
}

char **split_command_line(const char *cmdline, int *argc)
{
int i;
char **argv = NULL;

	wordexp_t p;
	if(wordexp(cmdline, &p, 0))
	{
		return NULL;
	}
	*argc = p.we_wordc;
	if((argv = (char **)calloc(*argc, sizeof(char *))))
	{
		for(i = 0; i < p.we_wordc;i++)
		{
			argv[i] = strdup(p.we_wordv[i]);
		}
	}
	wordfree(&p);
	return argv;
}

pid_t	popen2(const char *command, int *infp, int *outfp)
{
int p_stdin[2], p_stdout[2];
pid_t pid;
int loop;

	if(pipe(p_stdin) != 0 || pipe(p_stdout) != 0)
	{
		return(-1);
	}
	pid = fork();
	if(pid < 0)
	{
		return(pid);
	}
	else if(pid == 0)
	{
		close(p_stdin[WRITE]);
		dup2(p_stdin[READ], READ);
		close(p_stdout[READ]);
		dup2(p_stdout[WRITE], WRITE);

		int argc = 0;
		char **argv = split_command_line(command, &argc);
		execvp(argv[0], argv);
		exit(1);
	}
	if(infp == NULL)
	{
		close(p_stdin[WRITE]);
	}
	else
	{
		*infp = p_stdin[WRITE];
	}
	if(outfp == NULL)
	{
		close(p_stdout[READ]);
	}
	else
	{
		*outfp = p_stdout[READ];
	}
	return(pid);
}

void	my_cairo_set_line_style(cairo_t *context, int style, int width)
{
	cairo_set_line_cap(context, CAIRO_LINE_CAP_SQUARE);
	if((style & FL_CAP_ROUND) == FL_CAP_ROUND)
	{
		cairo_set_line_cap(context, CAIRO_LINE_CAP_ROUND);
	}
	if((style & FL_JOIN_ROUND) == FL_JOIN_ROUND)
	{
		cairo_set_line_join(context, CAIRO_LINE_JOIN_ROUND);
	}
	if((style & FL_JOIN_MITER) == FL_JOIN_MITER)
	{
		cairo_set_line_join(context, CAIRO_LINE_JOIN_MITER);
	}
	if((style & FL_JOIN_BEVEL) == FL_JOIN_BEVEL)
	{
		cairo_set_line_join(context, CAIRO_LINE_JOIN_BEVEL);
	}
	if((style & FL_DASH) == FL_DASH)
	{
  		static const double dashed2[] = {14.0, 12.0};
  		static int len2  = sizeof(dashed2) / sizeof(dashed2[0]);
		cairo_set_dash(context, dashed2, len2, 1);
		cairo_set_line_cap(context, CAIRO_LINE_CAP_SQUARE);
	}
	else if((style & FL_DOT) == FL_DOT)
	{
  		static const double dashed2[] = {1.0, 12.0};
  		static int len2  = sizeof(dashed2) / sizeof(dashed2[0]);
		cairo_set_dash(context, dashed2, len2, 1);
		cairo_set_line_cap(context, CAIRO_LINE_CAP_ROUND);
	}
	else
	{
		cairo_set_dash(context, NULL, 0, 1);
	}
	cairo_set_line_width(context, width);
}

void	my_cairo_set_source_rgb(cairo_t *context, int r, int g, int b)
{
	double rr = (double)r / 255.0;
	double gg = (double)g / 255.0;
	double bb = (double)b / 255.0;
	
	cairo_set_source_rgb(context, bb, gg, rr);
}

void	my_cairo_set_source_rgba(cairo_t *context, int r, int g, int b, int a)
{
	double rr = (double)r / 255.0;
	double gg = (double)g / 255.0;
	double bb = (double)b / 255.0;
	double aa = (double)a / 255.0;
	
	cairo_set_source_rgba(context, bb, gg, rr, aa);
}

int		parse_newlines(char *in, char **out)
{
	int cnt = 0;
	char *cp = in;
	out[cnt] = cp;
	cnt++;
	while(*cp != '\0')
	{
		if(*cp == 10)
		{
			*cp = '\0';
			cp++;
			out[cnt] = cp;
			cnt++;
		}
		cp++;
	}
	return(cnt);
}

void	my_cairo_draw_text(cairo_t *cr, int xx, int yy, char *text, char *font_name, int style, int size, int cur_pos, int r, int g, int b, int a, int out_r, int out_g, int out_b, int out_a)
{
int	interpret_output_path(MyWin *win, char *in, char *out);
int	loop;
int	inner;

	cairo_font_slant_t slant = CAIRO_FONT_SLANT_NORMAL;
	cairo_font_weight_t bold = CAIRO_FONT_WEIGHT_NORMAL;
	if((style & FONT_STYLE_ITALIC) == FONT_STYLE_ITALIC)
	{
		slant = CAIRO_FONT_SLANT_ITALIC;
	}
	if((style & FONT_STYLE_BOLD) == FONT_STYLE_BOLD)
	{
		bold = CAIRO_FONT_WEIGHT_BOLD;
	}
	my_cairo_set_source_rgba(cr, r, g, b, a);
	cairo_select_font_face(cr, font_name, slant, bold);
	cairo_set_font_size(cr, size);

	char out[32768];
	interpret_output_path(NULL, text, out);
	char cc[2];
	char *cp = out;
	int save_x = xx;
	inner = 0;
	while(*cp != '\0')
	{
		cc[0] = *cp;
		cc[1] = '\0';
		if(*cp == 10)
		{
			if(inner == cur_pos)
			{
				cairo_set_line_width(cr, 2.0);
				cairo_move_to(cr, xx, yy);
				cairo_line_to(cr, xx, yy - size);
				cairo_stroke(cr);
			}
			yy += size;
			xx = save_x;
		}
		else
		{
			cairo_move_to(cr, xx, yy);
			if((style & FONT_STYLE_OUTLINE) == FONT_STYLE_OUTLINE)
			{
				my_cairo_set_source_rgba(cr, r, g, b, a);
				cairo_text_path(cr, cc);
				cairo_fill_preserve(cr);
				my_cairo_set_source_rgba(cr, out_r, out_g, out_b, out_a);
				cairo_set_line_width(cr, 2.56);
				cairo_stroke(cr);
			}
			else
			{
				if(inner == cur_pos)
				{
					cairo_set_line_width(cr, 2.0);
					cairo_line_to(cr, xx, yy - size);
					cairo_stroke(cr);
					cairo_move_to(cr, xx, yy);
				}
				cairo_show_text(cr, cc);
			}
			cairo_text_extents_t extents;
			cairo_text_extents(cr, cc, &extents);
			xx += extents.x_advance;
		}
		inner++;
		cp++;
	}
	if(inner == cur_pos)
	{
		cairo_set_line_width(cr, 2.0);
		cairo_move_to(cr, xx, yy);
		cairo_line_to(cr, xx, yy - size);
		cairo_stroke(cr);
	}
}

void	test_blend(int xx, int yy, int ww, int hh, int width, int height, int stride, void *data_in, BLImageData *data_out)
{
	BLImage img;
	img.createFromData(width, height, BL_FORMAT_PRGB32, data_in, stride);
	BLContext ctx(img);

	ctx.setFillStyle(BLRgba32(255, 0, 0));
	ctx.fillRect(xx, yy, ww, hh);

	ctx.end();
	img.makeMutable(data_out);
}

int	force_to_grid2(int grid_sz, int use_x)
{
	int nx = use_x % grid_sz;
	if(nx != 0)
	{
		double nx = (double)use_x / (double)grid_sz;
		nx = round(nx);
		use_x = nx * grid_sz;
	}
	return(use_x);
}

int	force_to_grid(int grid_sz, int use_x)
{
	int nx = use_x % grid_sz;
	if(nx != 0)
	{
		double nx = (double)use_x / (double)grid_sz;
		nx = round(nx);
		use_x = nx * grid_sz;
	}
	return(use_x);
}

void	strip_lf(char *in)
{
	char *cp = in;
	while(*cp != '\0')
	{
		if((*cp == 10) || (*cp == 13))
		{
			*cp = '\0';
		}
		cp++;
	}
}

void	change_alpha(Mat rgba, int direction)
{
	for(int y = 0; y < rgba.rows; ++y)
	{
		for(int x = 0; x < rgba.cols; ++x)
		{
			cv::Vec4b & pixel = rgba.at<cv::Vec4b>(y, x);
			int val = pixel[3];
			if(direction > 0)
			{
				if(val < 255)
				{
					pixel[3]++;
				}
			}
			else
			{
				if(val > 0)
				{
					pixel[3]--;
				}
			}
		}
	}
}

static int cmpstringp(const void *p1, const void *p2)
{
	return strcmp(*(char * const *)p1, *(char * const *)p2);
}

long int local_timestamp()
{
struct timeval tv;
	
	gettimeofday(&tv, NULL);
	long int ts = ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
	return(ts);
}

long int precise_time()
{
struct timeval tv;
	
	gettimeofday(&tv, NULL);
	long int ts = (tv.tv_sec * 1000000) + tv.tv_usec;
	return(ts);
}

long int filelength(int fd)
{
long int size = -1;
struct stat stat_buf;

	size = 0;
	if(fstat(fd, &stat_buf) == 0)
	{
		size = stat_buf.st_size;
	}
	return(size);
}

int	interpret_output_path(MyWin *win, char *in, char *out)
{
char	buf[256];

	char *cp_in = in;
	char *cp_out = out;
	time_t now = time(0);
	struct tm *tm = localtime(&now);
	strcpy(out, "");
	while(*cp_in != '\0')
	{
		if(strncmp(cp_in, "%home", 5) == 0)
		{
			sprintf(buf, "%s", getenv("HOME"));
			strcat(cp_out, buf);
			cp_in += 5;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%frame", 6) == 0)
		{
			if(win != NULL)
			{
				sprintf(buf, "%06d", win->recorded_frames);
				strcat(cp_out, buf);
				cp_out += strlen(buf);
			}
			cp_in += 6;
		}
		else if(strncmp(cp_in, "%source", 7) == 0)
		{
			if(win != NULL)
			{
				Camera *cam = win->DisplayedCamera();
				if(cam != NULL)
				{
					char *str = cam->path;
					if(strlen(cam->alias) > 0)
					{
						str = cam->alias;
					}
					strcat(cp_out, str);
					cp_out += strlen(str);
				}
				cp_in += 7;
			}
		}
		else if(strncmp(cp_in, "%cwd", 5) == 0)
		{
			sprintf(buf, "%s", getenv("PWD"));
			strcat(cp_out, buf);
			cp_in += 4;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%Y", 2) == 0)
		{
			sprintf(buf, "%d", 1900 + tm->tm_year);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%M", 2) == 0)
		{
			sprintf(buf, "%d", tm->tm_mon + 1);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%D", 2) == 0)
		{
			sprintf(buf, "%d", tm->tm_mday);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%h", 2) == 0)
		{
			sprintf(buf, "%02d", tm->tm_hour);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%m", 2) == 0)
		{
			sprintf(buf, "%02d", tm->tm_min);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%s", 2) == 0)
		{
			sprintf(buf, "%02d", tm->tm_sec);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%u", 2) == 0)
		{
			sprintf(buf, "%ld", precise_time());
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%U", 2) == 0)
		{
			sprintf(buf, "%ld", precise_time() / 1000);
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%S", 2) == 0)
		{
			sprintf(buf, "%ld", time(0));
			strcat(cp_out, buf);
			cp_in += 2;
			cp_out += strlen(buf);
		}
		else if(strncmp(cp_in, "%d", 2) == 0)
		{
			if(win != NULL)
			{
				Camera *cam = win->DisplayedCamera();
				if(cam != NULL)
				{
					int total_seconds = cam->running_time / 1000;
					int minutes = total_seconds / 60;
					int seconds = total_seconds % 60;
					sprintf(buf, "%03d:%02d", minutes, seconds);
					strcat(cp_out, buf);
					cp_in += 2;
					cp_out += strlen(buf);
				}
			}
		}
		else
		{
			*cp_out = *cp_in;
			cp_in++;
			cp_out++;
		}
		*cp_out = '\0';
	}
	int streaming = 0;
	char *cp = out;
	while(*cp != '\0')
	{
		if(strncmp(cp, "://", 3) == 0)
		{
			streaming = 1;
		}
		cp++;
	}
	return(streaming);
}

void	swap_rgb(unsigned char *ptr, int sz)
{
int	 loop;

	for(loop = 0;loop < (sz / 3);loop++)
	{
		unsigned char *r = ptr;
		unsigned char *b = (ptr + 2);
		unsigned char t = *r;
		*r = *b;
		*b = t;
		ptr += 3;
	}
}

int	write_frame(int fd, void *ptr, int sz, long int ts)
{
	int nn = -1;
	nn = write(fd, &ts, sizeof(long int));
	if(nn == sizeof(long int))
	{
		nn = write(fd, ptr, sz);
	}
	return(nn);
}

int	write_frame(int fd, void *ptr, int w, int h, long int ts)
{
	int nn = -1;
	cv::Mat image(cv::Size(w, h), CV_8UC4, ptr);
	std::vector<uchar> buffer;
	imencode(".jpg", image, buffer);
	long int sz = buffer.size();
	nn = write(fd, &ts, sizeof(long int));
	nn = write(fd, &sz, sizeof(long int));
	nn = write(fd, buffer.data(), sz);
	return(nn);
}

int	read_frame(int fd, void *ptr, int sz, long int *ts)
{
	int nn = -1;
	nn = read(fd, ts, sizeof(long int));
	if(nn == sizeof(long int))
	{
		nn = read(fd, ptr, sz);
	}
	return(nn);
}

int	read_frame(int fd, void *ptr, int w, int h, long int *ts)
{
	int nn = -1;
	long int sz = 0;
	nn = read(fd, ts, sizeof(long int));
	nn = read(fd, &sz, sizeof(long int));
	if(nn == sizeof(long int))
	{
		nn = read(fd, ptr, sz);
		cv::Mat mat;
		mat = cv::imdecode(cv::Mat(1, sz, CV_8UC1, ptr), IMREAD_UNCHANGED);
		memcpy(ptr, mat.ptr(), w * h * 3);
	}
	return(nn);
}

void	dump_object(int fd, void *thing, int sz)
{
	long int nn = (long int)thing;
	write(fd, &sz, sizeof(int));
	write(fd, &nn, sizeof(long int));
	write(fd, thing, sz);
}

int	CreateTask(int (*funct)(int *), void *flag)
{
int	 	status;
pthread_t	mythread;
pthread_attr_t	attr;

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	if(pthread_create(&mythread, &attr, (void * (*)(void *))funct, flag))
	{
		fprintf(stderr, "Error: Cannot create a new thread.\n");
	}
	return((int)mythread);
}

void	copy_frame(unsigned char *dest, unsigned char *src, int sz)
{
	memcpy(dest, src, sz);
}

int	fifo_save_frame(int *flag)
{
int	loop;

	SaveFIFO *fifo = (SaveFIFO *)flag;
	if(fifo != NULL)
	{
		int last_ts = 0;
		while(fifo->done == 0)
		{
			if(fifo->top > 0)
			{
				long int fifo_start_ts = local_timestamp();
				int limit = fifo->top;
				for(loop = 0;loop < fifo->top;loop++)
				{
					pthread_mutex_lock(&fifo->mutex[loop]);
					if(fifo->frame[loop] != NULL)
					{
						if(fifo->use_ts > (last_ts + 29))
						{
							write_frame(fifo->fd, fifo->frame[loop], fifo->frame_sz, fifo->use_ts);
							last_ts = fifo->use_ts;
						}
						free(fifo->frame[loop]);
						fifo->frame[loop] = NULL;
					}
					pthread_mutex_unlock(&fifo->mutex[loop]);
				}
				fifo->top = 0;
			}
			else
			{
				usleep(10);
			}
		}
	}
	return(0);
}

XImage  *CreateSharedImage(XShmSegmentInfo *shminfo, int in_ww, int in_hh)
{
	XImage *image = XShmCreateImage(fl_display, DefaultVisual(fl_display, 0), 24, ZPixmap, NULL, shminfo, in_ww, in_hh);
	shminfo->shmid = shmget(IPC_PRIVATE, image->bytes_per_line * image->height, IPC_CREAT | 0777);
	shminfo->shmaddr = image->data = (char *)shmat(shminfo->shmid, 0, 0);
	shminfo->readOnly = False;
	XShmAttach(fl_display, shminfo);

	return(image);
}

void	DestroySharedImage(XImage *image, XShmSegmentInfo *shminfo)
{
	if(image != NULL)
	{
		XShmDetach(fl_display, shminfo);
		XDestroyImage(image);
		shmdt(shminfo->shmaddr);
		shmctl(shminfo->shmid, IPC_RMID, 0);
	}
}

unsigned char *grab_raw_desktop_image()
{
unsigned char	*fl_read_image(unsigned char *, int, int, int, int, int = 0);

	unsigned char *r_data = NULL;
	int start_x = 0;
	int start_y = 0;
	int start_w = Fl::w();
	int start_h = Fl::h();
	Window xwin = RootWindow(fl_display, fl_screen);

	int use_x = 0;
	int use_y = 0;
	int my_depth = 4;

	fl_window = xwin;
	unsigned char *b = fl_read_image((unsigned char *)NULL, use_x, use_y, start_w, start_h, 0);
	r_data = b;
	return(r_data);
}

void	convert_fourcc(int fourcc, char &c1, char &c2, char &c3, char &c4)
{
	c1 = fourcc & 255;
	c2 = (fourcc >> 8) & 255;
	c3 = (fourcc >> 16) & 255;
	c4 = (fourcc >> 24) & 255;
}

int	get_title_bar_height(Fl_Window *win)
{
Atom		t;
int		f;
unsigned long	n, b;
unsigned char	*data = 0;
XEvent		e;
long		*extents;

	Atom a = XInternAtom(fl_display, "_NET_FRAME_EXTENTS", True);
	while(XGetWindowProperty(fl_display, fl_xid(win), a, 0, 4, False, AnyPropertyType, &t, &f, &n, &b, &data) != Success || n != 4 || b != 0)
	{
		XNextEvent(fl_display, &e);
	}
	extents = (long *)data;
	printf("%ld %ld %ld %ld\n", extents[0], extents[1], extents[2], extents[3]);
	int hh = (int)extents[2];
	return(hh);
}

void	invert_mat(Mat one)
{
int	row, col;

	for(row = 0;row < one.rows;row++)
	{
		for(col = 0;col < one.cols;col++)
		{
			unsigned char *color1 = one.ptr(row, col);

			unsigned char r1 = (double)color1[0];
			unsigned char g1 = (double)color1[1];
			unsigned char b1 = (double)color1[2];

			color1[0] = 255 - r1;
			color1[1] = 255 - g1;
			color1[2] = 255 - b1;
		}
	}
}

void	chromakey2(Mat& src, Mat& img, Mat& result, double a1, double a2)
{
	Size S = Size((int)src.cols, (int)src.rows);

	src.convertTo(src, CV_32FC3, 1.0 / 255);
	img.convertTo(img, CV_32FC3, 1.0 / 255);

	Mat res_front, res_back, res;
	vector<Mat> channels, img_channels;

	Mat alpha = Mat::zeros(S, CV_32F);
	split(src, channels);
	split(img, img_channels);

	alpha = Scalar::all(1.0) - a1 * (channels[1] - a2 * channels[0]);
 
	threshold(alpha, alpha, 1, 1, THRESH_TRUNC);
	threshold(-1 * alpha, alpha, 0, 0, THRESH_TRUNC);
	alpha = -1 * alpha;

	for(int i = 0;i < 3; ++i) 
	{
		multiply(alpha, channels[i], channels[i]);
		multiply(Scalar::all(1.0) - alpha, img_channels[i], img_channels[i]);  
	}
	merge(channels, res_front);
	merge(img_channels, res_back);

	res = res_front + res_back;
	res.convertTo(res, CV_8UC4, 255);

	result = res.clone();
}

void	chromakey(Mat& src, Mat& result, int use_color, double a1, double a2)
{
	Size S = Size((int)src.cols, (int)src.rows);

	src.convertTo(src, CV_32FC4, 1.0 / 255);

	Mat res;
	vector<Mat> channels, img_channels;

	Mat alpha = Mat::zeros(S, CV_32F);
	split(src, channels);

	if(use_color == CHROMA_ON_GREEN)
	{
		alpha = Scalar::all(1.0) - a1 * (channels[1] - a2 * channels[0]);
	}
	else if(use_color == CHROMA_ON_BLUE)
	{
		alpha = Scalar::all(1.0) - a1 * (channels[2] - a2 * channels[0]);
	}
	threshold(alpha, alpha, 1, 1, THRESH_TRUNC);
	threshold(-1 * alpha, alpha, 0, 0, THRESH_TRUNC);
	alpha = -1 * alpha;

	for(int i = 0;i < 3; ++i) 
	{
		multiply(alpha, channels[i], channels[i]);
	}
	Mat rgb[4] = {channels[0], channels[1], channels[2], alpha};
	merge(rgb, 4, res);

	res.convertTo(res, CV_8UC4, 255);

	result = res.clone();
}

void	immediate_drawing_mode_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *id = (ImmediateDrawingWindow *)v;
	MyWin *win = id->my_window;
	Camera *cam = win->DisplayedCamera();

	id->general->labelcolor(FL_WHITE);
	id->text->labelcolor(FL_WHITE);
	id->line->labelcolor(FL_WHITE);
	id->rectangle->labelcolor(FL_WHITE);
	id->ellipse->labelcolor(FL_WHITE);
	id->image_im->labelcolor(FL_WHITE);
	id->polygon->labelcolor(FL_WHITE);
	id->loop->labelcolor(FL_WHITE);
	id->freehand->labelcolor(FL_WHITE);
	id->pixelate->labelcolor(FL_WHITE);
	id->select_rectangle->labelcolor(FL_WHITE);
	id->select_polygon->labelcolor(FL_WHITE);
	id->delete_im->labelcolor(FL_WHITE);
	id->hide_im->labelcolor(FL_WHITE);
	id->hide_all->labelcolor(FL_WHITE);
	id->show_all->labelcolor(FL_WHITE);

	if(w == id->general)
	{
		win->im_drawing_mode = 1;
		id->general->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_GENERAL;
		id->selected_widget = NULL;
		id->GeneralSetup();
	}
	else if(w == id->text)
	{
		win->im_drawing_mode = 1;
		id->text->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_TEXT;
		id->selected_widget = NULL;
		id->TextSetup();
	}
	else if(w == id->line)
	{
		win->im_drawing_mode = 1;
		id->line->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_LINE;
		id->selected_widget = NULL;
		id->LineSetup();
	}
	else if(w == id->polygon)
	{
		win->im_drawing_mode = 1;
		id->polygon->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_POLYGON;
		id->selected_widget = NULL;
		id->LineSetup();
	}
	else if(w == id->select_polygon)
	{
		win->im_drawing_mode = 1;
		id->select_polygon->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_POLYGON_SELECT;
		id->general_group->hide();
		id->text_group->hide();
		id->line_group->hide();
		id->rectangle_group->hide();
		id->image_group->hide();
		id->freehand_group->hide();
		id->selected_widget = NULL;
		id->resize(id->x(), id->y(), 120 * id->gsf, 420 * id->gsf);
	}
	else if(w == id->loop)
	{
		win->im_drawing_mode = 1;
		id->loop->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_LOOP;
		id->selected_widget = NULL;
		id->LineSetup();
	}
	else if(w == id->rectangle)
	{
		win->im_drawing_mode = 1;
		id->rectangle->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_RECTANGLE;
		id->selected_widget = NULL;
		id->RectangleSetup();
	}
	else if(w == id->pixelate)
	{
		win->im_drawing_mode = 1;
		id->pixelate->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_PIXELATE;
		id->selected_widget = NULL;
		id->PixelateSetup();
	}
	else if(w == id->image_im)
	{
		win->im_drawing_mode = 1;
		id->image_im->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_IMAGE;
		id->selected_widget = NULL;
		id->ImageSetup();
	}
	else if(w == id->ellipse)
	{
		win->im_drawing_mode = 1;
		id->ellipse->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_ELLIPSE;
		id->selected_widget = NULL;
		id->RectangleSetup();
	}
	else if(w == id->freehand)
	{
		win->im_drawing_mode = 1;
		id->freehand->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_FREEHAND;
		id->selected_widget = NULL;
		id->FreehandSetup();
	}
	else if(w == id->select_rectangle)
	{
		win->im_drawing_mode = 1;
		id->select_rectangle->labelcolor(FL_YELLOW);
		id->mode = DRAWING_MODE_RECTANGLE_SELECT;
		id->general_group->hide();
		id->text_group->hide();
		id->line_group->hide();
		id->rectangle_group->hide();
		id->image_group->hide();
		id->freehand_group->hide();
		id->selected_widget = NULL;
		id->resize(id->x(), id->y(), 120 * id->gsf, 420 * id->gsf);
	}
	else if(w == id->delete_im)
	{
		win->im_drawing_mode = 1;
		id->delete_im->labelcolor(FL_YELLOW);
		id->general_group->hide();
		id->text_group->hide();
		id->line_group->hide();
		id->rectangle_group->hide();
		id->image_group->hide();
		id->freehand_group->hide();
		id->mode = DRAWING_MODE_DELETE;
		id->selected_widget = NULL;
		id->resize(id->x(), id->y(), 120 * id->gsf, 420 * id->gsf);
	}
	else if(w == id->hide_im)
	{
		win->im_drawing_mode = 1;
		id->hide_im->labelcolor(FL_YELLOW);
		id->general_group->hide();
		id->text_group->hide();
		id->line_group->hide();
		id->freehand_group->hide();
		id->rectangle_group->hide();
		id->image_group->hide();
		id->mode = DRAWING_MODE_HIDE;
		id->selected_widget = NULL;
		id->resize(id->x(), id->y(), 120 * id->gsf, 420 * id->gsf);
	}
	else if(w == id->hide_all)
	{
		win->im_drawing_mode = 1;
		id->general_group->hide();
		id->text_group->hide();
		id->line_group->hide();
		id->freehand_group->hide();
		id->rectangle_group->hide();
		id->image_group->hide();
		id->mode = DRAWING_MODE_HIDE_ALL;
		id->selected_widget = NULL;
		id->resize(id->x(), id->y(), 120 * id->gsf, 420 * id->gsf);
		Camera *cam = id->my_window->DisplayedCamera();
		if(cam->immediate_list != NULL)
		{
			int loop;
			for(loop = 0;loop < cam->immediate_cnt;loop++)
			{
				if(cam->immediate_list[loop] != NULL)
				{
					cam->immediate_list[loop]->Hide();
				}
			}
		}
	}
	else if(w == id->show_all)
	{
		win->im_drawing_mode = 1;
		id->general_group->hide();
		id->text_group->hide();
		id->line_group->hide();
		id->freehand_group->hide();
		id->rectangle_group->hide();
		id->image_group->hide();
		id->mode = DRAWING_MODE_SHOW_ALL;
		id->selected_widget = NULL;
		id->resize(id->x(), id->y(), 120 * id->gsf, 420 * id->gsf);
		Camera *cam = id->my_window->DisplayedCamera();
		if(cam->immediate_list != NULL)
		{
			int loop;
			for(loop = 0;loop < cam->immediate_cnt;loop++)
			{
				if(cam->immediate_list[loop] != NULL)
				{
					cam->immediate_list[loop]->Show();
				}
			}
		}
	}
	id->redraw();
}

void	drawing_font_selection_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hold_Browser *hold = (Fl_Hold_Browser *)w;
	char *str = (char *)hold->text(hold->value());
	if(str != NULL)
	{
		idw->font_num = (int)(long int)hold->data(hold->value());
		strcpy(idw->selected_font, str);
		idw->font_output->label(str);
		idw->font_output->labelfont(idw->font_num);
		idw->font_sample->labelfont(idw->font_num);
		idw->font_sample->redraw();
		if(idw->selected_widget != NULL)
		{
			if(idw->selected_widget->text != NULL)
			{
				idw->selected_widget->text->textfont(idw->font_num);
				strncpy(idw->selected_widget->text->font_name, str, 128);
				idw->selected_widget->redraw();
			}
		}
	}
}

void	drawing_font_color_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	int use = 255;
	if(slider == idw->font_red_slider)
	{
		if(idw->using_background_color == 2)
		{
			idw->outline_color_red = (int)slider->value();
			use = idw->outline_color_red;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_red = (int)slider->value();
			use = idw->back_color_red;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_red = (int)slider->value();
			use = idw->font_color_red;
		}
		sprintf(buf, "%3d", use);
		idw->font_red_output->value(buf);
	}
	else if(slider == idw->font_green_slider)
	{
		if(idw->using_background_color == 2)
		{
			idw->outline_color_green = (int)slider->value();
			use = idw->outline_color_green;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_green = (int)slider->value();
			use = idw->back_color_green;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_green = (int)slider->value();
			use = idw->font_color_green;
		}
		sprintf(buf, "%3d", use);
		idw->font_green_output->value(buf);
	}
	else if(slider == idw->font_blue_slider)
	{
		if(idw->using_background_color == 2)
		{
			idw->outline_color_blue = (int)slider->value();
			use = idw->outline_color_blue;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_blue = (int)slider->value();
			use = idw->back_color_blue;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_blue = (int)slider->value();
			use = idw->font_color_blue;
		}
		sprintf(buf, "%3d", use);
		idw->font_blue_output->value(buf);
	}
	else if(slider == idw->font_alpha_slider)
	{
		if(idw->using_background_color == 2)
		{
			idw->outline_color_alpha = (int)slider->value();
			use = idw->outline_color_alpha;
		}
		else if(idw->using_background_color == 1)
		{
			idw->back_color_alpha = (int)slider->value();
			use = idw->back_color_alpha;
		}
		else if(idw->using_background_color == 0)
		{
			idw->font_color_alpha = (int)slider->value();
			use = idw->font_color_alpha;
		}
		sprintf(buf, "%3d", use);
		idw->font_alpha_output->value(buf);
	}
	if(idw->using_background_color == 2)
	{
		idw->font_sample->color(fl_rgb_color(idw->outline_color_red, idw->outline_color_green, idw->outline_color_blue));
		idw->font_sample->redraw();
	}
	else if(idw->using_background_color == 1)
	{
		idw->font_sample->color(fl_rgb_color(idw->back_color_red, idw->back_color_green, idw->back_color_blue));
		idw->font_sample->redraw();
		if(idw->selected_widget != NULL)
		{
			if(idw->selected_widget->text != NULL)
			{
				idw->selected_widget->text->color(fl_rgb_color(idw->back_color_red, idw->back_color_green, idw->back_color_blue));
				idw->selected_widget->text->background_red = idw->back_color_red;
				idw->selected_widget->text->background_green = idw->back_color_green;
				idw->selected_widget->text->background_blue = idw->back_color_blue;
				idw->selected_widget->text->background_alpha = idw->back_color_alpha;
				idw->selected_widget->redraw();
			}
		}
	}
	else
	{
		idw->font_sample->labelcolor(fl_rgb_color(idw->font_color_red, idw->font_color_green, idw->font_color_blue));
		idw->font_sample->redraw();
		if(idw->selected_widget != NULL)
		{
			if(idw->selected_widget->text != NULL)
			{
				idw->selected_widget->text->textcolor(fl_rgb_color(idw->font_color_red, idw->font_color_green, idw->font_color_blue));
				idw->selected_widget->text->red = idw->font_color_red;
				idw->selected_widget->text->green = idw->font_color_green;
				idw->selected_widget->text->blue = idw->font_color_blue;
				idw->selected_widget->text->font_alpha = idw->font_color_alpha;
				idw->selected_widget->redraw();
			}
		}
	}
}

void	drawing_line_color_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	if(slider == idw->line_red_slider)
	{
		idw->line_color_red = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_red);
		idw->line_red_output->value(buf);
	}
	else if(slider == idw->line_green_slider)
	{
		idw->line_color_green = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_green);
		idw->line_green_output->value(buf);
	}
	else if(slider == idw->line_blue_slider)
	{
		idw->line_color_blue = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_blue);
		idw->line_blue_output->value(buf);
	}
	else if(slider == idw->line_alpha_slider)
	{
		idw->line_color_alpha = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_alpha);
		idw->line_alpha_output->value(buf);
	}
	idw->line_sample->labelcolor(fl_rgb_color(idw->line_color_red, idw->line_color_green, idw->line_color_blue));
	idw->line_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->line != NULL)
		{
			idw->selected_widget->line->red = idw->line_color_red;
			idw->selected_widget->line->green = idw->line_color_green;
			idw->selected_widget->line->blue = idw->line_color_blue;
			idw->selected_widget->line->alpha = idw->line_color_alpha;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_rectangle_color_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	if(slider == idw->rectangle_red_slider)
	{
		idw->rectangle_color_red = (int)slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_red);
		idw->rectangle_red_output->value(buf);
	}
	else if(slider == idw->rectangle_green_slider)
	{
		idw->rectangle_color_green = (int)slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_green);
		idw->rectangle_green_output->value(buf);
	}
	else if(slider == idw->rectangle_blue_slider)
	{
		idw->rectangle_color_blue = (int)slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_blue);
		idw->rectangle_blue_output->value(buf);
	}
	else if(slider == idw->rectangle_alpha_slider)
	{
		idw->rectangle_color_alpha = (int)slider->value();
		sprintf(buf, "%3d", idw->rectangle_color_alpha);
		idw->rectangle_alpha_output->value(buf);
	}
	idw->rectangle_sample->labelcolor(fl_rgb_color(idw->rectangle_color_red, idw->rectangle_color_green, idw->rectangle_color_blue));
	idw->rectangle_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if((idw->selected_widget->rectangle != NULL) && (idw->mode == DRAWING_MODE_RECTANGLE))
		{
			idw->selected_widget->rectangle->red = idw->rectangle_color_red;
			idw->selected_widget->rectangle->green = idw->rectangle_color_green;
			idw->selected_widget->rectangle->blue = idw->rectangle_color_blue;
			idw->selected_widget->rectangle->alpha = idw->rectangle_color_alpha;
			idw->selected_widget->redraw();
		}
		else if((idw->selected_widget->ellipse != NULL) && (idw->mode == DRAWING_MODE_ELLIPSE))
		{
			idw->selected_widget->ellipse->red = idw->rectangle_color_red;
			idw->selected_widget->ellipse->green = idw->rectangle_color_green;
			idw->selected_widget->ellipse->blue = idw->rectangle_color_blue;
			idw->selected_widget->ellipse->alpha = idw->rectangle_color_alpha;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_freehand_color_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	if(slider == idw->freehand_red_slider)
	{
		idw->line_color_red = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_red);
		idw->freehand_red_output->value(buf);
	}
	else if(slider == idw->freehand_green_slider)
	{
		idw->line_color_green = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_green);
		idw->freehand_green_output->value(buf);
	}
	else if(slider == idw->freehand_blue_slider)
	{
		idw->line_color_blue = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_blue);
		idw->freehand_blue_output->value(buf);
	}
	else if(slider == idw->freehand_alpha_slider)
	{
		idw->line_color_alpha = (int)slider->value();
		sprintf(buf, "%3d", idw->line_color_alpha);
		idw->freehand_alpha_output->value(buf);
	}
	idw->freehand_sample->labelcolor(fl_rgb_color(idw->line_color_red, idw->line_color_green, idw->line_color_blue));
	idw->freehand_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->freehand != NULL)
		{
			idw->selected_widget->freehand->red = idw->line_color_red;
			idw->selected_widget->freehand->green = idw->line_color_green;
			idw->selected_widget->freehand->blue = idw->line_color_blue;
			idw->selected_widget->freehand->alpha = idw->line_color_alpha;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_font_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->font_size = (int)slider->value();
	idw->font_sample->labelsize(idw->font_size);
	sprintf(buf, "%3d", idw->font_size);
	idw->font_size_output->value(buf);
	idw->font_size_output->redraw();
	idw->font_sample->redraw();
	idw->text_group->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->text != NULL)
		{
			idw->selected_widget->text->textsize(idw->font_size);
			idw->selected_widget->text->use_size = idw->font_size;
			idw->selected_widget->text->redraw();
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_line_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->line_size = (int)slider->value();
	idw->line_sample->labelsize(idw->line_size);
	idw->line_sample->redraw();
	sprintf(buf, "%3d", idw->line_size);
	idw->line_size_output->value(buf);
	idw->line_size_output->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->line != NULL)
		{
			idw->selected_widget->line->width = idw->line_size;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_rectangle_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->rectangle_size = (int)slider->value();
	idw->rectangle_sample->labelsize(idw->rectangle_size);
	idw->rectangle_sample->redraw();
	sprintf(buf, "%3d", idw->rectangle_size);
	idw->rectangle_size_output->value(buf);
	idw->rectangle_size_output->redraw();
	if(idw->selected_widget != NULL)
	{
		if((idw->selected_widget->rectangle != NULL) && (idw->mode == DRAWING_MODE_RECTANGLE))
		{
			idw->selected_widget->rectangle->width = idw->rectangle_size;
			idw->selected_widget->rectangle->redraw();
			idw->selected_widget->redraw();
		}
		else if((idw->selected_widget->ellipse != NULL) && (idw->mode == DRAWING_MODE_ELLIPSE))
		{
			idw->selected_widget->ellipse->width = idw->rectangle_size;
			idw->selected_widget->ellipse->redraw();
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_freehand_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->line_size = (int)slider->value();
	idw->freehand_sample->labelsize(idw->line_size);
	idw->freehand_sample->redraw();
	sprintf(buf, "%3d", idw->line_size);
	idw->freehand_size_output->value(buf);
	idw->freehand_size_output->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->freehand != NULL)
		{
			idw->selected_widget->freehand->width = idw->line_size;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_pixelate_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->pixelate_size = (int)slider->value();
	sprintf(buf, "%3d", idw->pixelate_size);
	idw->pixelate_size_output->value(buf);
	idw->pixelate_size_output->redraw();

	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->pixelate != NULL)
		{
			idw->selected_widget->pixelate->use_size = idw->pixelate_size;
			idw->selected_widget->redraw();
		}
	}
}

void	drawing_pixelate_mode_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int shape = 0;
	if(idw->pixelate_pixelate_button->value()) shape = PIXELATE_MODE_PIXELATE;
	if(idw->pixelate_blur_button->value()) shape = PIXELATE_MODE_BLUR;
	idw->line_style = shape;
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->pixelate != NULL)
		{
			idw->selected_widget->pixelate->style = idw->line_style;
			idw->selected_widget->redraw();
		}
	}
}

PopupMenu::PopupMenu(int xx, int yy, int ww, int hh) : Fl_Window(xx, yy, ww, hh)
{
	box(FL_FRAME_BOX);
	color(FL_BLACK);
	border(0);
	
	browser = new Fl_Hold_Browser(4, 4, ww, hh);
	browser->box(FL_FLAT_BOX);
	browser->color(FL_BLACK);
	browser->textsize(9);
	browser->textcolor(FL_WHITE);
	browser->has_scrollbar(0);
	end();
}

PopupMenu::~PopupMenu()
{
}

int	PopupMenu::handle(int event)
{
	int flag = 0;
	if(event == FL_LEAVE)
	{
		hide();
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	PopupMenu::Resize(int xx, int yy, int ww, int hh)
{
	Fl_Window::resize(xx, yy, ww, hh);
	browser->resize(0, 0, ww, hh);
}

void	PopupMenu::Fit()
{
	int nn = browser->size();
	fl_font(FL_HELVETICA, 9);
	int ww = 0;
	int hh = 0;
	fl_measure("Hello", ww, hh);
	int sz = nn * hh;
	browser->resize(4, 4, browser->w(), sz);
	resize(x(), y(), w() + 8, sz + 8);
}

LineSample::LineSample(ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh) : Fl_Box(xx, yy, ww, hh)
{
	idw = in_idw;
	line_style = 0;
}

LineSample::~LineSample()
{
}

void	LineSample::draw()
{
	fl_color(color());
	fl_rectf(x(), y(), w(), h());
	fl_push_clip(x() + 1, y() + 1, w() - 2, h() - 2);
	fl_color(labelcolor());
	int width = labelsize();
	fl_line_style((line_style & 0xF), width, NULL);
	fl_begin_line();
	fl_vertex(x() + 12, y() + 4);
	fl_vertex(x() + 60, y() + 40);
	fl_vertex(x() + 19, y() + 70);
	fl_vertex(x() + 80, y() + 90);
	fl_end_line();
	fl_pop_clip();
	fl_line_style(FL_SOLID, 1, NULL);
}

FreehandSample::FreehandSample(ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh) : Fl_Box(xx, yy, ww, hh)
{
	idw = in_idw;
	line_style = FREEHAND_SHAPE_SQUARE;
	key = '/';
}

FreehandSample::~FreehandSample()
{
}

void	FreehandSample::draw()
{
char	buf[2];

	fl_color(color());
	fl_rectf(x(), y(), w(), h());
	fl_push_clip(x() + 1, y() + 1, w() - 2, h() - 2);
	fl_color(labelcolor());
	int width = labelsize();
	int cx = x() + (w() / 2);
	int cy = y() + (h() / 2);
	if(line_style == FREEHAND_SHAPE_SQUARE)
	{
		fl_rectf(cx - (width / 2), cy - (width / 2), width, width);
	}
	else if(line_style == FREEHAND_SHAPE_CIRCLE)
	{
		fl_begin_polygon();
		fl_arc(cx, cy, (width / 2) + 1, 0.0, 359.9);
		fl_end_polygon();
	}
	else if(line_style == FREEHAND_SHAPE_STAMP)
	{
		if((freehand_mat.cols > 0) && (freehand_mat.rows > 0))
		{
			Mat local_mat;
			cv::resize(freehand_mat, local_mat, cv::Size(width, width));
			fl_draw_image(local_mat.ptr(), cx - (width / 2), cy - (width / 2), local_mat.cols, local_mat.rows, local_mat.channels());
		}
	}
	else if(line_style == FREEHAND_SHAPE_KEY)
	{
		buf[0] = key;
		buf[1] = '\0';
		fl_font(labelfont(), labelsize());
		fl_draw(buf, x(), y(), w(), h(), align());
	}
	fl_pop_clip();
}

RectangleSample::RectangleSample(ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh) : Fl_Box(xx, yy, ww, hh)
{
	idw = in_idw;
	line_style = 0;
}

RectangleSample::~RectangleSample()
{
}

void	RectangleSample::draw()
{
	fl_color(color());
	fl_rectf(x(), y(), w(), h());
	fl_push_clip(x() + 1, y() + 1, w() - 2, h() - 2);
	fl_color(labelcolor());
	int width = labelsize();
	fl_line_style(line_style, width, NULL);
	if(idw->mode == DRAWING_MODE_RECTANGLE)
	{
		if(idw->rectangle_filled == 0)
		{
			fl_rect(x() + 10, y() + 10, w() - 20, h() - 20);
		}
		else
		{
			fl_rectf(x() + 10, y() + 10, w() - 20, h() - 20);
		}
	}
	else if(idw->mode == DRAWING_MODE_ELLIPSE)
	{
		if(idw->rectangle_filled == 0)
		{
			fl_arc(x() + 10, y() + 10, w() - 20, h() - 20, 0, 359.99);
		}
		else
		{
			double nx = (double)(x() + (w() / 2));
			double ny = (double)(y() + (h() / 2));
			fl_begin_polygon();
			fl_arc(nx, ny, (double)((w() / 2) - 10), 0, 359.99);
			fl_end_polygon();
		}
	}
	else if(idw->mode == DRAWING_MODE_IMAGE)
	{
		if((idw->image_mat.cols > 0) && (idw->image_mat.rows > 0))
		{
			Mat local_mat;
			cv::resize(idw->image_mat, local_mat, cv::Size(w(), h()));
			Fl_RGB_Image image(local_mat.ptr(), w(), h(), local_mat.channels());
			image.draw(x(), y(), w(), h());
		}
	}
	fl_pop_clip();
	fl_line_style(FL_SOLID, 1, NULL);
}

FontSample::FontSample(ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh, char *lbl) : Fl_Box(xx, yy, ww, hh, lbl)
{
	idw = in_idw;
}

FontSample::~FontSample()
{
}

void	FontSample::draw()
{
	fl_color(color());
	fl_rectf(x(), y(), w(), h());
	fl_push_clip(x() + 1, y() + 1, w() - 2, h() - 2);
	fl_color(labelcolor());
	fl_font(labelfont(), labelsize());
	fl_draw(label(), x(), y(), w(), h(), align());
	fl_pop_clip();
}

void	draw_arrow(int x1, int y1, int x2, int y2, int head_length, int head_width)
{
int	ax[3];
int	ay[3];

	double dx = (x1 - x2);
	double dy = (y1 - y2);
	double length = std::sqrt((dx * dx) + (dy * dy));
	if((head_length < 1) || (length < head_length)) return;

	// ux,uy is a unit vector parallel to the line.
	double ux = dx / length;
	double uy = dy / length;

	// vx,vy is a unit vector perpendicular to ux,uy
	double vx = -uy;
	double vy = ux;

	double half_width = 0.5 * head_width;
	ax[0] = round(x1 + (half_width * ux));
	ay[0] = round(y1 + (half_width * uy));
	ax[1] = round(x1 - (head_length * ux) + (half_width * vx));
	ay[1] = round(y1 - (head_length * uy) + (half_width * vy));
	ax[2] = round(x1 - (head_length * ux) - (half_width * vx));
	ay[2] = round(y1 - (head_length * uy) - (half_width * vy));
	fl_begin_polygon();
	fl_vertex(ax[0], ay[0]);
	fl_vertex(ax[1], ay[1]);
	fl_vertex(ax[2], ay[2]);
	fl_end_polygon();
}

void	my_cairo_draw_arrow(cairo_t *context, int x1, int y1, int x2, int y2, int head_length, int head_width)
{
int	ax[3];
int	ay[3];

	double dx = (x1 - x2);
	double dy = (y1 - y2);
	double length = std::sqrt((dx * dx) + (dy * dy));
	if((head_length < 1) || (length < head_length)) return;

	// ux,uy is a unit vector parallel to the line.
	double ux = dx / length;
	double uy = dy / length;

	// vx,vy is a unit vector perpendicular to ux,uy
	double vx = -uy;
	double vy = ux;

	double half_width = 0.5 * head_width;
	ax[0] = round(x1 + (half_width * ux));
	ay[0] = round(y1 + (half_width * uy));
	ax[1] = round(x1 - (head_length * ux) + (half_width * vx));
	ay[1] = round(y1 - (head_length * uy) + (half_width * vy));
	ax[2] = round(x1 - (head_length * ux) - (half_width * vx));
	ay[2] = round(y1 - (head_length * uy) - (half_width * vy));

	cairo_move_to(context, ax[0], ay[0]);
	cairo_line_to(context, ax[1], ay[1]);
	cairo_line_to(context, ax[2], ay[2]);
	cairo_fill(context);
}

void	line_style_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int style = 0;
	if(idw->line_style_solid_button->value()) style |= FL_SOLID;
	if(idw->line_style_dash_button->value()) style |= FL_DASH;
	if(idw->line_style_dot_button->value()) style |= FL_DOT;
	if(idw->line_style_flat_button->value()) style |= FL_CAP_FLAT;
	if(idw->line_style_round_button->value()) style |= FL_CAP_ROUND;
	if(idw->line_style_square_button->value()) style |= FL_CAP_SQUARE;
	if(idw->line_style_arrow_button->value()) style = MY_CAP_ARROW;
	if(idw->line_style_join_miter_button->value()) style |= FL_JOIN_MITER;
	if(idw->line_style_join_round_button->value()) style |= FL_JOIN_ROUND;
	if(idw->line_style_join_bevel_button->value()) style |= FL_JOIN_BEVEL;
	if(idw->line_type_segments_button->value()) style &= ~MY_TYPE_CURVES;
	if(idw->line_type_curves_button->value()) style |= MY_TYPE_CURVES;
	idw->erase = idw->line_style_erase_button->value();
	idw->line_style = style;
	idw->line_sample->line_style = style;
	idw->line_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->line != NULL)
		{
			idw->selected_widget->line->style = idw->line_style;
			idw->selected_widget->redraw();
		}
	}
}

void	rectangle_style_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int style = 0;
	if(idw->rectangle_style_solid_button->value()) style |= FL_SOLID;
	if(idw->rectangle_style_dash_button->value()) style |= FL_DASH;
	if(idw->rectangle_style_dot_button->value()) style |= FL_DOT;
	if(idw->rectangle_style_join_miter_button->value()) style |= FL_JOIN_MITER;
	if(idw->rectangle_style_join_round_button->value()) style |= FL_JOIN_ROUND;
	if(idw->rectangle_style_join_bevel_button->value()) style |= FL_JOIN_BEVEL;
	idw->rectangle_filled = idw->rectangle_filled_button->value();
	idw->rectangle_erase = idw->rectangle_erase_button->value();
	idw->rectangle_style = style;
	idw->rectangle_sample->line_style = style;
	idw->rectangle_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if((idw->selected_widget->rectangle != NULL) && (idw->mode == DRAWING_MODE_RECTANGLE))
		{
			idw->selected_widget->rectangle->style = idw->rectangle_style;
			idw->selected_widget->rectangle->filled = idw->rectangle_filled;
			idw->selected_widget->rectangle->erase = idw->rectangle_erase;
			idw->selected_widget->redraw();
		}
		else if((idw->selected_widget->ellipse != NULL) && (idw->mode == DRAWING_MODE_ELLIPSE))
		{
			idw->selected_widget->ellipse->style = idw->rectangle_style;
			idw->selected_widget->ellipse->filled = idw->rectangle_filled;
			idw->selected_widget->ellipse->erase = idw->rectangle_erase;
			idw->selected_widget->redraw();
		}
	}
}

void	freehand_shape_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int shape = 0;
	if(idw->freehand_shape_square_button->value()) shape = FREEHAND_SHAPE_SQUARE;
	if(idw->freehand_shape_circle_button->value()) shape = FREEHAND_SHAPE_CIRCLE;
	if(idw->freehand_shape_erase_square_button->value()) shape = FREEHAND_SHAPE_ERASE_SQUARE;
	if(idw->freehand_shape_erase_circle_button->value()) shape = FREEHAND_SHAPE_ERASE_CIRCLE;
	if(idw->freehand_shape_stamp_button->value()) shape = FREEHAND_SHAPE_STAMP;
	if(idw->freehand_shape_key_button->value()) shape = FREEHAND_SHAPE_KEY;
	idw->line_style = shape;
	idw->freehand_sample->line_style = shape;
	idw->freehand_sample->redraw();
	if(idw->selected_widget != NULL)
	{
		if(idw->selected_widget->freehand != NULL)
		{
			idw->selected_widget->freehand->style = idw->line_style;
			idw->selected_widget->redraw();
		}
	}
}

void	freehand_shape_file_cb(Fl_Widget *w, void *v)
{
int	native_file_chooser(char *prompt, char *filter, char *start_path, char *result);
char	filename[4096];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int nn = native_file_chooser("Select an image file", "*.{png,jpg,jpeg,webp,tiff,tif,bmp}", "./", filename);
	if(nn > 0)
	{
		Mat local_mat = imread(filename, IMREAD_UNCHANGED);
		if(local_mat.channels() == 3)
		{
			cvtColor(local_mat, local_mat, COLOR_BGR2RGB);
		}
		else
		{
			cvtColor(local_mat, local_mat, COLOR_BGRA2RGBA);
		}
		idw->freehand_mat = local_mat;
		idw->freehand_sample->redraw();
		strcpy(idw->freehand_filename, filename);
	}
}

void	image_file_cb(Fl_Widget *w, void *v)
{
int	native_file_chooser(char *prompt, char *filter, char *start_path, char *result);
char	filename[4096];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int nn = 0;
	if(w == idw->image_file_button)
	{
		strcpy(filename, "");
		nn = native_file_chooser("Select an image file", "*.{png,jpg,jpeg,webp,tiff,tif,bmp}", "./", filename);
	}
	else
	{
		char *str = (char *)idw->image_file_path->value();
		if(str != NULL)
		{
			strcpy(filename, str);
			nn = 1;
		}
	}
	if(nn > 0)
	{
		Mat local_mat = imread(filename, IMREAD_UNCHANGED);
		if((local_mat.rows > 0) && (local_mat.cols > 0))
		{
			if(local_mat.channels() == 3)
			{
				cvtColor(local_mat, local_mat, COLOR_BGR2RGB);
			}
			else
			{
				cvtColor(local_mat, local_mat, COLOR_BGRA2RGBA);
			}
			idw->image_file_path->value(filename);
			idw->image_mat = local_mat;
			idw->image_sample->redraw();
			idw->redraw();
		}
	}
}

void	drawing_grid_size_cb(Fl_Widget *w, void *v)
{
char	buf[64];

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Hor_Slider *slider = (Fl_Hor_Slider *)w;
	idw->grid_size = (int)slider->value();
	sprintf(buf, "%3d", idw->grid_size);
	idw->grid_size_output->value(buf);
	idw->grid_size_output->redraw();
}

void	text_color_selection_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(w == idw->text_foreground_color_button)
	{
		idw->using_background_color = 0;
	}
	else if(w == idw->text_background_color_button)
	{
		idw->using_background_color = 1;
	}
	else if(w == idw->text_outline_color_button)
	{
		idw->using_background_color = 2;
	}
}

void	drawing_text_box_cb(Fl_Widget *w, void *v)
{
	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Fl_Choice *choice = (Fl_Choice *)w;
	char *str = (char *)choice->text();
	if(str != NULL)
	{
		Fl_Boxtype box_type = FL_NO_BOX;
		if(strcmp(str, "No Box") == 0)
		{
			box_type = FL_NO_BOX;
		}
		if(strcmp(str, "Flat Box") == 0)
		{
			box_type = FL_FLAT_BOX;
		}
		if(strcmp(str, "Frame") == 0)
		{
			box_type = FL_FRAME;
		}
		if(strcmp(str, "Framed Box") == 0)
		{
			box_type = FL_FRAME_BOX;
		}
		idw->text_box_type = box_type;
		idw->font_sample->box(box_type);
		idw->font_sample->redraw();
		if(idw->selected_widget != NULL)
		{
			if(idw->selected_widget->text != NULL)
			{
				idw->selected_widget->text->box(box_type);
				idw->selected_widget->redraw();
			}
		}
	}
}

void	layer_select_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Camera *cam = idw->my_window->DisplayedCamera();
	if(cam != NULL)
	{
		cam->edit_layer = 0;
		for(loop = 0;loop < 8;loop++)
		{
			if(idw->layer_select_button[loop]->value())
			{
				cam->edit_layer = loop;
			}
		}
	}
}

void	layer_visible_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	Camera *cam = idw->my_window->DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < 8;loop++)
		{
			cam->layer_state[loop] = 0;
			if(idw->layer_visible_button[loop]->value())
			{
				cam->layer_state[loop] = 1;
			}
		}
	}
}

void	layer_up_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int use_layer = -1;
	for(loop = 0;loop < 8;loop++)
	{
		if(w == idw->layer_up_button[loop])
		{
			use_layer = loop;
		}
	}
	if((use_layer > -1) && (use_layer < 8))
	{
		Camera *cam = idw->my_window->DisplayedCamera();
		if(cam != NULL)
		{
			cam->RaiseALayer(use_layer);
		}
	}
	idw->redraw();
}

void	layer_down_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	int use_layer = -1;
	for(loop = 0;loop < 8;loop++)
	{
		if(w == idw->layer_down_button[loop])
		{
			use_layer = loop;
		}
	}
	if((use_layer > -1) && (use_layer < 8))
	{
		Camera *cam = idw->my_window->DisplayedCamera();
		if(cam != NULL)
		{
			cam->LowerALayer(use_layer);
		}
	}
	idw->redraw();
}

void	general_paste_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(idw->my_window != NULL)
	{
		MyWin *win = idw->my_window;
		win->PasteImmediate();
	}
}

void	clear_copy_buffer_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(idw->my_window != NULL)
	{
		MyWin *win = idw->my_window;
		win->ClearImmediate();
	}
}

void	general_save_button_cb(Fl_Widget *w, void *v)
{
int	native_file_chooser(char *prompt, char *filter, char *start_path, char *result);

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(idw->my_window != NULL)
	{
		MyWin *win = idw->my_window;
		Camera *cam = idw->my_window->DisplayedCamera();
		if(cam != NULL)
		{
			if(access("./ImmediateDrawingFiles", 0) != 0)
			{
				mkdir("./ImmediateDrawingFiles", 0755);
			}
			chdir("./ImmediateDrawingFiles");
			Fl_Native_File_Chooser nfc;
			nfc.title("Select a camera file");
			nfc.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
			nfc.filter("*.imd");
			nfc.directory("ImmediateDrawingFiles/sample.imd");
			int nn = nfc.show();
			if((nn != -1) && (nn != 1))
			{
				char *filename = (char *)nfc.filename();
				if(filename != NULL)
				{
					if(strlen(filename) > 0)
					{
						int fd = open(filename, O_WRONLY | O_CREAT, 0777);
						if(fd != -1)
						{
							cam->SaveImmediate(fd);
							close(fd);
						}
					}
				}
			}
			chdir("..");
		}
	}
}

void	general_load_button_cb(Fl_Widget *w, void *v)
{
int	native_file_chooser(char *prompt, char *filter, char *start_path, char *result);

	ImmediateDrawingWindow *idw = (ImmediateDrawingWindow *)v;
	if(idw->my_window != NULL)
	{
		MyWin *win = idw->my_window;
		Camera *cam = idw->my_window->DisplayedCamera();
		if(cam != NULL)
		{
			char filename[4096];
			strcpy(filename, "");
			int nn = native_file_chooser("Select an immediate drawing file", "*.imd", "./ImmediateDrawingFiles/*", filename);
			if(nn > 0)
			{
				if(strlen(filename) > 0)
				{
					int fd = open(filename, O_RDONLY);
					if(fd != -1)
					{
						cam->LoadImmediate(fd);
						close(fd);
					}
				}
			}
		}
	}
}

LayerLabelButton::LayerLabelButton(MyWin *in_win, int in_layer, int xx, int yy, int ww, int hh, char *lbl) : Fl_Toggle_Button(xx, yy, ww, hh, lbl)
{
	my_window = in_win;
	layer = in_layer;
}

LayerLabelButton::~LayerLabelButton()
{
}

void	LayerLabelButton::draw()
{
int		loop;
char	buf[256];

	Fl_Toggle_Button::draw();
	if(value())
	{
		fl_color(FL_WHITE);
	}
	else
	{
		fl_color(color());
	}
	fl_rectf(x(), y(), w(), h());
	fl_font(labelfont(), labelsize());
	if(value())
	{
		fl_color(FL_BLACK);
	}
	else
	{
		fl_color(labelcolor());
	}
	int cnt = 0;
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < cam->immediate_cnt;loop++)
		{
			if(cam->immediate_list[loop] != NULL)
			{
				if(cam->immediate_list[loop]->layer == layer)
				{
					cnt++;
				}
			}
		}
		for(loop = 0;loop < cam->image_window_cnt;loop++)
		{
			if(cam->image_window[loop] != NULL)
			{
				if(cam->image_window[loop]->layer == layer)
				{
					cnt++;
				}
			}
		}
	}
	sprintf(buf, "Layer #%d (%d)", layer, cnt);
	fl_draw(buf, x(), y(), w(), h(), FL_ALIGN_CENTER);
}

int	MyWin::ImageWindowHit(int xx, int yy)
{
int	loop;

	int hit = -1;
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < cam->image_window_cnt;loop++)
		{
			if(cam->image_window[loop] != NULL)
			{
				ImageWindow *im = cam->image_window[loop];
				if((xx >= im->x()) && (xx <= (im->x() + im->w()))
				&& (yy >= im->y()) && (yy <= (im->y() + im->h())))
				{
					hit = loop;
				}
			}
		}
	}
	return(hit);
}

void	text_edit_window_cb(Fl_Widget *w, void *v)
{
char	buf[256];

	TextEditWindow *win = (TextEditWindow *)v;
	sprintf(buf, "%3d", (int)win->font_red_slider->value());
	win->font_red_output->value(buf);
	sprintf(buf, "%3d", (int)win->font_green_slider->value());
	win->font_green_output->value(buf);
	sprintf(buf, "%3d", (int)win->font_blue_slider->value());
	win->font_blue_output->value(buf);
	sprintf(buf, "%3d", (int)win->font_alpha_slider->value());
	win->font_alpha_output->value(buf);

	sprintf(buf, "%3d", (int)win->font_size_slider->value());
	win->font_size_output->value(buf);

	int nn = win->font_browser->value();
	win->font_output->label(win->font_browser->text(nn));


	if(win->my_misc != NULL)
	{
		MiscCopy *misc = win->my_misc;
		if(misc->quick_text != NULL)
		{
			QuickText *qt = misc->quick_text;
			qt->textsize((int)win->font_size_slider->value());
			int rr = (int)win->font_red_slider->value();
			int gg = (int)win->font_green_slider->value();
			int bb = (int)win->font_blue_slider->value();
			qt->textcolor(fl_rgb_color(rr, gg, bb));
			qt->alpha = (int)win->font_alpha_slider->value();
			qt->italic = win->text_italic_button->value();
			qt->bold = win->text_bold_button->value();
			qt->outline = win->text_outline_button->value();
			qt->value(win->text_initial_text->value());
			qt->redraw();
		}
	}
	win->redraw();
}

TextEditWindow::TextEditWindow(MyWin *in_win, Camera *in_cam, MiscCopy *in_misc) : Fl_Window(400, 460, "Edit Text")
{
int	loop;

	my_window = in_win;
	my_camera = in_cam;
	my_misc = in_misc;

	color(FL_BLACK);
	box(FL_FLAT_BOX);

	double gsf = in_win->gui_scale_factor;
	int yp = 18;
	strcpy(selected_font, "");

	font_output = new Fl_Box(60 * gsf, yp, 300 * gsf, 20 * gsf);
	font_output->color(FL_BLACK);
	font_output->box(FL_FRAME_BOX);
	font_output->labelcolor(FL_WHITE);
	font_output->labelsize(9 * gsf);
	font_output->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	yp += (24 * gsf);
	
	font_browser = new Fl_Hold_Browser(60 * gsf, yp, 300 * gsf, 200 * gsf);
	font_browser->color(FL_BLACK);
	font_browser->box(FL_FLAT_BOX);
	font_browser->textcolor(FL_WHITE);
	font_browser->textsize(9 * gsf);
	font_browser->selection_color(FL_YELLOW);
	font_browser->scrollbar_size(4);
	font_browser->scrollbar.color(FL_BLACK);
	font_browser->callback(text_edit_window_cb, this);
	yp += (204 * gsf);
	int nn = my_window->number_of_fonts;
	for(loop = 0;loop < nn;loop++)
	{
		int attr = 0;
		char *str = (char *)Fl::get_font_name(loop, &attr);
		if(attr == 0)
		{
			font_browser->add(str, (void *)(long int)loop);
		}
	}
	if(strlen(selected_font) < 1)
	{
		font_browser->value(1);
		char *str = (char *)font_browser->text(font_browser->value());
		if(str != NULL)
		{
			strcpy(selected_font, str);
			font_output->label(str);
			font_output->redraw();
		}
	}
	
	font_size_slider = new Fl_Hor_Slider(60 * gsf, yp, 100 * gsf, 10 * gsf, "Size");
	font_size_slider->color(FL_BLACK);
	font_size_slider->box(FL_FRAME_BOX);
	font_size_slider->align(FL_ALIGN_LEFT);
	font_size_slider->labelcolor(FL_WHITE);
	font_size_slider->labelsize(9 * gsf);
	font_size_slider->value(72.0);
	font_size_slider->range(3.0, 255.0);
	font_size_slider->callback(text_edit_window_cb, this);

	font_size_output = new Fl_Output(165 * gsf, yp, 25 * gsf, 10 * gsf);
	font_size_output->color(FL_BLACK);
	font_size_output->box(FL_FLAT_BOX);
	font_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
	font_size_output->textfont(FL_COURIER);
	font_size_output->textcolor(FL_WHITE);
	font_size_output->textsize(9 * gsf);
	font_size_output->value(" 72");
	yp += (16 * gsf);

	font_red_slider = new Fl_Hor_Slider(60 * gsf, yp, 100 * gsf, 10 * gsf, "Red");
	font_red_slider->color(FL_BLACK);
	font_red_slider->box(FL_FRAME_BOX);
	font_red_slider->align(FL_ALIGN_LEFT);
	font_red_slider->labelcolor(FL_WHITE);
	font_red_slider->labelsize(9 * gsf);
	font_red_slider->value(255.0);
	font_red_slider->range(0.0, 255.0);
	font_red_slider->callback(text_edit_window_cb, this);

	font_red_output = new Fl_Output(165 * gsf, yp, 25 * gsf, 10 * gsf);
	font_red_output->color(FL_BLACK);
	font_red_output->box(FL_FLAT_BOX);
	font_red_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
	font_red_output->textfont(FL_COURIER);
	font_red_output->textcolor(FL_WHITE);
	font_red_output->textsize(9 * gsf);
	font_red_output->value("255");
	yp += (12 * gsf);
	
	font_green_slider = new Fl_Hor_Slider(60 * gsf, yp, 100 * gsf, 10 * gsf, "Green");
	font_green_slider->color(FL_BLACK);
	font_green_slider->box(FL_FRAME_BOX);
	font_green_slider->align(FL_ALIGN_LEFT);
	font_green_slider->labelcolor(FL_WHITE);
	font_green_slider->labelsize(9 * gsf);
	font_green_slider->value(255.0);
	font_green_slider->range(0.0, 255.0);
	font_green_slider->callback(text_edit_window_cb, this);

	font_green_output = new Fl_Output(165 * gsf, yp, 25 * gsf, 10 * gsf);
	font_green_output->color(FL_BLACK);
	font_green_output->box(FL_FLAT_BOX);
	font_green_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
	font_green_output->textfont(FL_COURIER);
	font_green_output->textcolor(FL_WHITE);
	font_green_output->textsize(9 * gsf);
	font_green_output->value("255");
	yp += (12 * gsf);
	
	font_blue_slider = new Fl_Hor_Slider(60 * gsf, yp, 100 * gsf, 10 * gsf, "Blue");
	font_blue_slider->color(FL_BLACK);
	font_blue_slider->box(FL_FRAME_BOX);
	font_blue_slider->align(FL_ALIGN_LEFT);
	font_blue_slider->labelcolor(FL_WHITE);
	font_blue_slider->labelsize(9 * gsf);
	font_blue_slider->value(255.0);
	font_blue_slider->range(0.0, 255.0);
	font_blue_slider->callback(text_edit_window_cb, this);

	font_blue_output = new Fl_Output(165 * gsf, yp, 25 * gsf, 10 * gsf);
	font_blue_output->color(FL_BLACK);
	font_blue_output->box(FL_FLAT_BOX);
	font_blue_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
	font_blue_output->textfont(FL_COURIER);
	font_blue_output->textcolor(FL_WHITE);
	font_blue_output->textsize(9 * gsf);
	font_blue_output->value("255");
	yp += (12 * gsf);

	font_alpha_slider = new Fl_Hor_Slider(60 * gsf, yp, 100 * gsf, 10 * gsf, "Alpha");
	font_alpha_slider->color(FL_BLACK);
	font_alpha_slider->box(FL_FRAME_BOX);
	font_alpha_slider->align(FL_ALIGN_LEFT);
	font_alpha_slider->labelcolor(FL_WHITE);
	font_alpha_slider->labelsize(9 * gsf);
	font_alpha_slider->value(255.0);
	font_alpha_slider->range(0.0, 255.0);
	font_alpha_slider->callback(text_edit_window_cb, this);

	font_alpha_output = new Fl_Output(165 * gsf, yp, 25 * gsf, 10 * gsf);
	font_alpha_output->color(FL_BLACK);
	font_alpha_output->box(FL_FLAT_BOX);
	font_alpha_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
	font_alpha_output->textfont(FL_COURIER);
	font_alpha_output->textcolor(FL_WHITE);
	font_alpha_output->textsize(9 * gsf);
	font_alpha_output->value("255");

	yp += (24 * gsf);
	int xp = 60 * gsf;

	text_italic_button = new Fl_Light_Button(xp, yp, 60 * gsf, 20 * gsf, "Italic");
	text_italic_button->labelsize(9 * gsf);
	text_italic_button->labelcolor(FL_WHITE);
	text_italic_button->color(DARK_GRAY);
	text_italic_button->box(FL_FLAT_BOX);
	text_italic_button->clear_visible_focus();
	text_italic_button->callback(text_edit_window_cb, this);
	xp += (60 * gsf);

	text_bold_button = new Fl_Light_Button(xp, yp, 60 * gsf, 20 * gsf, "Bold");
	text_bold_button->labelsize(9 * gsf);
	text_bold_button->labelcolor(FL_WHITE);
	text_bold_button->color(DARK_GRAY);
	text_bold_button->box(FL_FLAT_BOX);
	text_bold_button->clear_visible_focus();
	text_bold_button->callback(text_edit_window_cb, this);
	xp += (60 * gsf);

	text_outline_button = new Fl_Light_Button(xp, yp, 60 * gsf, 20 * gsf, "Outline");
	text_outline_button->labelsize(9 * gsf);
	text_outline_button->labelcolor(FL_WHITE);
	text_outline_button->color(DARK_GRAY);
	text_outline_button->box(FL_FLAT_BOX);
	text_outline_button->clear_visible_focus();
	text_outline_button->callback(text_edit_window_cb, this);
	yp += (48 * gsf);

	xp = 60 * gsf;
	text_initial_text = new Fl_Multiline_Input(xp, yp, 300 * gsf, 60 * gsf, "Initial Text");
	text_initial_text->labelsize(9 * gsf);
	text_initial_text->textsize(9 * gsf);
	text_initial_text->labelcolor(FL_WHITE);
	text_initial_text->textcolor(FL_WHITE);
	text_initial_text->cursor_color(FL_WHITE);
	text_initial_text->color(FL_BLACK);
	text_initial_text->box(FL_FRAME_BOX);
	text_initial_text->align(FL_ALIGN_CENTER | FL_ALIGN_TOP);
	if(my_misc->quick_text != NULL)
	{
		text_initial_text->value(my_misc->quick_text->value());
	}
	text_initial_text->callback(text_edit_window_cb, this);
	text_initial_text->when(FL_WHEN_CHANGED);
}

TextEditWindow::~TextEditWindow()
{
}

ImmediateDrawingWindow::ImmediateDrawingWindow(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Window(xx, yy, ww, hh, lbl)
{
char	buf[256];
int		ii;

	my_window = in_win;
	gsf = in_win->gui_scale_factor;
	resize(x() * gsf, y() * gsf, w() * gsf, h() * gsf);

	selected_widget = NULL;
	last_x = 0;
	last_y = 0;
	font_num = 0;
	strcpy(selected_font, "");
	strcpy(freehand_filename, "");
	font_size = 72;
	font_color_red = 255;
	font_color_green = 255;
	font_color_blue = 255;
	font_color_alpha = 255;
	back_color_red = 0;
	back_color_green = 0;
	back_color_blue = 0;
	back_color_alpha = 255;
	outline_color_red = 0;
	outline_color_green = 0;
	outline_color_blue = 0;
	outline_color_alpha = 255;
	using_background_color = 0;
	line_style = 0;
	line_size = 1;
	line_color_red = 255;
	line_color_green = 255;
	line_color_blue = 255;
	line_color_alpha = 255;
	rectangle_style = 0;
	rectangle_size = 1;
	rectangle_color_red = 255;
	rectangle_color_green = 255;
	rectangle_color_blue = 255;
	rectangle_color_alpha = 255;
	rectangle_filled = 0;
	freehand_key = '/';
	text_box_type = FL_NO_BOX;
	grid_size = 1;
	pixelate_size = 10;
	erase = 0;

	color(FL_BLACK);
	box(FL_FLAT_BOX);
	border(0);
	int yp = 20 * gsf;
	general = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "General");
	general->labelsize(9 * gsf);
	general->labelcolor(FL_WHITE);
	general->color(DARK_GRAY);
	general->box(FL_FLAT_BOX);
	general->clear_visible_focus();
	general->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	text = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Text");
	text->labelsize(9 * gsf);
	text->labelcolor(FL_WHITE);
	text->color(DARK_GRAY);
	text->box(FL_FLAT_BOX);
	text->clear_visible_focus();
	text->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	line = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Line");
	line->labelsize(9 * gsf);
	line->labelcolor(FL_WHITE);
	line->color(DARK_GRAY);
	line->box(FL_FLAT_BOX);
	line->clear_visible_focus();
	line->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	rectangle = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Rectangle");
	rectangle->labelsize(9 * gsf);
	rectangle->labelcolor(FL_WHITE);
	rectangle->color(DARK_GRAY);
	rectangle->box(FL_FLAT_BOX);
	rectangle->clear_visible_focus();
	rectangle->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	ellipse = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Ellipse");
	ellipse->labelsize(9 * gsf);
	ellipse->labelcolor(FL_WHITE);
	ellipse->color(DARK_GRAY);
	ellipse->box(FL_FLAT_BOX);
	ellipse->clear_visible_focus();
	ellipse->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	image_im = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Image");
	image_im->labelsize(9 * gsf);
	image_im->labelcolor(FL_WHITE);
	image_im->color(DARK_GRAY);
	image_im->box(FL_FLAT_BOX);
	image_im->clear_visible_focus();
	image_im->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	polygon = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Polygon");
	polygon->labelsize(9 * gsf);
	polygon->labelcolor(FL_WHITE);
	polygon->color(DARK_GRAY);
	polygon->box(FL_FLAT_BOX);
	polygon->clear_visible_focus();
	polygon->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	loop = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Loop");
	loop->labelsize(9 * gsf);
	loop->labelcolor(FL_WHITE);
	loop->color(DARK_GRAY);
	loop->box(FL_FLAT_BOX);
	loop->clear_visible_focus();
	loop->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	freehand = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Freehand");
	freehand->labelsize(9 * gsf);
	freehand->labelcolor(FL_WHITE);
	freehand->color(DARK_GRAY);
	freehand->box(FL_FLAT_BOX);
	freehand->clear_visible_focus();
	freehand->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	pixelate = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Pixelate/Blur");
	pixelate->labelsize(9 * gsf);
	pixelate->labelcolor(FL_WHITE);
	pixelate->color(DARK_GRAY);
	pixelate->box(FL_FLAT_BOX);
	pixelate->clear_visible_focus();
	pixelate->callback(immediate_drawing_mode_cb, this);
	yp += (32 * gsf);
	select_rectangle = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Passthru Rect");
	select_rectangle->labelsize(9 * gsf);
	select_rectangle->labelcolor(FL_WHITE);
	select_rectangle->color(DARK_GRAY);
	select_rectangle->box(FL_FLAT_BOX);
	select_rectangle->clear_visible_focus();
	select_rectangle->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	select_polygon = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Passthru Poly");
	select_polygon->labelsize(9 * gsf);
	select_polygon->labelcolor(FL_WHITE);
	select_polygon->color(DARK_GRAY);
	select_polygon->box(FL_FLAT_BOX);
	select_polygon->clear_visible_focus();
	select_polygon->callback(immediate_drawing_mode_cb, this);
	yp += (32 * gsf);
	delete_im = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Delete");
	delete_im->labelsize(9 * gsf);
	delete_im->labelcolor(FL_WHITE);
	delete_im->color(DARK_GRAY);
	delete_im->box(FL_FLAT_BOX);
	delete_im->clear_visible_focus();
	delete_im->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	hide_im = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Hide");
	hide_im->labelsize(9 * gsf);
	hide_im->labelcolor(FL_WHITE);
	hide_im->color(DARK_GRAY);
	hide_im->box(FL_FLAT_BOX);
	hide_im->clear_visible_focus();
	hide_im->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	hide_all = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Hide All");
	hide_all->labelsize(9 * gsf);
	hide_all->labelcolor(FL_WHITE);
	hide_all->color(DARK_GRAY);
	hide_all->box(FL_FLAT_BOX);
	hide_all->clear_visible_focus();
	hide_all->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);
	show_all = new Fl_Button(10 * gsf, yp, 100 * gsf, 20 * gsf, "Show All");
	show_all->labelsize(9 * gsf);
	show_all->labelcolor(FL_WHITE);
	show_all->color(DARK_GRAY);
	show_all->box(FL_FLAT_BOX);
	show_all->clear_visible_focus();
	show_all->callback(immediate_drawing_mode_cb, this);
	yp += (22 * gsf);

	general_group = new Fl_Group(120 * gsf, 0, 1920 * gsf, 1080 * gsf);
	general_group->box(FL_FLAT_BOX);
	general_group->color(DARK_GRAY);
		yp = (18 * gsf);
		grid_size_slider = new Fl_Hor_Slider(180 * gsf, yp, 100 * gsf, 10 * gsf, "Grid Size");
		grid_size_slider->color(FL_BLACK);
		grid_size_slider->box(FL_FRAME_BOX);
		grid_size_slider->align(FL_ALIGN_LEFT);
		grid_size_slider->labelcolor(FL_WHITE);
		grid_size_slider->labelsize(9 * gsf);
		grid_size_slider->value(1.0);
		grid_size_slider->range(1.0, 100.0);
		grid_size_slider->callback(drawing_grid_size_cb, this);

		grid_size_output = new Fl_Output(280 * gsf, yp, 25 * gsf, 10 * gsf);
		grid_size_output->color(FL_BLACK);
		grid_size_output->box(FL_FLAT_BOX);
		grid_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		grid_size_output->textfont(FL_COURIER);
		grid_size_output->textcolor(FL_WHITE);
		grid_size_output->textsize(9 * gsf);
		grid_size_output->value("  1");
		yp += 22;
		int save_yp = yp;
		Fl_Group *layer_select_group = new Fl_Group(180 * gsf, yp, 100 * gsf, (20 * gsf) * 8);
		for(ii = 0;ii < 8;ii++)
		{
			sprintf(buf, "Layer %d", ii);
			layer_select_button[ii] = new LayerLabelButton(my_window, ii, 180 * gsf, yp, 100 * gsf, 20 * gsf, strdup(buf));
			layer_select_button[ii]->labelsize(9 * gsf);
			layer_select_button[ii]->labelcolor(FL_WHITE);
			layer_select_button[ii]->color(DARK_GRAY);
			layer_select_button[ii]->box(FL_FLAT_BOX);
			layer_select_button[ii]->clear_visible_focus();
			layer_select_button[ii]->type(FL_RADIO_BUTTON);
			layer_select_button[ii]->callback(layer_select_cb, this);
			if(ii == 0)
			{
				layer_select_button[ii]->value(1);
			}
			yp += 21;
		}
		layer_select_group->end();
		yp = save_yp;
		for(ii = 0;ii < 8;ii++)
		{
			layer_visible_button[ii] = new Fl_Toggle_Button(160 * gsf, yp + 4, 12 * gsf, 12 * gsf, " ");
			layer_visible_button[ii]->labelsize(9 * gsf);
			layer_visible_button[ii]->labelcolor(FL_WHITE);
			layer_visible_button[ii]->color(DARK_GRAY);
			layer_visible_button[ii]->box(FL_FRAME_BOX);
			layer_visible_button[ii]->clear_visible_focus();
			layer_visible_button[ii]->value(1);
			layer_visible_button[ii]->callback(layer_visible_cb, this);

			layer_down_button[ii] = new Fl_Button(280 * gsf, yp + 4, 12 * gsf, 12 * gsf, "@8->");
			layer_down_button[ii]->labelsize(9 * gsf);
			layer_down_button[ii]->labelcolor(FL_WHITE);
			layer_down_button[ii]->color(DARK_GRAY);
			layer_down_button[ii]->box(FL_FLAT_BOX);
			layer_down_button[ii]->clear_visible_focus();
			layer_down_button[ii]->callback(layer_down_cb, this);
			if(ii == 0)
			{
				layer_down_button[ii]->hide();
			}
			layer_up_button[ii] = new Fl_Button(294 * gsf, yp + 4, 12 * gsf, 12 * gsf, "@2->");
			layer_up_button[ii]->labelsize(9 * gsf);
			layer_up_button[ii]->labelcolor(FL_WHITE);
			layer_up_button[ii]->color(DARK_GRAY);
			layer_up_button[ii]->box(FL_FLAT_BOX);
			layer_up_button[ii]->clear_visible_focus();
			layer_up_button[ii]->callback(layer_up_cb, this);
			if(ii == 7)
			{
				layer_up_button[ii]->hide();
			}
			yp += 21;
		}
		int xp = 140;
		yp += 5;
		paste_button = new Fl_Button(xp * gsf, yp, 60 * gsf, 18 * gsf, "Paste");
		paste_button->labelsize(11 * gsf);
		paste_button->labelcolor(FL_WHITE);
		paste_button->color(DARK_GRAY);
		paste_button->box(FL_FLAT_BOX);
		paste_button->clear_visible_focus();
		paste_button->hide();
		paste_button->callback(general_paste_button_cb, this);
		xp += 120;
		clear_copy_buffer_button = new Fl_Button(xp * gsf, yp, 120 * gsf, 18 * gsf, "Clear Copy Buffer");
		clear_copy_buffer_button->labelsize(11 * gsf);
		clear_copy_buffer_button->labelcolor(FL_WHITE);
		clear_copy_buffer_button->color(DARK_GRAY);
		clear_copy_buffer_button->box(FL_FLAT_BOX);
		clear_copy_buffer_button->clear_visible_focus();
		clear_copy_buffer_button->hide();
		clear_copy_buffer_button->callback(clear_copy_buffer_button_cb, this);
		xp = 140;
		yp += 20;
		save_button = new Fl_Button(xp * gsf, yp, 60 * gsf, 18 * gsf, "Save");
		save_button->labelsize(11 * gsf);
		save_button->labelcolor(FL_WHITE);
		save_button->color(DARK_GRAY);
		save_button->box(FL_FLAT_BOX);
		save_button->clear_visible_focus();
		save_button->callback(general_save_button_cb, this);
		xp += 120;
		load_button = new Fl_Button(xp * gsf, yp, 120 * gsf, 18 * gsf, "Load");
		load_button->labelsize(11 * gsf);
		load_button->labelcolor(FL_WHITE);
		load_button->color(DARK_GRAY);
		load_button->box(FL_FLAT_BOX);
		load_button->clear_visible_focus();
		load_button->callback(general_load_button_cb, this);
	general_group->end();
	general_group->hide();
	text_group = new Fl_Group(120 * gsf, 0, 1920 * gsf, 1080 * gsf);
	text_group->box(FL_FLAT_BOX);
	text_group->color(DARK_GRAY);
		yp = 18;
		font_output = new Fl_Box(120 * gsf, yp, 300 * gsf, 20 * gsf);
		font_output->color(FL_BLACK);
		font_output->box(FL_FRAME_BOX);
		font_output->labelcolor(FL_WHITE);
		font_output->labelsize(9 * gsf);
		font_output->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		yp += (24 * gsf);
	
		font_browser = new Fl_Hold_Browser(120 * gsf, yp, 300 * gsf, 200 * gsf);
		font_browser->color(FL_BLACK);
		font_browser->box(FL_FLAT_BOX);
		font_browser->textcolor(FL_WHITE);
		font_browser->textsize(9 * gsf);
		font_browser->selection_color(FL_YELLOW);
		font_browser->scrollbar_size(4);
		font_browser->scrollbar.color(FL_BLACK);
		font_browser->callback(drawing_font_selection_cb, this);
		yp += (204 * gsf);
	
		font_sample = new FontSample(this, 120 * gsf, yp, 100 * gsf, 100 * gsf, "Ab");
		font_sample->color(DARK_GRAY);
		font_sample->box(FL_FRAME_BOX);
		font_sample->labelcolor(FL_WHITE);
		font_sample->labelsize(72);
		font_sample->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

		font_size_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Size");
		font_size_slider->color(FL_BLACK);
		font_size_slider->box(FL_FRAME_BOX);
		font_size_slider->align(FL_ALIGN_LEFT);
		font_size_slider->labelcolor(FL_WHITE);
		font_size_slider->labelsize(9 * gsf);
		font_size_slider->value(72.0);
		font_size_slider->range(3.0, 255.0);
		font_size_slider->callback(drawing_font_size_cb, this);

		font_size_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		font_size_output->color(FL_BLACK);
		font_size_output->box(FL_FLAT_BOX);
		font_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_size_output->textfont(FL_COURIER);
		font_size_output->textcolor(FL_WHITE);
		font_size_output->textsize(9 * gsf);
		font_size_output->value(" 72");
		yp += (16 * gsf);
	
		font_red_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Red");
		font_red_slider->color(FL_BLACK);
		font_red_slider->box(FL_FRAME_BOX);
		font_red_slider->align(FL_ALIGN_LEFT);
		font_red_slider->labelcolor(FL_WHITE);
		font_red_slider->labelsize(9 * gsf);
		font_red_slider->value(255.0);
		font_red_slider->range(0.0, 255.0);
		font_red_slider->callback(drawing_font_color_cb, this);

		font_red_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		font_red_output->color(FL_BLACK);
		font_red_output->box(FL_FLAT_BOX);
		font_red_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_red_output->textfont(FL_COURIER);
		font_red_output->textcolor(FL_WHITE);
		font_red_output->textsize(9 * gsf);
		font_red_output->value("255");
		yp += (12 * gsf);
	
		font_green_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Green");
		font_green_slider->color(FL_BLACK);
		font_green_slider->box(FL_FRAME_BOX);
		font_green_slider->align(FL_ALIGN_LEFT);
		font_green_slider->labelcolor(FL_WHITE);
		font_green_slider->labelsize(9 * gsf);
		font_green_slider->value(255.0);
		font_green_slider->range(0.0, 255.0);
		font_green_slider->callback(drawing_font_color_cb, this);

		font_green_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		font_green_output->color(FL_BLACK);
		font_green_output->box(FL_FLAT_BOX);
		font_green_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_green_output->textfont(FL_COURIER);
		font_green_output->textcolor(FL_WHITE);
		font_green_output->textsize(9 * gsf);
		font_green_output->value("255");
		yp += (12 * gsf);
	
		font_blue_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Blue");
		font_blue_slider->color(FL_BLACK);
		font_blue_slider->box(FL_FRAME_BOX);
		font_blue_slider->align(FL_ALIGN_LEFT);
		font_blue_slider->labelcolor(FL_WHITE);
		font_blue_slider->labelsize(9 * gsf);
		font_blue_slider->value(255.0);
		font_blue_slider->range(0.0, 255.0);
		font_blue_slider->callback(drawing_font_color_cb, this);

		font_blue_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		font_blue_output->color(FL_BLACK);
		font_blue_output->box(FL_FLAT_BOX);
		font_blue_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_blue_output->textfont(FL_COURIER);
		font_blue_output->textcolor(FL_WHITE);
		font_blue_output->textsize(9 * gsf);
		font_blue_output->value("255");
		yp += (12 * gsf);

		font_alpha_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Alpha");
		font_alpha_slider->color(FL_BLACK);
		font_alpha_slider->box(FL_FRAME_BOX);
		font_alpha_slider->align(FL_ALIGN_LEFT);
		font_alpha_slider->labelcolor(FL_WHITE);
		font_alpha_slider->labelsize(9 * gsf);
		font_alpha_slider->value(255.0);
		font_alpha_slider->range(0.0, 255.0);
		font_alpha_slider->callback(drawing_font_color_cb, this);

		font_alpha_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		font_alpha_output->color(FL_BLACK);
		font_alpha_output->box(FL_FLAT_BOX);
		font_alpha_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		font_alpha_output->textfont(FL_COURIER);
		font_alpha_output->textcolor(FL_WHITE);
		font_alpha_output->textsize(9 * gsf);
		font_alpha_output->value("255");
		yp += (16 * gsf);

		xp = 240 * gsf;
		Fl_Group *drawing_text_color_selection_group = new Fl_Group(xp, yp, 186 * gsf, 18 * gsf);
			text_foreground_color_button = new Fl_Toggle_Button(xp, yp, 40 * gsf, 20 * gsf, "Fore");
			text_foreground_color_button->labelsize(9 * gsf);
			text_foreground_color_button->labelcolor(FL_WHITE);
			text_foreground_color_button->color(DARK_GRAY);
			text_foreground_color_button->box(FL_FLAT_BOX);
			text_foreground_color_button->clear_visible_focus();
			text_foreground_color_button->type(FL_RADIO_BUTTON);
			text_foreground_color_button->value(1);
			text_foreground_color_button->callback(text_color_selection_cb, this);
			xp += 42;

			text_background_color_button = new Fl_Toggle_Button(xp, yp, 40 * gsf, 18 * gsf, "Back");
			text_background_color_button->labelsize(9 * gsf);
			text_background_color_button->labelcolor(FL_WHITE);
			text_background_color_button->color(DARK_GRAY);
			text_background_color_button->box(FL_FLAT_BOX);
			text_background_color_button->clear_visible_focus();
			text_background_color_button->type(FL_RADIO_BUTTON);
			text_background_color_button->callback(text_color_selection_cb, this);
			xp += 42;

			text_outline_color_button = new Fl_Toggle_Button(xp, yp, 40 * gsf, 18 * gsf, "Outline");
			text_outline_color_button->labelsize(9 * gsf);
			text_outline_color_button->labelcolor(FL_WHITE);
			text_outline_color_button->color(DARK_GRAY);
			text_outline_color_button->box(FL_FLAT_BOX);
			text_outline_color_button->clear_visible_focus();
			text_outline_color_button->type(FL_RADIO_BUTTON);
			text_outline_color_button->callback(text_color_selection_cb, this);
			xp += 42;
		drawing_text_color_selection_group->end();
		yp += (24 * gsf);
		xp = 260 * gsf;

		drawing_text_box = new Fl_Choice(xp, yp, 100 * gsf, 16 * gsf, "Box");
		drawing_text_box->labelsize(9 * gsf);
		drawing_text_box->labelcolor(FL_WHITE);
		drawing_text_box->textsize(9);
		drawing_text_box->color(DARK_GRAY);
		drawing_text_box->box(FL_FLAT_BOX);
		drawing_text_box->value(1);
		drawing_text_box->callback(drawing_text_box_cb, this);
		drawing_text_box->add("No Box");
		drawing_text_box->add("Flat Box");
		drawing_text_box->add("Frame");
		drawing_text_box->add("Framed Box");
		yp += (18 * gsf);

		xp = 230 * gsf;
		text_italic_button = new Fl_Light_Button(xp, yp, 60 * gsf, 20 * gsf, "Italic");
		text_italic_button->labelsize(9 * gsf);
		text_italic_button->labelcolor(FL_WHITE);
		text_italic_button->color(DARK_GRAY);
		text_italic_button->box(FL_FLAT_BOX);
		text_italic_button->clear_visible_focus();
		xp += (60 * gsf);

		text_bold_button = new Fl_Light_Button(xp, yp, 60 * gsf, 20 * gsf, "Bold");
		text_bold_button->labelsize(9 * gsf);
		text_bold_button->labelcolor(FL_WHITE);
		text_bold_button->color(DARK_GRAY);
		text_bold_button->box(FL_FLAT_BOX);
		text_bold_button->clear_visible_focus();
		xp += (60 * gsf);

		text_outline_button = new Fl_Light_Button(xp, yp, 60 * gsf, 20 * gsf, "Outline");
		text_outline_button->labelsize(9 * gsf);
		text_outline_button->labelcolor(FL_WHITE);
		text_outline_button->color(DARK_GRAY);
		text_outline_button->box(FL_FLAT_BOX);
		text_outline_button->clear_visible_focus();
		yp += (28 * gsf);

		xp = 140 * gsf;
		text_initial_text = new Fl_Multiline_Input(xp, yp, 250 * gsf, 60 * gsf, "Initial Text");
		text_initial_text->labelsize(9 * gsf);
		text_initial_text->textsize(9 * gsf);
		text_initial_text->labelcolor(FL_WHITE);
		text_initial_text->textcolor(FL_WHITE);
		text_initial_text->cursor_color(FL_WHITE);
		text_initial_text->color(FL_BLACK);
		text_initial_text->box(FL_FRAME_BOX);
		text_initial_text->align(FL_ALIGN_TOP_LEFT);

	text_group->end();
	text_group->hide();
	line_group = new Fl_Group(120 * gsf, 0, 1920 * gsf, 1080 * gsf);
	line_group->box(FL_FLAT_BOX);
	line_group->color(DARK_GRAY);
		yp = 18 * gsf;
		line_sample = new LineSample(this, 120 * gsf, yp, 100 * gsf, 100 * gsf);
		line_sample->color(DARK_GRAY);
		line_sample->box(FL_FRAME_BOX);
		line_sample->labelcolor(FL_WHITE);
		line_sample->labelsize(1 * gsf);

		line_size_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Size");
		line_size_slider->color(FL_BLACK);
		line_size_slider->box(FL_FRAME_BOX);
		line_size_slider->align(FL_ALIGN_LEFT);
		line_size_slider->labelcolor(FL_WHITE);
		line_size_slider->labelsize(9 * gsf);
		line_size_slider->value(1.0);
		line_size_slider->range(1.0, 30.0);
		line_size_slider->callback(drawing_line_size_cb, this);

		line_size_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		line_size_output->color(FL_BLACK);
		line_size_output->box(FL_FLAT_BOX);
		line_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_size_output->textfont(FL_COURIER);
		line_size_output->textcolor(FL_WHITE);
		line_size_output->textsize(9 * gsf);
		line_size_output->value("  1");
		yp += (16 * gsf);
	
		line_red_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Red");
		line_red_slider->color(FL_BLACK);
		line_red_slider->box(FL_FRAME_BOX);
		line_red_slider->align(FL_ALIGN_LEFT);
		line_red_slider->labelcolor(FL_WHITE);
		line_red_slider->labelsize(9 * gsf);
		line_red_slider->value(255.0);
		line_red_slider->range(0.0, 255.0);
		line_red_slider->callback(drawing_line_color_cb, this);

		line_red_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		line_red_output->color(FL_BLACK);
		line_red_output->box(FL_FLAT_BOX);
		line_red_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_red_output->textfont(FL_COURIER);
		line_red_output->textcolor(FL_WHITE);
		line_red_output->textsize(9 * gsf);
		line_red_output->value("255");
		yp += (12 * gsf);
	
		line_green_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Green");
		line_green_slider->color(FL_BLACK);
		line_green_slider->box(FL_FRAME_BOX);
		line_green_slider->align(FL_ALIGN_LEFT);
		line_green_slider->labelcolor(FL_WHITE);
		line_green_slider->labelsize(9 * gsf);
		line_green_slider->value(255.0);
		line_green_slider->range(0.0, 255.0);
		line_green_slider->callback(drawing_line_color_cb, this);

		line_green_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		line_green_output->color(FL_BLACK);
		line_green_output->box(FL_FLAT_BOX);
		line_green_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_green_output->textfont(FL_COURIER);
		line_green_output->textcolor(FL_WHITE);
		line_green_output->textsize(9 * gsf);
		line_green_output->value("255");
		yp += (12 * gsf);
	
		line_blue_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Blue");
		line_blue_slider->color(FL_BLACK);
		line_blue_slider->box(FL_FRAME_BOX);
		line_blue_slider->align(FL_ALIGN_LEFT);
		line_blue_slider->labelcolor(FL_WHITE);
		line_blue_slider->labelsize(9 * gsf);
		line_blue_slider->value(255.0);
		line_blue_slider->range(0.0, 255.0);
		line_blue_slider->callback(drawing_line_color_cb, this);

		line_blue_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		line_blue_output->color(FL_BLACK);
		line_blue_output->box(FL_FLAT_BOX);
		line_blue_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_blue_output->textfont(FL_COURIER);
		line_blue_output->textcolor(FL_WHITE);
		line_blue_output->textsize(9 * gsf);
		line_blue_output->value("255");
		yp += (12 * gsf);

		line_alpha_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Alpha");
		line_alpha_slider->color(FL_BLACK);
		line_alpha_slider->box(FL_FRAME_BOX);
		line_alpha_slider->align(FL_ALIGN_LEFT);
		line_alpha_slider->labelcolor(FL_WHITE);
		line_alpha_slider->labelsize(9 * gsf);
		line_alpha_slider->value(255.0);
		line_alpha_slider->range(0.0, 255.0);
		line_alpha_slider->callback(drawing_line_color_cb, this);

		line_alpha_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		line_alpha_output->color(FL_BLACK);
		line_alpha_output->box(FL_FLAT_BOX);
		line_alpha_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		line_alpha_output->textfont(FL_COURIER);
		line_alpha_output->textcolor(FL_WHITE);
		line_alpha_output->textsize(9 * gsf);
		line_alpha_output->value("255");
		yp += (14 * gsf);

		int start_yp = yp;
		Fl_Group *line_style_group = new Fl_Group(220 * gsf, yp, 60 * gsf, 60 * gsf);
			line_style_solid_button = new Fl_Toggle_Button(220, yp, 60, 16, "Solid");
			line_style_solid_button->labelsize(9 * gsf);
			line_style_solid_button->labelcolor(FL_WHITE);
			line_style_solid_button->color(DARK_GRAY);
			line_style_solid_button->box(FL_FLAT_BOX);
			line_style_solid_button->clear_visible_focus();
			line_style_solid_button->type(FL_RADIO_BUTTON);
			line_style_solid_button->value(1);
			line_style_solid_button->callback(line_style_cb, this);
			yp += (18 * gsf);

			line_style_dash_button = new Fl_Toggle_Button(220 * gsf, yp, 60 * gsf, 16 * gsf, "Dash");
			line_style_dash_button->labelsize(9 * gsf);
			line_style_dash_button->labelcolor(FL_WHITE);
			line_style_dash_button->color(DARK_GRAY);
			line_style_dash_button->box(FL_FLAT_BOX);
			line_style_dash_button->clear_visible_focus();
			line_style_dash_button->type(FL_RADIO_BUTTON);
			line_style_dash_button->callback(line_style_cb, this);
			yp += (18 * gsf);

			line_style_dot_button = new Fl_Toggle_Button(220 * gsf, yp, 60 * gsf, 16 * gsf, "Dot");
			line_style_dot_button->labelsize(9 * gsf);
			line_style_dot_button->labelcolor(FL_WHITE);
			line_style_dot_button->color(DARK_GRAY);
			line_style_dot_button->box(FL_FLAT_BOX);
			line_style_dot_button->clear_visible_focus();
			line_style_dot_button->type(FL_RADIO_BUTTON);
			line_style_dot_button->callback(line_style_cb, this);
			yp += (24 * gsf);

		line_style_group->end();
		line_style_erase_button = new Fl_Toggle_Button(290 * gsf, yp, 60 * gsf, 16 * gsf, "Erase");
		line_style_erase_button->labelsize(9);
		line_style_erase_button->labelcolor(FL_WHITE);
		line_style_erase_button->color(DARK_GRAY);
		line_style_erase_button->box(FL_FLAT_BOX);
		line_style_erase_button->clear_visible_focus();
		line_style_erase_button->callback(line_style_cb, this);
		line_style_erase_button->hide();
		Fl_Group *line_type_group = new Fl_Group(220 * gsf, yp, 60 * gsf, 40 * gsf);
			line_type_segments_button = new Fl_Toggle_Button(220, yp, 60, 16, "Segments");
			line_type_segments_button->labelsize(9 * gsf);
			line_type_segments_button->labelcolor(FL_WHITE);
			line_type_segments_button->color(DARK_GRAY);
			line_type_segments_button->box(FL_FLAT_BOX);
			line_type_segments_button->clear_visible_focus();
			line_type_segments_button->value(1);
			line_type_segments_button->type(FL_RADIO_BUTTON);
			line_type_segments_button->callback(line_style_cb, this);
			yp += (18 * gsf);
			line_type_curves_button = new Fl_Toggle_Button(220 * gsf, yp, 60 * gsf, 16 * gsf, "Curves");
			line_type_curves_button->labelsize(9 * gsf);
			line_type_curves_button->labelcolor(FL_WHITE);
			line_type_curves_button->color(DARK_GRAY);
			line_type_curves_button->box(FL_FLAT_BOX);
			line_type_curves_button->clear_visible_focus();
			line_type_curves_button->type(FL_RADIO_BUTTON);
			line_type_curves_button->callback(line_style_cb, this);
		line_type_group->end();
		yp = start_yp;
		Fl_Group *line_cap_group = new Fl_Group(290 * gsf, yp, 60 * gsf, 80 * gsf);
			line_style_flat_button = new Fl_Toggle_Button(290 * gsf, yp, 60 * gsf, 16 * gsf, "Flat");
			line_style_flat_button->labelsize(9 * gsf);
			line_style_flat_button->labelcolor(FL_WHITE);
			line_style_flat_button->color(DARK_GRAY);
			line_style_flat_button->box(FL_FLAT_BOX);
			line_style_flat_button->clear_visible_focus();
			line_style_flat_button->type(FL_RADIO_BUTTON);
			line_style_flat_button->value(1);
			line_style_flat_button->callback(line_style_cb, this);
			yp += (18 * gsf);
			line_style_round_button = new Fl_Toggle_Button(290 * gsf, yp, 60 * gsf, 16 * gsf, "Round");
			line_style_round_button->labelsize(9 * gsf);
			line_style_round_button->labelcolor(FL_WHITE);
			line_style_round_button->color(DARK_GRAY);
			line_style_round_button->box(FL_FLAT_BOX);
			line_style_round_button->clear_visible_focus();
			line_style_round_button->type(FL_RADIO_BUTTON);
			line_style_round_button->callback(line_style_cb, this);
			yp += (18 * gsf);
			line_style_square_button = new Fl_Toggle_Button(290 * gsf, yp, 60 * gsf, 16 * gsf, "Square");
			line_style_square_button->labelsize(9 * gsf);
			line_style_square_button->labelcolor(FL_WHITE);
			line_style_square_button->color(DARK_GRAY);
			line_style_square_button->box(FL_FLAT_BOX);
			line_style_square_button->clear_visible_focus();
			line_style_square_button->type(FL_RADIO_BUTTON);
			line_style_square_button->callback(line_style_cb, this);
			yp += (18 * gsf);
			line_style_arrow_button = new Fl_Toggle_Button(290 * gsf, yp, 60 * gsf, 16 * gsf, "Arrow");
			line_style_arrow_button->labelsize(9);
			line_style_arrow_button->labelcolor(FL_WHITE);
			line_style_arrow_button->color(DARK_GRAY);
			line_style_arrow_button->box(FL_FLAT_BOX);
			line_style_arrow_button->clear_visible_focus();
			line_style_arrow_button->type(FL_RADIO_BUTTON);
			line_style_arrow_button->callback(line_style_cb, this);
			line_style_arrow_button->hide();
		line_cap_group->end();
		yp = start_yp;
		Fl_Group *line_join_group = new Fl_Group(360 * gsf, yp, 60 * gsf, 60 * gsf);
			line_style_join_miter_button = new Fl_Toggle_Button(360 * gsf, yp, 60 * gsf, 16 * gsf, "Join Miter");
			line_style_join_miter_button->labelsize(9 * gsf);
			line_style_join_miter_button->labelcolor(FL_WHITE);
			line_style_join_miter_button->color(DARK_GRAY);
			line_style_join_miter_button->box(FL_FLAT_BOX);
			line_style_join_miter_button->clear_visible_focus();
			line_style_join_miter_button->type(FL_RADIO_BUTTON);
			line_style_join_miter_button->value(1);
			line_style_join_miter_button->callback(line_style_cb, this);
			yp += (18 * gsf);
			line_style_join_round_button = new Fl_Toggle_Button(360 * gsf, yp, 60 * gsf, 16 * gsf, "Join Round");
			line_style_join_round_button->labelsize(9 * gsf);
			line_style_join_round_button->labelcolor(FL_WHITE);
			line_style_join_round_button->color(DARK_GRAY);
			line_style_join_round_button->box(FL_FLAT_BOX);
			line_style_join_round_button->clear_visible_focus();
			line_style_join_round_button->type(FL_RADIO_BUTTON);
			line_style_join_round_button->callback(line_style_cb, this);
			yp += (18 * gsf);
			line_style_join_bevel_button = new Fl_Toggle_Button(360 * gsf, yp, 60 * gsf, 16 * gsf, "Join Bevel");
			line_style_join_bevel_button->labelsize(9 * gsf);
			line_style_join_bevel_button->labelcolor(FL_WHITE);
			line_style_join_bevel_button->color(DARK_GRAY);
			line_style_join_bevel_button->box(FL_FLAT_BOX);
			line_style_join_bevel_button->clear_visible_focus();
			line_style_join_bevel_button->type(FL_RADIO_BUTTON);
			line_style_join_bevel_button->callback(line_style_cb, this);
			yp += (18 * gsf);
		line_join_group->end();
	line_group->end();
	line_group->hide();
	rectangle_group = new Fl_Group(120 * gsf, 0, 1920 * gsf, 1080 * gsf);
	rectangle_group->box(FL_FLAT_BOX);
	rectangle_group->color(DARK_GRAY);
		yp = 18 * gsf;
		rectangle_sample = new RectangleSample(this, 120 * gsf, yp, 100 * gsf, 100 * gsf);
		rectangle_sample->color(DARK_GRAY);
		rectangle_sample->box(FL_FRAME_BOX);
		rectangle_sample->labelcolor(FL_WHITE);
		rectangle_sample->labelsize(1 * gsf);

		rectangle_size_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Size");
		rectangle_size_slider->color(FL_BLACK);
		rectangle_size_slider->box(FL_FRAME_BOX);
		rectangle_size_slider->align(FL_ALIGN_LEFT);
		rectangle_size_slider->labelcolor(FL_WHITE);
		rectangle_size_slider->labelsize(9 * gsf);
		rectangle_size_slider->value(1.0);
		rectangle_size_slider->range(1.0, 30.0);
		rectangle_size_slider->callback(drawing_rectangle_size_cb, this);

		rectangle_size_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		rectangle_size_output->color(FL_BLACK);
		rectangle_size_output->box(FL_FLAT_BOX);
		rectangle_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_size_output->textfont(FL_COURIER);
		rectangle_size_output->textcolor(FL_WHITE);
		rectangle_size_output->textsize(9 * gsf);
		rectangle_size_output->value("  1");
		yp += (16 * gsf);
	
		rectangle_red_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Red");
		rectangle_red_slider->color(FL_BLACK);
		rectangle_red_slider->box(FL_FRAME_BOX);
		rectangle_red_slider->align(FL_ALIGN_LEFT);
		rectangle_red_slider->labelcolor(FL_WHITE);
		rectangle_red_slider->labelsize(9 * gsf);
		rectangle_red_slider->value(255.0);
		rectangle_red_slider->range(0.0, 255.0);
		rectangle_red_slider->callback(drawing_rectangle_color_cb, this);

		rectangle_red_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		rectangle_red_output->color(FL_BLACK);
		rectangle_red_output->box(FL_FLAT_BOX);
		rectangle_red_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_red_output->textfont(FL_COURIER);
		rectangle_red_output->textcolor(FL_WHITE);
		rectangle_red_output->textsize(9 * gsf);
		rectangle_red_output->value("255");
		yp += (12 * gsf);
	
		rectangle_green_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Green");
		rectangle_green_slider->color(FL_BLACK);
		rectangle_green_slider->box(FL_FRAME_BOX);
		rectangle_green_slider->align(FL_ALIGN_LEFT);
		rectangle_green_slider->labelcolor(FL_WHITE);
		rectangle_green_slider->labelsize(9 * gsf);
		rectangle_green_slider->value(250.0);
		rectangle_green_slider->range(0.0, 255.0);
		rectangle_green_slider->callback(drawing_rectangle_color_cb, this);

		rectangle_green_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		rectangle_green_output->color(FL_BLACK);
		rectangle_green_output->box(FL_FLAT_BOX);
		rectangle_green_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_green_output->textfont(FL_COURIER);
		rectangle_green_output->textcolor(FL_WHITE);
		rectangle_green_output->textsize(9 * gsf);
		rectangle_green_output->value("255");
		yp += (12 * gsf);
	
		rectangle_blue_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Blue");
		rectangle_blue_slider->color(FL_BLACK);
		rectangle_blue_slider->box(FL_FRAME_BOX);
		rectangle_blue_slider->align(FL_ALIGN_LEFT);
		rectangle_blue_slider->labelcolor(FL_WHITE);
		rectangle_blue_slider->labelsize(9 * gsf);
		rectangle_blue_slider->value(255.0);
		rectangle_blue_slider->range(0.0, 255.0);
		rectangle_blue_slider->callback(drawing_rectangle_color_cb, this);

		rectangle_blue_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		rectangle_blue_output->color(FL_BLACK);
		rectangle_blue_output->box(FL_FLAT_BOX);
		rectangle_blue_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_blue_output->textfont(FL_COURIER);
		rectangle_blue_output->textcolor(FL_WHITE);
		rectangle_blue_output->textsize(9 * gsf);
		rectangle_blue_output->value("255");
		yp += (12 * gsf);

		rectangle_alpha_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Alpha");
		rectangle_alpha_slider->color(FL_BLACK);
		rectangle_alpha_slider->box(FL_FRAME_BOX);
		rectangle_alpha_slider->align(FL_ALIGN_LEFT);
		rectangle_alpha_slider->labelcolor(FL_WHITE);
		rectangle_alpha_slider->labelsize(9 * gsf);
		rectangle_alpha_slider->value(255.0);
		rectangle_alpha_slider->range(0.0, 255.0);
		rectangle_alpha_slider->callback(drawing_rectangle_color_cb, this);

		rectangle_alpha_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		rectangle_alpha_output->color(FL_BLACK);
		rectangle_alpha_output->box(FL_FLAT_BOX);
		rectangle_alpha_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		rectangle_alpha_output->textfont(FL_COURIER);
		rectangle_alpha_output->textcolor(FL_WHITE);
		rectangle_alpha_output->textsize(9 * gsf);
		rectangle_alpha_output->value("255");
		yp += (14 * gsf);

		start_yp = yp;
		Fl_Group *rectangle_style_group = new Fl_Group(250 * gsf, yp, 60 * gsf, 60 * gsf);
			rectangle_style_solid_button = new Fl_Toggle_Button(250, yp, 60, 16, "Solid");
			rectangle_style_solid_button->labelsize(9 * gsf);
			rectangle_style_solid_button->labelcolor(FL_WHITE);
			rectangle_style_solid_button->color(DARK_GRAY);
			rectangle_style_solid_button->box(FL_FLAT_BOX);
			rectangle_style_solid_button->clear_visible_focus();
			rectangle_style_solid_button->type(FL_RADIO_BUTTON);
			rectangle_style_solid_button->value(1);
			rectangle_style_solid_button->callback(rectangle_style_cb, this);
			yp += (18 * gsf);

			rectangle_style_dash_button = new Fl_Toggle_Button(250 * gsf, yp, 60 * gsf, 16 * gsf, "Dash");
			rectangle_style_dash_button->labelsize(9 * gsf);
			rectangle_style_dash_button->labelcolor(FL_WHITE);
			rectangle_style_dash_button->color(DARK_GRAY);
			rectangle_style_dash_button->box(FL_FLAT_BOX);
			rectangle_style_dash_button->clear_visible_focus();
			rectangle_style_dash_button->type(FL_RADIO_BUTTON);
			rectangle_style_dash_button->callback(rectangle_style_cb, this);
			yp += (18 * gsf);

			rectangle_style_dot_button = new Fl_Toggle_Button(250 * gsf, yp, 60 * gsf, 16 * gsf, "Dot");
			rectangle_style_dot_button->labelsize(9 * gsf);
			rectangle_style_dot_button->labelcolor(FL_WHITE);
			rectangle_style_dot_button->color(DARK_GRAY);
			rectangle_style_dot_button->box(FL_FLAT_BOX);
			rectangle_style_dot_button->clear_visible_focus();
			rectangle_style_dot_button->type(FL_RADIO_BUTTON);
			rectangle_style_dot_button->callback(rectangle_style_cb, this);
		rectangle_style_group->end();
		yp = start_yp;
		Fl_Group *rectangle_join_group = new Fl_Group(320 * gsf, yp, 60 * gsf, 60 * gsf);
			rectangle_style_join_miter_button = new Fl_Toggle_Button(320, yp, 60, 16, "Join Miter");
			rectangle_style_join_miter_button->labelsize(9 * gsf);
			rectangle_style_join_miter_button->labelcolor(FL_WHITE);
			rectangle_style_join_miter_button->color(DARK_GRAY);
			rectangle_style_join_miter_button->box(FL_FLAT_BOX);
			rectangle_style_join_miter_button->clear_visible_focus();
			rectangle_style_join_miter_button->type(FL_RADIO_BUTTON);
			rectangle_style_join_miter_button->value(1);
			rectangle_style_join_miter_button->callback(rectangle_style_cb, this);
			yp += (18 * gsf);
			rectangle_style_join_round_button = new Fl_Toggle_Button(320 * gsf, yp, 60 * gsf, 16 * gsf, "Join Round");
			rectangle_style_join_round_button->labelsize(9 * gsf);
			rectangle_style_join_round_button->labelcolor(FL_WHITE);
			rectangle_style_join_round_button->color(DARK_GRAY);
			rectangle_style_join_round_button->box(FL_FLAT_BOX);
			rectangle_style_join_round_button->clear_visible_focus();
			rectangle_style_join_round_button->type(FL_RADIO_BUTTON);
			rectangle_style_join_round_button->callback(rectangle_style_cb, this);
			yp += (18 * gsf);
			rectangle_style_join_bevel_button = new Fl_Toggle_Button(320 * gsf, yp, 60 * gsf, 16 * gsf, "Join Bevel");
			rectangle_style_join_bevel_button->labelsize(9 * gsf);
			rectangle_style_join_bevel_button->labelcolor(FL_WHITE);
			rectangle_style_join_bevel_button->color(DARK_GRAY);
			rectangle_style_join_bevel_button->box(FL_FLAT_BOX);
			rectangle_style_join_bevel_button->clear_visible_focus();
			rectangle_style_join_bevel_button->type(FL_RADIO_BUTTON);
			rectangle_style_join_bevel_button->callback(rectangle_style_cb, this);
			yp += (22 * gsf);
		rectangle_join_group->end();
		rectangle_filled_button = new Fl_Toggle_Button(250 * gsf, yp, 60 * gsf, 16 * gsf, "Filled");
		rectangle_filled_button->labelsize(9 * gsf);
		rectangle_filled_button->labelcolor(FL_WHITE);
		rectangle_filled_button->color(DARK_GRAY);
		rectangle_filled_button->box(FL_FLAT_BOX);
		rectangle_filled_button->clear_visible_focus();
		rectangle_filled_button->value(0);
		rectangle_filled_button->callback(rectangle_style_cb, this);
		yp += (22 * gsf);

		rectangle_erase_button = new Fl_Toggle_Button(250 * gsf, yp, 60 * gsf, 16 * gsf, "Erase");
		rectangle_erase_button->labelsize(9 * gsf);
		rectangle_erase_button->labelcolor(FL_WHITE);
		rectangle_erase_button->color(DARK_GRAY);
		rectangle_erase_button->box(FL_FLAT_BOX);
		rectangle_erase_button->clear_visible_focus();
		rectangle_erase_button->value(0);
		rectangle_erase_button->callback(rectangle_style_cb, this);
	rectangle_group->end();
	rectangle_group->hide();

	freehand_group = new Fl_Group(120 * gsf, 0, 1920 * gsf, 1080 * gsf);
	freehand_group->box(FL_FLAT_BOX);
	freehand_group->color(DARK_GRAY);
		yp = 18 * gsf;
		freehand_sample = new FreehandSample(this, 120 * gsf, yp, 100 * gsf, 100 * gsf);
		freehand_sample->color(DARK_GRAY);
		freehand_sample->box(FL_FRAME_BOX);
		freehand_sample->labelcolor(FL_WHITE);
		freehand_sample->labelsize(1 * gsf);
		freehand_sample->freehand_mat = freehand_mat;

		freehand_size_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Size");
		freehand_size_slider->color(FL_BLACK);
		freehand_size_slider->box(FL_FRAME_BOX);
		freehand_size_slider->align(FL_ALIGN_LEFT);
		freehand_size_slider->labelcolor(FL_WHITE);
		freehand_size_slider->labelsize(9 * gsf);
		freehand_size_slider->value(1.0);
		freehand_size_slider->range(1.0, 90.0);
		freehand_size_slider->callback(drawing_freehand_size_cb, this);

		freehand_size_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		freehand_size_output->color(FL_BLACK);
		freehand_size_output->box(FL_FLAT_BOX);
		freehand_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		freehand_size_output->textfont(FL_COURIER);
		freehand_size_output->textcolor(FL_WHITE);
		freehand_size_output->textsize(9 * gsf);
		freehand_size_output->value("  1");
		yp += (16 * gsf);
	
		freehand_red_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Red");
		freehand_red_slider->color(FL_BLACK);
		freehand_red_slider->box(FL_FRAME_BOX);
		freehand_red_slider->align(FL_ALIGN_LEFT);
		freehand_red_slider->labelcolor(FL_WHITE);
		freehand_red_slider->labelsize(9 * gsf);
		freehand_red_slider->value(255.0);
		freehand_red_slider->range(0.0, 255.0);
		freehand_red_slider->callback(drawing_freehand_color_cb, this);

		freehand_red_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		freehand_red_output->color(FL_BLACK);
		freehand_red_output->box(FL_FLAT_BOX);
		freehand_red_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		freehand_red_output->textfont(FL_COURIER);
		freehand_red_output->textcolor(FL_WHITE);
		freehand_red_output->textsize(9 * gsf);
		freehand_red_output->value("255");
		yp += (12 * gsf);
	
		freehand_green_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Green");
		freehand_green_slider->color(FL_BLACK);
		freehand_green_slider->box(FL_FRAME_BOX);
		freehand_green_slider->align(FL_ALIGN_LEFT);
		freehand_green_slider->labelcolor(FL_WHITE);
		freehand_green_slider->labelsize(9 * gsf);
		freehand_green_slider->value(255.0);
		freehand_green_slider->range(0.0, 255.0);
		freehand_green_slider->callback(drawing_freehand_color_cb, this);

		freehand_green_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		freehand_green_output->color(FL_BLACK);
		freehand_green_output->box(FL_FLAT_BOX);
		freehand_green_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		freehand_green_output->textfont(FL_COURIER);
		freehand_green_output->textcolor(FL_WHITE);
		freehand_green_output->textsize(9 * gsf);
		freehand_green_output->value("255");
		yp += (12 * gsf);
	
		freehand_blue_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Blue");
		freehand_blue_slider->color(FL_BLACK);
		freehand_blue_slider->box(FL_FRAME_BOX);
		freehand_blue_slider->align(FL_ALIGN_LEFT);
		freehand_blue_slider->labelcolor(FL_WHITE);
		freehand_blue_slider->labelsize(9 * gsf);
		freehand_blue_slider->value(255.0);
		freehand_blue_slider->range(0.0, 255.0);
		freehand_blue_slider->callback(drawing_freehand_color_cb, this);

		freehand_blue_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		freehand_blue_output->color(FL_BLACK);
		freehand_blue_output->box(FL_FLAT_BOX);
		freehand_blue_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		freehand_blue_output->textfont(FL_COURIER);
		freehand_blue_output->textcolor(FL_WHITE);
		freehand_blue_output->textsize(9 * gsf);
		freehand_blue_output->value("255");
		yp += (14 * gsf);
		start_yp = yp;
		Fl_Group *freehand_shape_group = new Fl_Group(250 * gsf, yp, 120 * gsf, 120 * gsf);
			freehand_shape_square_button = new Fl_Toggle_Button(250 * gsf, yp, 80 * gsf, 16 * gsf, "Square");
			freehand_shape_square_button->labelsize(9 * gsf);
			freehand_shape_square_button->labelcolor(FL_WHITE);
			freehand_shape_square_button->color(DARK_GRAY);
			freehand_shape_square_button->box(FL_FLAT_BOX);
			freehand_shape_square_button->clear_visible_focus();
			freehand_shape_square_button->type(FL_RADIO_BUTTON);
			freehand_shape_square_button->value(1);
			freehand_shape_square_button->callback(freehand_shape_cb, this);
			yp += (18 * gsf);
			freehand_shape_circle_button = new Fl_Toggle_Button(250 * gsf, yp, 80 * gsf, 16 * gsf, "Circle");
			freehand_shape_circle_button->labelsize(9 * gsf);
			freehand_shape_circle_button->labelcolor(FL_WHITE);
			freehand_shape_circle_button->color(DARK_GRAY);
			freehand_shape_circle_button->box(FL_FLAT_BOX);
			freehand_shape_circle_button->clear_visible_focus();
			freehand_shape_circle_button->type(FL_RADIO_BUTTON);
			freehand_shape_circle_button->value(0);
			freehand_shape_circle_button->callback(freehand_shape_cb, this);
			yp += (18 * gsf);
			freehand_shape_erase_square_button = new Fl_Toggle_Button(250 * gsf, yp, 80 * gsf, 16 * gsf, "Erase Square");
			freehand_shape_erase_square_button->labelsize(9 * gsf);
			freehand_shape_erase_square_button->labelcolor(FL_WHITE);
			freehand_shape_erase_square_button->color(DARK_GRAY);
			freehand_shape_erase_square_button->box(FL_FLAT_BOX);
			freehand_shape_erase_square_button->clear_visible_focus();
			freehand_shape_erase_square_button->type(FL_RADIO_BUTTON);
			freehand_shape_erase_square_button->value(0);
			freehand_shape_erase_square_button->callback(freehand_shape_cb, this);
			yp += (18 * gsf);
			freehand_shape_erase_circle_button = new Fl_Toggle_Button(250 * gsf, yp, 80 * gsf, 16 * gsf, "Erase Circle");
			freehand_shape_erase_circle_button->labelsize(9 * gsf);
			freehand_shape_erase_circle_button->labelcolor(FL_WHITE);
			freehand_shape_erase_circle_button->color(DARK_GRAY);
			freehand_shape_erase_circle_button->box(FL_FLAT_BOX);
			freehand_shape_erase_circle_button->clear_visible_focus();
			freehand_shape_erase_circle_button->type(FL_RADIO_BUTTON);
			freehand_shape_erase_circle_button->value(0);
			freehand_shape_erase_circle_button->callback(freehand_shape_cb, this);
			yp += (18 * gsf);
			freehand_shape_stamp_button = new Fl_Toggle_Button(250 * gsf, yp, 80 * gsf, 16 * gsf, "Stamp");
			freehand_shape_stamp_button->labelsize(9 * gsf);
			freehand_shape_stamp_button->labelcolor(FL_WHITE);
			freehand_shape_stamp_button->color(DARK_GRAY);
			freehand_shape_stamp_button->box(FL_FLAT_BOX);
			freehand_shape_stamp_button->clear_visible_focus();
			freehand_shape_stamp_button->type(FL_RADIO_BUTTON);
			freehand_shape_stamp_button->value(0);
			freehand_shape_stamp_button->callback(freehand_shape_cb, this);

			freehand_shape_stamp_file_button = new Fl_Button(330 * gsf, yp, 16 * gsf, 16 * gsf, "@fileopen");
			freehand_shape_stamp_file_button->labelsize(9 * gsf);
			freehand_shape_stamp_file_button->labelcolor(FL_WHITE);
			freehand_shape_stamp_file_button->color(DARK_GRAY);
			freehand_shape_stamp_file_button->box(FL_FLAT_BOX);
			freehand_shape_stamp_file_button->clear_visible_focus();
			freehand_shape_stamp_file_button->callback(freehand_shape_file_cb, this);
			yp += (18 * gsf);
			freehand_shape_key_button = new Fl_Toggle_Button(250 * gsf, yp, 80 * gsf, 16 * gsf, "Key");
			freehand_shape_key_button->labelsize(9 * gsf);
			freehand_shape_key_button->labelcolor(FL_WHITE);
			freehand_shape_key_button->color(DARK_GRAY);
			freehand_shape_key_button->box(FL_FLAT_BOX);
			freehand_shape_key_button->clear_visible_focus();
			freehand_shape_key_button->type(FL_RADIO_BUTTON);
			freehand_shape_key_button->value(0);
			freehand_shape_key_button->callback(freehand_shape_cb, this);
			yp += (18 * gsf);
		freehand_shape_group->end();

	freehand_group->end();
	freehand_group->hide();
	image_group = new Fl_Group(120 * gsf, 0, 1920 * gsf, 1080 * gsf);
	image_group->box(FL_FLAT_BOX);
	image_group->color(DARK_GRAY);
		yp = 18 * gsf;
		image_sample = new RectangleSample(this, 120 * gsf, yp, 320 * gsf, 180 * gsf);
		image_sample->color(LIGHT_GRAY);
		image_sample->box(FL_FRAME_BOX);
		image_sample->labelcolor(FL_WHITE);
		image_sample->labelsize(1 * gsf);
		yp += (190 * gsf);

		image_file_button = new Fl_Toggle_Button(120 * gsf, yp, 16 * gsf, 16 * gsf, "@fileopen");
		image_file_button->labelsize(9 * gsf);
		image_file_button->labelcolor(FL_WHITE);
		image_file_button->color(DARK_GRAY);
		image_file_button->box(FL_FLAT_BOX);
		image_file_button->clear_visible_focus();
		image_file_button->callback(image_file_cb, this);

		image_file_path = new Fl_Input(138 * gsf, yp, 300 * gsf, 18 * gsf);
		image_file_path->textsize(11 * gsf);
		image_file_path->textcolor(FL_BLACK);
		image_file_path->color(LIGHT_GRAY);
		image_file_path->box(FL_FLAT_BOX);
		image_file_path->set_visible_focus();
		image_file_path->when(FL_WHEN_ENTER_KEY);
		image_file_path->callback(image_file_cb, this);
		yp += (18 * gsf);
	image_group->end();
	image_group->hide();
	pixelate_group = new Fl_Group(120 * gsf, 0, 1920 * gsf, 1080 * gsf);
	pixelate_group->box(FL_FLAT_BOX);
	pixelate_group->color(DARK_GRAY);
		yp = 18 * gsf;
		pixelate_size_slider = new Fl_Hor_Slider(260 * gsf, yp, 100 * gsf, 10 * gsf, "Size");
		pixelate_size_slider->color(FL_BLACK);
		pixelate_size_slider->box(FL_FRAME_BOX);
		pixelate_size_slider->align(FL_ALIGN_LEFT);
		pixelate_size_slider->labelcolor(FL_WHITE);
		pixelate_size_slider->labelsize(9 * gsf);
		pixelate_size_slider->value(10.0);
		pixelate_size_slider->range(2.0, 255.0);
		pixelate_size_slider->callback(drawing_pixelate_size_cb, this);

		pixelate_size_output = new Fl_Output(365 * gsf, yp, 25 * gsf, 10 * gsf);
		pixelate_size_output->color(FL_BLACK);
		pixelate_size_output->box(FL_FLAT_BOX);
		pixelate_size_output->align(FL_ALIGN_RIGHT | FL_ALIGN_INSIDE);
		pixelate_size_output->textfont(FL_COURIER);
		pixelate_size_output->textcolor(FL_WHITE);
		pixelate_size_output->textsize(9 * gsf);
		pixelate_size_output->value(" 10");

		yp += (32 * gsf);
		pixelate_pixelate_button = new Fl_Toggle_Button(250 * gsf, yp, 60 * gsf, 16 * gsf, "Pixelate");
		pixelate_pixelate_button->labelsize(9 * gsf);
		pixelate_pixelate_button->labelcolor(FL_WHITE);
		pixelate_pixelate_button->color(DARK_GRAY);
		pixelate_pixelate_button->box(FL_FLAT_BOX);
		pixelate_pixelate_button->clear_visible_focus();
		pixelate_pixelate_button->type(FL_RADIO_BUTTON);
		pixelate_pixelate_button->value(1);
		pixelate_pixelate_button->callback(drawing_pixelate_mode_cb, this);
		yp += (18 * gsf);
		pixelate_blur_button = new Fl_Toggle_Button(250 * gsf, yp, 60 * gsf, 16 * gsf, "Blur");
		pixelate_blur_button->labelsize(9 * gsf);
		pixelate_blur_button->labelcolor(FL_WHITE);
		pixelate_blur_button->color(DARK_GRAY);
		pixelate_blur_button->box(FL_FLAT_BOX);
		pixelate_blur_button->clear_visible_focus();
		pixelate_blur_button->type(FL_RADIO_BUTTON);
		pixelate_blur_button->value(0);
		pixelate_blur_button->callback(drawing_pixelate_mode_cb, this);
		yp += (18 * gsf);
	pixelate_group->end();
	pixelate_group->hide();
	end();
	show();
}

ImmediateDrawingWindow::~ImmediateDrawingWindow()
{
}

void	ImmediateDrawingWindow::hide()
{
	my_window->im_drawing_mode = 0;
	Fl_Window::hide();
}

void	ImmediateDrawingWindow::Color(int in_color)
{
int	loop;

	color(in_color);
	for(loop = 0;loop < children();loop++)
	{
		if(child(loop) != NULL)
		{
			child(loop)->color(in_color);
		}
	}
}

int	ImmediateDrawingWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		last_x = Fl::event_x_root();
		last_y = Fl::event_y_root();
	}
	else if(event == FL_DRAG)
	{
		int xx = Fl::event_x_root();
		int yy = Fl::event_y_root();
		int dx = last_x - xx;
		int dy = last_y - yy;
		resize(x() - dx, y() - dy, w(), h());
		last_x = xx;
		last_y = yy;
		flag = 1;
	}
	else if((event == FL_FOCUS) || (event == FL_UNFOCUS))
	{
		flag = 1;
	}
	else if(event == FL_KEYBOARD)
	{
		if(mode == DRAWING_MODE_FREEHAND)
		{
			char *str = (char *)Fl::event_text();
			if(str != NULL)
			{
				char key = str[0];
				if((key > 32) && (key < 127))
				{
					freehand_key = key;
					freehand_sample->key = key;
					freehand_sample->redraw();
					flag = 1;
				}
			}
		}
	}
	else if(event == FL_SHOW)
	{
		if(my_window != NULL)
		{
			if(my_window->immediate_cnt > 0)
			{
				paste_button->show();
				clear_copy_buffer_button->show();
			}
			else
			{
				paste_button->hide();
				clear_copy_buffer_button->hide();
			}
		}
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	font_selection_cb(Fl_Widget *w, void *v)
{
}

void	ImmediateDrawingWindow::GeneralSetup()
{
int	loop;

	line_group->hide();
	text_group->hide();
	rectangle_group->hide();
	pixelate_group->hide();
	freehand_group->hide();
	freehand_group->hide();
	image_group->hide();
	general_group->show();
	resize(x(), y(), 430 * gsf, 420 * gsf);
}

void	ImmediateDrawingWindow::TextSetup()
{
int	loop;

	general_group->hide();
	line_group->hide();
	rectangle_group->hide();
	pixelate_group->hide();
	freehand_group->hide();
	image_group->hide();
	font_browser->clear();
	int yp = 0;
	int nn = my_window->number_of_fonts;
	for(loop = 0;loop < nn;loop++)
	{
		int attr = 0;
		char *str = (char *)Fl::get_font_name(loop, &attr);
		if(attr == 0)
		{
			font_browser->add(str, (void *)(long int)loop);
		}
	}
	if(strlen(selected_font) < 1)
	{
		font_browser->value(1);
		char *str = (char *)font_browser->text(font_browser->value());
		if(str != NULL)
		{
			strcpy(selected_font, str);
			font_output->label(str);
			font_output->redraw();
		}
	}
	text_group->show();
	resize(x(), y(), 430 * gsf, 620 * gsf);
}

void	ImmediateDrawingWindow::LineSetup()
{
	general_group->hide();
	text_group->hide();
	rectangle_group->hide();
	pixelate_group->hide();
	freehand_group->hide();
	image_group->hide();
	line_group->show();
	if(mode == DRAWING_MODE_LINE)
	{
		line_style_arrow_button->show();
		line_style_erase_button->hide();
	}
	else
	{
		line_style_arrow_button->hide();
		line_style_erase_button->show();
	}
	resize(x(), y(), 430 * gsf, 420 * gsf);
}

void	ImmediateDrawingWindow::RectangleSetup()
{
	general_group->hide();
	text_group->hide();
	line_group->hide();
	freehand_group->hide();
	image_group->hide();
	pixelate_group->hide();
	rectangle_group->show();
	resize(x(), y(), 430 * gsf, 420 * gsf);
}

void	ImmediateDrawingWindow::PixelateSetup()
{
	general_group->hide();
	text_group->hide();
	line_group->hide();
	freehand_group->hide();
	image_group->hide();
	rectangle_group->hide();
	pixelate_group->show();
	resize(x(), y(), 430 * gsf, 420 * gsf);
}

void	ImmediateDrawingWindow::ImageSetup()
{
	general_group->hide();
	text_group->hide();
	line_group->hide();
	freehand_group->hide();
	rectangle_group->hide();
	pixelate_group->hide();
	image_group->show();
	resize(x(), y(), 460 * gsf, 420 * gsf);
}

void	ImmediateDrawingWindow::FreehandSetup()
{
	general_group->hide();
	text_group->hide();
	line_group->hide();
	rectangle_group->hide();
	pixelate_group->hide();
	image_group->hide();
	freehand_group->show();
	resize(x(), y(), 430 * gsf, 420 * gsf);
}

TransparentWindow::TransparentWindow(Fl_Window *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Window(xx, yy, ww, hh, lbl)
{
	primary = in_win;
	border(0);
	box(FL_NO_BOX);
}

TransparentWindow::~TransparentWindow()
{
}

void	TransparentWindow::draw()
{
unsigned char *grab_raw_image(Fl_Window *win, int xx, int yy, int ww, int hh, int *sz, int *in_depth);
int	loop;
	
	if((x() >= primary->x())
	&& (y() >= primary->y())
	&& (x() + w() < primary->x() + primary->w())
	&& (y() + h() < primary->h() + primary->h()))
	{
		int depth = 0;
		int sz = 0;
		unsigned char *b = grab_raw_image(primary, x() - primary->x(), y() - primary->y(), w(), h(), &sz, &depth);
		if(b != NULL)
		{
			double s = Fl::screen_scale(0);
			int nw = Fl_Scalable_Graphics_Driver::floor(w(), s);
			int nh = Fl_Scalable_Graphics_Driver::floor(h(), s);
			Mat src = Mat(nh, nw, CV_8UC4, b);
			cv::resize(src, src, cv::Size(w(), h()));
			cvtColor(src, src, COLOR_BGRA2RGB);
			src.convertTo(src, -1, 1, -100);
		 	fl_draw_image(src.ptr(), 0, 0, w(), h(), 3);
		}
	}
	else
	{
		fl_color(color());
		fl_rectf(0, 0, w(), h());
	}
	Fl_Window::draw();
}

void	color_dialog_cb(Fl_Widget *w, void *v)
{
	ColorDialog *cd = (ColorDialog *)v;
	int rr = cd->red->value();
	int gg = cd->green->value();
	int bb = cd->blue->value();
	int aa = cd->alpha->value();
	if(cd->client_red != NULL) *cd->client_red = rr;
	if(cd->client_green != NULL) *cd->client_green = gg;
	if(cd->client_blue != NULL) *cd->client_blue = bb;
	if(cd->client_alpha != NULL) *cd->client_alpha = aa;
	cd->sample->color(fl_rgb_color(rr, gg, bb));
	cd->redraw();
}

void	color_dialog_close_cb(Fl_Widget *w, void *v)
{
	ColorDialog *cd = (ColorDialog *)v;
	cd->hide();
	Fl::delete_widget(cd);
}

ColorDialog::ColorDialog(MyWin *in_win, int ww, int hh, char *title, int *use_r, int *use_g, int *use_b, int *use_a) : Fl_Window(ww, hh)
{
	my_window = in_win;
	box(FL_FLAT_BOX);
	color(FL_BLACK);
	border(0);
	set_non_modal();

	last_x = 0;
	last_y = 0;

	client_red = use_r;  
	client_green = use_g;  
	client_blue = use_b;  
	client_alpha = use_a;
	int rr = 128;
	if(client_red != NULL)
	{
		rr = *client_red;
	}
	int gg = 128;
	if(client_green != NULL)
	{
		gg = *client_green;
	}
	int bb = 128;
	if(client_blue != NULL)
	{
		bb = *client_blue;
	}
	int aa = 255;
	if(client_alpha != NULL)
	{
		aa = *client_alpha;
	}
	if(title != NULL)
	{
		Fl_Box *title_box = new Fl_Box(0, 0, ww, 20, title);
		title_box->color(FL_BLACK);
		title_box->labelcolor(FL_WHITE);
		title_box->box(FL_FLAT_BOX);
		title_box->labelsize(12);
	}
	int y_pos = 25;
	red = new ColorSlider(40, y_pos, 300, 20, 128, "Red");
	red->callback(color_dialog_cb, this);
	y_pos += 22;
	green = new ColorSlider(40, y_pos, 300, 20, 128, "Green");
	green->callback(color_dialog_cb, this);
	y_pos += 22;
	blue = new ColorSlider(40, y_pos, 300, 20, 128, "Blue");
	blue->callback(color_dialog_cb, this);
	y_pos += 22;
	alpha = new ColorSlider(40, y_pos, 300, 20, 255, "Alpha");
	alpha->callback(color_dialog_cb, this);

	red->value(rr);
	green->value(gg);
	blue->value(bb);
	alpha->value(aa);

	sample = new Fl_Box(350, 25, 50, 50);
	sample->box(FL_FRAME_BOX);
	sample->color(fl_rgb_color(rr, gg, bb));

	close = new Fl_Button(350, 5, 50, 20, "Close");
	close->box(FL_FLAT_BOX);
	close->color(FL_BLACK);
	close->labelcolor(FL_YELLOW);
	close->labelsize(9);
	close->callback(color_dialog_close_cb, this);
}

ColorDialog::~ColorDialog()
{
	hide();
}

void	ColorDialog::draw()
{
	Fl_Window::draw();
}

int	ColorDialog::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		last_x = Fl::event_x_root();
		last_y = Fl::event_y_root();
	}
	else if(event == FL_DRAG)
	{
		int xx = Fl::event_x_root();
		int yy = Fl::event_y_root();
		int dx = last_x - xx;
		int dy = last_y - yy;
		resize(x() - dx, y() - dy, w(), h());
		last_x = xx;
		last_y = yy;
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

FakeWindow::FakeWindow(MyWin *in_win, char *raw) : Fl_Double_Window(0, 0, Fl::w(), Fl::h())
{
	my_window = in_win;
	border(0);
	fullscreen();
	set_modal();
	raw_data = raw;
	start_x = -1;
	start_y = -1;
	end_x = -1;
	end_y = -1;
	final_sx = -1;
	final_sy = -1;
	final_ww = -1;
	final_hh = -1;
	dragging = 0;
	end();
	show();
}

FakeWindow::~FakeWindow()
{
}

void	FakeWindow::draw()
{
	Fl_Window::draw();
	if(raw_data != NULL)
	{
		fl_draw_image((unsigned char *)raw_data, 0, 0, w(), h(), 3);
		if((start_x > -1)
		&& (start_y > -1)
		&& (end_x > -1)
		&& (end_y > -1))
		{
			int sx = 0;
			int sy = 0;
			int ww = Fl::w();
			int hh = Fl::h();
			if(start_x < end_x)
			{
				ww = end_x - start_x;
				sx = start_x;
			}
			else
			{
				ww = start_x - end_x;
				sx = end_x;
			}
			if(start_y < end_y)
			{
				hh = end_y - start_y;
				sy = start_y;
			}
			else
			{
				hh = start_y - end_y;
				sy = end_y;
			}
			fl_color(FL_YELLOW);
			fl_rect(sx, sy, ww, hh);
			final_sx = sx;
			final_sy = sy;
			final_ww = ww;
			final_hh = hh;
		}
	}
}

int	FakeWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		if(Fl::event_button() == 1)
		{
			start_x = Fl::event_x();
			start_y = Fl::event_y();
			end_x = start_x;
			end_y = start_y;
			redraw();
			dragging = 1;
		}
		else if(Fl::event_button() == 3)
		{
			if((final_sx > -1)
			&& (final_sy > -1)
			&& (final_ww > -1)
			&& (final_hh > -1))
			{
				char buf[4096];
				char buf2[4096];
				sprintf(buf, "desktop://%d,%d,%d,%d", final_sx, final_sy, final_ww, final_hh);
				sprintf(buf2, "Desktop (%d,%d,%d,%d)", final_sx, final_sy, final_ww, final_hh);
				if(my_window->new_source_window != NULL)
				{
					Fl_Input *alias_in = (Fl_Input *)my_window->new_source_window->alias;
					char *alias = (char *)alias_in->value();
					if(alias != NULL)
					{
						if(strlen(alias) > 0)
						{
							strcpy(buf2, alias);
						}
					}
				}
				my_window->SetupCamera(buf, buf2, final_ww, final_hh, 32);
				my_window->show();
				hide();
			}
			dragging = 0;
		}
		flag = 1;
	}
	else if((event == FL_DRAG) || (event == FL_DRAG))
	{
		if(dragging == 1)
		{
			end_x = Fl::event_x();
			end_y = Fl::event_y();
			redraw();
			flag = 1;
		}
	}
	else if(event == FL_RELEASE)
	{
		end_x = Fl::event_x();
		end_y = Fl::event_y();
		dragging = 0;
		redraw();
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

unsigned char	*local_capture_cap(int *width, int *height)
{
	unsigned char *(*capture_cap)(int *, int *);
	capture_cap = (unsigned char *(*)(int *, int *))void_capture_capture;
	int pseudo_width = 0;
	int pseudo_height = 0;
	unsigned char *ptr = capture_cap(&pseudo_width, &pseudo_height);
	*width = pseudo_width;
	*height = pseudo_height;
	return(ptr);
}

Camera::Camera(MyWin *in_win, int in_id, char *source, int num, double forced_fps, int in_requested_w, int in_requested_h, int rr, int gg, int bb, int aa, int t_rr, int t_gg, int t_bb, int t_aa, int use_chroma)
{
int		loop;
int		read_pipe(int *flag);
int		read_single_frame_file(int *flag);
char	*parse_quadlet(char *cp, int *sx, int *sy, int *ex, int *ey);

	my_window = in_win;
	double gsf = in_win->gui_scale_factor;
	type = CAMERA_TYPE_CAMERA;
	id = in_id;
	power = 1;
	requested_x = -1;
	requested_y = -1;
	requested_w = in_requested_w;
	requested_h = in_requested_h;
	strcpy(path, "");
	strcpy(original_path, "");
	strcpy(alias, "");
	record = 0;
	recording = 0;
	last = 0;
	object_detect = 0;
	motion_detect = 0;
	follow_objects = 0;
	follow_motion = 0;
	ever_opened = 0;
	capture_scaling = 1.0;
	zoom = 1.0;
	priority = 0;
	cap = NULL;
	width = 0;
	height = 0;
	orig_width = 0;
	orig_height = 0;
	last_grab_time = 0;
	grab_interval = 0;
	last_capture_time = 0;
	capture_interval = 0.0;
	newly_captured = 0;
	font_sz = 32;
	grab_window_id = 0;
	static_initialized = 0;
	save_fifo = NULL;
	stopped = 1;
	forced_aspect_x = 1.0;
	forced_aspect_y = 1.0;
	fd[0] = -1;
	fd[1] = -1;
	total_frames[0] = 0;
	total_frames[1] = 0;
	true_total_frames[0] = 0;
	true_total_frames[1] = 0;
	since_frames[0] = 0;
	since_frames[1] = 0;
	since_time = 0;
	elapsed = 0;
	old_elapsed = -1;
	frame_cnt[0] = 0;
	frame_cnt[1] = 0;
	fps = forced_fps;
	capturing = 0;
	current_fps = 30.0;
	old_fps = 0;
	fps_cnt = 0;
	focus_using_samples = 0;
	keep_focusing = 0;
	focus_frame_ready = 0;
	cap_fourcc = 0;
	cap_total_frames = 0;
	cap_format = 0;
	ccx = 0;
	ccy = 0;
	cx = 0;
	cy = 0;
	last_cx = cx;
	last_cy = cy;
	shared_image = NULL;
	accel = 100;
	pip_idx = -1;
	keep_pip = 0;
	red = rr;
	green = gg;
	blue = bb;
	alpha = aa;
	text_red = t_rr;
	text_green = t_gg;
	text_blue = t_bb;
	text_alpha = t_aa;
	html = NULL;
	strcpy(snapshot_filename_format, "photo_%U.png");
	snapshot_initial_delay = 0;
	snapshot_repeat_delay = 0;
	snapshot_trigger_condition = SNAPSHOT_TRIGGER_BUTTON;
	snapshot_scale = 1.0;
	snapshot = 0;

	immediate_list = NULL;
	immediate_cnt = 0;
	for(loop = 0;loop < 8;loop++)
	{
		layer_state[loop] = 1;
	}
	edit_layer = 0;

	strcpy(pseudo_camera_name, "PSEUDO CAMERA");
	plugin_camera = NULL;
	freeze_video = 0;
	mute_video = 0;
	alternate_interval = 5.0;
	alternate_index = 0;
	alternate_time = 0;
	for(loop = 0;loop < 128;loop++)
	{
		color_it_r[loop] = 0;
		color_it_g[loop] = 0;
		color_it_b[loop] = 0;
		color_it_tolerance_r[loop] = 24;
		color_it_tolerance_g[loop] = 24;
		color_it_tolerance_b[loop] = 24;
		color_it_replace_r[loop] = 0;
		color_it_replace_g[loop] = 0;
		color_it_replace_b[loop] = 0;
		color_it_replace_a[loop] = 0;
	}
	color_it_cnt = 0;

	crop_start_x = 0;
	crop_start_y = 0;
	use_crop_start = 0;
	last_start_x = 0;
	last_start_y = 0;

	edge_blend = 0.5;
	paused_accumulation_ts = 0;
	paused_start_ts = 0;
	start_ts = local_timestamp();
	local_ts = local_timestamp();
	running_time = 0;
	starting_time = 0;

	flip_horizontal = 0;
	flip_vertical = 0;
	brightness = 0.5;
	saturation = 1.0;
	hue = 1.0;
	intensity = 1.0;
	red_intensity = 1.0;
	green_intensity = 1.0;
	blue_intensity = 1.0;
	alpha_intensity = 1.0;
	contrast = 0.5;
	motion_threshold = 100;
	recognition_threshold = 0.5;
	recognize_interval = 10;

	zoom_box_display = 0;
	zoom_box_x = -1;
	zoom_box_y = -1;
	zoom_box_w = -1;
	zoom_box_h = -1;
	resuming = 0;
	strcpy(format_code, "");
	grab_portion_x = -1;
	grab_portion_y = -1;
	grab_portion_w = -1;
	grab_portion_h = -1;
	source_camera = NULL;
	cairo_surface = NULL;
	cairo_context = NULL;
	single_frame_fd = -1;
	chroma_color = CHROMA_ON_GREEN;

	for(loop = 0;loop < 128;loop++)
	{
		filter_plugin[loop] = NULL;
		filter_plugin_name[loop] = NULL;
		filter_name[loop] = NULL;
		filter_dialog[loop] = NULL;
	}
	filter_plugin_cnt = 0;
	filter_cnt = 0;

	osg_viewer = NULL;
	instrument_window = NULL;
	for(loop = 0;loop < 128;loop++)
	{
		matrix_state[loop] = NULL;
	}
	matrix_state_cnt = 0;

	av_window = NULL;

	list_length = -1;
	list_position = 0;
	list_ready_for_more = 0;
	pipe_done = 0;
	for(loop = 0;loop < 128;loop++)
	{
		strcpy(text_list[loop], "");
	}
	display_width = my_window->display_width;
	display_height = my_window->display_height;
	int mw_w = my_window->w();
	int mw_h = my_window->h();
	if(my_window->auto_scale == 1)
	{
		if(Fl::h() > 0)
		{
			double use_scale = 1080.0 / (double)Fl::h();
			mw_w = my_window->w() * use_scale;
			mw_h = my_window->h() * use_scale;
		}
	}
	image_sx = (mw_w / 2) - (display_width / 2);
	image_sy = (mw_h / 2) - (display_height / 2);

	once = 0;
	detected_object_cnt = 0;
	detected_object_countdown = 0;
	for(loop = 0;loop < 10;loop++)
	{
		detected_object[loop].x = -1;
		detected_object[loop].y = -1;
		detected_object[loop].w = -1;
		detected_object[loop].h = -1;
		detected_object[loop].idx = -1;
		detected_object[loop].confidence = 0.0;
	}
	for(loop = 0;loop < 1024;loop++)
	{
		object_index[loop] = 0;
	}
	trigger_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		trigger[loop] = -1;
	}
	for(loop = 0;loop < 32;loop++)
	{
		pip[loop] = NULL;
	}
	for(loop = 0;loop < 128;loop++)
	{
		image_window[loop] = NULL;
	}
	image_window_cnt = 0;
	int progress_thumb = 0;

	pipe_pid = -1;
	pipe_in = -1;
	pipe_out = -1;
	pipe_fp = NULL;

	piping_text = 0;
	VideoCapture *n_cap = CreateCameraCapture(source, num);
	if(n_cap != NULL)
	{
		if(n_cap->isOpened())
		{
			SetSystemAlias();
			int starting_width = (int)n_cap->get(CAP_PROP_FRAME_WIDTH);
			int starting_height = (int)n_cap->get(CAP_PROP_FRAME_HEIGHT);
			if(strlen(format_code) > 0)
			{
				n_cap->set(CAP_PROP_FOURCC, VideoWriter::fourcc(format_code[0], format_code[1], format_code[2], format_code[3]));
			}
			if((starting_width != requested_w) || (starting_height != requested_h))
			{
				n_cap->set(CAP_PROP_FRAME_WIDTH, requested_w);
				n_cap->set(CAP_PROP_FRAME_HEIGHT, requested_h);
				sleep(1);
			}
			int n_width = (int)n_cap->get(CAP_PROP_FRAME_WIDTH);
			int n_height = (int)n_cap->get(CAP_PROP_FRAME_HEIGHT);
			n_cap->set(CAP_PROP_BUFFERSIZE, 10);
			n_cap->set(CAP_PROP_FPS, 60);

			cap_fourcc = n_cap->get(cv::CAP_PROP_FOURCC);
			char c1, c2, c3, c4;
			convert_fourcc(cap_fourcc, c1, c2, c3, c4);
			cap_total_frames = n_cap->get(cv::CAP_PROP_FRAME_COUNT);
			cap_format = n_cap->get(cv::CAP_PROP_FORMAT);
			int frame_rate = n_cap->get(cv::CAP_PROP_FPS);
			Mat test_only = imread(path);
			if((cap_fourcc == 0) || ((test_only.rows > 0) && (test_only.cols > 0)))
			{
				type = CAMERA_TYPE_IMAGE;
			}
			n_width = (int)n_cap->get(CAP_PROP_FRAME_WIDTH);
			n_height = (int)n_cap->get(CAP_PROP_FRAME_HEIGHT);
			cap = n_cap;
			width = n_width;
			height = n_height;
			if((n_width != requested_w) || (n_height != requested_h))
			{
				fprintf(stderr, "Warning: Cannot fit to requested dimensions. (%d x %d) vs. (%d x %d)\n",
					n_width, n_height,
					requested_w, requested_h);
				width = requested_w;
				height = requested_h;
			}
			progress_thumb = 1;
		}
		else if(source != NULL)
		{
			type = CAMERA_TYPE_TEXT;
			width = requested_w;
			height = requested_h;
			if(strncmp(source, "blank://", strlen("blank://")) == 0)
			{
				red = 0;
				green = 0;
				blue = 0;
				alpha = 0;
				char *cp = source + strlen("blank://");
				if(strlen(cp) > 0)
				{
					parse_quadlet(cp, &red, &green, &blue, &alpha);
				}
				cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(red, green, blue, alpha));
				mat = local_mat;
				reserve_mat = local_mat.clone();

				width = requested_w;
				height = requested_h;
				type = CAMERA_TYPE_BLANK;
			}
			else if(strncmp(source, "pipe://", strlen("pipe://")) == 0)
			{
				char *cp = source + strlen("pipe://");
				pipe_pid = popen2(cp, &pipe_in, &pipe_out);
				if(pipe_pid != -1)
				{
					piping_text = 1;
					type = CAMERA_TYPE_PIPED;
					pipe_fp = fdopen(pipe_out, "r");
					CreateTask((int (*)(int *))read_pipe, (void *)this);
				}
			}
			else if(strncmp(source, "file://", strlen("file://")) == 0)
			{
				char *cp = source + strlen("file://");
				single_frame_fd = open(cp, O_RDWR);
				if(single_frame_fd != -1)
				{
					type = CAMERA_TYPE_SINGLE_FRAME_FILE;
					CreateTask((int (*)(int *))read_single_frame_file, (void *)this);
				}
			}
			else if(strncmp(source, "osg://", strlen("osg://")) == 0)
			{
				char *cp = source + strlen("osg://");
				char *file[1];
				file[0] = cp;
				osg_viewer = open_osg(1, file, requested_w, requested_h);
				type = CAMERA_TYPE_OSG;
			}
			else if(strncmp(source, "desktop://", strlen("desktop://")) == 0)
			{
				char *cp = source + strlen("desktop://");
				if(strlen(cp) > 0)
				{
					int sx = 0;
					int sy = 0;
					int sw = Fl::w();
					int sh = Fl::h();
					parse_quadlet(cp, &sx, &sy, &sw, &sh);
					grab_portion_x = sx;
					grab_portion_y = sy;
					grab_portion_w = sw;
					grab_portion_h = sh;
				}
				in_win->GrabDesktop();
				width = in_win->desktop_mat.cols;
				height = in_win->desktop_mat.rows;
				type = CAMERA_TYPE_DESKTOP;
			}
			else if(strncmp(source, "this://", strlen("this://")) == 0)
			{
			}
			else if(strncmp(source, "window://", strlen("window://")) == 0)
			{
				char *cp = source + strlen("window://");
				if(strlen(cp) > 0)
				{
					grab_window_id = (unsigned long int)atol(cp);
					GrabWindow();
					width = mat.cols;
					height = mat.rows;
					type = CAMERA_TYPE_WINDOW;
				}
			}
			else if(strncmp(source, "pseudo://", strlen("pseudo://")) == 0)
			{
				if(void_pseudo_camera != NULL)
				{
					int use_id = 0;
					char *cp = source + strlen("pseudo://");
					if(strlen(cp) > 0)
					{
						strcpy(pseudo_camera_name, cp);
					}
					void *(*pseudo_camera)(char *, int *, int *, int *);
					pseudo_camera = (void *(*)(char *, int *, int *, int *))void_pseudo_camera;
					int pseudo_width = 0;
					int pseudo_height = 0;
					int pseudo_depth = 0;
					void *ptr = pseudo_camera(pseudo_camera_name, &pseudo_width, &pseudo_height, &pseudo_depth);
					if(ptr != NULL)
					{
						free(ptr);
						width = pseudo_width;
						height = pseudo_height;
						type = CAMERA_TYPE_PSEUDO;
					}
				}
			}
			else if(strncmp(source, "plugin://", strlen("plugin://")) == 0)
			{
				int use_id = 0;
				char *cp = source + strlen("plugin://");
				if(strlen(cp) > 0)
				{
					plugin_camera = (void *)atol(cp);
					void *(*pseudo_camera)(char *, int *, int *, int *);
					pseudo_camera = (void *(*)(char *, int *, int *, int *))plugin_camera;
					int pseudo_width = 0;
					int pseudo_height = 0;
					int pseudo_depth = 0;
					void *ptr = pseudo_camera(pseudo_camera_name, &pseudo_width, &pseudo_height, &pseudo_depth);
					if(ptr != NULL)
					{
						free(ptr);
						width = pseudo_width;
						height = pseudo_height;
						type = CAMERA_TYPE_PLUGIN;
					}
				}
			}
			else if(strncmp(source, "av://", strlen("av://")) == 0)
			{
				char *cp = source + strlen("av://");
				if(strlen(cp) > 0)
				{
					av_window = new VLC_Window(cp, width, height);
					type = CAMERA_TYPE_AV;
					Fl::add_timeout(1.0, vlc_window_start_cb, av_window);
				}
			}
			else if(strncmp(source, "html://", strlen("html://")) == 0)
			{
				if(global_html == 1)
				{
					char *cp = source + strlen("html://");
					if(strlen(cp) > 0)
					{
						html = new HTML_Win(cp, NULL, width, height);
						while(html->raw == NULL)
						{
							Fl::check();
						}
						type = CAMERA_TYPE_HTML;
					}
				}
			}
			else if(strncmp(source, "html source://", strlen("html source://")) == 0)
			{
				if(global_html == 1)
				{
					char *cp = source + strlen("html source://");
					if(strlen(cp) > 0)
					{
						html = new HTML_Win(NULL, cp, width, height);
						while(html->raw == NULL)
						{
							Fl::check();
						}
						type = CAMERA_TYPE_HTML;
					}
				}
			}
			else if(strncmp(source, "sourced://", strlen("sourced://")) == 0)
			{
				source_camera = NULL;
				char *cp = source + strlen("sourced://");
				if(strlen(cp) > 0)
				{
					double factor = 1.0;
					if(*cp == '(')
					{
						cp++;
						factor = atof(cp);
						while((*cp != ')') && (*cp != '\0')) cp++;
						while(*cp == ')') cp++;
					}
					int match = -1;
					for(loop = 0;((loop < my_window->source_cnt) && (match == -1));loop++)
					{
						Camera *compare_cam = my_window->camera[loop];
						if(compare_cam->alias != NULL)
						{
							if(strcmp(cp, compare_cam->alias) == 0)
							{
								match = loop;
							}
						}
						if(match == -1)
						{
							if(compare_cam->path != NULL)
							{
								if(strcmp(cp, compare_cam->path) == 0)
								{
									match = loop;
								}
							}
						}
					}
					if(match > -1)
					{
						Camera *test_camera = my_window->camera[match];
						if((test_camera->type != CAMERA_TYPE_ALL)
						&& (test_camera->type != CAMERA_TYPE_ALTERNATING)
						&& (test_camera->type != CAMERA_TYPE_SOURCED)
						&& (test_camera->type != CAMERA_TYPE_EDGE_DETECT)
						&& (test_camera->type != CAMERA_TYPE_CHROMAKEY))
						{
							source_camera = test_camera;
							requested_w = source_camera->width * factor;
							requested_h = source_camera->height * factor;
						}
					}
					type = CAMERA_TYPE_SOURCED;
				}
			}
			else if(strncmp(source, "edge://", strlen("edge://")) == 0)
			{
				source_camera = NULL;
				char *cp = source + strlen("edge://");
				if(strlen(cp) > 0)
				{
					double factor = 1.0;
					if(*cp == '(')
					{
						cp++;
						factor = atof(cp);
						while((*cp != ')') && (*cp != '\0')) cp++;
						while(*cp == ')') cp++;
					}
					int match = -1;
					for(loop = 0;((loop < my_window->source_cnt) && (match == -1));loop++)
					{
						Camera *compare_cam = my_window->camera[loop];
						if(compare_cam->alias != NULL)
						{
							if(strcmp(cp, compare_cam->alias) == 0)
							{
								match = loop;
							}
						}
						if(match == -1)
						{
							if(compare_cam->path != NULL)
							{
								if(strcmp(cp, compare_cam->path) == 0)
								{
									match = loop;
								}
							}
						}
					}
					if(match > -1)
					{
						Camera *test_camera = my_window->camera[match];
						if((test_camera->type != CAMERA_TYPE_ALL)
						&& (test_camera->type != CAMERA_TYPE_ALTERNATING)
						&& (test_camera->type != CAMERA_TYPE_SOURCED)
						&& (test_camera->type != CAMERA_TYPE_EDGE_DETECT)
						&& (test_camera->type != CAMERA_TYPE_CHROMAKEY))
						{
							source_camera = test_camera;
							requested_w = source_camera->width * factor;
							requested_h = source_camera->height * factor;
						}
					}
					type = CAMERA_TYPE_EDGE_DETECT;
				}
			}
			else if(strncmp(source, "chroma://", strlen("chroma://")) == 0)
			{
				source_camera = NULL;
				char *cp = source + strlen("chroma://");
				if(strlen(cp) > 0)
				{
					double factor = 1.0;
					if(*cp == '(')
					{
						cp++;
						factor = atof(cp);
						while((*cp != ')') && (*cp != '\0')) cp++;
						while(*cp == ')') cp++;
					}
					int match = -1;
					for(loop = 0;((loop < my_window->source_cnt) && (match == -1));loop++)
					{
						Camera *compare_cam = my_window->camera[loop];
						if(compare_cam->alias != NULL)
						{
							if(strcmp(cp, compare_cam->alias) == 0)
							{
								match = loop;
							}
						}
						if(match == -1)
						{
							if(compare_cam->path != NULL)
							{
								if(strcmp(cp, compare_cam->path) == 0)
								{
									match = loop;
								}
							}
						}
					}
					if(match > -1)
					{
						Camera *test_camera = my_window->camera[match];
						if((test_camera->type != CAMERA_TYPE_ALL)
						&& (test_camera->type != CAMERA_TYPE_ALTERNATING)
						&& (test_camera->type != CAMERA_TYPE_SOURCED)
						&& (test_camera->type != CAMERA_TYPE_EDGE_DETECT)
						&& (test_camera->type != CAMERA_TYPE_CHROMAKEY))
						{
							source_camera = test_camera;
							requested_w = source_camera->width * factor;
							requested_h = source_camera->height * factor;
						}
					}
					chroma_color = use_chroma;
					type = CAMERA_TYPE_CHROMAKEY;
				}
			}
			else if(strncmp(source, "alternating://", strlen("alternating://")) == 0)
			{
				alternate_interval = 5;
				char *cp = source + strlen("alternating://");
				if(strlen(cp) > 0)
				{
					alternate_interval = atof(cp);
				}
				alternate_index = 0;
				alternate_time = precise_time();
				type = CAMERA_TYPE_ALTERNATING;
			}
			else if(strncmp(source, "all://", strlen("all://")) == 0)
			{
				type = CAMERA_TYPE_ALL;
			}
			cap = n_cap;
		}
	}
	net = my_window->net;
	for(loop = 0;loop < my_window->recognize_class_cnt;loop++)
	{
		if(my_window->recognize_class_name[loop] != NULL)
		{
			if((strcasecmp("bird", my_window->recognize_class_name[loop]) == 0)
			|| (strcasecmp("squirrel", my_window->recognize_class_name[loop]) == 0)
			|| (strcasecmp("animal", my_window->recognize_class_name[loop]) == 0))
			{
				object_index[loop] = 1;
			}
		}
	}
	if(!mat.empty())
	{
		if(mat.channels() == 3)
		{
			cvtColor(mat, mat, COLOR_RGB2RGBA);
		}
		cairo_surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
		if(cairo_surface != NULL)
		{
			cairo_context = cairo_create(cairo_surface);
		}
	}
	if(progress_thumb == 1)
	{
		if(start_win != NULL)
		{
			if(start_win->visible())
			{
				char buf[8192];
				if(strlen(alias) > 0)
				{
					sprintf(buf, "Open camera:\n%s", alias);
				}
				else
				{
					sprintf(buf, "Open camera:\n%s", source);
				}
				if(mat.empty())
				{
					if(cap != NULL)
					{
						if(cap->isOpened())
						{
							cap->grab();
							last_grab_time = precise_time();
						}
					}
					Capture(1);
				}
				if(!mat.empty())
				{
					if(start_win->image_mat_cnt < 128)
					{
						Mat local_mat;
						mat.copyTo(local_mat);
						cv::resize(local_mat, local_mat, cv::Size(160, 90));
						start_win->image_mat[start_win->image_mat_cnt] = local_mat.clone();
						start_win->image_mat_cnt++;
						start_win->redraw();
					}
				}
				start_win->Update(buf);
			}
		}
	}
}

Camera::~Camera()
{
int	outer;
int	loop;

	pipe_done = 1;
	if(single_frame_fd != -1)
	{
		close(single_frame_fd);
	}
	if(cairo_context != NULL)
	{
		cairo_destroy(cairo_context);
	}
	if(cairo_surface != NULL)
	{
		cairo_surface_destroy(cairo_surface);
	}
	if(shared_image != NULL)
	{
		DestroySharedImage(shared_image, &shminfo);
	}
	if(immediate_list != NULL)
	{
		free(immediate_list);
		immediate_list = NULL;
		immediate_cnt = 0;
	}
	if(av_window != NULL)
	{
		av_window->Pause();
		av_window->Stop();
		delete av_window;
		av_window = NULL;
	}
	for(loop = 0;loop < 32;loop++)
	{
		if(pip[loop] != NULL)
		{
			delete pip[loop];
			pip[loop] = NULL;
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(filter_plugin[loop] != NULL)
		{
			filter_plugin[loop] = NULL;
		}
		if(filter_plugin_name[loop] != NULL)
		{
			free(filter_plugin_name[loop]);
			filter_plugin_name[loop] = NULL;
		}
		if(filter_name[loop] != NULL)
		{
			free(filter_name[loop]);
			filter_name[loop] = NULL;
		}
		if(filter_dialog[loop] != NULL)
		{
			filter_dialog[loop]->hide();
			Fl::delete_widget(filter_dialog[loop]);
			filter_dialog[loop] = NULL;
		}
	}
	if(my_window->single_stream == 1)
	{
		for(outer = 0;outer < my_window->source_cnt;outer++)
		{
			if(my_window->camera[outer] != NULL)
			{
				Camera *cam = my_window->camera[outer];
				if(cam != this)
				{
					save_fifo = NULL;
					fd[0] = -1;
					fd[1] = -1;
				}
			}
		}
	}
	if(save_fifo != NULL)
	{
		while(save_fifo->top > 0)
		{
			usleep(10000);
		}
		delete save_fifo;
	}
	if(fd[0] > -1)
	{
		close(fd[0]);
	}
	if(fd[1] > -1)
	{
		close(fd[1]);
	}
	if(cap != NULL)
	{
		if(cap->isOpened())
		{
			cap->release();
			delete cap;
		}
	}
	if(html != NULL)
	{
		delete html;
	}
}

void	Camera::LowerALayer(int use_layer)
{
int			loop;
Immediate	*local[1024];
ImageWindow	*local_im[128];

	int cnt = 0;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop]->layer == use_layer)
			{
				if(cnt < 1024)
				{
					local[cnt] = immediate_list[loop];
					cnt++;
				}
			}
		}
	}
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop]->layer == (use_layer - 1))
			{
				immediate_list[loop]->layer++;
			}
		}
	}
	for(loop = 0;loop < cnt;loop++)
	{
		local[loop]->layer--;
	}
	cnt = 0;
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->layer == use_layer)
			{
				if(cnt < 128)
				{
					local_im[cnt] = image_window[loop];
					cnt++;
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->layer == (use_layer - 1))
			{
				image_window[loop]->layer++;
			}
		}
	}
	for(loop = 0;loop < cnt;loop++)
	{
		local_im[loop]->layer--;
	}
}

void	Camera::RaiseALayer(int use_layer)
{
int			loop;
Immediate	*local[1024];
ImageWindow	*local_im[128];

	int cnt = 0;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop]->layer == use_layer)
			{
				if(cnt < 1024)
				{
					local[cnt] = immediate_list[loop];
					cnt++;
				}
			}
		}
	}
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop]->layer == (use_layer + 1))
			{
				immediate_list[loop]->layer--;
			}
		}
	}
	for(loop = 0;loop < cnt;loop++)
	{
		local[loop]->layer++;
	}
	cnt = 0;
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->layer == use_layer)
			{
				if(cnt < 128)
				{
					local_im[cnt] = image_window[loop];
					cnt++;
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->layer == (use_layer + 1))
			{
				image_window[loop]->layer--;
			}
		}
	}
	for(loop = 0;loop < cnt;loop++)
	{
		local_im[loop]->layer++;
	}
}

void	GetV4LCardName(char *path, char *card_name)
{
struct v4l2_capability  capability;

	if((path != NULL) && (card_name != NULL))
	{
		strcpy(card_name, "");
		int fd = open(path, O_RDONLY);
		if(fd > -1)
		{
			memset(&capability, 0, sizeof(capability));
			int nn = ioctl(fd, VIDIOC_QUERYCAP, &capability);
			if(nn != -1)
			{
				if(capability.card != NULL)
				{
					if((capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) == V4L2_CAP_VIDEO_CAPTURE)
					{
						int done = 0;
						int i = 0;
						int go = 0;
						while(done == 0)
						{
							struct v4l2_fmtdesc fmtdesc;
							memset(&fmtdesc, 0, sizeof(fmtdesc));
							fmtdesc.index = i;
							fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
							if(ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc) != -1)
							{
								go = 1;
							}
							else
							{
								done = 1;
							}
							i++;
						}
						if(go == 1)
						{
							strcpy(card_name, (char *)capability.card);
						}
					}
				}
			}
			close(fd);
		}
	}
}

int	GetV4LFormats(char *path, int *format, char **format_desc)
{
struct v4l2_capability  capability;

	int cnt = 0;
	if((path != NULL) && (format != NULL))
	{
		int fd = open(path, O_RDONLY);
		if(fd > -1)
		{
			memset(&capability, 0, sizeof(capability));
			int nn = ioctl(fd, VIDIOC_QUERYCAP, &capability);
			if(nn != -1)
			{
				if(capability.card != NULL)
				{
					if((capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) == V4L2_CAP_VIDEO_CAPTURE)
					{
						int done = 0;
						int i = 0;
						while(done == 0)
						{
							struct v4l2_fmtdesc fmtdesc;
							memset(&fmtdesc, 0, sizeof(fmtdesc));
							fmtdesc.index = i;
							fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
							if(ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc) != -1)
							{
								format[cnt] = fmtdesc.pixelformat;
								format_desc[cnt] = strdup((char *)fmtdesc.description);
								cnt++;
							}
							else
							{
								done = 1;
							}
							i++;
						}
					}
				}
			}
			close(fd);
		}
	}
	return(cnt);
}

void	Camera::SetSystemAlias()
{
char	card[4096];

	strcpy(card, "");
	GetV4LCardName(path, card);
	if(strlen(alias) < 1)
	{
		strcpy(alias, (char *)card);
	}
}

void	Camera::AddImmediate(Immediate *in)
{
int	loop;

	int done = -1;
	if(immediate_list != NULL)
	{
		for(loop = 0;((loop < immediate_cnt) && (done == -1));loop++)
		{
			if(immediate_list[loop] == NULL)
			{
				done = loop;
			}
		}
	}
	if(done > -1)
	{
		immediate_list[done] = in;
	}
	else
	{
		immediate_list = (Immediate **)realloc(immediate_list, sizeof(Fl_Widget *) * (immediate_cnt + 1));
		if(immediate_list != NULL)
		{
			immediate_list[immediate_cnt] = in;
			immediate_cnt++;
		}
	}
}

void	MyWin::AddImmediate(Immediate *in)
{
int	loop;

	int done = -1;
	if(immediate_list != NULL)
	{
		for(loop = 0;((loop < immediate_cnt) && (done == -1));loop++)
		{
			if(immediate_list[loop] == NULL)
			{
				done = loop;
			}
		}
	}
	if(done > -1)
	{
		immediate_list[done] = in;
	}
	else
	{
		immediate_list = (Immediate **)realloc(immediate_list, sizeof(Fl_Widget *) * (immediate_cnt + 1));
		if(immediate_list != NULL)
		{
			immediate_list[immediate_cnt] = in;
			immediate_cnt++;
		}
	}
}

void	MyWin::PasteImmediate()
{
int	loop;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < immediate_cnt;loop++)
		{
			Immediate *old_im = immediate_list[loop];
			if(old_im != NULL)
			{
				Immediate *new_im = new Immediate(old_im, cam);
				cam->AddImmediate(new_im);
				add(new_im);
			}
		}
	}
}

void	MyWin::ClearImmediate()
{
int	loop;

	if(immediate_list != NULL)
	{
		for(loop = 0;loop < immediate_cnt;loop++)
		{
			if(immediate_list[loop] != NULL)
			{
				Fl::delete_widget(immediate_list[loop]);
			}
		}
		free(immediate_list);
		immediate_cnt = 0;
		immediate_list = NULL;
		immediate_drawing_window->paste_button->hide();
		immediate_drawing_window->clear_copy_buffer_button->hide();
		immediate_drawing_window->redraw();
	}
}

void	Camera::Save(char *filename)
{
	StoredCamera *stored = new StoredCamera(this);
	int fd = open(filename, O_CREAT | O_WRONLY, 0777);
	if(fd > -1)
	{
		write(fd, stored, sizeof(StoredCamera));
		SaveImmediate(fd);
		close(fd);
	}
	delete stored;
}

void	Camera::Save(int fd)
{
	StoredCamera *stored = new StoredCamera(this);
	write(fd, stored, sizeof(StoredCamera));
	SaveImmediate(fd);
	delete stored;
}

StoredCamera::StoredCamera(Camera *in)
{
int	loop;

	strcpy(path, in->path);
	strcpy(original_path, in->original_path);
	strcpy(alias, in->alias);

	requested_x = in->requested_x;
	requested_y = in->requested_y;
	requested_w = in->requested_w;
	requested_h = in->requested_h;
	object_detect = in->object_detect;
	follow_objects = in->follow_objects;
	motion_detect = in->motion_detect;
	follow_motion = in->follow_motion;
	font_sz = in->font_sz;
	zoom = in->zoom;
	width = in->width;
	height = in->height;
	id = in->id;

	flip_horizontal = in->flip_horizontal;
	flip_vertical = in->flip_vertical;
	brightness = in->brightness;
	saturation = in->saturation;
	hue = in->hue;
	intensity = in->intensity;
	contrast = in->contrast;
	motion_threshold = in->motion_threshold;
	recognition_threshold = in->recognition_threshold;
	recognize_interval = in->recognize_interval;

	zoom_box_display = in->zoom_box_display;
	zoom_box_x = in->zoom_box_x;
	zoom_box_y = in->zoom_box_y;
	zoom_box_w = in->zoom_box_w;
	zoom_box_h = in->zoom_box_h;

	display_width = in->display_width;
	display_height = in->display_height;

	red = in->red;
	green = in->green;
	blue = in->blue;
	alpha = in->alpha;
	text_red = in->text_red;
	text_green = in->text_green;
	text_blue = in->text_blue;
	text_alpha = in->text_alpha;

	strcpy(snapshot_filename_format, in->snapshot_filename_format);
	snapshot_initial_delay = in->snapshot_initial_delay;
	snapshot_repeat_delay = in->snapshot_repeat_delay;
	snapshot_trigger_condition = in->snapshot_trigger_condition;
	snapshot_scale = in->snapshot_scale;

	image_window_cnt = in->image_window_cnt;
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(strlen(in->image_window[loop]->camera->original_path) > 0)
		{
			strcpy(image_window[loop].source_path, in->image_window[loop]->camera->original_path);
		}
		else
		{
			strcpy(image_window[loop].source_path, in->image_window[loop]->camera->path);
		}
		image_window[loop].width = in->image_window[loop]->width;
		image_window[loop].height = in->image_window[loop]->height;
		image_window[loop].orig_w = in->image_window[loop]->orig_w;
		image_window[loop].orig_h = in->image_window[loop]->orig_h;
		image_window[loop].dx = in->image_window[loop]->dx;
		image_window[loop].dy = in->image_window[loop]->dy;
		image_window[loop].dw = in->image_window[loop]->dw;
		image_window[loop].dh = in->image_window[loop]->dh;
		image_window[loop].buttonize = in->image_window[loop]->buttonize;
		image_window[loop].buttonized_x = in->image_window[loop]->buttonized_x;
		image_window[loop].buttonized_y = in->image_window[loop]->buttonized_y;
		image_window[loop].buttonized_w = in->image_window[loop]->buttonized_w;
		image_window[loop].buttonized_h = in->image_window[loop]->buttonized_h;
		image_window[loop].layer = in->image_window[loop]->layer;
	}
	filter_plugin_cnt = in->filter_plugin_cnt;
	filter_cnt = in->filter_cnt;
	for(loop = 0;loop < 128;loop++)
	{
		if(in->filter_plugin_name[loop] != NULL)
		{
			strcpy(filter_plugin_name[loop], in->filter_plugin_name[loop]);
		}
		else
		{
			strcpy(filter_plugin_name[loop], "");
		}
		if(in->filter_name[loop] != NULL)
		{
			strcpy(filter_name[loop], in->filter_name[loop]);
		}
		else
		{
			strcpy(filter_name[loop], "");
		}
	}
}

StoredCamera::StoredCamera()
{
int	loop;

	strcpy(path, "");
	strcpy(alias, "");

	requested_x = -1;
	requested_y = -1;
	requested_w = 0;
	requested_h = 0;
	object_detect = 0;
	follow_objects = 0;
	motion_detect = 0;
	follow_motion = 0;
	font_sz = 0;
	zoom = 0;
	width = 0;
	height = 0;
	id = -1;

	flip_horizontal = 0;
	flip_vertical = 0;
	brightness = 0;
	saturation = 0;
	hue = 0;
	intensity = 0;
	contrast = 0;
	motion_threshold = 0;
	recognition_threshold = 0;
	recognize_interval = 0;

	zoom_box_display = 0;
	zoom_box_x = 0;
	zoom_box_y = 0;
	zoom_box_w = 0;
	zoom_box_h = 0;

	display_width = 0;
	display_height = 0;

	red = 0;
	green = 0;
	blue = 0;
	alpha = 0;
	text_red = 0;
	text_green = 0;
	text_blue = 0;
	text_alpha = 0;

	strcpy(snapshot_filename_format, "");
	snapshot_initial_delay = 0;
	snapshot_repeat_delay = 0;
	snapshot_trigger_condition = 0;
	snapshot_scale = 1.0;

	image_window_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		strcpy(image_window[loop].source_path, "");
		image_window[loop].width = 0;
		image_window[loop].height = 0;
		image_window[loop].orig_w = 0;
		image_window[loop].orig_h = 0;
		image_window[loop].dx = 0;
		image_window[loop].dy = 0;
		image_window[loop].dw = 0;
		image_window[loop].dh = 0;
	}
	filter_plugin_cnt = 0;
	filter_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		strcpy(filter_plugin_name[loop], "");
		strcpy(filter_name[loop], "");
	}
}

StoredImmediate::StoredImmediate()
{
int	loop;

	for(loop = 0;loop < 32768;loop++)
	{
		stored_default.xx[loop] = 0;
		stored_default.yy[loop] = 0;
		stored_default.pt_type[loop] = 0;
	}
	strcpy(stored_default.image_file_path, "");
}

void	Camera::SaveImmediate(int fd)
{
int				loop;
StoredImmediate	stored;

	write(fd, &immediate_cnt, sizeof(int));
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			stored.Populate(immediate_list[loop]);
			write(fd, &stored, sizeof(StoredImmediate));
		}
	}
}  

void	Camera::LoadImmediate(int fd)
{
int				loop;
StoredImmediate	stored;

	int im_cnt = 0;
	read(fd, &im_cnt, sizeof(int));
	for(loop = 0;loop < im_cnt;loop++)
	{
		int nn = read(fd, &stored, sizeof(StoredImmediate));
		if(nn == sizeof(StoredImmediate))
		{
			int xx = stored.sx;
			int yy = stored.sy;
			int ww = stored.sw;
			int hh = stored.sh;
			ImmediateDrawingWindow *idw = my_window->immediate_drawing_window;
			Immediate *immediate = new Immediate(my_window, this, xx, yy, ww, hh);
			immediate->idw = idw;
			stored.Depopulate(my_window, this, immediate);
			AddImmediate(immediate);
			my_window->add(immediate);
		}
	}
}

void	StoredImmediate::Populate(Immediate *im)
{
int	loop;

	sx = im->x();
	sy = im->y();
	sw = im->w();
	sh = im->h();
	im_type = im->im_type;
	draw_it = im->draw_it;
	immediate_type = im->immediate_type;
	hovering = im->hovering;
	dragging = im->dragging;
	initial_x = im->initial_x;
	initial_y = im->initial_y;
	last_x = im->last_x;
	last_y = im->last_y;
	layer = im->layer;
	drag_mode = im->drag_mode;
	overall_alpha = im->overall_alpha;
	mw_mode = im->mw_mode;

	ImDefault *use_default = NULL;
	if(im->text != NULL) use_default = (ImDefault *)im->text;
	if(im->line != NULL) use_default = (ImDefault *)im->line;
	if(im->rectangle != NULL) use_default = (ImDefault *)im->rectangle;
	if(im->rectangle_select != NULL) use_default = (ImDefault *)im->rectangle_select;
	if(im->ellipse != NULL) use_default = (ImDefault *)im->ellipse;
	if(im->freehand != NULL) use_default = (ImDefault *)im->freehand;
	if(im->pixelate != NULL) use_default = (ImDefault *)im->pixelate;
	if(im->image_im != NULL) use_default = (ImDefault *)im->image_im;

	strcpy(stored_value, "");
	strcpy(stored_default.font_name, "");
	if(use_default == im->text)
	{
		strncpy(stored_value, im->text->value(), 32768);
		strncpy(stored_default.font_name, im->text->font_name, 128);
	}
	strncpy(stored_default.image_file_path, use_default->image_file_path, 4096);
	strncpy(stored_default.freehand_filename, use_default->freehand_filename, 4096);
	stored_default.width = use_default->width;
	stored_default.red = use_default->red;
	stored_default.green = use_default->green;
	stored_default.blue = use_default->blue;
	stored_default.alpha = use_default->alpha;

	stored_default.style = use_default->style;
	stored_default.shape = use_default->shape;
	stored_default.use_size = use_default->use_size;
	stored_default.filled = use_default->filled;
	stored_default.selecting = use_default->selecting;
	stored_default.erase = use_default->erase;
	stored_default.box_type = use_default->box_type;
	stored_default.cnt = use_default->cnt;
	for(loop = 0;loop < use_default->cnt;loop++)
	{
		stored_default.xx[loop] = use_default->xx[loop];
		stored_default.yy[loop] = use_default->yy[loop];
		stored_default.pt_type[loop] = use_default->pt_type[loop];
	}
	stored_default.key = use_default->key;
	stored_default.italic = use_default->italic;
	stored_default.bold = use_default->bold;
	stored_default.outline = use_default->outline;
	stored_default.font_alpha = use_default->font_alpha;
	stored_default.background_red = use_default->background_red;
	stored_default.background_green = use_default->background_green;
	stored_default.background_blue = use_default->background_blue;
	stored_default.background_alpha = use_default->background_alpha;
	stored_default.outline_alpha = use_default->outline_alpha;
}

void	StoredImmediate::Depopulate(MyWin *win, Camera *cam, Immediate *im)
{
int	loop;

	im->im_type = im_type;
	im->draw_it = draw_it;
	im->immediate_type = immediate_type;
	im->hovering = hovering;
	im->dragging = dragging;
	im->initial_x = initial_x;
	im->initial_y = initial_y;
	im->last_x = last_x;
	im->last_y = last_y;
	im->layer = layer;
	im->drag_mode = drag_mode;
	im->overall_alpha = overall_alpha;
	im->mw_mode = mw_mode;

	ImDefault *def = NULL;
	if(im_type == IM_RECTANGLE)
	{
		im->rectangle = new ImRectangle(win, im, sx, sy, sw, sh);
		im->add(im->rectangle);
		def = (ImDefault *)im->rectangle;
	}
	else if(im_type == IM_PIXELATE)
	{
		im->pixelate = new ImPixelate(win, im, sx, sy, sw, sh);
		im->add(im->pixelate);
		def = (ImDefault *)im->pixelate;
	}
	else if(im_type == IM_RECTANGLE_SELECT)
	{
		im->rectangle_select = new ImRectangleSelect(win, im, sx, sy, sw, sh);
		im->add(im->rectangle_select);
		def = (ImDefault *)im->pixelate;
	}
	else if(im_type == IM_IMAGE)
	{
		im->image_im = new ImImage(win, im, sx, sy, sw, sh);
		im->add(im->image_im);
		def = (ImDefault *)im->image_im;
	}
	else if(im_type == IM_ELLIPSE)
	{
		im->ellipse = new ImEllipse(win, im, sx, sy, sw, sh);
		im->add(im->ellipse);
		def = (ImDefault *)im->ellipse;
	}
	else if(im_type == IM_FREEHAND)
	{
		im->freehand = new ImFreehand(win, im, sx, sy, sw, sh);
		im->add(im->freehand);
		def = (ImDefault *)im->freehand;
	}
	else if(im_type == IM_LINE)
	{
		im->line = new ImLine(win, im, immediate_type, sx, sy, sw, sh);
		im->add(im->line);
		def = (ImDefault *)im->line;
	}
	else if(im_type == IM_TEXT)
	{
		im->text = new ImText(win, im, sx, sy, sw, sh);
		im->text->value(stored_value);
		im->add(im->text);
		def = (ImDefault *)im->text;
	}
	if(def != NULL)
	{
		def->width = stored_default.width;
		def->red = stored_default.red;
		def->green = stored_default.green;
		def->blue = stored_default.blue;
		def->alpha = stored_default.alpha;
		def->style = stored_default.style;
		def->shape = stored_default.shape;
		def->use_size = stored_default.use_size;
		def->filled = stored_default.filled;
		def->selecting = stored_default.selecting;
		def->erase = stored_default.erase;
		def->box_type = stored_default.box_type;
		def->cnt = stored_default.cnt;
		if(def->cnt > 0)
		{
			def->xx = (int *)malloc(sizeof(int) * def->cnt);
			def->yy = (int *)malloc(sizeof(int) * def->cnt);
			def->pt_type = (int *)malloc(sizeof(int) * def->cnt);
			for(loop = 0;loop < stored_default.cnt;loop++)
			{
				def->xx[loop] = stored_default.xx[loop];
				def->yy[loop] = stored_default.yy[loop];
				def->pt_type[loop] = stored_default.pt_type[loop];
			}
		}
		def->key = stored_default.key;
		def->italic = stored_default.italic;
		def->bold = stored_default.bold;
		def->outline = stored_default.outline;
		def->font_alpha = stored_default.font_alpha;
		def->background_red = stored_default.background_red;
		def->background_green = stored_default.background_green;
		def->background_blue = stored_default.background_blue;
		def->background_alpha = stored_default.background_alpha;
		def->outline_alpha = stored_default.outline_alpha;
		strncpy(def->font_name, stored_default.font_name, 128);
		strncpy(def->image_file_path, stored_default.image_file_path, 4096);
		strncpy(def->freehand_filename, stored_default.freehand_filename, 4096);
	}
}

StoredImDefault::StoredImDefault()
{
	strcpy(image_file_path, "");
	strcpy(freehand_filename, "");
}

CameraCaps::CameraCaps()
{
int	loop;

	path = NULL;
	alias = NULL;
	for(loop = 0;loop < 128;loop++)
	{
		fourcc[loop] = 0;
		fourcc_description[loop] = NULL;
	}
	fourcc_cnt = 0;
}

CameraCaps::~CameraCaps()
{
int	loop;

	if(path != NULL) free(path);
	if(alias != NULL) free(alias);
	for(loop = 0;loop < fourcc_cnt;loop++)
	{
		if(fourcc_description[loop] != NULL) free(fourcc_description[loop]);
	}
}

void	MyWin::ClearCameraCaps()
{
int	loop;

	for(loop = 0;loop < camera_caps_cnt;loop++)
	{
		if(camera_caps[loop] != NULL)
		{
			delete camera_caps[loop];
			camera_caps[loop] = NULL;
		}
	}
	camera_caps_cnt = 0;
}

int	MyWin::PopulateCameraCaps()
{
int		loop;
char	path[4096];
char	card_name[4096];

	ClearCameraCaps();
	camera_caps_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		strcpy(card_name, "");
		sprintf(path, "/dev/video%d", loop);
		GetV4LCardName(path, card_name);
		if(strlen(card_name) > 0)
		{
			if(camera_caps_cnt < 128)
			{
				camera_caps[camera_caps_cnt] = new CameraCaps();
				camera_caps[camera_caps_cnt]->path = strdup(path);
				camera_caps[camera_caps_cnt]->alias = strdup(card_name);
				int nn = GetV4LFormats(path, camera_caps[camera_caps_cnt]->fourcc, camera_caps[camera_caps_cnt]->fourcc_description);
				camera_caps[camera_caps_cnt]->fourcc_cnt = nn;
				camera_caps_cnt++;
			}
		}
	}
	return(camera_caps_cnt);
}

Camera	*MyWin::FindCameraByPath(char *path)
{
int	loop;

	Camera *r = NULL;
	for(loop = 0;((loop < source_cnt) && (r == NULL));loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			if(strcmp(path, cam->path) == 0)
			{
				r = cam;
			}
		}
	}
	return(r);
}

void	Camera::RestoreFromStoredCamera(StoredCamera *in)
{
int	loop;
int	inner;

	strcpy(path, in->path);
	strcpy(original_path, in->original_path);
	strcpy(alias, in->alias);

	requested_x = in->requested_x;
	requested_y = in->requested_y;
	requested_w = in->requested_w;
	requested_h = in->requested_h;
	object_detect = in->object_detect;
	follow_objects = in->follow_objects;
	motion_detect = in->motion_detect;
	follow_motion = in->follow_motion;
	font_sz = in->font_sz;
	zoom = in->zoom;
	width = in->width;
	height = in->height;

	flip_horizontal = in->flip_horizontal;
	flip_vertical = in->flip_vertical;
	brightness = in->brightness;
	saturation = in->saturation;
	hue = in->hue;
	intensity = in->intensity;
	contrast = in->contrast;
	motion_threshold = in->motion_threshold;
	recognition_threshold = in->recognition_threshold;
	recognize_interval = in->recognize_interval;

	zoom_box_display = in->zoom_box_display;
	zoom_box_x = in->zoom_box_x;
	zoom_box_y = in->zoom_box_y;
	zoom_box_w = in->zoom_box_w;
	zoom_box_h = in->zoom_box_h;

	display_width = in->display_width;
	display_height = in->display_height;

	red = in->red;
	green = in->green;
	blue = in->blue;
	alpha = in->alpha;
	text_red = in->text_red;
	text_green = in->text_green;
	text_blue = in->text_blue;
	text_alpha = in->text_alpha;

	strcpy(snapshot_filename_format, in->snapshot_filename_format);
	snapshot_initial_delay = in->snapshot_initial_delay;
	snapshot_repeat_delay = in->snapshot_repeat_delay;
	snapshot_trigger_condition = in->snapshot_trigger_condition;
	snapshot_scale = in->snapshot_scale;

	image_window_cnt = in->image_window_cnt;
	int cnt = 0;
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		Camera *source_cam = my_window->FindCameraByPath(in->image_window[loop].source_path);
		if(source_cam == NULL)
		{
			int cam_num = my_window->SetupCamera(in->image_window[loop].source_path, NULL, my_window->requested_w, my_window->requested_h, 32);
			if(cam_num > -1)
			{
				source_cam = my_window->camera[cam_num];
			}
		}
		if(source_cam != NULL)
		{
			int dx = in->image_window[loop].dx;
			int dy = in->image_window[loop].dy;
			int dw = in->image_window[loop].width;
			int dh = in->image_window[loop].height;
			ImageWindow *iw = new ImageWindow(loop, my_window, source_cam, this, dx, dy, dw, dh);
			image_window[cnt] = iw;

			image_window[cnt]->camera = source_cam;
			image_window[cnt]->dest_camera = this;

			image_window[cnt]->width = in->image_window[loop].width;
			image_window[cnt]->height = in->image_window[loop].height;
			image_window[cnt]->orig_w = in->image_window[loop].orig_w;
			image_window[cnt]->orig_h = in->image_window[loop].orig_h;
			image_window[cnt]->dx = in->image_window[loop].dx;
			image_window[cnt]->dy = in->image_window[loop].dy;
			image_window[cnt]->dw = in->image_window[loop].dw;
			image_window[cnt]->dh = in->image_window[loop].dh;
			image_window[cnt]->layer = in->image_window[loop].layer;

			image_window[cnt]->buttonize = in->image_window[loop].buttonize;
			image_window[cnt]->buttonized_x = in->image_window[loop].buttonized_x;
			image_window[cnt]->buttonized_y = in->image_window[loop].buttonized_y;
			image_window[cnt]->buttonized_w = in->image_window[loop].buttonized_w;
			image_window[cnt]->buttonized_h = in->image_window[loop].buttonized_h;

			if(image_window[cnt]->buttonize == 0)
			{
				image_window[cnt]->show();
			}
			else
			{
				image_window[cnt]->hide();
			}
			my_window->add(iw);
			cnt++;
		}
	}
	immediate_cnt = 0;
	filter_plugin_cnt = in->filter_plugin_cnt;
	for(loop = 0;loop < 128;loop++)
	{
		if(strlen(in->filter_plugin_name[loop]) > 0)
		{
			filter_plugin_name[loop] = strdup(in->filter_plugin_name[loop]);
			for(inner = 0;inner < global_potential_filter_cnt;inner++)
			{
				if((global_potential_filter[inner] != NULL) && (global_potential_filter_handle[inner] != NULL))
				{
					if(strcmp(filter_plugin_name[loop], global_potential_filter[inner]) == 0)
					{
						filter_plugin[loop] = (void *)dlsym(global_potential_filter_handle[inner], global_potential_filter[inner]);
					}
				}
			}
		}
		else
		{
			filter_plugin_name[loop] = NULL;
		}
		if(strlen(in->filter_name[loop]) > 0)
		{
			filter_name[loop] = strdup(in->filter_name[loop]);
			filter_dialog[loop] = new FilterDialog(my_window, 0, 0, 100, 70, strdup(in->filter_name[loop]));
		}
		else
		{
			filter_name[loop] = NULL;
			filter_dialog[loop] = NULL;
		}
	}
}

void	Camera::DrawPIP()
{
int	loop;

	int cnt = 0;
	for(loop = 0;loop < 32;loop++)
	{
		if(pip[loop] != NULL)
		{
			pip[loop]->draw(cnt);
			cnt++;
		}
	}
}

void	Camera::AddPIP(PIP *in_pip)
{
int	loop;

	int no_go = -1;
	int use = -1;
	for(loop = 0;loop < 32;loop++)
	{
		if(pip[loop] != NULL)
		{
			if(in_pip->camera == pip[loop]->camera)
			{
				no_go = loop;
			}
		}
		else if(use == -1)
		{
			use = loop;
		}
	}
	if(use > -1)
	{
		pip[use] = in_pip;
	}
}

void	Camera::AddPIPByCamera(Camera *in_cam, int in_embed)
{
int	loop;

	int no_go = 0;
	if(in_cam != this)
	{
		for(loop = 0;loop < 32;loop++)
		{
			if(pip[loop] != NULL)
			{
				if(pip[loop]->camera == in_cam)
				{
					no_go = 1;
				}
			}
		}
		if(no_go == 0)
		{
			int px, py;
			int nw, nh;
			Mat dst = mat;
			Mat src = in_cam->mat;
			nw = (int)((double)src.cols * my_window->pip_size);
			nh = (int)((double)src.rows * my_window->pip_size);

			px = (int)((double)dst.cols * my_window->pip_x_position);
			py = (int)((double)dst.rows * my_window->pip_y_position);

			int dx = dst.cols - (px + nw);
			if(dx < 0) px += dx;
			int dy = dst.rows - (py + nh);
			if(dy < 0) py += dy;
			PIP *n_pip = new PIP(in_cam, px, py, nw, nh);
			AddPIP(n_pip);
		}
		else
		{
			RemovePIPByCamera(in_cam);
		}
	}
}

void	Camera::RemovePIPByCamera(Camera *in_cam)
{
int	loop;

	for(loop = 0;loop < 32;loop++)
	{
		if(pip[loop] != NULL)
		{
			if(pip[loop]->camera == in_cam)
			{
				delete pip[loop];
				pip[loop] = NULL;
			}
		}
	}
}

void	Camera::Resize(int ww, int hh)
{
	if((ww >= 320) && (ww <= my_window->w())
	&& (hh >= 240) && (hh <= my_window->h()))
	{
		cap->set(CAP_PROP_FRAME_WIDTH, ww);
		cap->set(CAP_PROP_FRAME_HEIGHT, hh);
		cap->set(CAP_PROP_BUFFERSIZE, 10);
		cap->set(CAP_PROP_FPS, 60);
		width = (int)cap->get(CAP_PROP_FRAME_WIDTH);
		height = (int)cap->get(CAP_PROP_FRAME_HEIGHT);
	}
}

void	Camera::SetCairo()
{
	if(cairo_surface != NULL)
	{
		if(mat.channels() == 3)
		{
			cvtColor(mat, mat, COLOR_RGB2RGBA);
		}
		void *add1 = cairo_image_surface_get_data(cairo_surface);
		void *add2 = mat.ptr();
		if(add1 != add2)
		{
			if(add1 != NULL)
			{
				cairo_surface_destroy(cairo_surface);
			}
			if(cairo_context != NULL)
			{
				cairo_destroy(cairo_context);
			}
			cairo_surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
			if(cairo_surface != NULL)
			{
				cairo_context = cairo_create(cairo_surface);
			}
		}
	}
	else
	{
		if(mat.channels() == 3)
		{
			cvtColor(mat, mat, COLOR_RGB2RGBA);
		}
		cairo_surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
		if(cairo_surface != NULL)
		{
			cairo_context = cairo_create(cairo_surface);
		}
	}
}

void	edge_detect_with_blend(Mat& mat, double blend)
{
void				blend_two(Mat one, Mat two, int xx, int yy, double alpha);
std::vector<Mat>	channels;
Mat					contours;
Mat					gray_image;
Mat					hsv;
Mat					out;

	cvtColor(mat, hsv, COLOR_RGB2HSV);
	split(hsv, channels);
	gray_image = channels[0];

	Mat detected_edges;
	blur(mat, detected_edges, Size(3, 3));
	cv::Canny(detected_edges, contours, 35, 90);

	Mat rgb[4] = {contours, contours, contours, contours};
	merge(rgb, 4, out);

	blend_two(mat, out, 0, 0, blend);
	mat = out.clone();
}

void	edge_detect(Mat& mat, int blur_radius, int low, int high, double blend)
{
void				blend_two(Mat one, Mat two, int xx, int yy, double alpha);
std::vector<Mat>	channels;
Mat					contours;
Mat					gray_image;
Mat					hsv;
Mat					out;

	cvtColor(mat, hsv, COLOR_RGB2HSV);
	split(hsv, channels);
	gray_image = channels[0];

	Mat detected_edges;
	if(blur_radius < 1) blur_radius = 1;
	blur(mat, detected_edges, Size(blur_radius, blur_radius));
	cv::Canny(detected_edges, contours, low, high);

	Mat rgb[4] = {contours, contours, contours, contours};
	merge(rgb, 4, out);

	blend_two(mat, out, 0, 0, blend);
	mat = out.clone();
}

void	Camera::RunFilters()
{
void	blend_two(Mat one, Mat two, int xx, int yy, double alpha);
int		loop;

	for(loop = 0;loop < filter_cnt;loop++)
	{
		if(filter_name[loop] != NULL)
		{
			if(filter_dialog[loop] != NULL)
			{
				if(filter_dialog[loop]->disable != 1)
				{
					if(strcmp(filter_name[loop], "Grayscale") == 0)
					{
						cvtColor(mat, mat, COLOR_RGBA2GRAY);
						cvtColor(mat, mat, COLOR_GRAY2RGBA);
					}
					else if(strcmp(filter_name[loop], "Threshold") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						int sel = filter_dialog[loop]->selected;
						int use = 0;
						if(sel == 0) use = THRESH_BINARY;
						else if(sel == 1) use = THRESH_BINARY_INV;
						else if(sel == 2) use = THRESH_TRUNC;
						else if(sel == 3) use = THRESH_TOZERO;
						else if(sel == 4) use = THRESH_TOZERO_INV;
						threshold(mat, mat, val0, val1, use);
					}
					else if(strcmp(filter_name[loop], "Invert") == 0)
					{
						invert_mat(mat);
					}
					else if(strcmp(filter_name[loop], "Edge Detect") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						double val2 = filter_dialog[loop]->number[2];
						double val3 = filter_dialog[loop]->number[3];
						edge_detect(mat, val0, val1, val2, val3);
					}
					else if(strcmp(filter_name[loop], "Brightness") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						brightness_mat(mat, val0);
					}
					else if(strcmp(filter_name[loop], "Contrast") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						contrast_mat(mat, val0);
					}
					else if(strcmp(filter_name[loop], "Saturation") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						mat = change_saturation(mat, saturation);
					}
					else if(strcmp(filter_name[loop], "Hue") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						if(val0 != 1.0)
						{
							mat = change_hue(mat, val0);
						}
					}
					else if(strcmp(filter_name[loop], "CLAHE") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						clahe_mat(mat, val0);
					}
					else if(strcmp(filter_name[loop], "Color Intensity") == 0)
					{
							double val0 = filter_dialog[loop]->number[0];
							double val1 = filter_dialog[loop]->number[1];
							double val2 = filter_dialog[loop]->number[2];
							double val3 = filter_dialog[loop]->number[3];
							ColorIntensity(mat, val0, val1, val2, val3);
					}
					else if(strcmp(filter_name[loop], "Blur") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						if(val0 != 1.0)
						{
							blur_mat(mat, val0);
						}
					}
					else if(strcmp(filter_name[loop], "Crop") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						double val2 = filter_dialog[loop]->number[2];
						double val3 = filter_dialog[loop]->number[3];
						double left = mat.cols * val0;
						double right = mat.cols * val1;
						if(right < left)
						{
							double tmp = left;
							left = right;
							right = tmp;
						}
						double top = mat.rows * val2;
						double bottom = mat.rows * val3;
						if(bottom < top)
						{
							double tmp = top;
							top = bottom;
							bottom = tmp;
						}
						int i_left = left;
						int i_top = top;
						int i_width = (int)right - i_left;
						int i_height = (int)bottom - i_top;
						if((i_width > 0) && (i_height > 0))
						{
							crop_mat(mat, i_left, i_top, i_width, i_height);
							width = i_width;
							height = i_height;
						}
					}
					else if(strcmp(filter_name[loop], "Scale") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						if((val0 >= 0.1) && (val1 >= 0.1))
						{
							int width = (double)mat.cols * val0;
							int height = (double)mat.rows * val1;
							cv::resize(mat, mat, cv::Size(width, height));
						}
					}
					else if(strcmp(filter_name[loop], "Blend") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						int sel = filter_dialog[loop]->selected;
						Camera *other_cam = NULL;
						if((sel > -1) && (sel < 128))
						{
							char *selected_alias = filter_dialog[loop]->str[sel];
							if(selected_alias != NULL)
							{
								if(strlen(selected_alias) > 0)
								{
									for(loop = 0;((loop < my_window->source_cnt) && (other_cam == NULL));loop++)
									{
										Camera *camera = my_window->camera[loop];
										if(camera != NULL)
										{
											if(strcmp(camera->alias, selected_alias) == 0)
											{
												other_cam = camera;
											}
										}
									}
								}
							}
							if(other_cam != NULL)
							{
								Mat in = other_cam->mat;
								blend_two(in, mat, 0, 0, val0);
							}
						}
					}
					else if(strcmp(filter_name[loop], "Bevel") == 0)
					{
						double val0 = filter_dialog[loop]->number[0];
						double val1 = filter_dialog[loop]->number[1];
						double val2 = filter_dialog[loop]->number[2];
						double val3 = filter_dialog[loop]->number[3];
						double val4 = filter_dialog[loop]->number[4];
						if(((val0 < (mat.cols / 2)) && (val0 < (mat.rows / 2)))
						&& ((val2 < (mat.cols / 2)) && (val2 < (mat.rows / 2))))
						{
							rounded_rectangle(mat, Point(val0, val0), Point(mat.cols - val0, mat.rows - val0), Scalar(val2, val3, val4), 3, LINE_8, val1);
						}
					}
					else if(strcmp(filter_name[loop], "Gradient") == 0)
					{
						int direction = filter_dialog[loop]->selected;
						double r1 = filter_dialog[loop]->number[0];
						double g1 = filter_dialog[loop]->number[1];
						double b1 = filter_dialog[loop]->number[2];
						double a1 = filter_dialog[loop]->number[3];
						double r2 = filter_dialog[loop]->number[4];
						double g2 = filter_dialog[loop]->number[5];
						double b2 = filter_dialog[loop]->number[6];
						double a2 = filter_dialog[loop]->number[7];
						color_gradient(mat, direction, Scalar(r1, g1, b1, a1), Scalar(r2, g2, b2, a2));
					}
				}
			}
		}
	}
}

void	Camera::RunInstruments()
{
int	loop;

	for(loop = 0;loop < matrix_state_cnt;loop++)
	{
		if(matrix_state[loop] != NULL)
		{
			osg::Node *nd = matrix_state[loop]->node;
			if(nd != NULL)
			{
				double start_x = matrix_state[loop]->start_x;
				double start_y = matrix_state[loop]->start_y;
				double start_z = matrix_state[loop]->start_z;
				double end_x = matrix_state[loop]->end_x;
				double end_y = matrix_state[loop]->end_y;
				double end_z = matrix_state[loop]->end_z;
				osg::MatrixTransform *matrix = (osg::MatrixTransform *)nd;
				if(matrix_state[loop]->command == INSTRUMENT_COMMAND_SET)
				{
					matrix_state[loop]->current_x = start_x;
					matrix_state[loop]->current_y = start_y;
					matrix_state[loop]->current_z = start_z;
				}
				else if(matrix_state[loop]->command == INSTRUMENT_COMMAND_ONCE)
				{
					double diff_x = fabs(matrix_state[loop]->end_x - matrix_state[loop]->current_x);
					double diff_y = fabs(matrix_state[loop]->end_y - matrix_state[loop]->current_y);
					double diff_z = fabs(matrix_state[loop]->end_z - matrix_state[loop]->current_z);
					if((diff_x > 0.001)
					|| (diff_y > 0.001)
					|| (diff_z > 0.001))
					{
						if(matrix_state[loop]->frames < 1) matrix_state[loop]->frames = 1;
						double inc_x = (matrix_state[loop]->end_x - matrix_state[loop]->start_x) / matrix_state[loop]->frames;
						double inc_y = (matrix_state[loop]->end_y - matrix_state[loop]->start_y) / matrix_state[loop]->frames;
						double inc_z = (matrix_state[loop]->end_z - matrix_state[loop]->start_z) / matrix_state[loop]->frames;
						matrix_state[loop]->current_x += inc_x;
						matrix_state[loop]->current_y += inc_y;
						matrix_state[loop]->current_z += inc_z;
					}
				}
				else if(matrix_state[loop]->command == INSTRUMENT_COMMAND_REPEAT)
				{
					if(matrix_state[loop]->frames < 1) matrix_state[loop]->frames = 1;
					double inc_x = (matrix_state[loop]->end_x - matrix_state[loop]->start_x) / matrix_state[loop]->frames;
					double inc_y = (matrix_state[loop]->end_y - matrix_state[loop]->start_y) / matrix_state[loop]->frames;
					double inc_z = (matrix_state[loop]->end_z - matrix_state[loop]->start_z) / matrix_state[loop]->frames;
					matrix_state[loop]->current_x += inc_x;
					matrix_state[loop]->current_y += inc_y;
					matrix_state[loop]->current_z += inc_z;
					double diff_x = fabs(matrix_state[loop]->end_x - matrix_state[loop]->current_x);
					double diff_y = fabs(matrix_state[loop]->end_y - matrix_state[loop]->current_y);
					double diff_z = fabs(matrix_state[loop]->end_z - matrix_state[loop]->current_z);
					if(diff_x < 0.001)
					{
						matrix_state[loop]->current_x = matrix_state[loop]->start_x;
					}
					if(diff_y < 0.001)
					{
						matrix_state[loop]->current_y = matrix_state[loop]->start_y;
					}
					if(diff_z < 0.001)
					{
						matrix_state[loop]->current_z = matrix_state[loop]->start_z;
					}
				}
				else if(matrix_state[loop]->command == INSTRUMENT_COMMAND_CYCLE)
				{
					if(matrix_state[loop]->frames < 1) matrix_state[loop]->frames = 1;
					double inc_x = (matrix_state[loop]->end_x - matrix_state[loop]->start_x) / matrix_state[loop]->frames;
					double inc_y = (matrix_state[loop]->end_y - matrix_state[loop]->start_y) / matrix_state[loop]->frames;
					double inc_z = (matrix_state[loop]->end_z - matrix_state[loop]->start_z) / matrix_state[loop]->frames;
					matrix_state[loop]->current_x += inc_x;
					matrix_state[loop]->current_y += inc_y;
					matrix_state[loop]->current_z += inc_z;
					double diff_x = fabs(matrix_state[loop]->end_x - matrix_state[loop]->current_x);
					double diff_y = fabs(matrix_state[loop]->end_y - matrix_state[loop]->current_y);
					double diff_z = fabs(matrix_state[loop]->end_z - matrix_state[loop]->current_z);
					if(diff_x < 0.001)
					{
						double tmp = matrix_state[loop]->start_x;
						matrix_state[loop]->start_x =  matrix_state[loop]->end_x;
						matrix_state[loop]->end_x = tmp;
						matrix_state[loop]->current_x = matrix_state[loop]->start_x;
					}
					if(diff_y < 0.001)
					{
						double tmp = matrix_state[loop]->start_y;
						matrix_state[loop]->start_y =  matrix_state[loop]->end_y;
						matrix_state[loop]->end_y = tmp;
						matrix_state[loop]->current_y = matrix_state[loop]->start_y;
					}
					if(diff_z < 0.001)
					{
						double tmp = matrix_state[loop]->start_z;
						matrix_state[loop]->start_z =  matrix_state[loop]->end_z;
						matrix_state[loop]->end_z = tmp;
						matrix_state[loop]->current_z = matrix_state[loop]->start_z;
					}
				}
				double current_x = matrix_state[loop]->current_x;
				double current_y = matrix_state[loop]->current_y;
				double current_z = matrix_state[loop]->current_z;
				if(matrix_state[loop]->type == MATRIX_STATE_TYPE_TRANSLATE)
				{
					matrix->setMatrix(osg::Matrix::translate(osg::Vec3(current_x, current_y, current_z)));
				}
				else if(matrix_state[loop]->type == MATRIX_STATE_TYPE_ROTATE)
				{
					osg::Matrix m;
					osg::Quat(current_z, osg::Vec3d(0, 0, 1), current_y, osg::Vec3d(0, 1, 0), current_x, osg::Vec3d(1, 0, 0)).get(m);
					matrix->setMatrix(m);
				}
				else if(matrix_state[loop]->type == MATRIX_STATE_TYPE_SCALE)
				{
					matrix->setMatrix(osg::Matrix::scale(osg::Vec3(current_x, current_y, current_z)));
				}
				matrix_state[loop]->current_frame++;;
			}
		}
	}
}

void	example_mask_it(Mat& mat)
{
	cv::Point corners[1][4];
	corners[0][0] = Point(10, 10);
	corners[0][1] = Point(600, 200);
	corners[0][2] = Point(800, 700);
	corners[0][3] = Point(20, 800);
	const Point* corner_list[1] = { corners[0] };

	int num_points = 4;
	int num_polygons = 1;
	int line_type = 8;
	cv::Mat mask(mat.rows, mat.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
	cv::fillPoly(mask, corner_list, &num_points, num_polygons, cv::Scalar(255, 255, 255, 255), line_type);

	cv::Mat result;
	cv::bitwise_and(mat, mask, mat);
}

void	MyWin::GrabAllCameras()
{
int		loop;

	for(loop = 0;loop < source_cnt;loop++)
	{
		if(camera[loop] != NULL)
		{
			Camera *cam = camera[loop];
			if(cam->power == 1)
			{
				if(cam->cap != NULL)
				{
					long int nn = precise_time();
					if((cam->last_grab_time + cam->grab_interval) < nn)
					{
						if(cam->cap->isOpened())
						{
							cam->cap->grab();
							cam->last_grab_time = nn;
						}
					}
					if(cam == DisplayedCamera())
					{
						cam->grab_interval = 0;
					}
					else
					{
						cam->grab_interval = 100000;
					}
				}
			}
		}
	}
}

void	Camera::Capture(int test_only)
{
int				loop;
int				inner;

	if(since_time == 0)
	{
		since_time = time(0);
	}
	long int now = precise_time();
	if(now > (last_capture_time + (int)(1000000.0 * capture_interval)))
	{
		last_capture_time = now;
		newly_captured = 1;
		if(type == CAMERA_TYPE_IMAGE)
		{
			if(static_initialized == 0)
			{
				mat = imread(path, IMREAD_UNCHANGED);
				reserve_mat = mat.clone();
				static_initialized = 1;
			}
			reserve_mat.copyTo(mat);
			if(mat.channels() == 3)
			{
				cvtColor(mat, mat, COLOR_BGR2RGBA);
			}
			else if(mat.channels() == 4)
			{
				cvtColor(mat, mat, COLOR_BGRA2RGBA);
			}
		}
		else if((type == CAMERA_TYPE_BLANK) && (!reserve_mat.empty()))
		{
			reserve_mat.copyTo(mat);
		}
		else
		{
			if(cap != NULL)
			{
				if(cap->isOpened())
				{
					Mat temp_mat;
					cap->retrieve(temp_mat);
					if(freeze_video == 1)
					{
						if(!reserve_mat.empty())
						{
							temp_mat = reserve_mat.clone();
							cvtColor(temp_mat, temp_mat, COLOR_BGRA2RGBA);
						}
						else
						{
							cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 255));
							temp_mat = local_mat.clone();
						}
					}
					if(mute_video == 1)
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 255));
						temp_mat = local_mat.clone();
					}
					int current_frame = 0;
					if(cap_total_frames > 1)	
					{
						current_frame = cap->get(cv::CAP_PROP_POS_FRAMES);
						if(current_frame >= cap_total_frames)
						{
							cap->set(cv::CAP_PROP_POS_FRAMES, 0);
						}
					}
					if(!temp_mat.empty())
					{
						mat = temp_mat;
						reserve_mat = temp_mat.clone();
						if(temp_mat.channels() == 3)
						{
							cvtColor(reserve_mat, reserve_mat, COLOR_BGR2RGBA);
							cvtColor(mat, mat, COLOR_BGR2RGBA);
						}
						else
						{
							cvtColor(reserve_mat, reserve_mat, COLOR_BGRA2RGBA);
							cvtColor(mat, mat, COLOR_BGRA2RGBA);
						}
					}
					else
					{
						if(cap_total_frames < 2)
						{
							type = CAMERA_TYPE_IMAGE;
						}
						else
						{
							cap->set(cv::CAP_PROP_POS_FRAMES, 0);
						}
					}
				}
				else if(type == CAMERA_TYPE_TEXT)
				{
					cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					literal_mat = local_mat.clone();
					RenderTextToMat(path, &literal_mat);
					mat = literal_mat.clone();
					reserve_mat = mat.clone();
					static_initialized = 1;
				}
				else if(type == CAMERA_TYPE_PIPED)
				{
					cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					literal_mat = local_mat.clone();
					RenderTextToMat(path, &literal_mat);
					mat = literal_mat.clone();
					reserve_mat = mat.clone();
					static_initialized = 1;
				}
				else if(type == CAMERA_TYPE_SINGLE_FRAME_FILE)
				{
					cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					if(mat.empty())
					{
						mat = local_mat.clone();
					}
					width = mat.cols;
					height = mat.rows;
				}
				else if(type == CAMERA_TYPE_OSG)
				{
					if(osg_viewer != NULL)
					{
						osg_viewer->frame();
						unsigned char *im = (unsigned char *)osg_viewer->image->getDataPointer();
						Mat src(osg_viewer->image->t(), osg_viewer->image->s(), CV_8UC4, (void *)im);
						mat = src.clone();
						width = mat.cols;
						height = mat.rows;
						RunInstruments();
					}
				}
				else if(type == CAMERA_TYPE_DESKTOP)
				{
					my_window->GrabDesktop(1);
					if((my_window->desktop_mat.cols > 0) && (my_window->desktop_mat.rows > 0))
					{
						if((grab_portion_x > -1)
						&& (grab_portion_y > -1)
						&& (grab_portion_w > -1)
						&& (grab_portion_h > -1))
						{
							Mat local_mat = my_window->desktop_mat(Rect(grab_portion_x, grab_portion_y, grab_portion_w, grab_portion_h));
							mat = local_mat.clone();
							reserve_mat = local_mat.clone();
							width = mat.cols;
							height = mat.rows;
						}
						else
						{
							mat = my_window->desktop_mat.clone();
							reserve_mat = mat.clone();
						}
					}
				}
				else if(type == CAMERA_TYPE_WINDOW)
				{
					GrabWindow();
					reserve_mat = mat.clone();
					width = mat.cols;
					height = mat.rows;
				}
				else if(type == CAMERA_TYPE_PSEUDO)
				{
					void *(*pseudo_camera)(char *, int *, int *, int *);
					pseudo_camera = (void *(*)(char *, int *, int *, int *))void_pseudo_camera;
					int pseudo_width = 0;
					int pseudo_height = 0;
					int pseudo_depth = 0;
					void *ptr = pseudo_camera(pseudo_camera_name, &pseudo_width, &pseudo_height, &pseudo_depth);
					if(ptr != NULL)
					{
						width = pseudo_width;
						height = pseudo_height;
						int depth = pseudo_depth;
						if(depth == 4)
						{
							Mat src = Mat(height, width, CV_8UC4, ptr);
							mat = src.clone();
						}
						else if(depth == 3)
						{
							Mat src = Mat(height, width, CV_8UC3, ptr);
							mat = src.clone();
						}
						reserve_mat = mat.clone();
						free(ptr);
					}
				}
				else if(type == CAMERA_TYPE_PLUGIN)
				{
					if(plugin_camera != NULL)
					{
						void *(*pseudo_camera)(char *, int *, int *, int *);
						pseudo_camera = (void *(*)(char *, int *, int *, int *))plugin_camera;
						int pseudo_width = 0;
						int pseudo_height = 0;
						int pseudo_depth = 0;
						void *ptr = pseudo_camera("Text", &pseudo_width, &pseudo_height, &pseudo_depth);
						if(ptr != NULL)
						{
							width = pseudo_width;
							height = pseudo_height;
							int depth = pseudo_depth;
							if(depth == 4)
							{
								Mat src = Mat(height, width, CV_8UC4, ptr);
								mat = src.clone();
							}
							else if(depth == 3)
							{
								Mat src = Mat(height, width, CV_8UC3, ptr);
								mat = src.clone();
							}
							reserve_mat = mat.clone();
							free(ptr);
						}
					}
				}
				else if(type == CAMERA_TYPE_AV)
				{
					if(av_window != NULL)
					{
						mat = av_window->mat.clone();
						width = mat.cols;
						height = mat.rows;
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_HTML)
				{
					if(html != NULL)
					{
						Mat src = Mat(height, width, CV_8UC4, html->raw);
						mat = src.clone();
						width = mat.cols;
						height = mat.rows;
						if(mat.channels() == 3)
						{
							cvtColor(mat, mat, COLOR_BGR2RGB);
						}
						else if(mat.channels() == 4)
						{
							cvtColor(mat, mat, COLOR_BGRA2RGBA);
						}
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_SOURCED)
				{
					if(source_camera != NULL)
					{
						source_camera->Capture();
						width = source_camera->mat.cols;
						height = source_camera->mat.rows;
						if((requested_w < width) && (requested_h < height)
						&& (requested_w > 0) && (requested_h > 0))
						{
							int sx = 0;
							int sy = 0;
							if((requested_x == -1) || (requested_y == -1))
							{
								sx = (width / 2) - (requested_w / 2);
								sy = (height / 2) - (requested_h / 2);
							}
							else
							{
								sx = requested_x;
								sy = requested_y;
								width = requested_w;
								height = requested_h;
							}
							my_window->CropFrame(source_camera->mat, &mat, sx, sy, requested_w, requested_h);
							cv::resize(mat, mat, cv::Size(width, height));
							reserve_mat = mat.clone();
						}
						else
						{
							mat = source_camera->mat.clone();
							reserve_mat = mat.clone();
						}
					}
					else
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(55, 100, 150, 255));
						mat = local_mat.clone();
						width = local_mat.cols;
						height = local_mat.rows;
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_EDGE_DETECT)
				{
					if(source_camera != NULL)
					{
						source_camera->Capture();
						width = source_camera->mat.cols;
						height = source_camera->mat.rows;
						if((requested_w < width) && (requested_h < height))
						{
							int sx = (width / 2) - (requested_w / 2);
							int sy = (height / 2) - (requested_h / 2);
							my_window->CropFrame(source_camera->mat, &mat, sx, sy, requested_w, requested_h);
							cv::resize(mat, mat, cv::Size(width, height));
							edge_detect_with_blend(mat, edge_blend);
							reserve_mat = mat.clone();
						}
						else
						{
							mat = source_camera->mat.clone();
							edge_detect_with_blend(mat, edge_blend);
							reserve_mat = mat.clone();
						}
					}
					else
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(55, 100, 150, 255));
						mat = local_mat.clone();
						width = local_mat.cols;
						height = local_mat.rows;
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_CHROMAKEY)
				{
					if(source_camera != NULL)
					{
						source_camera->Capture();
						width = source_camera->mat.cols;
						height = source_camera->mat.rows;
						if((requested_w < width) && (requested_h < height))
						{
							int sx = (width / 2) - (requested_w / 2);
							int sy = (height / 2) - (requested_h / 2);
							my_window->CropFrame(source_camera->mat, &mat, sx, sy, requested_w, requested_h);
							cv::resize(mat, mat, cv::Size(width, height));
							chromakey(mat, mat, chroma_color, 4.0, 1.0);
							reserve_mat = mat.clone();
						}
						else
						{
							mat = source_camera->mat.clone();
							chromakey(mat, mat, chroma_color, 4.0, 1.0);
							reserve_mat = mat.clone();
						}
					}
					else
					{
						cv::Mat local_mat(my_window->requested_h, my_window->requested_w, CV_8UC4, cv::Scalar(55, 100, 150, 255));
						mat = local_mat.clone();
						width = local_mat.cols;
						height = local_mat.rows;
						reserve_mat = mat.clone();
					}
				}
				else if(type == CAMERA_TYPE_ALTERNATING)
				{
					int must_advance = 0;
					Camera *use_camera = my_window->camera[alternate_index];
					if((use_camera != NULL) && (use_camera != this))
					{
						if(use_camera->power == 1)
						{
							if((use_camera->type != CAMERA_TYPE_ALTERNATING)
							&& (use_camera->type != CAMERA_TYPE_ALL)
							&& (use_camera->type != CAMERA_TYPE_SOURCED)
							&& (use_camera->type != CAMERA_TYPE_EDGE_DETECT))
							{
								use_camera->Capture();
								width = use_camera->mat.cols;
								height = use_camera->mat.rows;
								if((requested_w < width) && (requested_h < height))
								{
									int sx = (width / 2) - (requested_w / 2);
									int sy = (height / 2) - (requested_h / 2);
									my_window->CropFrame(use_camera->mat, &mat, sx, sy, requested_w, requested_h);
									cv::resize(mat, mat, cv::Size(width, height));
								}
								else
								{
									mat = use_camera->mat.clone();
								}
								reserve_mat = mat.clone();
							}
							else
							{
								must_advance = 1;
							}
						}
						else
						{
							must_advance = 1;
						}
					}
					else
					{
						must_advance = 1;
					}
					long int interval = precise_time() - alternate_time;
					if((interval > (long int)(alternate_interval * 1000000.0)) || (must_advance == 1))
					{
						alternate_index++;
						if(alternate_index >= my_window->source_cnt)
						{
							alternate_index = 0;
						}
						alternate_time = precise_time();
					}
				}
				else if(type == CAMERA_TYPE_ALL)
				{
					cv::Mat tmp_mat(height, width, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					mat = tmp_mat.clone();
					Mat local_mat[9];
					int usable_cnt = 0;
					for(loop = 0;loop < my_window->source_cnt;loop++)
					{
						Camera *use_camera = my_window->camera[loop];
						if((use_camera != NULL) && (use_camera != this))
						{
							if(use_camera->power == 1)
							{
								if((use_camera->type != CAMERA_TYPE_ALTERNATING)
								&& (use_camera->type != CAMERA_TYPE_ALL)
								&& (use_camera->type != CAMERA_TYPE_SOURCED)
								&& (use_camera->type != CAMERA_TYPE_EDGE_DETECT))
								{
									if(usable_cnt < 9)
									{
										use_camera->Capture();
										local_mat[usable_cnt] = use_camera->mat.clone();
									}
									usable_cnt++;
								}
							}
						}
					}
					int uw = width;
					int uh = height;
					if(usable_cnt > 1)
					{
						if(usable_cnt < 5)
						{
							uw = width / 2;
							uh = height / 2;
						}
						else
						{
							uw = width / 3;
							uh = height / 3;
						}
					}
					int px = 0;
					int py = 0;
					for(loop = 0;loop < usable_cnt;loop++)
					{
						Mat use_mat;
						cv::resize(local_mat[loop], use_mat, cv::Size(uw, uh));
						use_mat.copyTo(mat.rowRange(py, py + uh).colRange(px, px + uw));
						px += uw;
						if((px + uw) > mat.cols)
						{
							px = 0;
							py += uh;
						}
					}
					reserve_mat = mat.clone();
				}
				else
				{
					fprintf(stderr, "Error: Image is closed.\n");
				}
			}
		}
	}
	if(test_only == 0)
	{
		for(loop = 0;loop < filter_plugin_cnt;loop++)
		{
			void (*receive_image)(int, int, int, unsigned char *);
			receive_image = (void (*)(int, int, int, unsigned char*))filter_plugin[loop];
			if(receive_image != NULL)
			{
				receive_image(mat.cols, mat.rows, mat.channels(), mat.ptr());
			}
		}
		for(loop = 0;loop < global_filter_plugin_cnt;loop++)
		{
			void (*receive_image)(int, int, int, unsigned char *);
			receive_image = (void (*)(int, int, int, unsigned char*))void_filter_plugin[loop];
			if(receive_image != NULL)
			{
				receive_image(mat.cols, mat.rows, mat.channels(), mat.ptr());
			}
		}
		if(!mat.empty())
		{
			RunFilters();
			if((width > 0) && (height > 0))
			{
				if((my_window->frame_scaling != 1)
				&& (my_window->crop_scaling != 1))
				{
					if((width != mat.cols) || (height != mat.rows))
					{
						cv::resize(mat, mat, cv::Size(width, height));
					}
				}
			}
			if(capture_scaling != 1.0)
			{
				int scaled_x = (int)((double)mat.cols * capture_scaling);
				int scaled_y = (int)((double)mat.rows * capture_scaling);
				cv::resize(mat, mat, cv::Size(scaled_x, scaled_y));
			}
			if((my_window->frame_scaling == 1)
			|| (my_window->crop_scaling == 1))
			{
				orig_width = mat.cols;
				orig_height = mat.rows;
				my_window->FrameImage(this, mat, mat, forced_aspect_x, forced_aspect_y);
			}
			if(!mat.empty())
			{
				VideoEffects();
				SetCairo();
				int moving_element = 0;
				int someone_is_dragging = 0;
				ShowImmediateList();
				ColorIt();
				MiscCopyCommands();
				DrawShapes();
				if(my_window->timestamp == 1)
				{
					SetCairo();
					TimestampFrame();
				}
				if(my_window->visible_debug == 1)
				{
					if((follow_motion == 1) 
					|| (follow_objects == 1) 	
					|| (motion_detect == 1) 
					|| (object_detect == 1))
					{
						my_window->Detect();
					}
				}
				if(snapshot_trigger_condition == SNAPSHOT_TRIGGER_CONTINUOUS)
				{
					snapshot_initial_delay = 0.0;
					snapshot_repeat_delay = 0.0;
					TriggerSnapshot();
				}
				if(snapshot_trigger_condition == SNAPSHOT_TRIGGER_START)
				{
					TriggerSnapshot();
					snapshot_trigger_condition = SNAPSHOT_TRIGGER_BUTTON;
				}
			}
		}
	}
}

void	Camera::DrawShapes()
{
int	loop;
int	outer;

	int cnt = 0;
	Shape **list = my_window->FindShapesOnCamera(this, cnt);
	if(list != NULL)
	{
		for(outer = 0;outer < 7;outer++)
		{
			for(loop = 0;loop < cnt;loop++)
			{
				if(list[loop] != NULL)
				{
					if(list[loop]->hidden == 0)
					{
						if(list[loop]->layer == outer)
						{
							list[loop]->draw();
						}
					}
					if(list[loop]->highlight == 1)
					{
						int xx = list[loop]->x();
						int yy = list[loop]->y();
						int ww = list[loop]->w();
						int hh = list[loop]->h();
						fl_color(FL_YELLOW);
						fl_rect(xx, yy, ww, hh);
					}
				}
			}
		}
		free(list);
	}
}

void	Camera::HighlightShapes()
{
int	loop;
int	outer;

	int cnt = 0;
	Shape **list = my_window->FindShapesOnCamera(this, cnt);
	if(list != NULL)
	{
		for(outer = 0;outer < 7;outer++)
		{
			for(loop = 0;loop < cnt;loop++)
			{
				if(list[loop] != NULL)
				{
					if(list[loop]->highlight == 1)
					{
						int xx = list[loop]->x();
						int yy = list[loop]->y();
						int ww = list[loop]->w();
						int hh = list[loop]->h();
						fl_color(FL_YELLOW);
						fl_rect(xx, yy, ww, hh);
					}
				}
			}
		}
		free(list);
	}
}

int	capture_frame(int *flag)
{
	Camera *cam = (Camera *)flag;
	if(cam != NULL)
	{
		while(cam->capturing == 1)
		{
			if(cam->cap != NULL)
			{
				if(cam->cap->isOpened())
				{
					cam->cap->grab();
				}
			}
			cam->Capture();
		}
	}
	return(0);
}

void	Camera::MiscCopyCommands()
{
int	loop;
int	inner;

	MyWin *win = my_window;
	for(loop = 0;loop < win->misc_copy_cnt;loop++)
	{
		if(win->misc_copy[loop] != NULL)
		{
			if(win->misc_copy[loop]->display == 1)
			{
				if(win->misc_copy[loop]->type == MISC_COPY_DYNAMIC)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						win->CropFrame(mat, &win->misc_copy[loop]->mat, use_x, use_y, use_w, use_h);
					}
				}
				if((win->misc_copy[loop]->type == MISC_COPY_STATIC)
				|| (win->misc_copy[loop]->type == MISC_COPY_DYNAMIC))
				{
					for(inner = 0;inner < win->misc_copy[loop]->destination_cnt;inner++)
					{
						if(win->misc_copy[loop]->destination[inner] == this)
						{
							if(!win->misc_copy[loop]->mat.empty())
							{
								if(win->misc_copy[loop]->dest_display[inner] == 1)
								{
									int px = win->misc_copy[loop]->dest_x[inner];
									int py = win->misc_copy[loop]->dest_y[inner];
									int uw = win->misc_copy[loop]->ww;
									int uh = win->misc_copy[loop]->hh;
									if((uw > 0) && (uh > 0))
									{
										PasteMat(win->misc_copy[loop]->mat, px, py);
									}
								}
							}
						}
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_MASK)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						rectangle(mat, Point(use_x, use_y), Point(use_x + use_w, use_y + use_h), Vec4b(0, 0, 0, 0), cv::FILLED);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_FILL)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						int rr = win->misc_copy[loop]->red;
						int gg = win->misc_copy[loop]->green;
						int bb = win->misc_copy[loop]->blue;
						int aa = win->misc_copy[loop]->alpha;
						rectangle(mat, Point(use_x, use_y), Point(use_x + use_w, use_y + use_h), Vec4b(rr, gg, bb, aa), cv::FILLED);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_CROP)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						win->CropFrame(mat, &mat, use_x, use_y, use_w, use_h);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_TEXT)
				{
					if(win->misc_copy[loop]->source == this)
					{
						if(win->misc_copy[loop]->quick_text != NULL)
						{
							win->misc_copy[loop]->quick_text->show();
							win->misc_copy[loop]->quick_text->draw();
							int use_x = win->misc_copy[loop]->xx;
							int use_y = win->misc_copy[loop]->yy;
							int use_w = win->misc_copy[loop]->ww;
							int use_h = win->misc_copy[loop]->hh;
						}
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_RECTANGLE)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						rectangle(mat, Point(use_x, use_y), Point(use_x + use_w, use_y + use_h), Scalar(255, 255, 255), 1);
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_MAGNIFY)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						if((win->output_height > 0) && (win->output_width > 0))
						{
							if(use_w > use_h)
							{
								double use = (double)win->output_width / (double)win->output_height;
								int fh = (int)((double)use_h * use);
								win->CropFrame(mat, &mat, use_x, use_y, fh, use_h);
								cv::resize(mat, mat, cv::Size(my_window->output_width, my_window->output_height));
							}
							else
							{
								double use = (double)win->output_height / (double)win->output_width;
								int fh = (int)((double)use_w * use);
								win->CropFrame(mat, &mat, use_x, use_y, use_w, fh);
								cv::resize(mat, mat, cv::Size(my_window->output_width, my_window->output_height));
							}
						}
						else
						{
							win->CropFrame(mat, &mat, use_x, use_y, use_w, use_h);
						}
					}
				}
				else if(win->misc_copy[loop]->type == MISC_COPY_BORDER)
				{
					if(win->misc_copy[loop]->source == this)
					{
						int use_x = win->misc_copy[loop]->xx;
						int use_y = win->misc_copy[loop]->yy;
						int use_w = win->misc_copy[loop]->ww;
						int use_h = win->misc_copy[loop]->hh;
						rectangle(mat, Point(0, 0), Point(use_x, (mat.rows - 1)), Scalar(0, 0, 0), FILLED);
						rectangle(mat, Point(0, 0), Point((mat.cols - 1), use_y), Scalar(0, 0, 0), FILLED);
						rectangle(mat, Point((use_x + use_w), 0), Point((mat.cols - 1), (mat.rows - 1)), Scalar(0, 0, 0), FILLED);
						rectangle(mat, Point(0, (use_y + use_h)), Point((mat.cols - 1), (mat.rows - 1)), Scalar(0, 0, 0), FILLED);
					}
				}
			}
		}
	}
}

void	Camera::PrepImageForNet(Mat in_mat)
{
std::vector<int> param(2);

	if(cap != NULL)
	{
		if(cap->isOpened())
		{
			if(my_window->image_memory.ready == 0)
			{
				Mat new_mat;
				param[0] = cv::IMWRITE_JPEG_QUALITY;
				param[1] = 45;
				cv::resize(in_mat, new_mat, cv::Size(640, 360));
				imencode(".jpg", new_mat, my_window->image_memory.buffer, param);
				my_window->image_memory.size = my_window->image_memory.buffer.size();
				my_window->image_memory.ptr = my_window->image_memory.buffer.data();
				my_window->image_memory.ready = 1;
			}
		}
	}
}

int	requesting_control(int *flag)
{
void	request_control(ImageMemory *, char *ip, int port);

	MyWin *win = (MyWin *)flag;
	if(win != NULL)
	{
		request_control(&win->image_memory, win->jpeg_streaming, win->jpeg_streaming_port + 1);
	}
	return(0);
}

int	send_to_network(int *flag)
{
void	send_images(ImageMemory *, char *ip, int port);

	MyWin *win = (MyWin *)flag;
	if(win != NULL)
	{
		send_images(&win->image_memory, win->jpeg_streaming, win->jpeg_streaming_port);
	}
	return(0);
}

int	respond_to_control(int *flag)
{
void	send_images(ImageMemory *, char *ip, int port);

	MyWin *win = (MyWin *)flag;
	if(win != NULL)
	{
		int old = 0;
		int panning = 0;
		int zooming = 0;
		int focusing = 0;
		while(win->image_memory.done == 0)
		{
			if(win->image_memory.ptz != old)
			{
				if(win->image_memory.ptz == 1)
				{
					win->ViscaCommand(PTZ_UP_LEFT);
					panning = 1;
				}
				else if(win->image_memory.ptz == 2)
				{
					win->ViscaCommand(PTZ_UP);
					panning = 1;
				}
				else if(win->image_memory.ptz == 3)
				{
					win->ViscaCommand(PTZ_UP_RIGHT);
					panning = 1;
				}
				else if(win->image_memory.ptz == 4)
				{
					win->ViscaCommand(PTZ_LEFT);
					panning = 1;
				}
				else if(win->image_memory.ptz == 5)
				{
					win->ViscaCommand(PTZ_HOME);
					panning = 1;
				}
				else if(win->image_memory.ptz == 6)
				{
					win->ViscaCommand(PTZ_RIGHT);
					panning = 1;
				}
				else if(win->image_memory.ptz == 7)
				{
					win->ViscaCommand(PTZ_DOWN_LEFT);
					panning = 1;
				}
				else if(win->image_memory.ptz == 8)
				{
					win->ViscaCommand(PTZ_DOWN);
					panning = 1;
				}
				else if(win->image_memory.ptz == 9)
				{
					win->ViscaCommand(PTZ_DOWN_RIGHT);
					panning = 1;
				}
				else if(win->image_memory.ptz == 10)
				{
					win->ViscaCommand(PTZ_ZOOM_IN);
					zooming = 1;
				}
				else if(win->image_memory.ptz == 11)
				{
					win->ViscaCommand(PTZ_ZOOM_OUT);
					zooming = 1;
				}
				else if(win->image_memory.ptz == 12)
				{
					win->ViscaCommand(PTZ_FOCUS_FAR);
					focusing = 1;
				}
				else if(win->image_memory.ptz == 13)
				{
					win->ViscaCommand(PTZ_FOCUS_NEAR);
					focusing = 1;
				}
				else if(win->image_memory.ptz == 0)
				{
					if(panning == 1)
					{
						win->ViscaCommand(PTZ_PAN_STOP);
						panning = 0;
					}
					if(zooming == 1)
					{
						win->ViscaCommand(PTZ_ZOOM_STOP);
						zooming = 0;
					}
					if(focusing == 1)
					{
						win->ViscaCommand(PTZ_FOCUS_STOP);
						focusing = 0;
					}
				}
				old = win->image_memory.ptz;
			}
		}
	}
	return(0);
}

FilterDialog::FilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Double_Window(xx, yy, ww, hh, lbl)
{
int	loop;

	my_window = in_win;

	border(0);
	box(FL_FRAME_BOX);
	color(FL_BLACK);
	align(FL_ALIGN_INSIDE | FL_ALIGN_TOP);
	labelcolor(FL_WHITE);

	selected = 0;
	disable = 0;
	limit = 0;

	my_box = new Fl_Box(0, 0, w(), h());
	my_box->label(lbl);
	my_box->labelsize(8);
	my_box->align(FL_ALIGN_INSIDE | FL_ALIGN_TOP | FL_ALIGN_CENTER);
	my_box->labelcolor(FL_WHITE);
	my_box->color(FL_BLACK);
	my_box->box(FL_FRAME_BOX);
	for(loop = 0;loop < 128;loop++)
	{
		str[loop] = NULL;
	}
	end();
	hide();
}

FilterDialog::~FilterDialog()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(str[loop] != NULL)
		{
			free(str[loop]);
			str[loop] = NULL;
		}
	}
}

int	FilterDialog::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		int yy = Fl::event_y();
		if(yy < 10)
		{
			if(disable == 0)
			{
				disable = 1;
			}
			else
			{
				disable = 0;
			}
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

void	FilterDialog::draw()
{
	if(disable == 0)
	{
		my_box->color(FL_BLACK);
	}
	else
	{
		my_box->color(FL_GRAY);
	}
	Fl_Double_Window::draw();
}

GrayscaleFilterDialog::GrayscaleFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

GrayscaleFilterDialog::~GrayscaleFilterDialog()
{
}

ThresholdFilterDialog::ThresholdFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ThresholdFilterDialog::~ThresholdFilterDialog()
{
}

int	ThresholdFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		double use = (255.0 / (double)width) * (double)xx;
		if(use < 0.0)
		{
			use = 0.0;
		}
		if(use > 255.0)
		{
			use = 255.0;
		}
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			selected++;
			if(selected >= limit)
			{
				selected = 0;
			}
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ThresholdFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Threshold", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Max Value", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Type", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 14);
	fl_color(FL_YELLOW);
	fl_draw(str[selected], 14, y_pos + 10);
	y_pos += 20;
}

InvertFilterDialog::InvertFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

InvertFilterDialog::~InvertFilterDialog()
{
}

EdgeDetectFilterDialog::EdgeDetectFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

EdgeDetectFilterDialog::~EdgeDetectFilterDialog()
{
}

int	EdgeDetectFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		double use = (255.0 / (double)width) * (double)xx;
		if(use < 0.0)
		{
			use = 0.0;
		}
		if(use > 255.0)
		{
			use = 255.0;
		}
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (32.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 32.0)
			{
				use = 32.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 1.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[3] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	EdgeDetectFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Blur Radius", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 32.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Low", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("High", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Blend", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 1.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

BrightnessFilterDialog::BrightnessFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

BrightnessFilterDialog::~BrightnessFilterDialog()
{
}

int	BrightnessFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	BrightnessFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Brightness", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 1.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

ContrastFilterDialog::ContrastFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ContrastFilterDialog::~ContrastFilterDialog()
{
}

int	ContrastFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ContrastFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Contrast", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 1.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

SaturationFilterDialog::SaturationFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

SaturationFilterDialog::~SaturationFilterDialog()
{
}

int	SaturationFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	SaturationFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Saturation", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 2.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

HueFilterDialog::HueFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

HueFilterDialog::~HueFilterDialog()
{
}

int	HueFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	HueFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Hue", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 2.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

ClaheFilterDialog::ClaheFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ClaheFilterDialog::~ClaheFilterDialog()
{
}

int	ClaheFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (4.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 4.0)
			{
				use = 4.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ClaheFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("CLAHE", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 4.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

ColorIntensityFilterDialog::ColorIntensityFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ColorIntensityFilterDialog::~ColorIntensityFilterDialog()
{
}

int	ColorIntensityFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (2.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 2.0)
			{
				use = 2.0;
			}
			number[3] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ColorIntensityFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Red", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 2.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Green", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 2.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Blue", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 2.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Alpha", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 2.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

BlurFilterDialog::BlurFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

BlurFilterDialog::~BlurFilterDialog()
{
}

int	BlurFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (64.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 64.0)
			{
				use = 64.0;
			}
			number[0] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	BlurFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Radius", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 64.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

CropFilterDialog::CropFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

CropFilterDialog::~CropFilterDialog()
{
}

int	CropFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (1.0 / (double)width) * (double)xx;
			if(use < 0.0)
			{
				use = 0.0;
			}
			if(use > 1.0)
			{
				use = 1.0;
			}
			number[3] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	CropFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Left", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 1.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Right", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 1.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Top", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 1.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Bottom", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 1.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

ScaleFilterDialog::ScaleFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

ScaleFilterDialog::~ScaleFilterDialog()
{
}

int	ScaleFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (10.0 / (double)width) * (double)xx;
			if(use < 0.1)
			{
				use = 0.1;
			}
			if(use > 10.0)
			{
				use = 10.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (10.0 / (double)width) * (double)xx;
			if(use < 0.1)
			{
				use = 0.1;
			}
			if(use > 10.0)
			{
				use = 10.0;
			}
			number[1] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	ScaleFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Horizontal", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 10.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Vertical", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 10.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

BlendFilterDialog::BlendFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

BlendFilterDialog::~BlendFilterDialog()
{
}

int	BlendFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		double use = (1.0 / (double)width) * (double)xx;
		if(use < 0.0)
		{
			use = 0.0;
		}
		if(use > 1.0)
		{
			use = 1.0;
		}
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			selected++;
			if(selected >= limit)
			{
				selected = 0;
			}
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	BlendFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Balance", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 1.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Camera", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 14);
	fl_color(FL_YELLOW);
	fl_push_clip(10, y_pos, width, 14);
	fl_draw(str[selected], 14, y_pos + 10);
	fl_pop_clip();
	y_pos += 20;
}

BevelFilterDialog::BevelFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

BevelFilterDialog::~BevelFilterDialog()
{
}

int	BevelFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			double use = (100.0 / (double)width) * (double)xx;
			if(use < 8.0)
			{
				use = 8.0;
			}
			if(use > 100.0)
			{
				use = 10.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (100.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 100.0)
			{
				use = 100.0;
			}
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[3] = use;
			flag = 1;
		}
		else if((yy > y_marker[4]) && (yy < y_marker[4] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[4] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	BevelFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;
	fl_color(FL_WHITE);
	fl_draw("Offset", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	int use = (int)(((double)width / 100.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Radius", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 100.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 24;

	fl_color(FL_WHITE);
	fl_draw("Red", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Green", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Blue", 10, y_pos);
	y_pos += 2;
	y_marker[4] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[4];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

GradientFilterDialog::GradientFilterDialog(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : FilterDialog(in_win, xx, yy, ww, hh, lbl)
{
}

GradientFilterDialog::~GradientFilterDialog()
{
}

int	GradientFilterDialog::handle(int event)
{
	int flag = 0;
	if((event == FL_PUSH)
	|| (event == FL_DRAG))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= 10;
		int width = w() - 20;
		if((yy > y_marker[0]) && (yy < y_marker[0] + 10))
		{
			selected++;
			if(selected >= limit)
			{
				selected = 0;
			}
			flag = 1;
		}
		else if((yy > y_marker[1]) && (yy < y_marker[1] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[0] = use;
			flag = 1;
		}
		else if((yy > y_marker[2]) && (yy < y_marker[2] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[1] = use;
			flag = 1;
		}
		else if((yy > y_marker[3]) && (yy < y_marker[3] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[2] = use;
			flag = 1;
		}
		else if((yy > y_marker[4]) && (yy < y_marker[4] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[3] = use;
			flag = 1;
		}
		else if((yy > y_marker[5]) && (yy < y_marker[5] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[4] = use;
			flag = 1;
		}
		else if((yy > y_marker[6]) && (yy < y_marker[6] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[5] = use;
			flag = 1;
		}
		else if((yy > y_marker[7]) && (yy < y_marker[7] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[6] = use;
			flag = 1;
		}
		else if((yy > y_marker[8]) && (yy < y_marker[8] + 10))
		{
			double use = (255.0 / (double)width) * (double)xx;
			if(use < 1.0)
			{
				use = 1.0;
			}
			if(use > 255.0)
			{
				use = 255.0;
			}
			number[7] = use;
			flag = 1;
		}
		redraw();
	}
	if(flag == 0)
	{
		flag = FilterDialog::handle(event);
	}
	return(flag);
}

void	GradientFilterDialog::draw()
{
	FilterDialog::draw();
	fl_color(FL_WHITE);
	int width = w() - 20;
	fl_font(FL_HELVETICA, 7);

	int y_pos = 22;

	fl_color(FL_WHITE);
	fl_draw("Direction", 10, y_pos);
	y_pos += 2;
	y_marker[0] = y_pos;
	fl_rect(10, y_pos, width, 14);
	fl_color(FL_YELLOW);
	fl_push_clip(10, y_pos, width, 14);
	fl_draw(str[selected], 14, y_pos + 10);
	fl_pop_clip();
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Start Red", 10, y_pos);
	y_pos += 2;
	y_marker[1] = y_pos;
	fl_rect(10, y_pos, width, 10);
	double val = number[0];
	double use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Start Green", 10, y_pos);
	y_pos += 2;
	y_marker[2] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[1];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Start Blue", 10, y_pos);
	y_pos += 2;
	y_marker[3] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[2];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("Start Alpha", 10, y_pos);
	y_pos += 2;
	y_marker[4] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[3];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("End Red", 10, y_pos);
	y_pos += 2;
	y_marker[5] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[4];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("End Green", 10, y_pos);
	y_pos += 2;
	y_marker[6] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[5];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("End Blue", 10, y_pos);
	y_pos += 2;
	y_marker[7] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[6];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;

	fl_color(FL_WHITE);
	fl_draw("End Alpha", 10, y_pos);
	y_pos += 2;
	y_marker[8] = y_pos;
	fl_rect(10, y_pos, width, 10);
	val = number[7];
	use = (int)(((double)width / 255.0) * val);
	fl_color(FL_YELLOW);
	fl_rectf(11, y_pos + 1, use, 8);
	y_pos += 20;
}

PIP::PIP(Camera *cam, int xx, int yy, int ww, int hh)
{
	camera = cam;
	x = xx;
	y = yy;
	w = ww;
	h = hh;
	visible = 0;
}

PIP::~PIP()
{
}

void	PIP::draw(int idx)
{
	Mat local_mat;
	local_mat = camera->mat.clone();
	if(!local_mat.empty())
	{
		MyWin *win = camera->my_window;
		Camera *cam = win->DisplayedCamera();
		Mat new_mat;
		Mat dst = cam->mat;
		int nw = (int)((double)local_mat.cols * win->pip_size);
		int nh = (int)((double)local_mat.rows * win->pip_size);
		cv::resize(local_mat, new_mat, cv::Size(nw, nh));

		int px = dst.cols - (nw + 10);
		int py = 10 + ((nh + 10) * idx);
		if(win->multipip == MULTIPIP_SIDE_RIGHT)
		{
			px = dst.cols - (nw + 10);
			py = 10 + ((nh + 10) * idx);
			if((py + nh) > local_mat.rows)
			{
				px = dst.cols - ((nw + 10) * 2);
			}
		}
		else if(win->multipip == MULTIPIP_SIDE_LEFT)
		{
			px = 10;
		}
		else if(win->multipip == MULTIPIP_SIDE_TOP)
		{
			px = 10 + ((nw + 10) * idx);
			py = 10;
		}
		else if(win->multipip == MULTIPIP_SIDE_BOTTOM)
		{
			px = 10 + ((nw + 10) * idx);
			py = local_mat.rows - (nh + 10);
		}
		if(win->embed_pip == 1)
		{
			if(((py + nh) < local_mat.rows) && ((px + nw) < local_mat.cols))
			{
				new_mat.copyTo(dst.rowRange(py, py + nh).colRange(px, px + nw));
				if((win->pip_red > -1) && (win->pip_green > -1) && (win->pip_blue > -1))
				{
					rectangle(dst, Point(px, py), Point(px + nw, py + nh), Scalar(win->pip_blue, win->pip_green, win->pip_red), 1);
				}
			}
		}
		else
		{
			fl_draw_image((unsigned char *)new_mat.ptr(), win->w() - (nw + 50), win->h() - (nh + 50), new_mat.cols, new_mat.rows, new_mat.channels());
			if(cam->keep_pip == 0)
			{
				fl_color(FL_WHITE);
			}
			else
			{
				fl_color(FL_YELLOW);
			}
			fl_rect(win->w() - (nw + 50), win->h() - (nh + 50), new_mat.cols, new_mat.rows);
		}
	}
}

void	MyWin::SendToNetwork()
{
	if(jpeg_streaming != NULL)
	{
		CreateTask((int (*)(int *))send_to_network, (void *)this);
		CreateTask((int (*)(int *))requesting_control, (void *)this);
		CreateTask((int (*)(int *))respond_to_control, (void *)this);
	}
}

void	Camera::StartCapture()
{
	capturing = 1;
	pthread_t signal_thread = CreateTask((int (*)(int *))capture_frame, (void *)this);
}

int	MyWin::AddShape(Shape *in_shape)
{
int	loop;

	int found = -1;
	for(loop = 0;((loop < shape_cnt) && (found == -1));loop++)
	{
		if(shape[loop] == NULL)
		{
			shape[loop] = in_shape;
			found = loop;
		}
	}
	if(found == -1)
	{
		Shape **tmp = (Shape **)realloc(shape, (shape_cnt + 1) * sizeof(Shape *));
		if(tmp != NULL)
		{
			shape = tmp;
			shape[shape_cnt] = in_shape;
			found = shape_cnt;
			shape_cnt++;
		}
	}
	add(in_shape);
	return(found);
}

int	MyWin::RemoveShape(Shape *in_shape)
{
int	loop;

	int found = -1;
	for(loop = 0;((loop < shape_cnt) && (found == -1));loop++)
	{
		if(shape[loop] == in_shape)
		{
			shape[loop] = NULL;
			found = loop;
		}
	}
	remove(in_shape);
	return(found);
}

Shape	**MyWin::FindShapesOnCamera(Camera *cam, int& final)
{
Shape	*tmp[1024];
int		loop;

	int cnt = 0;
	for(loop = 0;loop < shape_cnt;loop++)
	{
		if(shape[loop] != NULL)
		{
			if(shape[loop]->destination == cam)
			{
				if(cnt < 1024)
				{
					tmp[cnt] = shape[loop];
					cnt++;
				}
			}
		}
	}
	Shape **list = NULL;
	if(cnt > 0)
	{
		list = (Shape **)malloc(cnt * sizeof(Shape *));
		if(list != NULL)
		{
			memcpy(list, tmp, cnt * sizeof(Shape *));
		}
	}
	final = cnt;
	return(list);
}

Shape	**MyWin::FindShapesFromCamera(Camera *cam, int& final)
{
Shape	*tmp[1024];
int		loop;

	int cnt = 0;
	for(loop = 0;loop < shape_cnt;loop++)
	{
		if(shape[loop]->source == cam)
		{
			if(cnt < 1024)
			{
				tmp[cnt] = shape[loop];
				cnt++;
			}
		}
	}
	Shape **list = NULL;
	if(cnt > 0)
	{
		list = (Shape **)malloc(cnt * sizeof(Shape *));
		if(list != NULL)
		{
			memcpy(list, tmp, cnt * sizeof(Shape *));
		}
	}
	final = cnt;
	return(list);
}

Shape::Shape(MyWin *in_win, int in_x, int in_y, int in_w, int in_h) : Fl_Box(in_x, in_y, in_w, in_h)
{
void	shape_popup_cb(Fl_Widget *w, void *v);

	my_window = in_win;
	type = SHAPE_NO_TYPE;

	xx = in_x;
	yy = in_y;
	ww = in_w;
	hh = in_h;
	mode = SHAPE_MODE_MOVE;
	layer = 0;
	hidden = 0;
	highlight = 0;

	background_r = 0;
	background_g = 0;
	background_b = 0;
	background_a = 0;
	foreground_r = 0;
	foreground_g = 0;
	foreground_b = 0;
	foreground_a = 0;
	
	font = 0;
	style = 0;
	font_sz = 0;

	thickness = 0;

	source = NULL;
	destination = NULL;
	popup = new PopupMenu(0, 0, 160, 300);
	popup->browser->callback(shape_popup_cb, this);
	popup->browser->add("Move");
	popup->browser->add("Resize");
	popup->browser->add("Remove");
	popup->browser->add("Up a Layer");
	popup->browser->add("Down a Layer");
	popup->browser->add("Hide");
	popup->set_non_modal();

	last_x = 0;
	last_y = 0;
}

Shape::~Shape()
{
}

void	Shape::Remove()
{
	hide();
	my_window->RemoveShape(this);
}

void	Shape::draw()
{
}

void	shape_popup_cb(Fl_Widget *w, void *v)
{
	Shape *shape = (Shape *)v;
	if(shape->popup != NULL)
	{
		shape->popup->hide();
	}
	Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
	char *str = (char *)browser->text(browser->value());
	if(str != NULL)
	{
		if(strcmp(str, "Move") == 0)
		{
			shape->mode = SHAPE_MODE_MOVE;
		}
		else if(strcmp(str, "Resize") == 0)
		{
			shape->mode = SHAPE_MODE_RESIZE;
		}
		else if(strcmp(str, "Remove") == 0)
		{
			shape->Remove();
			delete shape;
		}
		else if(strcmp(str, "Set Line Thickness") == 0)
		{
			shape->mode = SHAPE_MODE_THICKNESS;
		}
		else if(strcmp(str, "Set Filled") == 0)
		{
			shape->filled = 1;
			browser->text(browser->value(), "Set Hollow");
		}
		else if(strcmp(str, "Set Hollow") == 0)
		{
			shape->filled = 0;
			browser->text(browser->value(), "Set Filled");
		}
		else if(strcmp(str, "Set Line Color") == 0)
		{
			ColorDialog *cd = new ColorDialog(shape->my_window, 420, 125, "Line Color", &shape->foreground_r, &shape->foreground_g, &shape->foreground_b, &shape->foreground_a);
			cd->show();
		}
		else if(strcmp(str, "Set Fill Color") == 0)
		{
			ColorDialog *cd = new ColorDialog(shape->my_window, 420, 125, "Fill Color", &shape->background_r, &shape->background_g, &shape->background_b, &shape->background_a);
			cd->show();
		}
		else if(strcmp(str, "Set to Erase") == 0)
		{
			shape->erase = 1;
			browser->text(browser->value(), "Set to Draw");
		}
		else if(strcmp(str, "Set to Draw") == 0)
		{
			shape->erase = 0;
			browser->text(browser->value(), "Set to Erase");
		}
		else if(strcmp(str, "Up a Layer") == 0)
		{
			shape->layer++;
			if(shape->layer > 6) shape->layer = 6;
		}
		else if(strcmp(str, "Down a Layer") == 0)
		{
			shape->layer--;
			if(shape->layer < 0) shape->layer = 0;
		}
		else if(strcmp(str, "Hide") == 0)
		{
			shape->hidden = 1;
			browser->text(browser->value(), "Reveal");
		}
		else if(strcmp(str, "Reveal") == 0)
		{
			shape->hidden = 0;
			browser->text(browser->value(), "Hide");
		}
	}
}

int	Shape::handle(int event)
{
	int flag = 0;
	Camera *cam = destination;
	if(cam != NULL)
	{
		int push_x = Fl::event_x();
		int push_y = Fl::event_y();
		switch(event)
		{
			case(FL_PUSH):
			{
				if(Fl::event_state(FL_BUTTON1) == FL_BUTTON1)
				{
					last_x = Fl::event_x_root();
					last_y = Fl::event_y_root();
				}
				else if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
				{
					if(popup != NULL)
					{
						popup->Fit();
						popup->resize(Fl::event_x_root(), Fl::event_y_root(), popup->w(), popup->h());
						popup->show();
					}
				}
				flag = 1;
			}
			break;
			case(FL_RELEASE):
			{
				last_x = 0;
				last_y = 0;
				flag = 1;
			}
			break;
			case(FL_DRAG):
			{
				if(Fl::event_state(FL_BUTTON1) == FL_BUTTON1)
				{
					if(mode == SHAPE_MODE_MOVE)
					{
						DragMove(cam);
					}
					else if(mode == SHAPE_MODE_RESIZE)
					{
						DragResize(cam);
					}
					else if(mode == SHAPE_MODE_THICKNESS)
					{
						DragThickness(cam);
					}
					flag = 1;
				}
			}
			break;
			case(FL_ENTER):
			{
				flag = 1;
				highlight = 1;
			}
			break;
			case(FL_LEAVE):
			{
				flag = 1;
				highlight = 0;
			}
			break;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Box::handle(event);
	}
	return(flag);
}

void	Shape::DragMove(Camera *cam)
{
	int xxx = Fl::event_x_root();
	int yyy = Fl::event_y_root();
	int ddx = last_x - xxx;
	int ddy = last_y - yyy;
	resize(x() - ddx, y() - ddy, ww, hh);
	xx = x() - cam->image_sx;
	yy = y() - cam->image_sy;
	last_x = xxx;
	last_y = yyy;
}

void	Shape::DragResize(Camera *cam)
{
	int xxx = Fl::event_x_root();
	int yyy = Fl::event_y_root();
	int ddx = last_x - xxx;
	int ddy = last_y - yyy;
	if((ddx < ww) && (ddy < hh))
	{
		ww -= ddx;
		hh -= ddy;
	}
	resize(x(), y(), ww, hh);
	last_x = xxx;
	last_y = yyy;
}

void	Shape::DragThickness(Camera *cam)
{
	int xxx = Fl::event_x_root();
	int yyy = Fl::event_y_root();
	int ddy = last_y - yyy;
	if(ddy > 0)
	{
		thickness++;
	}
	else
	{
		thickness--;
	}
	if(thickness < 0) thickness = 0;
	if(thickness > ww) thickness = ww;
	last_x = xxx;
	last_y = yyy;
}

ShapeRectangle::ShapeRectangle(MyWin *in_win, Camera *in_cam, int in_x, int in_y, int in_w, int in_h, 
					int in_filled,
					int in_thick,
					int in_erase,
					int fr, int fg, int fb, int fa, 
					int br, int bg, int bb, int ba) : Shape(in_win, in_x, in_y, in_w, in_h)
{
	destination = in_cam;
	foreground_r = fr;
	foreground_g = fg;
	foreground_b = fb;
	foreground_a = fa;
	background_r = br;
	background_g = bg;
	background_b = bb;
	background_a = ba;
	thickness = in_thick;
	filled = in_filled;
	erase = in_erase;
	resize(xx + destination->image_sx, yy + destination->image_sy, ww, hh);
	popup->browser->add("Set Line Thickness");
	popup->browser->add("Set Line Color");
	popup->browser->add("Set Fill Color");
	if(filled == 0)
	{
		popup->browser->add("Set Filled");
	}
	else
	{
		popup->browser->add("Set Hollow");
	}
	if(erase == 0)
	{
		popup->browser->add("Set to Erase");
	}
	else
	{
		popup->browser->add("Set to Draw");
	}
}

ShapeRectangle::~ShapeRectangle()
{
}

void	ShapeRectangle::draw()
{
	Camera *cam = destination;
	if(erase == 1)
	{
		int x1 = xx;
		int y1 = yy;
		int x2 = x1 + ww;
		if(x2 >= cam->mat.cols) 
		{
			x2 = cam->mat.cols - 1;
		}
		int y2 = y1 + hh;
		if(y2 >= cam->mat.rows) 
		{
			y2 = cam->mat.rows - 1;
		}
		if(x1 < 0) 
		{
			x1 = 0;
		}
		if(y1 < 0) 
		{
			y1 = 0;
		}
		rectangle(cam->mat, Point(x1, y1), Point(x2, y2), Vec4b(0, 0, 0, 0), cv::FILLED);
	}
	else
	{
		my_cairo_set_line_style(cam->cairo_context, style, thickness);
		cairo_rectangle(cam->cairo_context, xx, yy, ww, hh);
		if(filled == 1)
		{
			my_cairo_set_source_rgba(cam->cairo_context, background_r, background_g, background_b, background_a);
			cairo_fill(cam->cairo_context);
		}
		cairo_rectangle(cam->cairo_context, xx, yy, ww, hh);
		my_cairo_set_source_rgba(cam->cairo_context, foreground_r, foreground_g, foreground_b, foreground_a);
		cairo_stroke(cam->cairo_context);
	}
}

int	ShapeRectangle::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		flag = Shape::handle(event);
	}
	return(flag);
}


SaveFIFO::SaveFIFO(MyWin *in_win, int in_fd, int in_sz, int ww, int hh, long int in_start_ts)
{
int	loop;

	my_window = in_win;
	fd = in_fd;
	frame_sz = in_sz;
	top = 0;
	done = 0;
	start_ts = in_start_ts;
	use_ts = 0;
	width = ww;
	height = hh;
	for(loop = 0;loop < 128;loop++)
	{
		frame[loop] = NULL;
		mutex[loop] = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
	}
	pthread_t signal_thread = CreateTask((int (*)(int *))fifo_save_frame, (void *)this);
}

SaveFIFO::~SaveFIFO()
{
int	loop;

	done = 1;
	usleep(1000);
	for(loop = 0;loop < my_window->source_cnt;loop++)
	{
		if(my_window->camera[loop] != NULL)
		{
			if(my_window->camera[loop]->save_fifo = this)
			{
				my_window->camera[loop]->save_fifo = NULL;
			}
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(frame[loop] != NULL)
		{
			free(frame[loop]);
		}
	}
}

void	SaveFIFO::Save(void *in_frame, long int in_ts, long int paused_accum)
{
	if(top < 127)
	{
		use_ts = in_ts - (start_ts + paused_accum);
		while(frame[top] != NULL)
		{
			usleep(10);
		}
		pthread_mutex_lock(&mutex[top]);
		frame[top] = malloc(frame_sz);
		if(frame[top] != NULL)
		{
			memcpy(frame[top], in_frame, frame_sz);
		}
		pthread_mutex_unlock(&mutex[top]);
		top++;
	}
}

void	MyWin::copy_interest(unsigned char *dest, unsigned char *src, int sz, int sx, int sy, int ex, int ey)
{
int	xx, yy;

	for(yy = sy;yy < ey;yy++)
	{
		for(xx = sx;xx < ex;xx++)
		{
			int off = (yy * camera[current_source]->width * 3) + (xx * 3);
			char *ptr = (char *)(src + off);
			*dest++ = *ptr++;
			*dest++ = *ptr++;
			*dest++ = *ptr++;
		}
	}
}

int	MyWin::MatchArea(int score, int xx, int yy)
{
int	loop;

	int flag = 0;
	for(loop = 0;loop < interest_cnt;loop++)
	{
		if((interest_x[loop] == xx) && (interest_y[loop] == yy))
		{
			flag = 1;
		}
	}
	return(flag);
}

void	MyWin::SetupObjectDetection()
{
	net = readNetFromDarknet(yolo_cfg_filename, yolo_weights_filename);
	net.setPreferableBackend(DNN_BACKEND_CUDA);
	net.setPreferableTarget(DNN_TARGET_CUDA);
}

vector<String> getOutputsNames(const Net& net)
{
	static vector<String> names;
	if (names.empty())
	{
		// Get the indices of the output layers, i.e. the layers with unconnected outputs
		vector<int> outLayers = net.getUnconnectedOutLayers();
		
		// Get the names of all the layers in the network
		vector<String> layersNames = net.getLayerNames();
		
		// Get the names of the output layers in names
		names.resize(outLayers.size());
		for (size_t i = 0; i < outLayers.size(); ++i)
		{
			names[i] = layersNames[outLayers[i] - 1];
		}
	}
	return(names);
}

int	MyWin::DrawPred(Camera *cam, int classId, float conf, int left, int top, int right, int bottom, Mat &frame)
{
	int found_bird = 0;
	char *label = recognize_class_name[classId];
	if(cam->object_index[classId] == 1)
	{
		rectangle(frame, Point(left, top), Point(right, bottom), Scalar(255, 255, 255), 1);

		int baseLine;
		Size labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, &baseLine);
		top = max(top, labelSize.height);
		rectangle(frame, Point(left, top - round(1.2 * labelSize.height)), Point(left + round(1.2 * labelSize.width), top + baseLine), Scalar(255, 255, 255), FILLED);
		putText(frame, label, Point(left, top), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0), 1);
		found_bird = classId;
	}
	return(found_bird);
}

int	Camera::PostProcessRecognition(Mat &frame, const vector<Mat> &outs, int *out_x, int *out_y, int *second_x, int *second_y)
{
vector<int> classIds;
vector<float> confidences;
vector<Rect> boxes;

	*out_x = -1;
	*out_y = -1;
	*second_x = -1;
	*second_y = -1;
	int found = -1;
	for(size_t i = 0; i < outs.size(); ++i)
	{
		float *data = (float *)outs[i].data;
		for(int j = 0;j < outs[i].rows; ++j, data += outs[i].cols)
		{
			Mat scores = outs[i].row(j).colRange(5, outs[i].cols);
			Point classIdPoint;
			double confidence;

			minMaxLoc(scores, 0, &confidence, 0, &classIdPoint);
			if(confidence > recognition_threshold)
			{
				int centerX = (int)(data[0] * frame.cols);
				int centerY = (int)(data[1] * frame.rows);
				int width = (int)(data[2] * frame.cols);
				int height = (int)(data[3] * frame.rows);
				int left = centerX - width / 2;
				int top = centerY - height / 2;
					
				classIds.push_back(classIdPoint.x);
				confidences.push_back((float)confidence);
				boxes.push_back(Rect(left, top, width, height));
			}
		}
	}
	vector<int> indices;
	NMSBoxes(boxes, confidences, recognition_threshold, 0.4, indices);
	detected_object_cnt = 0;
	int max_x = -1000000;
	int max_y = -1000000;
	int min_x = 1000000;
	int min_y = 1000000;
	for(size_t i = 0; i < indices.size(); ++i)
	{
		int idx = indices[i];
		Rect box = boxes[idx];
		if(object_index[classIds[idx]] == 1)
		{
			found = classIds[idx];

			if(box.x < min_x) min_x = box.x;
			if(box.y < min_y) min_y = box.y;
			if((box.x + box.width) > max_x) max_x = box.x + box.width;
			if((box.y + box.height) > max_y) max_y = box.y + box.height;

			detected_object[detected_object_cnt].x = box.x;
			detected_object[detected_object_cnt].y = box.y;
			detected_object[detected_object_cnt].w = box.width;
			detected_object[detected_object_cnt].h = box.height;
			detected_object[detected_object_cnt].idx = classIds[idx];
			detected_object[detected_object_cnt].confidence = confidences[idx];
			detected_object_cnt++;
		}
	}
	if((max_x > 0) && (max_y > 0) && (min_x < 10000) && (min_y < 10000))
	{
		*out_x = min_x;
		*out_y = min_y;
		*second_x = max_x;
		*second_y = max_y;
	}
	return(found);
}

int	Camera::DetectObjects(int *out_x, int *out_y, int *second_x, int *second_y)
{
Mat	blob;

	Mat use = mat.clone();
	cvtColor(use, use, COLOR_RGBA2BGR);
	int found = 0;
	blob = blobFromImage(use, 1 / 255.0, cv::Size(416, 416), Scalar(0, 0, 0), true, false);
	net.setInput(blob);

	vector<Mat> outs;
	net.forward(outs, getOutputsNames(net));
	found = PostProcessRecognition(mat, outs, out_x, out_y, second_x, second_y);

	return(found);
}

void	MyWin::ReadClasses()
{
char	buf[256];

	recognize_class_cnt = 0;
	FILE *fp = fopen(yolo_names_filename, "r");
	if(fp != NULL)
	{
		while(fgets(buf, 255, fp))
		{
			strip_lf(buf);
			recognize_class_name[recognize_class_cnt] = strdup(buf);
			recognize_class_cnt++;
		}
		fclose(fp);
	}
}

int	Camera::SetBackendFlag(char *cp)
{
	int flag = CAP_ANY;
	if(strncmp(cp, "VFW ", strlen("VFW")) == 0)
	{
		flag = CAP_VFW;
	}
	else if(strncmp(cp, "V4L ", strlen("V4L")) == 0)
	{
		flag = CAP_V4L;
	}
	else if(strncmp(cp, "V4L2 ", strlen("V4L2")) == 0)
	{
		flag = CAP_V4L2;
	}
	else if(strncmp(cp, "FIREWIRE ", strlen("FIREWIRE")) == 0)
	{
		flag = CAP_FIREWIRE;
	}
	else if(strncmp(cp, "IEEE1394 ", strlen("IEEE1394")) == 0)
	{
		flag = CAP_IEEE1394;
	}
	else if(strncmp(cp, "DC1394 ", strlen("DC1394")) == 0)
	{
		flag = CAP_DC1394;
	}
	else if(strncmp(cp, "CMU1394 ", strlen("CMU1394")) == 0)
	{
		flag = CAP_CMU1394;
	}
	else if(strncmp(cp, "QT ", strlen("QT")) == 0)
	{
		flag = CAP_QT;
	}
	else if(strncmp(cp, "UNICAP ", strlen("UNICAP")) == 0)
	{
		flag = CAP_UNICAP;
	}
	else if(strncmp(cp, "DSHOW ", strlen("DSHOW")) == 0)
	{
		flag = CAP_DSHOW;
	}
	else if(strncmp(cp, "PVAPI ", strlen("PVAPI")) == 0)
	{
		flag = CAP_PVAPI;
	}
	else if(strncmp(cp, "OPENNI ", strlen("OPENNI")) == 0)
	{
		flag = CAP_OPENNI;
	}
	else if(strncmp(cp, "OPENNI_ASUS ", strlen("OPENNI_ASUS")) == 0)
	{
		flag = CAP_OPENNI_ASUS;
	}
	else if(strncmp(cp, "ANDROID ", strlen("ANDROID")) == 0)
	{
		flag = CAP_ANDROID;
	}
	else if(strncmp(cp, "XIAPI ", strlen("XIAPI")) == 0)
	{
		flag = CAP_XIAPI;
	}
	else if(strncmp(cp, "AVFOUNDATION ", strlen("AVFOUNDATION")) == 0)
	{
		flag = CAP_AVFOUNDATION;
	}
	else if(strncmp(cp, "GIGANETIX ", strlen("GIGANETIX")) == 0)
	{
		flag = CAP_GIGANETIX;
	}
	else if(strncmp(cp, "MSMF ", strlen("MSMF")) == 0)
	{
		flag = CAP_MSMF;
	}
	else if(strncmp(cp, "WINRT ", strlen("WINRT")) == 0)
	{
		flag = CAP_WINRT;
	}
	else if(strncmp(cp, "INTELPERC ", strlen("INTELPERC")) == 0)
	{
		flag = CAP_INTELPERC;
	}
	else if(strncmp(cp, "OPENNI2 ", strlen("OPENNI2")) == 0)
	{
		flag = CAP_OPENNI2;
	}
	else if(strncmp(cp, "OPENNI2_ASUS ", strlen("OPENNI2_ASUS")) == 0)
	{
		flag = CAP_OPENNI2_ASUS;
	}
	else if(strncmp(cp, "GPHOTO2 ", strlen("GPHOTO2")) == 0)
	{
		flag = CAP_GPHOTO2;
	}
	else if(strncmp(cp, "GSTREAMER ", strlen("GSTREAMER")) == 0)
	{
		flag = CAP_GSTREAMER;
	}
	else if(strncmp(cp, "FFMPEG ", strlen("FFMPEG")) == 0)
	{
		flag = CAP_FFMPEG;
	}
	else if(strncmp(cp, "IMAGES ", strlen("IMAGES")) == 0)
	{
		flag = CAP_IMAGES;
	}
	else if(strncmp(cp, "ARAVIS ", strlen("ARAVIS")) == 0)
	{
		flag = CAP_ARAVIS;
	}
	else if(strncmp(cp, "OPENCV_MJPEG ", strlen("OPENCV_MJPEG")) == 0)
	{
		flag = CAP_OPENCV_MJPEG;
	}
	else if(strncmp(cp, "INTEL_MFX ", strlen("INTEL_MFX")) == 0)
	{
		flag = CAP_INTEL_MFX;
	}
	else if(strncmp(cp, "XINE ", strlen("XINE")) == 0)
	{
		flag = CAP_XINE;
	}
	char *cp2 = cp;
	while(*cp2 != '\0')
	{
		if(*cp2 == ':')
		{
			strcpy(format_code, cp2 + 1);
		}
		cp2++;
	}
	return(flag);
}

FaceDetect::FaceDetect()
{
	cascade.load("/usr/local/share/opencv4/haarcascades/haarcascade_frontalface_default.xml"); 
}

FaceDetect::~FaceDetect()
{
}

void FaceDetect::Detect(Mat& img, double scale)
{
vector<Rect> faces, faces2;
Mat gray, smallImg;

	cvtColor(img, gray, COLOR_BGR2GRAY );
	double fx = 1 / scale;

	resize(gray, smallImg, Size(), fx, fx, INTER_LINEAR); 
	equalizeHist(smallImg, smallImg);

	vector<int> levels;
	vector<double> weight;
	cascade.detectMultiScale(smallImg, faces, levels, weight, 1.1, 3, 0, Size(), Size(), true);
	for(size_t i = 0;i < faces.size();i++)
	{
		Rect r = faces[i];
		vector<Rect> nestedObjects;
		Point center;
		Scalar color = Scalar(255, 0, 0); // Color for Drawing tool
		int radius;

		rectangle(img, cv::Point(cvRound(r.x*scale), cvRound(r.y*scale)),
					cv::Point(cvRound((r.x + r.width-1)*scale), 
					cvRound((r.y + r.height-1)*scale)), color, 3, 8, 0);
	}
}

VideoCapture	*Camera::CreateCameraCapture(char *source, int num)
{
	int flag = CAP_V4L2;
	strcpy(format_code, "");
	VideoCapture *cam_cap = NULL;
	if(source == NULL)
	{
		cam_cap = new VideoCapture(num, flag);
		if(cam_cap->isOpened() == 0)
		{
			delete cam_cap;
			cam_cap = NULL;
		}
		else
		{
			cam_cap->set(CAP_PROP_FOURCC, VideoWriter::fourcc('M', 'J', 'P', 'G'));
		}
		sprintf(path, "/dev/video%d", num);
	}
	else
	{
		strcpy(original_path, source);
		if(strlen(source) == 1)
		{
			int nn = atoi(source);
			cam_cap = new VideoCapture(nn, flag);
			sprintf(path, "/dev/video%d", nn);
			if(cam_cap->isOpened() == 0)
			{
				delete cam_cap;
				cam_cap = NULL;
			}
			else
			{
				cam_cap->set(CAP_PROP_FOURCC, VideoWriter::fourcc('M', 'J', 'P', 'G'));
			}
		}
		else
		{
			char *cp = source;
			while(*cp != '\0')
			{
				if(strncmp(cp, "[alias=", strlen("[alias=")) == 0)
				{
					*cp = '\0';
					cp += strlen("[alias=");
					char *cp2 = cp;
					while((*cp != '\0') && (*cp != ']'))
					{
						cp++;
					}
					if(*cp == ']')
					{
						*cp = '\0';
					}
					strcpy(alias, cp2);
				}
				else
				{
					cp++;
				}
			}
			if(strncmp(source, "blank://", strlen("blank://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncmp(source, "av://", strlen("av://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncmp(source, "desktop://", strlen("desktop://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncmp(source, "window://", strlen("window://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncmp(source, "pseudo://", strlen("pseudo://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncmp(source, "sourced://", strlen("sourced://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncmp(source, "edge://", strlen("edge://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncmp(source, "chroma://", strlen("chroma://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else if(strncmp(source, "pipe://", strlen("pipe://")) == 0)
			{
				cam_cap = new VideoCapture();
			}
			else
			{
				char *cp = source;
				while(*cp != '\0')
				{
					if(strncmp(cp, "::", 2) == 0)
					{
						*cp = '\0';
						flag = SetBackendFlag(cp + 2);
					}
					cp++;
				}
				int no_go = my_window->ScanForDuplicateCameras(source);
				if(no_go == 0)
				{
					cam_cap = new VideoCapture(source, flag);
					if(cam_cap != NULL)
					{
						if(!cam_cap->isOpened())
						{
							delete cam_cap;
							cam_cap = new VideoCapture(source);
						}
						else
						{
							cam_cap->set(CAP_PROP_FOURCC, VideoWriter::fourcc('M', 'J', 'P', 'G'));
						}
					}
					else
					{
						cam_cap = new VideoCapture(source);
					}
				}
			}
			strcpy(path, source);
		}
	}
	return(cam_cap);
}

void	MyWin::RecordOn()
{
int	loop;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		cam->record = 1;
		if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
		{
			cam->TriggerSnapshot();
		}
	}
	recording = 1;
	if(pulse_mixer != NULL)
	{
		pulse_mixer->recording = 1;
		for(loop = 0;loop < audio_thumbnail_cnt;loop++)
		{
			if(audio_thumbnail[loop] != NULL)
			{
				if(audio_thumbnail[loop]->button->value())
				{
					if(audio_thumbnail[loop]->microphone != NULL)
					{
						audio_thumbnail[loop]->microphone->Record();
					}
				}
			}
		}
	}
}

void	MyWin::RecordOff()
{
int	loop;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		cam->record = 0;
		if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
		{
			cam->UnTriggerSnapshot();
		}
	}
	int no_go = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			if(cam->record == 1)
			{
				no_go = 1;
			}
		}
	}
	if(no_go == 0)
	{
		recording = 0;
	}
	if(pulse_mixer != NULL)
	{
		pulse_mixer->Stop();
		for(loop = 0;loop < audio_thumbnail_cnt;loop++)
		{
			if(audio_thumbnail[loop] != NULL)
			{
				if(audio_thumbnail[loop]->microphone != NULL)
				{
					audio_thumbnail[loop]->microphone->Stop();
				}
			}
		}
	}
}

void	Camera::RecordOn()
{
int	loop;

	record = 1;
	if(my_window->single_stream == 1)
	{
		my_window->Display(this);
		for(loop = 0;loop < my_window->source_cnt;loop++)
		{
			if(my_window->camera[loop] != NULL)
			{
				if(my_window->camera[loop] != this)
				{
					my_window->camera[loop]->record = 0;
				}
			}
		}
	}
	if(snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
	{
		TriggerSnapshot();
	}
	recording = 1;
	my_window->recording = 1;
	if(my_window->pulse_mixer != NULL)
	{
		my_window->pulse_mixer->recording = 1;
		for(loop = 0;loop < my_window->audio_thumbnail_cnt;loop++)
		{
			if(my_window->audio_thumbnail[loop] != NULL)
			{
				if(my_window->audio_thumbnail[loop]->button->value())
				{
					if(my_window->audio_thumbnail[loop]->microphone != NULL)
					{
						my_window->audio_thumbnail[loop]->microphone->Record();
					}
				}
			}
		}
	}
}

void	Camera::RecordOff()
{
int	loop;

	record = 0;
	if(snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
	{
		UnTriggerSnapshot();
	}
	int no_go = 0;
	for(loop = 0;loop < my_window->source_cnt;loop++)
	{
		Camera *cam = my_window->camera[loop];
		if(cam != NULL)
		{
			if(cam->record == 1)
			{
				no_go = 1;
			}
		}
	}
	if(no_go == 0)
	{
		my_window->recording = 0;
	}
	if(my_window->pulse_mixer != NULL)
	{
		my_window->pulse_mixer->Stop();
		for(loop = 0;loop < my_window->audio_thumbnail_cnt;loop++)
		{
			if(my_window->audio_thumbnail[loop] != NULL)
			{
				if(my_window->audio_thumbnail[loop]->microphone != NULL)
				{
					my_window->audio_thumbnail[loop]->microphone->Stop();
				}
			}
		}
	}
}

void	Camera::AddImageWindow(Camera *cam)
{
int	loop;

	int done = 0;
	for(loop = 0;((loop < 128) && (done == 0));loop++)
	{
		if(image_window[loop] == NULL)
		{
			int ww = cam->width;
			int hh = cam->height;
			while((ww >= (width / 2)) || (hh >= (height / 2)))
			{
				ww = ww / 2;
				hh = hh / 2;
			}
			int dw = width;
			int dh = height;
			int xx = image_sx + ((dw / 2) - (ww / 2));
			int yy = image_sy + ((dh / 2) - (hh / 2));
			if(my_window->dragging_thumb != NULL)
			{
				xx = my_window->dragging_thumb_x;
				yy = my_window->dragging_thumb_y;
			}
			ImageWindow *iw = new ImageWindow(loop, my_window, cam, this, xx, yy, ww, hh);
			image_window[loop] = iw;
			iw->show();
			done = 1;
			my_window->add(iw);
		}
	}
	CompressImageWindowList();
}

void	thumb_remove_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	for(loop = 0;loop < 128;loop++)
	{
		if(tg == win->thumbnail[loop])
		{
			tg->hide();
			ThumbButton *tb = tg->thumb_button;
			int idx = tb->index;
			if(idx > -1)
			{
				Camera *cam = win->camera[idx];
				if(cam != NULL)
				{
					win->RemoveCamera(cam);
					int done = 0;
					while(done == 0)
					{
						Camera *new_cam = win->camera[win->displayed_source];
						if((new_cam != NULL) || (win->displayed_source == 0))
						{
							done = 1;
						}
						else
						{
							win->displayed_source--;
						}
					}
				}
				tb->index = -1;
			}
		}
	}
}

void	thumb_place_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		Camera *dest = win->DisplayedCamera();
		if(dest != NULL)
		{
			if(cam != dest)
			{
				if(dest->CheckRecurseChildren(cam, dest) == 0)
				{
					dest->AddImageWindow(cam);
					if(win != NULL)
					{
						if(win->immediate_drawing_window != NULL)
						{
							win->immediate_drawing_window->redraw();
						}
					}
				}
			}
		}
	}
}

void	MyWin::ToggleRecord(int camera_index)
{
	if((camera_index > -1) && (camera_index < source_cnt))
	{
		Camera *cam = camera[camera_index];
		if(cam->record == 0)
		{
			cam->RecordOn();
		}
		else
		{
			cam->RecordOff();
		}
	}
}

void	MyWin::Display(int camera_index)
{
	if((camera_index > -1) && (camera_index < source_cnt))
	{
		int was_recording = 0;
		Camera *old = NULL;
		if(camera[displayed_source] != NULL)
		{
			if(camera[displayed_source]->record == 1)
			{
				was_recording = 1;
				old = camera[displayed_source];
			}
		}
		if(displayed_source != camera_index)
		{
			displayed_source = camera_index;
			alt_displayed_source = -1;
			if(single_stream == 1)
			{
				if(was_recording == 1)
				{
					if(old != NULL)
					{
						old->record = 0;
						last_cam = old;
					}
					camera[displayed_source]->record = 1;
				}
			}
		}
	}
}

void	MyWin::AltDisplay(int camera_index)
{
	if((camera_index > -1) && (camera_index < source_cnt))
	{
		if(camera_index != displayed_source)
		{
			alt_displayed_source = camera_index;
		}
		else
		{
			alt_displayed_source = -1;
		}
	}
}

void	MyWin::Display(Camera *cam)
{
int	loop;

	int done = 0;
	for(loop = 0;((loop < source_cnt) && (done == 0));loop++)
	{
		if(camera[loop] == cam)
		{
			Display(loop);
			done = 1;
		}
	}
}

void	thumb_record_button_cb(Fl_Widget *w, void *v)
{
void	record_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();

	int save_index = win->displayed_source;
	win->Display(tg->index);
	record_button_cb(w, v);
}

void	record_button_cb(Fl_Widget *w, void *v)
{
void	reset_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->record == 0)
	{
		w->label("Stop");
		win->encode_speed_window->Reset();
		win->encode_speed_window->show();
		win->motion_button->label("Detect Motion");
		win->object_button->label("Detect Objects");
		if(win->detail != NULL)
		{
			win->follow_button->label("Follow Motion");
			win->follow_objects_button->label("Follow Objects");
			if(win->stream == 0)
			{
				win->detail->show();
			}
		}
		cam->motion_detect = 0;
		cam->object_detect = 0;
		cam->follow_motion = 0;
		cam->follow_objects = 0;
		if(win->encoding == 0)
		{
			if(win->direct_recording == 0)
			{
				if((win->muxing == 0) || (win->stream_only == 0))
				{
					win->encode_button->show();
				}
			}
		}
		if(win->pulse_mixer != NULL)
		{
			win->pulse_mixer->recording = 1;
		}
		win->RecordOn();
		win->SetAllCamerasToGo();
		win->UpdateThumbButtons();
	}
	else
	{
		w->label("Record");
		win->encode_speed_window->Reset();
		win->encode_speed_window->hide();
		if(win->pulse_mixer != NULL)
		{
			win->pulse_mixer->Stop();
		}
		int err = cam->Record(win->stream);
		if(win->direct_recording == 0)
		{
			if(cam != NULL)
			{
				if(cam->total_frames[win->stream] == 0)
				{
					win->encode_button->hide();
				}
				else if(win->encoding == 0)
				{
					if((win->muxing == 0) || (win->stream_only == 0))
					{
						win->encode_button->show();
					}
				}
			}
		}
		cam->resuming = 1;
		win->RecordOff();
		win->SetAllCamerasToStop();
		if(win->streaming == 1)
		{
			reset_button_cb(NULL, win);
		}
	}
}

void	MyWin::RecordingFullStop()
{
void	reset_button_cb(Fl_Widget *w, void *v);

	Camera *cam = DisplayedCamera();
	record_button->label("Record");
	encode_speed_window->Reset();
	encode_speed_window->hide();
	if(pulse_mixer != NULL)
	{
		pulse_mixer->Stop();
	}
	int err = cam->Record(stream);
	if(direct_recording == 0)
	{
		if(cam != NULL)
		{
			if(cam->total_frames[stream] == 0)
			{
				encode_button->hide();
			}
			else if(encoding == 0)
			{
				if((muxing == 0) || (stream_only == 0))
				{
					encode_button->show();
				}
			}
		}
	}
	cam->resuming = 0;
	RecordOff();
	SetAllCamerasToStop();
	reset_button_cb(NULL, this);
}

void	freeze_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->freeze_video == 0)
	{
		w->label("Defrost");
		cam->freeze_video = 1;
	}
	else
	{
		w->label("Freeze");
		cam->freeze_video = 0;
	}
}

void	mute_video_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->mute_video == 0)
	{
		w->label("Unmute Video");
		cam->mute_video = 1;
	}
	else
	{
		w->label("Mute Video");
		cam->mute_video = 0;
	}
}

void	power_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->power == 0)
	{
		w->label("Turn Off");
		cam->power = 1;
	}
	else
	{
		w->label("Turn On");
		cam->power = 0;
	}
	win->HideButtons();
	win->ShowButtons();
}

void	save_setup_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(access("./Setups", 0) != 0)
	{
		mkdir("./Setups", 0755);
	}
	chdir("./Setups");
	Fl_Native_File_Chooser nfc;
	nfc.title("Select a setup file");
	nfc.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
	nfc.filter("*.setup");
	nfc.directory("Setups/sample.setup");
	int nn = nfc.show();
	if((nn != -1) && (nn != 1))
	{
		char *fn = (char *)nfc.filename();
		win->Save(fn);
	}
	chdir("..");
}

void	load_setup_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Native_File_Chooser nfc;
	nfc.title("Select a setup file");
	nfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
	nfc.filter("*.setup");
	nfc.directory("Setups/*");
	int nn = nfc.show();
	if((nn != -1) && (nn != 1))
	{
		char *fn = (char *)nfc.filename();
		win->Load(fn);
	}
}

void	hide_video_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->display_video == 1)
	{
		win->display_video = 0;
		win->hide_video_button->label("Display Video");
	}
	else
	{
		win->display_video = 1;
		win->hide_video_button->label("Hide Video");
	}
}

void	follow_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->follow_motion == 0)
	{
		w->label("Stop Following Motion");
		win->record_button->label("Record");
		win->motion_button->label("Detect Motion");
		win->object_button->label("Detect Objects");
		win->encode_speed_window->Reset();
		win->encode_speed_window->hide();
		if(win->stream == 0)
		{
			win->detail->show();
		}
		cam->follow_motion = 1;
		cam->motion_detect = 0;
		cam->object_detect = 0;
		win->UpdateThumbButtons();
	}
	else
	{
		w->label("Follow Motion");
		cam->follow_motion = 0;
		win->UpdateThumbButtons();
	}
}

void	follow_objects_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->follow_objects == 0)
	{
		w->label("Stop Following Objects");
		win->record_button->label("Record");
		win->motion_button->label("Detect Motion");
		win->object_button->label("Detect Objects");
		win->encode_speed_window->Reset();
		win->encode_speed_window->hide();
		if(win->stream == 0)
		{
			win->detail->show();
		}
		cam->follow_objects = 1;
		cam->motion_detect = 0;
		cam->object_detect = 0;
		win->UpdateThumbButtons();
	}
	else
	{
		w->label("Follow Objects");
		cam->follow_objects = 0;
		win->UpdateThumbButtons();
	}
}

void	timestamp_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(win->timestamp == 0)
	{
		w->label("No Timestamp");
		win->timestamp = 1;
		if(win->settings_window != NULL)
		{
			win->settings_window->timestamp_default->value(1);
		}
	}
	else
	{
		w->label("Timestamp");
		win->timestamp = 0;
		if(win->settings_window != NULL)
		{
			win->settings_window->timestamp_default->value(0);
		}
	}
}

void	dump_button_cb(Fl_Widget *w, void *v)
{
void	read_video_header(int fdx, int *uw, int *uh, int *depth, int *ufps);
char	buf[4096];
char	directory[4096];
char	filename[8192];
struct tm	*tm;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(win->stream == 0)
	{
		if(win->single_stream == 0)
		{
			sprintf(buf, "detail_%02d.bin", win->displayed_source);
		}
		else
		{
			sprintf(buf, "single_stream.bin");
		}
	}
	else
	{
		if(win->single_stream == 0)
		{
			sprintf(buf, "main_%02d.bin", win->displayed_source);
		}
		else
		{
			sprintf(buf, "single_stream.bin");
		}
	}
	if(access(buf, 0) == 0)
	{
		int fdi = open(buf, O_RDONLY);
		if(fdi > -1)
		{
			int uw = 0;
			int uh = 0;
			int depth = 0;
			int ufps = 0;
			long int length = filelength(fdi);
			read_video_header(fdi, &uw, &uh, &depth, &ufps);
			int in_frame = 0;
			int sz = uw * uh * depth;
			length -= (sizeof(int) * 4);
			int dumped_frame_cnt = length / sz;
			if(dumped_frame_cnt > 0)
			{
				void *ptr = malloc(sz);
				if(ptr != NULL)
				{
					time_t t_num = time(0);
					tm = localtime((const time_t *)&t_num);
		 			sprintf(directory, "FrameDump_%04d_%02d_%02d_%02d_%02d_%02d", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
					mkdir(directory, 0777);
					int cnt = 0;
					int done = 0;
					while((done == 0) && (cnt < dumped_frame_cnt))
					{
						long int ts = 0;
						int nn = read_frame(fdi, ptr, sz, &ts);
						if(nn == sz)
						{
							sprintf(filename, "%s/frame_%06d.png", directory, cnt);
							Mat src = Mat(uh, uw, CV_8UC3, ptr);
							cvtColor(src, src, COLOR_RGB2BGR);
							imwrite(filename, src);
							cnt++;
						}
						else
						{
							done = 1;
						}
					}
					free(ptr);
				}
			}
			close(fdi);
		}
	}
}

void	thumb_motion_button_cb(Fl_Widget *w, void *v)
{
void	motion_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();

	int save_index = win->displayed_source;
	win->Display(tg->index);
	motion_button_cb(w, v);
	win->Display(save_index);
}

void	motion_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->motion_detect == 0)
	{
		w->label("Stop Detecting Motion");
		win->record_button->label("Record");
		if(win->detail != NULL)
		{
			win->follow_button->label("Follow Motion");
			win->follow_objects_button->label("Follow Objects");
			if(win->stream == 0)
			{
				win->detail->show();
			}
		}
		win->encode_speed_window->Reset();
		win->encode_speed_window->hide();
		cam->motion_detect = 1;
		cam->object_detect = 0;
		cam->follow_motion = 0;
		cam->follow_objects = 0;
		win->UpdateThumbButtons();
	}
	else
	{
		w->label("Detect Motion");
		cam->Record(win->stream);
		cam->motion_detect = 0;
		cam->record = 0;
		if(win->muxer_cnt > 0)
		{
			if(win->pulse_mixer != NULL)
			{
				win->pulse_mixer->Stop();
			}
			for(loop = 0;loop < 128;loop++)
			{
				if(win->my_muxer[loop] != NULL)
				{
					win->my_muxer[loop]->Stop();
				}
			}
		}
		win->UpdateThumbButtons();
	}
}

void	thumb_instrument_button_cb(Fl_Widget *w, void *v)
{
void	object_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		if(cam->instrument_window == NULL)
		{
			cam->instrument_window = new InstrumentWindow(win, cam, 600, 1000);
		}
		else
		{
			cam->instrument_window->PopulateFromCamera();
		}
		if(cam->instrument_window != NULL)
		{
			cam->instrument_window->show();
		}
	}
}

void	thumb_object_button_cb(Fl_Widget *w, void *v)
{
void	object_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();

	int save_index = win->displayed_source;
	win->Display(tg->index);
	object_button_cb(w, v);
	win->Display(save_index);
}

void	object_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam->object_detect == 0)
	{
		w->label("Stop Detecting Objects");
		win->record_button->label("Record");
		if(win->detail != NULL)
		{
			win->follow_button->label("Follow Motion");
			win->follow_objects_button->label("Follow Objects");
			if(win->stream == 0)
			{
				win->detail->show();
			}
		}
		win->encode_speed_window->Reset();
		win->encode_speed_window->hide();
		cam->object_detect = 1;
		cam->motion_detect = 0;
		cam->follow_motion = 0;
		cam->follow_objects = 0;
		win->UpdateThumbButtons();
		if(win->tag_recognized == 1)
		{
			char filename[4096];
			strcpy(filename, "tag_file");
			win->SetUseOutputPath(0, filename);
			strcat(filename, ".tag");
			win->tag_fp = fopen(filename, "w");
		}
	}
	else
	{
		w->label("Detect Objects");
		cam->Record(win->stream);
		cam->object_detect = 0;
		cam->record = 0;
		if(win->pulse_mixer != NULL)
		{
			win->pulse_mixer->Stop();
		}
		for(loop = 0;loop < 128;loop++)
		{
			if(win->my_muxer[loop] != NULL)
			{
				win->my_muxer[loop]->Stop();
			}
		}
		win->UpdateThumbButtons();
		if(win->tag_recognized == 1)
		{
			if(win->tag_fp != NULL)
			{
				fclose(win->tag_fp);
				win->tag_fp = NULL;
			}
		}
	}
}

void	encode_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(win->encoding == 0)
	{
		win->record_button->label("Record");
		win->motion_button->label("Detect Motion");
		win->object_button->label("Detect Objects");
		if(win->detail != NULL)
		{
			win->follow_button->label("Follow Motion");
			win->follow_button->label("Follow Objects");
		}
		win->encode_speed_window->Reset();
		win->encode_speed_window->hide();
		cam->motion_detect = 0;
		cam->object_detect = 0;
		cam->follow_motion = 0;
		cam->follow_objects = 0;
		win->Encode();
		win->UpdateThumbButtons();

		win->encode_button->hide();
	}
}

void	thumb_background_button_cb(Fl_Widget *w, void *v)
{
void	object_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	unsigned char red = 200;
	unsigned char green = 200;
	unsigned char blue = 200;
	if(fl_color_chooser("Background Color", red, green, blue, 1))
	{
		Camera *cam = win->camera[tg->index];
		if(cam != NULL)
		{
			cam->red = red;
			cam->green = green;
			cam->blue = blue;
			if((cam->type != CAMERA_TYPE_TEXT) && (cam->type != CAMERA_TYPE_PIPED))
			{
				cam->mat.setTo(cv::Scalar(red ,green, blue));
				cam->reserve_mat.setTo(cv::Scalar(red ,green, blue));
			}
			cam->static_initialized = 0;
		}
	}
}

void	thumb_text_color_button_cb(Fl_Widget *w, void *v)
{
void	object_button_cb(Fl_Widget *w, void *v);

	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)w->parent();
	unsigned char red = 200;
	unsigned char green = 200;
	unsigned char blue = 200;
	if(fl_color_chooser("Text Color", red, green, blue, 1))
	{
		Camera *cam = win->camera[tg->index];
		if(cam != NULL)
		{
			cam->text_red = red;
			cam->text_green = green;
			cam->text_blue = blue;
			cam->static_initialized = 0;
		}
	}
}

void	thumb_pause_av_button_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)b->parent();
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		if(cam->av_window != NULL)
		{
			if(cam->av_window->paused == 1)
			{
				cam->av_window->Resume();
				b->label("Pause");
			}
			else
			{
				cam->av_window->Pause();
				b->label("Resume");
			}
		}
	}
}

void	thumb_mute_av_button_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	MyWin *win = (MyWin *)v;
	ThumbGroup *tg = (ThumbGroup *)b->parent();
	Camera *cam = win->camera[tg->index];
	if(cam != NULL)
	{
		if(cam->av_window != NULL)
		{
			if(cam->av_window->muted == 1)
			{
				cam->av_window->UnMute();
				b->label("Mute");
			}
			else
			{
				cam->av_window->Mute();
				b->label("Unmute");
			}
		}
	}
}

void	jpeg_streaming_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->transmitting == 0)
	{
		win->jpeg_streaming_button->label("Ceace Streaming");
		win->image_memory.done = 0;
		win->SendToNetwork();
		win->transmitting = 1;
	}
	else
	{
		win->jpeg_streaming_button->label("JPEG Streaming");
		win->transmitting = 0;
		win->image_memory.done = 1;
	}
}

void	main_detail_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(win->detail != NULL)
	{
		if(win->stream == 0)
		{
			w->label("Record to Detail");
			win->stream = 1;
			cam->follow_motion = 0;
			cam->follow_objects = 0;
			win->detail->hide();
			win->follow_button->hide();
			win->follow_objects_button->hide();
		}
		else
		{
			w->label("Record to Main");
			win->stream = 0;
			win->detail->show();
			if(win->use_old == 0)
			{
				win->follow_button->show();
			}
		}
	}
}

void	show_debug_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->visible_debug == 0)
	{
		w->label("Hide Debug");
		win->visible_debug = 1;
	}
	else
	{
		w->label("Record Debug");
		win->visible_debug = 0;
	}
}

void	show_motion_debug_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->motion_debug == 0)
	{
		w->label("Hide Motion Debug");
		win->motion_debug = 1;
	}
	else
	{
		w->label("Show Motion Debug");
		win->motion_debug = 0;
	}
}

void	clear_interest_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->interest_cnt = 0;
}

void	set_interest_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->mark_interest == 0)
	{
		win->HideButtons();
		w->show();
		win->interest_cnt = 0;
		w->label("Done Setting Interest");
		if(win->detail != NULL)
		{
			win->detail->hide();
		}
		win->mark_interest = 1;
	}
	else
	{
		win->mark_interest = 0;
		win->ShowButtons();
		w->label("Set Interest");
		if((win->detail != NULL) && (win->source == 0))
		{
			win->detail->show();
		}
	}
}

void	snapshot_timeout_cb(void *v)
{
	Camera *cam = (Camera *)v;
	cam->snapshot = 1;
	if(cam->snapshot_repeat_delay > 0)
	{
		Fl::repeat_timeout(cam->snapshot_repeat_delay, snapshot_timeout_cb, cam);
	}
}

void	snapshot_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		cam->TriggerSnapshot();
	}
}

void	Camera::TriggerSnapshot()
{
	Fl::add_timeout(snapshot_initial_delay, snapshot_timeout_cb, this);
}

void	Camera::UnTriggerSnapshot()
{
	Fl::remove_timeout(snapshot_timeout_cb, this);
}

void	MyWin::AddLastMuxed(char *filename)
{
int	loop;

	if(last_muxed_list[63] != NULL)
	{
		free(last_muxed_list[63]);
		last_muxed_list[63] = NULL;
	}
	for(loop = 63;loop > 0;loop--)
	{
		last_muxed_list[loop] = last_muxed_list[loop - 1];
	}
	last_muxed_list[loop] = strdup(filename);
}

void	review_muxed_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->review_muxed == NULL)
	{
		if(win->last_muxed_list[0] != NULL)
		{
			win->review_muxed = new MuxPreviewWindow(win, win->requested_w, win->requested_h, "Muxed Preview");
			win->review_muxed->show();
		}
	}
}

void	review_button_cb(Fl_Widget *w, void *v)
{
int	extract_audio(int *prg, char *in_filename, char *out_filename, int hz, int channels);
int	extract_video(int *prg, char *in_filename, char *out_filename);
void	review_win_cb(void *v);
char	buf[4092];

	MyWin *win = (MyWin *)v;
	if(win->review == NULL)
	{
		if((win->muxing == 1) && (win->stream_only == 1))
		{
			if(win->last_muxed_list[0] != NULL)
			{
				win->extracting = -1;
				int nn = extract_audio(&win->extracting, win->last_muxed_list[0], "audio.bin", 44100, 1);
				if(nn >= 0)
				{
					win->extracting = 1;
					nn = extract_video(&win->extracting, win->last_muxed_list[0], "video.bin");
					if(nn >= 0)
					{
						int n_ww = win->camera[win->displayed_source]->width;
						int n_hh = win->camera[win->displayed_source]->height;
						win->review = new ReviewWin(win, n_ww, n_hh, 24, "Review", "video.bin");
						cv::Mat local_mat(n_hh, n_ww, CV_8UC3, cv::Scalar(55, 100, 150));
						memcpy(win->review->frame, local_mat.ptr(), (n_ww * n_hh * 3));
						win->review->end();
						win->review->show();
						win->review->main = win;
						Fl::add_timeout(0.1, review_win_cb, win->review);
					}
				}
				win->extracting = 0;
			}
		}
		else
		{
			Camera *cam = win->camera[win->displayed_source];
			if(cam != NULL)
			{
				if(win->stream == 0)
				{
					if(win->single_stream == 0)
					{
						sprintf(buf, "detail_%02d.bin", win->displayed_source);
					}
					else
					{
						sprintf(buf, "single_stream.bin");
					}
					win->review = new ReviewWin(win, win->detail_width, win->detail_height, (int)cam->fps, "Review", buf);
					memcpy(win->review->frame, win->detail->mat.ptr(), (win->detail_width * win->detail_height * 3));
					win->review->end();
					win->review->show();
					win->review->main = win;
					Fl::add_timeout(0.1, review_win_cb, win->review);
				}
				else
				{
					if(win->single_stream == 0)
					{
						sprintf(buf, "main_%02d.bin", win->displayed_source);
					}
					else
					{
						sprintf(buf, "single_stream.bin");
					}
					int n_ww = win->camera[win->displayed_source]->width;
					int n_hh = win->camera[win->displayed_source]->height;
					win->review = new ReviewWin(win, n_ww, n_hh, (int)cam->fps, "Review", buf);
					memcpy(win->review->frame, cam->mat.ptr(), (n_ww * n_hh * 3));
					win->review->end();
					win->review->show();
					win->review->main = win;
					Fl::add_timeout(0.1, review_win_cb, win->review);
				}
			}
		}
	}
}

void	MyWin::SaveInterest()
{
int	loop;

	if(interest_cnt > 0)
	{
		char *filename = fl_file_chooser("Select a name of the interest file", "*,*", "interest.bin", 0);
		if(filename != NULL)
		{
			int fd = open(filename, O_WRONLY | O_TRUNC | O_CREAT, 0644);
			if(fd > -1)
			{
				write(fd, &interest_cnt, sizeof(int));
				for(loop = 0;loop < interest_cnt;loop++)
				{
					int xx = interest_x[loop];
					int yy = interest_y[loop];
					write(fd, &xx, sizeof(int));
					write(fd, &yy, sizeof(int));
				}
				close(fd);
			}
		}
	}
}

void	MyWin::LoadInterest()
{
int	loop;

	char *filename = fl_file_chooser("Select an interest file", "*,*", "interest.bin", 0);
	if(filename != NULL)
	{
		int fd = open(filename, O_RDONLY);
		if(fd > -1)
		{
			read(fd, &interest_cnt, sizeof(int));
			for(loop = 0;loop < interest_cnt;loop++)
			{
				int xx = -1;
				int yy = -1;
				read(fd, &xx, sizeof(int));
				read(fd, &yy, sizeof(int));
				interest_x[loop] = xx;
				interest_y[loop] = yy;
			}
			close(fd);
		}
	}
}

void	reset_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(win->pulse_mixer != NULL)
		{
			win->pulse_mixer->Stop();
		}
		if(cam->fd[0] > -1)
		{
			close(cam->fd[0]);
			cam->fd[0] = -1;
		}
		if(cam->fd[1] > -1)
		{
			close(cam->fd[1]);
			cam->fd[1] = -1;
		}
		cam->total_frames[win->stream] = 0;
		cam->ever_opened = 0;
		cam->starting_time = 0;
		cam->running_time = 0;
		for(loop = 0;loop < 128;loop++)
		{
			if(win->my_muxer[loop] != NULL)
			{
				win->my_muxer[loop]->FinishMux();
				delete win->my_muxer[loop];
				win->my_muxer[loop] = NULL;
			}
		}
		win->recorded_frames = 0;
	}
}

void	reset_cameras_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->ResetCameras(1, win->source, win->source_cnt);
}

void	trigger_camera_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->trigger_select_mode == 0)
	{
		win->trigger_select_mode = 1;
		win->trigger_button->label("Done Selecting Triggers");
		win->trigger_window->show();
	}
	else
	{
		win->trigger_select_mode = 0;
		win->trigger_button->label("Trigger Camera");
		win->trigger_window->hide();
	}
}

void	resize_capture_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->resize_capture == 0)
	{
		win->resize_capture = 1;
		reset_button_cb(NULL, win);
		win->resize_capture_button->label("Zoom");
	}
	else
	{
		win->resize_capture = 0;
		win->resize_capture_button->label("Resize Capture (reset)");
	}
}

void	quit_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->Done();
	if(win->detail != NULL)
	{
		win->detail->hide();
	}
	if(win->review != NULL)
	{
		win->review->hide();
	}
	if(win->immediate_drawing_window != NULL)
	{
		win->immediate_drawing_window->hide();
	}
	win->hide();
	delete win;
}

void	split_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->split == 0)
	{
		for(loop = 0;loop < 128;loop++)
		{
			win->thumbnail[loop]->hide();
		}
		win->split = 1;
	}
	else
	{
		win->split = 0;
	}
}

void	set_output_button_cb(Fl_Widget *w, void *v)
{
	MyWin *my_win = (MyWin *)v;
	my_win->set_output_window->show();
	my_win->set_output_window->set_non_modal();
}

void	select_output_button_cb(Fl_Widget *w, void *v)
{
	MyWin *my_win = (MyWin *)v;
	my_win->select_output_window->show();
	my_win->select_output_window->set_non_modal();
	my_win->select_output_window->Populate();
}

void	cancel_new_source_cb(Fl_Widget *w, void *v)
{
	MyWin *my_win = (MyWin *)v;
	my_win->new_source_button->show();
	my_win->showing_new_source_window = 0;
	my_win->pseudo_camera_window->hide();
	my_win->new_source_window->hide();
	my_win->cursor(FL_CURSOR_DEFAULT);
}

void	new_source_cb(Fl_Widget *w, void *v)
{
char buf[4096];

	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	int use_chroma = CHROMA_ON_GREEN;
	if(w == nsw->chromakey_blue_select)
	{
		use_chroma = CHROMA_ON_BLUE;
	}
	my_win->new_source_button->show();
	my_win->edit_source_button->show();
	my_win->showing_new_source_window = 0;
	Fl_Input *in = (Fl_Input *)w;
	NewSourceWindow *win = (NewSourceWindow *)in->window();
	if(win->children() >= 4)
	{
		Fl_Input *source = (Fl_Input *)nsw->source;
		Fl_Input *alias_in = (Fl_Input *)nsw->alias;
		Fl_Input *width = (Fl_Input *)nsw->width;
		Fl_Input *height = (Fl_Input *)nsw->height;
		Fl_Input *font_sz = (Fl_Input *)nsw->font_sz;

		char *text = (char *)source->value();
		char *alias = (char *)alias_in->value();
		char *ww = (char *)width->value();
		char *hh = (char *)height->value();
		char *fz = (char *)font_sz->value();
		char *font_name = (char *)nsw->font_browser->text(nsw->font_browser->value());
		int rr = (int)nsw->red->value();
		int gg = (int)nsw->green->value();
		int bb = (int)nsw->blue->value();
		int aa = (int)nsw->alpha->value();
		int t_rr = (int)nsw->text_red->value();
		int t_gg = (int)nsw->text_green->value();
		int t_bb = (int)nsw->text_blue->value();
		int t_aa = (int)nsw->text_alpha->value();
		if(text != NULL)
		{
			if(atoi(text) == 0)
			{
				if(strlen(text) == 0)
				{
					sprintf(buf, "blank://%d,%d,%d,%d", rr, gg, bb, aa);
					text = buf;
				}
				else
				{
					if(strcmp(text, "blank://") == 0)
					{
						sprintf(buf, "blank://%d,%d,%d,%d", rr, gg, bb, aa);
						text = buf;
					}
				}
				int nw = atoi(ww);
				int nh = atoi(hh);
				int nfz = atoi(fz);
				if((nw > 0) && (nh > 0))
				{
					char alias_arg[4096];
					strcpy(alias_arg, "Text");
					if(alias != NULL)
					{
						if(strlen(alias) > 0)
						{
							strcpy(alias_arg, alias);
						}
					}
					int cam_n = my_win->SetupCamera(text, alias_arg, nw, nh, nfz, font_name, rr, gg, bb, aa, t_rr, t_gg, t_bb, t_aa, use_chroma);
					if(cam_n > -1)
					{
						my_win->Display(cam_n);
						while(my_win->displayed_source >= (my_win->start_thumbgroup + DISPLAYED_THUMB_CNT))
						{
							my_win->start_thumbgroup++;
						}
						my_win->UpdateThumbButtons();
					}
				}
			}
		}
		source->value("");
		alias_in->value("");
	}
	my_win->new_source_window->hide();
	my_win->cursor(FL_CURSOR_DEFAULT);
}

void	edit_source_cb(Fl_Widget *w, void *v)
{
char buf[4096];

	MyWin *my_win = (MyWin *)v;
	Camera *cam = my_win->DisplayedCamera();
	NewSourceWindow *nsw = my_win->new_source_window;
	my_win->new_source_button->show();
	my_win->edit_source_button->show();
	my_win->showing_new_source_window = 0;
	if(cam != NULL)
	{
		Fl_Input *in = (Fl_Input *)w;
		NewSourceWindow *win = (NewSourceWindow *)in->window();
		if(win->children() >= 4)
		{
			Fl_Input *source = (Fl_Input *)nsw->source;
			Fl_Input *alias_in = (Fl_Input *)nsw->alias;
			Fl_Input *width = (Fl_Input *)nsw->width;
			Fl_Input *height = (Fl_Input *)nsw->height;
			Fl_Input *font_sz = (Fl_Input *)nsw->font_sz;

			char *text = (char *)source->value();
			char *alias = (char *)alias_in->value();
			char *ww = (char *)width->value();
			char *hh = (char *)height->value();
			char *fz = (char *)font_sz->value();
			char *font_name = (char *)nsw->font_browser->text(nsw->font_browser->value());
			int rr = (int)nsw->red->value();
			int gg = (int)nsw->green->value();
			int bb = (int)nsw->blue->value();
			int aa = (int)nsw->alpha->value();
			int t_rr = (int)nsw->text_red->value();
			int t_gg = (int)nsw->text_green->value();
			int t_bb = (int)nsw->text_blue->value();
			int t_aa = (int)nsw->text_alpha->value();
			if(strlen(text) > 0)
			{
				if(strcmp(cam->path, text) != 0)
				{
					if(cam->type == CAMERA_TYPE_TEXT)
					{
						strcpy(cam->path, text);
					}
					else
					{
						int displayed = my_win->displayed_source;
						my_win->RemoveCamera(cam);
						new_source_cb(w, v);
						cam = my_win->camera[displayed];
					}
				}
			}
			if(strlen(alias) > 0)
			{
				strcpy(cam->alias, alias);
			}
			int f_sz = atoi(fz);
			if((f_sz > 0) && (f_sz < 256))
			{
				cam->font_sz = f_sz;
			}
			if(strlen(font_name) > 0)
			{
				strcpy(cam->font_name, font_name);
			}
			cam->red = rr;
			cam->green = gg;
			cam->blue = bb;
			cam->alpha = aa;
			cam->text_red = t_rr;
			cam->text_green = t_gg;
			cam->text_blue = t_bb;
			cam->text_alpha = t_aa;
			int r_ww = atoi(ww);
			if(r_ww > 0)
			{
				cam->requested_w = r_ww;
			}
			int r_hh = atoi(hh);
			if(r_hh > 0)
			{
				cam->requested_h = r_hh;
			}
			if((r_ww > 0) && (r_hh > 0))
			{
				cv::resize(cam->mat, cam->mat, cv::Size(r_ww, r_hh));
				cam->width = r_ww;
				cam->height = r_hh;
			}
			cam->static_initialized = 0;
			source->value("");
			alias_in->value("");
		}
	}
	my_win->new_source_window->hide();
	my_win->cursor(FL_CURSOR_DEFAULT);
}

void	new_source_camera_select_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->new_source_window->hide();
	win->new_source_button->show();
	win->edit_source_button->show();
	win->showing_new_source_window = 0;
	SelectCameraWindow *scw = new SelectCameraWindow(win);
	scw->show();
}

void	new_source_audio_select_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->new_source_window->hide();
	win->new_source_button->show();
	win->edit_source_button->show();
	win->showing_new_source_window = 0;
	SelectAudioWindow *scw = new SelectAudioWindow(win);
	scw->show();
}

void	new_source_box_select_cb(Fl_Widget *w, void *v)
{
void	iconize_cb(void *v);

	MyWin *win = (MyWin *)v;
	win->new_source_window->hide();
	win->pseudo_camera_window->hide();
	win->iconize();
	Fl::add_timeout(1.0, iconize_cb, win);
}

static char *get_property(Display *disp, Window win, Atom xa_prop_type, char *prop_name, unsigned long *size)
{
Atom xa_prop_name;
Atom xa_ret_type;
int ret_format;
unsigned long ret_nitems;
unsigned long ret_bytes_after;
unsigned long tmp_size;
unsigned char *ret_prop;
char *ret;
	
	xa_prop_name = XInternAtom(disp, prop_name, False);
	
	// MAX_PROPERTY_VALUE_LEN / 4 explanation (XGetWindowProperty manpage):
	//
	// long_length = Specifies the length in 32-bit multiples of the
	//			   data to be retrieved.
	//
	if(XGetWindowProperty(disp, win, xa_prop_name, 0, MAX_PROPERTY_VALUE_LEN / 4, False, xa_prop_type, &xa_ret_type, &ret_format, &ret_nitems, &ret_bytes_after, &ret_prop) != Success)
	{
		return NULL;
	}
	if(xa_ret_type != xa_prop_type)
	{
		XFree(ret_prop);
		return NULL;
	}
	// null terminate the result to make string handling easier
	tmp_size = (ret_format / (32 / sizeof(long))) * ret_nitems;
	ret = (char *)malloc(tmp_size + 1);
	memcpy(ret, ret_prop, tmp_size);
	ret[tmp_size] = '\0';
	if (size)
	{
		*size = tmp_size;
	}
	XFree(ret_prop);
	return ret;
}

static char *get_window_class(Display *disp, Window win)
{
char *class_utf8;
char *wm_class;
unsigned long size;

	wm_class = get_property(disp, win, XA_STRING, "WM_CLASS", &size);
	if(wm_class)
	{
		char *p_0 = strchr(wm_class, '\0');
		if(wm_class + size - 1 > p_0)
		{
			*(p_0) = '.';
		}
		class_utf8 = strdup(wm_class);
	}
	else
	{
		class_utf8 = NULL;
	}
	free(wm_class);
	return class_utf8;
}

static Window *get_client_list(Display *disp, unsigned long *size)
{
	Window *client_list;

	if((client_list = (Window *)get_property(disp, DefaultRootWindow(disp), XA_WINDOW, "_NET_CLIENT_LIST", size)) == NULL)
	{
		if((client_list = (Window *)get_property(disp, DefaultRootWindow(disp), XA_CARDINAL, "_WIN_CLIENT_LIST", size)) == NULL)
		{
			fputs("Cannot get client list properties. \n" "(_NET_CLIENT_LIST or _WIN_CLIENT_LIST)" "\n", stderr);
			return NULL;
		}
	}
	return client_list;
}

static char *get_window_title(Display *disp, Window win)
{
char *title_utf8;
char *wm_name;
char *net_wm_name;

	wm_name = get_property(disp, win, XA_STRING, "WM_NAME", NULL);
	net_wm_name = get_property(disp, win, XInternAtom(disp, "UTF8_STRING", False), "_NET_WM_NAME", NULL);
	if(net_wm_name)
	{
		title_utf8 = (char *)strdup((char *)net_wm_name);
		free(net_wm_name);
	}
	else
	{
		if(wm_name)
		{
			title_utf8 = (char *)strdup((char *)wm_name);
		}
		else
		{
			title_utf8 = NULL;
		}
		free(wm_name);
	}
	return(title_utf8);
}

int	iterate_windows2(MyWin *my_window, Display *disp, char **window_list)
{
Window *client_list;
unsigned long client_list_size;
int i;
int max_client_machine_len = 0;
	
	if((client_list = get_client_list(disp, &client_list_size)) == NULL)
	{
		return EXIT_FAILURE;
	}
	// find the longest client_machine name
	for(i = 0; i < client_list_size / sizeof(Window); i++)
	{
		char *client_machine;
		if((client_machine = get_property(disp, client_list[i], XA_STRING, "WM_CLIENT_MACHINE", NULL)))
		{
			max_client_machine_len = strlen((char *)client_machine);	
		}
		free(client_machine);
	}
	// print the list
	int cnt = 0;
	for(i = 0; i < client_list_size / sizeof(Window); i++)
	{
		char *title_utf8 = get_window_title(disp, client_list[i]);
		char *title_out = strdup(title_utf8);
		char *client_machine;
		char *class_out = get_window_class(disp, client_list[i]);
		unsigned long *pid;
		unsigned long *desktop;
		int x, y, junkx, junky;
		unsigned int wwidth, wheight, bw, depth;
		Window junkroot;

		// desktop ID
		if((desktop = (unsigned long *)get_property(disp, client_list[i], XA_CARDINAL, "_NET_WM_DESKTOP", NULL)) == NULL)
		{
			desktop = (unsigned long *)get_property(disp, client_list[i], XA_CARDINAL, "_WIN_WORKSPACE", NULL);
		}
		// client machine
		client_machine = get_property(disp, client_list[i], XA_STRING, "WM_CLIENT_MACHINE", NULL);
	
		// pid
		pid = (unsigned long *)get_property(disp, client_list[i], XA_CARDINAL, "_NET_WM_PID", NULL);

		// geometry
		XGetGeometry(disp, client_list[i], &junkroot, &junkx, &junky, &wwidth, &wheight, &bw, &depth);
		XTranslateCoordinates(disp, client_list[i], junkroot, junkx, junky, &x, &y, &junkroot);
	
		// special desktop ID -1 means "all desktops", so we have to convert the desktop value to signed long
		// printf("0x%.8lx %2ld", client_list[i], desktop ? (signed long)*desktop : 0);
		// printf(" %*s %s\n", max_client_machine_len, client_machine ? client_machine : "N/A", title_out ? title_out : "N/A");
		// printf("%d %d %d %d\n", x, y, wwidth, wheight);

		char buf[4096];
		sprintf(buf, "%lu::%s", client_list[i], title_out ? title_out : "N/A");
		window_list[cnt] = strdup(buf);
		cnt++;

		free(title_utf8);
		free(title_out);
		free(desktop);
		free(client_machine);
		free(class_out);
		free(pid);
	}
	free(client_list);
	return(cnt);
}

void	iterate_windows(Display *display, Window rootWindow, int depth)
{
Window parent;
Window *children;
Window *child;
unsigned int nNumChildren;
XTextProperty wmName;
XTextProperty wmCommand;

	int status = XGetWMName(display, rootWindow, &wmName);
	if(status && wmName.value && wmName.nitems)
	{
		int i;
		char **list;
		status = XmbTextPropertyToTextList(display, &wmName, &list, &i);
		if(status >= Success && i && *list)
		{
			if(depth == 1)
			{
				printf("%d NAME: [%s]\n", depth, (char *)*list);
			}
		}
	}
	status = XQueryTree(display, rootWindow, &rootWindow, &parent, &children, &nNumChildren);
	if(status == 0)
	{
		// Could not query window tree further, aborting
		return;
	}
	if(nNumChildren == 0)
	{
		// No more children found. Aborting
		return;
	}
	for(int i = 0; i < nNumChildren; i++)
	{
		iterate_windows(display, children[i], depth + 1);
	}
	XFree((char*) children);
}

void	select_window_to_monitor_cb(Fl_Widget *w, void *v)
{
char	buf[8192];
int	loop;

	Fl_Toggle_Button *b = (Fl_Toggle_Button *)w;
	unsigned long int window_id = (unsigned long int)v;
	char buf2[4096];
	strcpy(buf2, "Window");
	if(global_window->new_source_window != NULL)
	{
		Fl_Input *alias_in = (Fl_Input *)global_window->new_source_window->alias;
		char *alias = (char *)alias_in->value();
		if(alias != NULL)
		{
			if(strlen(alias) > 0)
			{
				strcpy(buf2, alias);
			}
		}
	}
	sprintf(buf, "window://%lu", (unsigned long int)b->user_data());
	global_window->SetupCamera(buf, buf2, global_window->requested_w, global_window->requested_h, 32);
	Fl_Window *win = b->window();
	win->hide();
	Fl::delete_widget(win);
	global_window->showing_new_source_window = 0;
}

void	new_source_desktop_select_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	MyWin *win = (MyWin *)v;
	char buf2[4096];
	strcpy(buf2, "Desktop");
	if(win->new_source_window != NULL)
	{
		Fl_Input *alias_in = (Fl_Input *)win->new_source_window->alias;
		char *alias = (char *)alias_in->value();
		if(alias != NULL)
		{
			if(strlen(alias) > 0)
			{
				strcpy(buf2, alias);
			}
		}
	}
	win->SetupCamera("desktop://", buf2, win->requested_w, win->requested_h, 32);
	win->new_source_window->hide();
	win->pseudo_camera_window->hide();
	win->showing_new_source_window = 0;
}

void	new_source_av_file_select_cb(Fl_Widget *w, void *v)
{
int	native_file_chooser(char *prompt, char *filter, char *start_path, char *result);
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *win = (MyWin *)v;
	char buf2[4096];
	strcpy(buf2, "AV File");
	if(win->new_source_window != NULL)
	{
		Fl_Input *alias_in = (Fl_Input *)win->new_source_window->alias;
		char *alias = (char *)alias_in->value();
		if(alias != NULL)
		{
			if(strlen(alias) > 0)
			{
				strcpy(buf2, alias);
			}
		}
	}
	NewSourceWindow *nsw = win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	int no_go = 0;
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			sprintf(buf, "av://%s", text);
			win->SetupCamera(buf, buf2, win->requested_w, win->requested_h, 32);
			no_go = 1;
		}
	}
	if(no_go == 0)
	{
		char filename[4096];
		int nn = native_file_chooser("Select an A/V file", "*.*", "./", filename);
		if(nn > 0)
		{
			sprintf(buf, "av://%s", filename);
			win->SetupCamera(buf, buf2, win->requested_w, win->requested_h, 32);
		}
	}
	win->new_source_window->hide();
	win->pseudo_camera_window->hide();
	win->showing_new_source_window = 0;
}

void	new_source_image_file_select_cb(Fl_Widget *w, void *v)
{
int	native_file_chooser(char *prompt, char *filter, char *start_path, char *result);
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *win = (MyWin *)v;
	char buf2[4096];
	strcpy(buf2, "Image File");
	if(win->new_source_window != NULL)
	{
		Fl_Input *alias_in = (Fl_Input *)win->new_source_window->alias;
		char *alias = (char *)alias_in->value();
		if(alias != NULL)
		{
			if(strlen(alias) > 0)
			{
				strcpy(buf2, alias);
			}
		}
	}
	NewSourceWindow *nsw = win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	int no_go = 0;
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			sprintf(buf, "%s", text);
			win->SetupCamera(buf, buf2, win->requested_w, win->requested_h, 32);
			no_go = 1;
		}
	}
	if(no_go == 0)
	{
		char filename[4096];
		int nn = native_file_chooser("Select an image file", "*.*", "./", filename);
		if(nn > 0)
		{
			sprintf(buf, "%s", filename);
			win->SetupCamera(buf, buf2, win->requested_w, win->requested_h, 32);
		}
	}
	win->new_source_window->hide();
	win->pseudo_camera_window->hide();
	win->showing_new_source_window = 0;
}

void	new_source_html_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncmp(text, "html://", strlen("html://")) == 0)
			{
				ss += strlen("html://");
			}
			sprintf(buf, "html://%s", ss);
			source->value(buf);
			new_source_cb(w, v);
		}
	}
}

void	new_alternating_source_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		strcpy(buf, "alternating://");
		source->value(buf);
		char *use_alias = "Alternating";
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
		new_source_cb(w, v);
	}
}

void	new_all_source_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		strcpy(buf, "all://");
		source->value(buf);
		char *use_alias = "All";
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
		new_source_cb(w, v);
	}
}

void	new_source_html_source_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncmp(text, "html source://", strlen("html source://")) == 0)
			{
				ss += strlen("html source://");
			}
			sprintf(buf, "html source://%s", ss);
			source->value(buf);
			new_source_cb(w, v);
		}
	}
}

void	new_source_pipe_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncmp(text, "pipe://", strlen("pipe://")) == 0)
			{
				ss += strlen("pipe://");
			}
			sprintf(buf, "pipe://%s", ss);
			source->value(buf);
			new_source_cb(w, v);
		}
	}
}

void	new_source_frame_file_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncmp(text, "file://", strlen("file://")) == 0)
			{
				ss += strlen("file://");
			}
			sprintf(buf, "file://%s", ss);
			source->value(buf);
			new_source_cb(w, v);
		}
	}
}

void	new_source_osg_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			char *ss = text;
			if(strncmp(text, "osg://", strlen("osg://")) == 0)
			{
				ss += strlen("osg://");
			}
			sprintf(buf, "osg://%s", ss);
			source->value(buf);
			new_source_cb(w, v);
		}
	}
}

void	new_sourced_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		char use_alias[8192];
		int use_width = 0;
		int use_height = 0;
		char *ss = "";
		if(strlen(text) > 0)
		{
			ss = text;
			if(strncmp(text, "sourced://", strlen("sourced://")) == 0)
			{
				ss += strlen("sourced://");
			}
		}
		if(strlen(ss) < 1)
		{
			Camera *cam = my_win->DisplayedCamera();
			if(cam != NULL)
			{
				if(strlen(cam->alias) > 0)
				{
					ss = cam->alias;
					sprintf(use_alias, "Copy of %s", cam->alias);
				}
				else
				{
					ss = cam->path;
					sprintf(use_alias, "Copy of %s", cam->path);
				}
				use_width = cam->width;
				use_height = cam->height;
			}
		}
		char *width_str = (char *)nsw->width->value();
		if(width_str != NULL)
		{
			double val = atof(width_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_width;
				sprintf(buf, "%d", (int)val);
				nsw->width->value(buf);
			}
		}
		char *height_str = (char *)nsw->height->value();
		if(height_str != NULL)
		{
			double val = atof(height_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_height;
				sprintf(buf, "%d", (int)val);
				nsw->height->value(buf);
			}
		}
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
		sprintf(buf, "sourced://%s", ss);
		source->value(buf);
		new_source_cb(w, v);
	}
}

void	new_edge_detect_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		char use_alias[8192];
		int use_width = 0;
		int use_height = 0;
		char *ss = "";
		if(strlen(text) > 0)
		{
			ss = text;
			if(strncmp(text, "edge://", strlen("edge://")) == 0)
			{
				ss += strlen("edge://");
			}
		}
		if(strlen(ss) < 1)
		{
			Camera *cam = my_win->DisplayedCamera();
			if(cam != NULL)
			{
				if(strlen(cam->alias) > 0)
				{
					ss = cam->alias;
					sprintf(use_alias, "Copy of %s", cam->alias);
				}
				else
				{
					ss = cam->path;
					sprintf(use_alias, "Copy of %s", cam->path);
				}
				use_width = cam->width;
				use_height = cam->height;
			}
		}
		char *width_str = (char *)nsw->width->value();
		if(width_str != NULL)
		{
			double val = atof(width_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_width;
				sprintf(buf, "%d", (int)val);
				nsw->width->value(buf);
			}
		}
		char *height_str = (char *)nsw->height->value();
		if(height_str != NULL)
		{
			double val = atof(height_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_height;
				sprintf(buf, "%d", (int)val);
				nsw->height->value(buf);
			}
		}
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
		sprintf(buf, "edge://%s", ss);
		source->value(buf);
		new_source_cb(w, v);
	}
}

void	new_chromakey_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		char use_alias[8192];
		int use_width = 0;
		int use_height = 0;
		char *ss = "";
		if(strlen(text) > 0)
		{
			ss = text;
			if(strncmp(text, "chroma://", strlen("chroma://")) == 0)
			{
				ss += strlen("chroma://");
			}
		}
		if(strlen(ss) < 1)
		{
			Camera *cam = my_win->DisplayedCamera();
			if(cam != NULL)
			{
				if(strlen(cam->alias) > 0)
				{
					ss = cam->alias;
					sprintf(use_alias, "Copy of %s", cam->alias);
				}
				else
				{
					ss = cam->path;
					sprintf(use_alias, "Copy of %s", cam->path);
				}
				use_width = cam->width;
				use_height = cam->height;
			}
		}
		char *width_str = (char *)nsw->width->value();
		if(width_str != NULL)
		{
			double val = atof(width_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_width;
				sprintf(buf, "%d", (int)val);
				nsw->width->value(buf);
			}
		}
		char *height_str = (char *)nsw->height->value();
		if(height_str != NULL)
		{
			double val = atof(height_str);
			if(val < 1.0)
			{
				char buf[256];
				val = val * (double)use_height;
				sprintf(buf, "%d", (int)val);
				nsw->height->value(buf);
			}
		}
		char *alias = (char *)nsw->alias->value();
		if(alias != NULL)
		{
			if(strlen(alias) < 1)
			{
				nsw->alias->value(use_alias);
			}
		}
		else
		{
			nsw->alias->value(use_alias);
		}
		sprintf(buf, "chroma://%s", ss);
		source->value(buf);
		new_source_cb(w, v);
	}
}

void	new_source_pseudo_camera_select_cb(Fl_Widget *w, void *v)
{
char	buf[8192];

	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	NewSourceWindow *nsw = my_win->new_source_window;
	Fl_Input *source = (Fl_Input *)nsw->source;
	char *text = (char *)source->value();
	if(text != NULL)
	{
		if(strlen(text) > 0)
		{
			sprintf(buf, "pseudo://%s", text);
			source->value(buf);
			new_source_cb(w, v);
		}
	}
}

void	new_source_plugin_camera_select_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	MyWin *my_win = (MyWin *)v;
	my_win->pseudo_camera_window->show();
}

void	new_source_window_select_cb(Fl_Widget *w, void *v)
{
unsigned char	*grab_window_image(Camera *cam, Window window_id, int *im_w, int *im_h, int *im_d);
char			*window_list[128];
int				loop;

	Fl_Button *b = (Fl_Button *)w;
	MyWin *win = (MyWin *)v;
	Window xwin = RootWindow(fl_display, fl_screen);
	int cnt = iterate_windows2(win, fl_display, window_list);
	if(cnt > 0)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		Fl_Window *new_win = new Fl_Window(xx, yy, 200, 800);
		Fl_Scroll *scroll = new Fl_Scroll(0, 0, 200, 800);
		int ay = 4;
		int max_w = -1000;
		fl_font(FL_HELVETICA, 9);
		for(loop = 0;loop < cnt;loop++)
		{
			int mw = 0;
			int mh = 0;
			fl_measure(window_list[loop], mw, mh);
			if(mw > max_w) max_w = mw;
		}
		for(loop = 0;loop < cnt;loop++)
		{
			unsigned long int window_id = (unsigned long int)atol(window_list[loop]);
			char *cp = window_list[loop];
			while((*cp != '\0') && (*cp != ':')) cp++;
			while((*cp != '\0') && (*cp == ':')) cp++;
			
			char *str = strdup(cp);
			cp = str;
			while(*cp != '\0')
			{
				if(*cp == '@')
				{
					*cp = '_';
				}
				cp++;
			}
			int im_w = 0;
			int im_h = 0;
			int im_d = 0;
			unsigned char *image_data = grab_window_image(NULL, window_id, &im_w, &im_h, &im_d);
			if(image_data != NULL)
			{
				Fl_RGB_Image image(image_data, im_w, im_h, im_d);
				if(im_w <= 0) im_w = 1;
				double proportion = (double)max_w / (double)im_w;
				int set_h = (int)((double)im_h * proportion);
				Fl_RGB_Image *n_image = (Fl_RGB_Image *)image.copy(max_w, set_h);

				Fl_Toggle_Button *window_button = new Fl_Toggle_Button(4, ay, n_image->w(), n_image->h());
				window_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
				window_button->box(FL_FLAT_BOX);
				window_button->color(FL_BLACK);
				window_button->down_color(FL_GRAY);
				window_button->type(FL_RADIO_BUTTON);
				window_button->clear_visible_focus();
				window_button->image(n_image);
				window_button->callback(select_window_to_monitor_cb, (void *)window_id);
				ay += n_image->h();
				Fl_Box *window_label = new Fl_Box(4, ay, n_image->w(), 20, str);
				window_label->box(FL_FLAT_BOX);
				window_label->color(FL_BLACK);
				window_label->labelcolor(FL_YELLOW);
				window_label->labelsize(9);
				window_label->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
				ay += 20;
			}
		}
		scroll->end();
		scroll->scrollbar_size(4);
		scroll->box(FL_FLAT_BOX);
		scroll->color(FL_BLACK);
		scroll->type(Fl_Scroll::VERTICAL);
		scroll->hscrollbar.hide();
		new_win->end();
		new_win->border(0);
		new_win->color(FL_BLACK);
		int sz = 800;
		if(ay < 800) sz = ay + 20;
		new_win->resize(new_win->x(), new_win->y(), max_w + 32, sz);
		scroll->resize(0, 0, max_w + 32, 800);
		new_win->color(FL_BLACK);
		new_win->show();
		for(loop = 0;loop < cnt;loop++)
		{
			free(window_list[loop]);
		}
	}
	win->new_source_window->hide();
	win->pseudo_camera_window->hide();
	win->showing_new_source_window = 0;
}

void	MyWin::MakeNewSourceWindow()
{
	NewSourceWindow *nsw = new NewSourceWindow(this, 370, 320);
	new_source_window = nsw;
}

void	MyWin::MakeAliasWindow()
{
	AliasWindow *aw = new AliasWindow(this, 370 * gui_scale_factor, 240 * gui_scale_factor);
	alias_window = aw;
	add(aw);
}

void	alias_cb(Fl_Widget *w, void *v)
{
	AliasWindow *aw = (AliasWindow *)v;
	MyWin *my_win = aw->my_window;
	Camera *cam = my_win->DisplayedCamera();
	if(cam != NULL)
	{
		char *str = (char *)aw->alias->value();
		if(str != NULL)
		{
			strcpy(cam->alias, str);
		}
	}
	aw->hide();
	my_win->showing_alias_window = 0;
}

AliasWindow::AliasWindow(MyWin *in_win, int in_xx, int in_yy) : Fl_Window(in_xx, in_yy, 450, 30)
{
	my_window = in_win;
	double gsf = in_win->gui_scale_factor;
	resize(x(), y(), w() * gsf, h() * gsf);

	box(FL_NO_BOX);
	color(FL_BLACK);
	border(0);

	alias = new Fl_Input(45 * gsf, 1 * gsf, 404 * gsf, 28 * gsf, "Alias:");
	alias->color(FL_BLACK);
	alias->textcolor(FL_WHITE);
	alias->textsize(11 * gsf);
	alias->cursor_color(FL_WHITE);
	alias->labelcolor(FL_YELLOW);
	alias->labelsize(13 * gsf);
	alias->box(FL_FRAME_BOX);
	alias->align(FL_ALIGN_LEFT);
	alias->when(FL_WHEN_ENTER_KEY);
	alias->callback(alias_cb, this);
	end();
	hide();
}

AliasWindow::~AliasWindow()
{
}

int	AliasWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == FL_Escape)
		{
			hide();
			my_window->showing_alias_window = 0;
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	new_source_adj_color_cb(Fl_Widget *w, void *v)
{
	NewSourceWindow *nsw = (NewSourceWindow *)v;
	int rr = (int)nsw->red->value();
	int gg = (int)nsw->green->value();
	int bb = (int)nsw->blue->value();
	nsw->color_box->color(fl_rgb_color(rr, gg, bb));
	nsw->redraw();
}

void	new_source_adj_text_color_cb(Fl_Widget *w, void *v)
{
	NewSourceWindow *nsw = (NewSourceWindow *)v;
	int rr = (int)nsw->text_red->value();
	int gg = (int)nsw->text_green->value();
	int bb = (int)nsw->text_blue->value();
	nsw->text_color_box->color(fl_rgb_color(rr, gg, bb));
	nsw->redraw();
}

NewSourceWindow::NewSourceWindow(MyWin *in_win, int in_xx, int in_yy) : Fl_Window(in_xx, in_yy, 680, 490, "New Source")
{
char	buf[256];
int		loop;

	my_window = in_win;
	edit_mode = 0;

	box(FL_FRAME_BOX);
	color(FL_BLACK);
	border(0);

	source = new Fl_Multiline_Input(20, 20, 560, 140, "Source:");
	source->color(FL_BLACK);
	source->textcolor(FL_WHITE);
	source->textsize(11);
	source->cursor_color(FL_WHITE);
	source->labelcolor(FL_YELLOW);
	source->labelsize(9);
	source->box(FL_FRAME_BOX);
	source->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);

	alias = new Fl_Input(60, 167, 520, 22, "Alias:");
	alias->color(FL_BLACK);
	alias->textcolor(FL_WHITE);
	alias->textsize(11);
	alias->cursor_color(FL_WHITE);
	alias->labelcolor(FL_YELLOW);
	alias->labelsize(9);
	alias->box(FL_FRAME_BOX);
	alias->align(FL_ALIGN_LEFT);

	int cx = 60;
	width = new Fl_Float_Input(cx, 200, 60, 20, "Width:");
	width->color(FL_BLACK);
	width->textcolor(FL_WHITE);
	width->cursor_color(FL_WHITE);
	width->labelcolor(FL_YELLOW);
	width->labelsize(9);
	width->textsize(9);
	width->box(FL_FRAME_BOX);
	width->when(FL_WHEN_ENTER_KEY | FL_WHEN_NOT_CHANGED);
	sprintf(buf, "%d", my_window->requested_w);
	width->value(buf);
	cx += 110;
	height = new Fl_Float_Input(cx, 200, 60, 20, "Height:");
	height->color(FL_BLACK);
	height->textcolor(FL_WHITE);
	height->cursor_color(FL_WHITE);
	height->labelcolor(FL_YELLOW);
	height->labelsize(9);
	height->textsize(9);
	height->box(FL_FRAME_BOX);
	height->when(FL_WHEN_ENTER_KEY | FL_WHEN_NOT_CHANGED);
	sprintf(buf, "%d", my_window->requested_h);
	height->value(buf);
	cx += 120;
	font_sz = new Fl_Int_Input(cx, 200, 60, 20, "Font Size:");
	font_sz->color(FL_BLACK);
	font_sz->textcolor(FL_WHITE);
	font_sz->cursor_color(FL_WHITE);
	font_sz->labelcolor(FL_YELLOW);
	font_sz->labelsize(9);
	font_sz->textsize(9);
	font_sz->box(FL_FRAME_BOX);
	font_sz->when(FL_WHEN_ENTER_KEY | FL_WHEN_NOT_CHANGED);
	sprintf(buf, "%d", 32);
	font_sz->value(buf);
	cx += 160;

	int y_pos = 240;
	red = new ColorSlider(60, y_pos, 300, 18, 0, "Red");
	red->labelcolor(FL_YELLOW);
	red->callback(new_source_adj_color_cb, this);
	y_pos += 20;
	green = new ColorSlider(60, y_pos, 300, 18, 0, "Green");
	green->labelcolor(FL_YELLOW);
	green->callback(new_source_adj_color_cb, this);
	y_pos += 20;
	blue = new ColorSlider(60, y_pos, 300, 18, 0, "Blue");
	blue->labelcolor(FL_YELLOW);
	blue->callback(new_source_adj_color_cb, this);
	y_pos += 20;
	alpha = new ColorSlider(60, y_pos, 300, 18, 0, "Alpha");
	alpha->labelcolor(FL_YELLOW);
	y_pos += 22;

	int start_y = y_pos;
	text_red = new ColorSlider(60, y_pos, 300, 18, 255, "Text Red");
	text_red->labelcolor(FL_YELLOW);
	text_red->callback(new_source_adj_text_color_cb, this);
	y_pos += 20;
	text_green = new ColorSlider(60, y_pos, 300, 18, 255, "Text Green");
	text_green->labelcolor(FL_YELLOW);
	text_green->callback(new_source_adj_text_color_cb, this);
	y_pos += 20;
	text_blue = new ColorSlider(60, y_pos, 300, 18, 255, "Text Blue");
	text_blue->labelcolor(FL_YELLOW);
	text_blue->callback(new_source_adj_text_color_cb, this);
	y_pos += 20;
	text_alpha = new ColorSlider(60, y_pos, 300, 18, 255, "Text Alpha");
	text_alpha->labelcolor(FL_YELLOW);
	y_pos += 20;

	color_box = new Fl_Box(370, 240, 75, 75);
	color_box->box(FL_FRAME_BOX);
	color_box->color(FL_BLACK);

	text_color_box = new Fl_Box(370, start_y, 75, 75);
	text_color_box->box(FL_FRAME_BOX);
	text_color_box->color(FL_WHITE);

	font_browser = new Fl_Hold_Browser(60, y_pos, 385, 70, "Font");
	font_browser->color(FL_BLACK);
	font_browser->box(FL_FRAME_BOX);
	font_browser->textcolor(FL_WHITE);
	font_browser->labelcolor(FL_YELLOW);
	font_browser->labelsize(9);
	font_browser->textsize(9);
	font_browser->selection_color(FL_YELLOW);
	font_browser->scrollbar_size(4);
	font_browser->scrollbar.color(FL_BLACK);
	font_browser->align(FL_ALIGN_LEFT_TOP);
	int nn = my_window->number_of_fonts;
	for(loop = 0;loop < nn;loop++)
	{
		char *str = (char *)Fl::get_font_name(loop);
		font_browser->add(str);
	}
	font_browser->select(1);

	create = new Fl_Button(cx, 200, 60, 20, "Create");
	create->color(DARK_GRAY);
	create->labelcolor(FL_YELLOW);
	create->labelsize(9);
	create->box(FL_FRAME_BOX);
	create->callback(new_source_cb, my_window);
	cx += 70;

	cancel = new Fl_Button(cx, 200, 60, 20, "Cancel");
	cancel->color(DARK_GRAY);
	cancel->labelcolor(FL_YELLOW);
	cancel->labelsize(9);
	cancel->box(FL_FRAME_BOX);
	cancel->callback(cancel_new_source_cb, my_window);
	
	int yp = 20;
	camera_select = new Fl_Button(590, yp, 80, 20, "Camera");
	camera_select->color(DARK_GRAY);
	camera_select->labelcolor(FL_YELLOW);
	camera_select->labelsize(9);
	camera_select->box(FL_FRAME_BOX);
	camera_select->callback(new_source_camera_select_cb, my_window);
	yp += 24;

	audio_select = new Fl_Button(590, yp, 80, 20, "Audio");
	audio_select->color(DARK_GRAY);
	audio_select->labelcolor(FL_YELLOW);
	audio_select->labelsize(9);
	audio_select->box(FL_FRAME_BOX);
	audio_select->callback(new_source_audio_select_cb, my_window);
	yp += 24;

	box_select = new Fl_Button(590, yp, 80, 20, "Box Select");
	box_select->color(DARK_GRAY);
	box_select->labelcolor(FL_YELLOW);
	box_select->labelsize(9);
	box_select->box(FL_FRAME_BOX);
	box_select->callback(new_source_box_select_cb, my_window);
	yp += 24;

	window_select = new Fl_Button(590, yp, 80, 20, "Window Select");
	window_select->color(DARK_GRAY);
	window_select->labelcolor(FL_YELLOW);
	window_select->labelsize(9);
	window_select->box(FL_FRAME_BOX);
	window_select->callback(new_source_window_select_cb, my_window);
	yp += 24;

	desktop_select = new Fl_Button(590, yp, 80, 20, "Desktop Select");
	desktop_select->color(DARK_GRAY);
	desktop_select->labelcolor(FL_YELLOW);
	desktop_select->labelsize(9);
	desktop_select->box(FL_FRAME_BOX);
	desktop_select->callback(new_source_desktop_select_cb, my_window);
	yp += 24;

	image_file_select = new Fl_Button(590, yp, 80, 20, "Image File");
	image_file_select->color(DARK_GRAY);
	image_file_select->labelcolor(FL_YELLOW);
	image_file_select->labelsize(9);
	image_file_select->box(FL_FRAME_BOX);
	image_file_select->callback(new_source_image_file_select_cb, my_window);
	yp += 24;

	av_file_select = new Fl_Button(590, yp, 80, 20, "AV File");
	av_file_select->color(DARK_GRAY);
	av_file_select->labelcolor(FL_YELLOW);
	av_file_select->labelsize(9);
	av_file_select->box(FL_FRAME_BOX);
	av_file_select->callback(new_source_av_file_select_cb, my_window);
	yp += 24;

	html_select = NULL;
	html_source_select = NULL;
	if(global_html == 1)
	{
		html_select = new Fl_Button(590, yp, 80, 20, "HTTP");
		html_select->color(DARK_GRAY);
		html_select->labelcolor(FL_YELLOW);
		html_select->labelsize(9);
		html_select->box(FL_FRAME_BOX);
		html_select->callback(new_source_html_select_cb, my_window);
		yp += 24;

		html_source_select = new Fl_Button(590, yp, 80, 20, "HTML");
		html_source_select->color(DARK_GRAY);
		html_source_select->labelcolor(FL_YELLOW);
		html_source_select->labelsize(9);
		html_source_select->box(FL_FRAME_BOX);
		html_source_select->callback(new_source_html_source_select_cb, my_window);
		yp += 24;
	}
	sourced_select = new Fl_Button(590, yp, 80, 20, "Source Camera");
	sourced_select->color(DARK_GRAY);
	sourced_select->labelcolor(FL_YELLOW);
	sourced_select->labelsize(9);
	sourced_select->box(FL_FRAME_BOX);
	sourced_select->callback(new_sourced_select_cb, my_window);
	yp += 24;
	edge_detect_select = new Fl_Button(590, yp, 80, 20, "Edge Detect");
	edge_detect_select->color(DARK_GRAY);
	edge_detect_select->labelcolor(FL_YELLOW);
	edge_detect_select->labelsize(9);
	edge_detect_select->box(FL_FRAME_BOX);
	edge_detect_select->callback(new_edge_detect_select_cb, my_window);
	yp += 24;
	chromakey_green_select = new Fl_Button(590, yp, 80, 20, "Green Key");
	chromakey_green_select->color(DARK_GRAY);
	chromakey_green_select->labelcolor(FL_YELLOW);
	chromakey_green_select->labelsize(9);
	chromakey_green_select->box(FL_FRAME_BOX);
	chromakey_green_select->callback(new_chromakey_select_cb, my_window);
	yp += 24;
	chromakey_blue_select = new Fl_Button(590, yp, 80, 20, "Blue Key");
	chromakey_blue_select->color(DARK_GRAY);
	chromakey_blue_select->labelcolor(FL_YELLOW);
	chromakey_blue_select->labelsize(9);
	chromakey_blue_select->box(FL_FRAME_BOX);
	chromakey_blue_select->callback(new_chromakey_select_cb, my_window);
	yp += 24;
	alternating_select = new Fl_Button(590, yp, 80, 20, "Alternating");
	alternating_select->color(DARK_GRAY);
	alternating_select->labelcolor(FL_YELLOW);
	alternating_select->labelsize(9);
	alternating_select->box(FL_FRAME_BOX);
	alternating_select->callback(new_alternating_source_select_cb, my_window);
	yp += 24;
	all_select = new Fl_Button(590, yp, 80, 20, "All");
	all_select->color(DARK_GRAY);
	all_select->labelcolor(FL_YELLOW);
	all_select->labelsize(9);
	all_select->box(FL_FRAME_BOX);
	all_select->callback(new_all_source_select_cb, my_window);
	yp += 24;
	pipe_select = new Fl_Button(590, yp, 80, 20, "Pipe");
	pipe_select->color(DARK_GRAY);
	pipe_select->labelcolor(FL_YELLOW);
	pipe_select->labelsize(9);
	pipe_select->box(FL_FRAME_BOX);
	pipe_select->callback(new_source_pipe_select_cb, my_window);
	yp += 24;
	single_frame_file_select = new Fl_Button(590, yp, 80, 20, "Frame File");
	single_frame_file_select->color(DARK_GRAY);
	single_frame_file_select->labelcolor(FL_YELLOW);
	single_frame_file_select->labelsize(9);
	single_frame_file_select->box(FL_FRAME_BOX);
	single_frame_file_select->callback(new_source_frame_file_select_cb, my_window);
	yp += 24;
	osg_select = new Fl_Button(590, yp, 80, 20, "OSG");
	osg_select->color(DARK_GRAY);
	osg_select->labelcolor(FL_YELLOW);
	osg_select->labelsize(9);
	osg_select->box(FL_FRAME_BOX);
	osg_select->callback(new_source_osg_select_cb, my_window);
	yp += 24;

	pseudo_camera_select = NULL;
	if(void_pseudo_camera != NULL)
	{
		pseudo_camera_select = new Fl_Button(590, yp, 80, 20, "Pseudo Camera");
		pseudo_camera_select->color(DARK_GRAY);
		pseudo_camera_select->labelcolor(FL_YELLOW);
		pseudo_camera_select->labelsize(9);
		pseudo_camera_select->box(FL_FRAME_BOX);
		pseudo_camera_select->callback(new_source_pseudo_camera_select_cb, my_window);
		yp += 24;
	}
	plugin_camera_select = NULL;
	if(global_potential_camera_cnt > 0)
	{
		plugin_camera_select = new Fl_Button(590, yp, 80, 20, "Plugin Camera");
		plugin_camera_select->color(DARK_GRAY);
		plugin_camera_select->labelcolor(FL_YELLOW);
		plugin_camera_select->labelsize(9);
		plugin_camera_select->box(FL_FRAME_BOX);
		plugin_camera_select->callback(new_source_plugin_camera_select_cb, my_window);
		yp += 24;
	}
	end();
	hide();
}

NewSourceWindow::~NewSourceWindow()
{
}

void	NewSourceWindow::Show(int e_mode)
{
int	loop;

	edit_mode = e_mode;
	if(edit_mode == 1)
	{
		if(create != NULL) 
		{
			create->label("Accept");
			create->callback(edit_source_cb, my_window);
		}
		if(camera_select != NULL) camera_select->hide();
		if(audio_select != NULL) audio_select->hide();
		if(box_select != NULL) box_select->hide();
		if(window_select != NULL) window_select->hide();
		if(desktop_select != NULL) desktop_select->hide();
		if(av_file_select != NULL) av_file_select->hide();
		if(image_file_select != NULL) image_file_select->hide();
		if(html_select != NULL) html_select->hide();
		if(html_source_select != NULL) html_source_select->hide();
		if(sourced_select != NULL) sourced_select->hide();
		if(edge_detect_select != NULL) edge_detect_select->hide();
		if(chromakey_green_select != NULL) chromakey_green_select->hide();
		if(chromakey_blue_select != NULL) chromakey_blue_select->hide();
		if(alternating_select != NULL) alternating_select->hide();
		if(all_select != NULL) all_select->hide();
		if(pseudo_camera_select != NULL) pseudo_camera_select->hide();
		if(plugin_camera_select != NULL) plugin_camera_select->hide();
		Camera *cam = my_window->DisplayedCamera();
		if(cam != NULL)
		{
			source->value(cam->path);
			alias->value(cam->alias);
			width->value(cam->mat.cols);
			height->value(cam->mat.rows);
			font_sz->value(cam->font_sz);
			if(strlen(cam->font_name) > 0)
			{
				for(loop = 1;loop <= font_browser->size();loop++)
				{
					char *txt = (char *)font_browser->text(loop);
					if(txt != NULL)
					{
						if(strcmp(cam->font_name, txt) == 0)
						{
							font_browser->value(loop);
						}
					}
				}
			}
			red->value(cam->red);
			green->value(cam->green);
			blue->value(cam->blue);
			alpha->value(cam->alpha);
			text_red->value(cam->text_red);
			text_green->value(cam->text_green);
			text_blue->value(cam->text_blue);
			text_alpha->value(cam->text_alpha);
		}
		show();
		resize(x(), y(), 590, h());
	}
	else
	{
		if(create != NULL) 
		{
			create->label("Create");
			create->callback(new_source_cb, my_window);
		}
		if(camera_select != NULL) camera_select->show();
		if(audio_select != NULL) audio_select->show();
		if(box_select != NULL) box_select->show();
		if(window_select != NULL) window_select->show();
		if(desktop_select != NULL) desktop_select->show();
		if(av_file_select != NULL) av_file_select->show();
		if(image_file_select != NULL) image_file_select->show();
		if(html_select != NULL) html_select->show();
		if(html_source_select != NULL) html_source_select->show();
		if(sourced_select != NULL) sourced_select->show();
		if(edge_detect_select != NULL) edge_detect_select->show();
		if(chromakey_green_select != NULL) chromakey_green_select->show();
		if(chromakey_blue_select != NULL) chromakey_blue_select->show();
		if(alternating_select != NULL) alternating_select->show();
		if(all_select != NULL) all_select->show();
		if(pseudo_camera_select != NULL) pseudo_camera_select->show();
		if(plugin_camera_select != NULL) plugin_camera_select->show();
		show();
		resize(x(), y(), 690, h());
	}
}

int	NewSourceWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == FL_Escape)
		{
			hide();
			my_window->showing_new_source_window = 0;
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	new_source_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->new_source_window->visible())
	{
		win->showing_new_source_window = 1;
		win->new_source_window->set_modal();
		win->new_source_window->Show(0);
		win->new_source_window->take_focus();
	}
	else
	{
		win->showing_new_source_window = 0;
		win->new_source_window->hide();
	}
}

void	edit_source_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->new_source_window->visible())
	{
		win->showing_new_source_window = 1;
		win->new_source_window->set_modal();
		win->new_source_window->Show(1);
		win->new_source_window->take_focus();
	}
	else
	{
		win->showing_new_source_window = 0;
		win->new_source_window->hide();
	}
}

void	alias_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->alias_window->visible())
	{
		win->showing_alias_window = 1;
		win->alias_window->show();
		win->alias_window->take_focus();
		win->alias_window->set_non_modal();
	}
	else
	{
		win->showing_alias_window = 0;
		win->alias_window->hide();
	}
}

void	settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->settings_window->visible())
	{
		win->settings_window->Update();
		win->settings_window->set_non_modal();
		win->settings_window->show();
		win->settings_window->take_focus();
	}
	else
	{
		win->settings_window->hide();
	}
}

void	snapshot_settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->snapshot_settings_window->visible())
	{
		win->snapshot_settings_window->Update();
		win->snapshot_settings_window->set_non_modal();
		win->snapshot_settings_window->show();
		win->snapshot_settings_window->take_focus();
	}
	else
	{
		win->snapshot_settings_window->hide();
	}
}

void	keyboard_settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->command_key_settings->visible())
	{
		win->command_key_settings->show();
		win->command_key_settings->take_focus();
		win->command_key_settings->set_non_modal();
	}
	else
	{
		win->command_key_settings->hide();
	}
}

void	gui_settings_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->gui_settings_window->visible())
	{
		win->gui_settings_window->show();
		win->gui_settings_window->take_focus();
		win->gui_settings_window->set_non_modal();
	}
	else
	{
		win->gui_settings_window->hide();
	}
}

void	transitions_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->transitions_window->visible())
	{
		win->transitions_window->Update();
		win->transitions_window->set_non_modal();
		win->transitions_window->show();
		win->transitions_window->take_focus();
	}
	else
	{
		win->transitions_window->hide();
	}
}

void	filter_built_in_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->filter_built_in_window->visible())
	{
		win->filter_built_in_window->set_non_modal();
		win->filter_built_in_window->show();
		win->filter_built_in_window->take_focus();
	}
	else
	{
		win->filter_built_in_window->hide();
	}
}

void	filter_plugins_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->filter_plugins_window->visible())
	{
		win->filter_plugins_window->set_non_modal();
		win->filter_plugins_window->show();
		win->filter_plugins_window->take_focus();
	}
	else
	{
		win->filter_plugins_window->hide();
	}
}

void	audio_filter_plugins_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->audio_filter_plugins_window->visible())
	{
		win->audio_filter_plugins_window->set_non_modal();
		win->audio_filter_plugins_window->show();
		win->audio_filter_plugins_window->take_focus();
	}
	else
	{
		win->audio_filter_plugins_window->hide();
	}
}

void	external_pgm_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->embed_app_settings->visible())
	{
		win->embed_app_settings->set_non_modal();
		win->embed_app_settings->show();
	}
	else
	{
		win->embed_app_settings->hide();
	}
}

void	fltk_plugin_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->fltk_plugin_window->visible())
	{
		win->fltk_plugin_window->Reset();
		win->fltk_plugin_window->set_non_modal();
		win->fltk_plugin_window->show();
	}
	else
	{
		win->fltk_plugin_window->hide();
	}
}

void	immediate_drawing_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->immediate_drawing_window->visible())
	{
		win->immediate_drawing_window->set_non_modal();
		win->immediate_drawing_window->show();
		win->immediate_drawing_window->take_focus();
	}
	else
	{
		win->immediate_drawing_window->hide();
	}
}

void	dynamic_coloring_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(!win->color_it_window->visible())
	{
		win->color_it_window->set_non_modal();
		win->color_it_window->show();
	}
	else
	{
		win->color_it_window->hide();
	}
}

void	save_camera_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(access("./Cameras", 0) != 0)
		{
			mkdir("./Cameras", 0755);
		}
		chdir("./Cameras");
		Fl_Native_File_Chooser nfc;
		nfc.title("Select a camera file");
		nfc.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
		nfc.filter("*.camera");
		nfc.directory("./Cameras/sample.camera");
		int nn = nfc.show();
		if((nn != -1) && (nn != 1))
		{
			char *fn = (char *)nfc.filename();
			cam->Save(fn);
		}
		chdir("..");
	}
}

void	load_camera_button_cb(Fl_Widget *w, void *v)
{
int	native_file_chooser(char *prompt, char *filter, char *start_path, char *result);

	MyWin *win = (MyWin *)v;
	char filename[4096];
	int nn = native_file_chooser("Select a camera file", "*.camera", "./Cameras/*", filename);
	if(nn > 0)
	{
		win->LoadCamera(filename);
	}
}

int	native_file_chooser(char *prompt, char *filter, char *start_path, char *result)
{
	char *fn = NULL;
	int r = 0;
	Fl_Native_File_Chooser nfc;
	nfc.title(prompt);
	nfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
	nfc.filter(filter);
	nfc.directory(start_path);
	int nn = nfc.show();
	if((nn != -1) && (nn != 1))
	{
		fn = (char *)nfc.filename();
		if(fn != NULL)
		{
			strcpy(result, fn);
			r = strlen(fn);
		}
	}
	return(r);
}

void	monitor_audio_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->pulse_mixer->monitor == 1)
	{
		win->pulse_mixer->monitor = 0;
		win->monitor_audio_button->label("Monitor Audio");
	}
	else
	{
		win->pulse_mixer->monitor = 1;
		win->monitor_audio_button->label("Monitor Audio Off");
	}
}

void	audio_mute_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->mute_audio == 1)
	{
		win->mute_audio = 0;
		if(win->muxing == 1)
		{
			for(loop = 0;loop < 128;loop++)
			{
				if(win->my_muxer[loop] != NULL)
				{
					win->my_muxer[loop]->mute = 0;
				}
			}
		}
		if(win->pulse_mixer != NULL)
		{
			win->pulse_mixer->Mute();
		}
		win->audio_mute_button->label("Mute Audio");
	}
	else
	{
		win->mute_audio = 1;
		if(win->muxing == 1)
		{
			for(loop = 0;loop < 128;loop++)
			{
				if(win->my_muxer[loop] != NULL)
				{
					win->my_muxer[loop]->mute = 1;
				}
			}
		}
		if(win->pulse_mixer != NULL)
		{
			win->pulse_mixer->Unmute();
		}
		win->audio_mute_button->label("Unmute Audio");
	}
}

void	toggle_objects_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->object_box->visible())
	{
		win->HideObjects();
		w->label("Select Objects");
	}
	else
	{
		win->ShowObjects();
		w->label("Done Selecting Objects");
	}
}

void	flip_horizontal_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->flip_horizontal == 0)
		{
			cam->flip_horizontal = 1;
			win->flip_horizontal_button->label("Restore Horizontal");
		}
		else
		{
			cam->flip_horizontal = 0;
			win->flip_horizontal_button->label("Flip Horizontal");
		}
	}
}

void	flip_vertical_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->flip_vertical == 0)
		{
			cam->flip_vertical = 1;
			win->flip_vertical_button->label("Restore Vertical");
		}
		else
		{
			cam->flip_vertical = 0;
			win->flip_vertical_button->label("Flip Vertical");
		}
	}
}

void	save_interest_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->SaveInterest();
}

void	load_interest_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->LoadInterest();
}

void	resize_detail_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	win->resizing_detail = 1;
	win->drag_start_x = -1;
	win->drag_start_y = -1;
}

void	zoom_box_button_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->zoom_box_display == 0)
		{
			win->zoom_boxing = 1;
			win->drag_start_x = -1;
			win->drag_start_y = -1;
		}
		else
		{
			cam->zoom_box_display = 0;
		}
	}
}

void	thumbnail_cb(Fl_Widget *w, void *v)
{
void	ptz_select_interface_cb(Fl_Widget *w, void *v);
int	loop;
int	inner;

	MyWin *win = (MyWin *)v;
	for(loop = 0;loop < 128;loop++)
	{
		if((w == win->thumbnail[loop]->thumb_button)
		|| (w == win->trigger_window->thumbnail[loop]))
		{
			ThumbButton *tb = (ThumbButton *)w;
			if(win->trigger_select_mode == 0)
			{
				if((win->single_stream == 1) || (win->muxing == 1))
				{
					if(win->displayed_source > -1)
					{
						win->last_cam = win->camera[win->displayed_source];
					}
				}
				win->Display(loop);
				Camera *cam = win->camera[win->displayed_source];
				if((win->single_stream == 1) || (win->muxing == 1))
				{
					if(cam != NULL)
					{
						cam->total_frames[win->stream] = win->last_cam->total_frames[win->stream];
					}
				}
				if(win->ptz_mode == 1)
				{
					for(inner = 0;inner < win->ptz_device_cnt;inner++)
					{
						if(win->ptz_lock_alias[inner] != NULL)
						{
							if(strcmp(cam->alias, win->ptz_lock_alias[inner]) == 0)
							{
								Fl_Widget *wid = win->ptz_interface_select_button[inner];
								if(wid != NULL)
								{
									ptz_select_interface_cb(wid, win);
								}
							}
						}
					}
				}
			}
			else
			{
				if(loop != win->displayed_source)
				{
					Camera *cam = win->camera[win->displayed_source];
					if(cam != NULL)
					{
						int bad = 0;
						for(inner = 0;inner < cam->trigger_cnt;inner++)
						{
							if(cam->trigger[inner] == loop)
							{
								bad = 1;
							}
						}
						if(bad == 0)
						{
							cam->trigger[cam->trigger_cnt] = loop;
							cam->trigger_cnt++;
						}
					}
				}
			}
		}
	}
}

void	MyWin::HideButtons()
{
	record_button->hide();
	load_setup_button->hide();
	save_setup_button->hide();
	motion_button->hide();
	object_button->hide();
	encode_button->hide();
	if(main_detail_button != NULL)
	{
		main_detail_button->hide();
	}
	show_debug_button->hide();
	review_button->hide();
	reset_button->hide();
	review_muxed_button->hide();
	set_interest_button->hide();
	clear_interest_button->hide();
	save_interest_button->hide();
	load_interest_button->hide();
	if(resize_detail_button != NULL)
	{
		resize_detail_button->hide();
	}
	zoom_box_button->hide();
	split_button->hide();
	open_standalone_button->hide();
	new_source_button->hide();
	edit_source_button->hide();
	set_output_button->hide();
	select_output_button->hide();
	alias_button->hide();
	settings_button->hide();
	snapshot_settings_button->hide();
	transitions_button->hide();
	if(filter_plugins_button != NULL)
	{
		filter_plugins_button->hide();
	}
	if(external_pgm_button != NULL)
	{
		external_pgm_button->hide();
	}
	if(fltk_plugin_button != NULL)
	{
		fltk_plugin_button->hide();
	}
	immediate_drawing_button->hide();
	dynamic_coloring_button->hide();
	save_camera_button->hide();
	load_camera_button->hide();
	codecs_button->hide();
	flip_horizontal_button->hide();
	flip_vertical_button->hide();
	if(detail != NULL)
	{
		follow_button->hide();
		follow_objects_button->hide();
	}
	timestamp_button->hide();
	motion_button->hide();
	object_button->hide();
	snapshot_button->hide();
	if(jpeg_streaming_button != NULL)
	{
		jpeg_streaming_button->hide();
	}
	reset_button->hide();
	reset_cameras_button->hide();
	resize_capture_button->hide();
	show_motion_debug_button->hide();
	quit_button->hide();
	power_button->hide();
	freeze_button->hide();
	mute_video_button->hide();
	trigger_button->hide();
	dump_button->hide();
	audio_mute_button->hide();
	monitor_audio_button->hide();
	if(audio_filter_plugins_button != NULL)
	{
		audio_filter_plugins_button->hide();
	}
	toggle_objects_button->hide();
}

void	MyWin::ShowButtons()
{
	if(mark_interest == 0)
	{
		Camera *cam = DisplayedCamera();
		if(cam != NULL)
		{
			if(cam->power == 1)
			{
				if(cam->record == 1)
				{
					record_button->label("Stop");
					encode_speed_window->show();
					if(audio == 1)
					{
						audio_mute_button->show();
						monitor_audio_button->show();
					}
				}
				else
				{
					record_button->label("Record");
					encode_speed_window->hide();
					if(audio == 1)
					{
						audio_mute_button->hide();
						monitor_audio_button->hide();
					}
				}
			}
			if(audio_filter_plugins_button != NULL)
			{
				audio_filter_plugins_button->show();
			}
			if(cam->power == 1)
			{
				if(cam->object_detect == 1)
				{
					object_button->label("Stop Detecting Objects");
				}
				else
				{
					object_button->label("Detect Objects");
				}
				if(cam->motion_detect == 1)
				{
					motion_button->label("Stop Detecting Motion");
				}
				else
				{
					motion_button->label("Detect Motion");
				}
				if((follow_button != NULL) && (follow_objects_button != NULL))
				{
					if(cam->follow_motion == 1)
					{
						follow_button->label("Stop Following Motion");
					}
					else
					{
						follow_button->label("Follow Motion");
					}
					if(cam->follow_objects == 1)
					{
						follow_objects_button->label("Stop Following Objects");
					}
					else
					{
						follow_objects_button->label("Follow Objects");
					}
				}
			}
			if(use_old == 0)
			{
				if(cam->power == 1)
				{
					record_button->show();
					motion_button->show();
					if(init_detect == 1)
					{
						object_button->show();
					}
				}
			}
			load_setup_button->show();
			save_setup_button->show();
			if(encoding == 0)
			{
				if(direct_recording == 0)
				{
					if((muxing == 0) || (stream_only == 0))
					{
						encode_button->show();
					}
				}
			}
			if(main_detail_button != NULL)
			{
				main_detail_button->show();
			}
			show_debug_button->show();
			if(review == NULL)
			{
				review_button->show();
			}
			else
			{
				review_button->hide();
			}
			if(last_muxed_list[0] != NULL)
			{
				review_muxed_button->show();
			}
			if(interest_cnt > 0)
			{
				clear_interest_button->show();
				save_interest_button->show();
			}
			load_interest_button->show();
			if(resize_detail_button != NULL)
			{
				if((cam->record == 0) && (cam->motion_detect == 0) && (cam->object_detect == 0))
				{
					resize_detail_button->show();
				}
				else
				{
					resize_detail_button->hide();
				}
			}
			if(ptz_mode == 0)
			{
				if(cam->zoom_box_display == 1)
				{
					zoom_box_button->label("Cease Box Zoom");
				}
				else
				{
					zoom_box_button->label("Box Zoom");
				}
				zoom_box_button->show();
			}
			if(source_cnt > 1)
			{
				split_button->show();
				open_standalone_button->show();
			}
			if(showing_new_source_window == 0)
			{
				new_source_button->show();
			}
			if(showing_new_source_window == 0)
			{
				edit_source_button->show();
			}
			if(recording == 0)
			{
				set_output_button->show();
				select_output_button->show();
			}
			else
			{
				set_output_button->hide();
				select_output_button->hide();
			}
			if(showing_alias_window == 0)
			{
				alias_button->show();
			}
			if(cam->power == 1)
			{
				flip_horizontal_button->show();
				flip_vertical_button->show();
				settings_button->show();
				snapshot_settings_button->show();
				transitions_button->show();
			}
			if(global_potential_filter_cnt > 0)
			{
				filter_plugins_button->show();
			}
			if(external_pgm_button != NULL)
			{
				external_pgm_button->show();
			}
			if(fltk_plugin_button != NULL)
			{
				fltk_plugin_button->show();
			}
			if(cam->power == 1)
			{
				immediate_drawing_button->show();
				dynamic_coloring_button->show();
			}
			save_camera_button->show();
			load_camera_button->show();
			if(global_my_format_cnt > 0)
			{
				codecs_button->show();
			}
			if(detail != NULL)
			{
				if(use_old == 0)
				{
					if(cam->power == 1)
					{
						follow_button->show();
						follow_objects_button->show();
					}
				}
			}
			timestamp_button->show();
			if(use_old == 0)
			{
				if(cam->power == 1)
				{
					motion_button->show();
					if(init_detect == 1)
					{
						object_button->show();
					}
				}
			}
			if(cam->power == 1)
			{
				snapshot_button->show();
			}
			if(jpeg_streaming != NULL)
			{
				jpeg_streaming_button->show();
			}
			reset_button->show();
			reset_cameras_button->show();
			resize_capture_button->show();
			show_motion_debug_button->show();
			quit_button->show();
			if(cam->power == 1)
			{
				power_button->label("Turn Off");
			}
			else
			{
				power_button->label("Turn On");
			}
			power_button->show();
			if(cam->power == 1)
			{
				if(cam->mute_video == 1)
				{
					mute_video_button->label("Unmute Video");
				}
				else
				{
					mute_video_button->label("Mute Video");
				}
				mute_video_button->show();
				if(cam->freeze_video == 1)
				{
					freeze_button->label("Defrost");
				}
				else
				{
					freeze_button->label("Freeze");
				}
				freeze_button->show();
			}
			load_setup_button->show();
			save_setup_button->show();
			if(cam->power == 1)
			{
				trigger_button->show();
			}
			if(muxing == 0)
			{
				dump_button->show();
			}
			audio_mute_button->show();
			monitor_audio_button->show();
			toggle_objects_button->show();
			set_interest_button->show();
			if(audio_filter_plugins_button != NULL)
			{
				audio_filter_plugins_button->show();
			}
		}
		else
		{
			if(record_button != NULL)
				record_button->hide();
			if(audio_mute_button != NULL)
				audio_mute_button->hide();
			if(monitor_audio_button != NULL)
				monitor_audio_button->hide();
			if(audio_filter_plugins_button != NULL)
				audio_filter_plugins_button->hide();
			if(object_button != NULL)
				object_button->hide();
			if(motion_button != NULL)
				motion_button->hide();
			if(follow_button != NULL)
				follow_button->hide();
 			if(follow_objects_button != NULL)
 				follow_objects_button->hide();
			if(encode_button != NULL)
				encode_button->hide();
			if(main_detail_button != NULL)
				main_detail_button->hide();
			if(show_debug_button != NULL)
				show_debug_button->hide();
			if(review_button != NULL)
				review_button->hide();
			if(reset_button != NULL)
				reset_button->hide();
			if(review_muxed_button != NULL)
				review_muxed_button->hide();
			if(clear_interest_button != NULL)
				clear_interest_button->hide();
			if(save_interest_button != NULL)
				save_interest_button->hide();
			if(load_interest_button != NULL)
				load_interest_button->hide();
			if(resize_detail_button != NULL)
				resize_detail_button->hide();
			if(zoom_box_button != NULL)
				zoom_box_button->hide();
			if(split_button != NULL)
				split_button->hide();
			if(open_standalone_button != NULL)
				open_standalone_button->hide();
			if(showing_new_source_window == 0)
			{
				if(new_source_button != NULL)
				{
					new_source_button->show();
				}
			}
			if(showing_new_source_window == 0)
			{
				if(edit_source_button != NULL)
				{
					edit_source_button->show();
				}
			}
			if(set_output_button != NULL)
				set_output_button->hide();
			if(select_output_button != NULL)
				select_output_button->hide();
			if(alias_button != NULL)
				alias_button->hide();
			if(flip_horizontal_button != NULL)
				flip_horizontal_button->hide();
			if(flip_vertical_button != NULL)
				flip_vertical_button->hide();
			if(settings_button != NULL)
				settings_button->hide();
			if(snapshot_settings_button != NULL)
				snapshot_settings_button->hide();
			if(transitions_button != NULL)
				transitions_button->hide();
			if(filter_plugins_button != NULL)
				filter_plugins_button->hide();
			if(external_pgm_button != NULL)
				external_pgm_button->hide();
			if(fltk_plugin_button != NULL)
				fltk_plugin_button->hide();
			if(immediate_drawing_button != NULL)
				immediate_drawing_button->hide();
			if(dynamic_coloring_button != NULL)
				dynamic_coloring_button->hide();
			if(save_camera_button != NULL)
				save_camera_button->hide();
			if(load_camera_button != NULL)
				load_camera_button->hide();
			if(codecs_button != NULL)
				codecs_button->hide();
			if(timestamp_button != NULL)
				timestamp_button->hide();
			if(snapshot_button != NULL)
				snapshot_button->hide();
			if(jpeg_streaming_button != NULL)
				jpeg_streaming_button->hide();
			if(reset_button != NULL)
				reset_button->hide();
			if(reset_cameras_button != NULL)
				reset_cameras_button->hide();
			if(resize_capture_button != NULL)
				resize_capture_button->hide();
			if(show_motion_debug_button != NULL)
				show_motion_debug_button->hide();
			if(quit_button != NULL)
				quit_button->show();
			if(power_button != NULL)
				power_button->hide();
			if(mute_video_button != NULL)
				mute_video_button->hide();
			if(freeze_button != NULL)
				freeze_button->hide();
			if(hide_video_button != NULL)
				hide_video_button->hide();
			if(load_setup_button != NULL)
				load_setup_button->show();
			if(save_setup_button != NULL)
				save_setup_button->hide();
			if(trigger_button != NULL)
				trigger_button->hide();
			if(dump_button != NULL)
				dump_button->hide();
			if(toggle_objects_button != NULL)
				toggle_objects_button->hide();
			if(set_interest_button != NULL)
				set_interest_button->hide();
		}
	}
	button_group->redraw();
	redraw();
}

void	select_objects_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			char *label = (char *)w->label();
			if(label != NULL)
			{
				for(loop = 0;loop < win->recognize_class_cnt;loop++)
				{
					if(strcmp(label, win->recognize_class_name[loop]) == 0)
					{
						if(cam->object_index[loop] == 0)
						{
							cam->object_index[loop] = 1;
							w->labelcolor(FL_WHITE);
						}
						else
						{
							cam->object_index[loop] = 0;
							w->labelcolor(FL_YELLOW);
						}
					}
				}
			}
			win->redraw();
		}
	}
}

void	clear_select_objects_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			for(loop = 0;loop < win->recognize_class_cnt;loop++)
			{
				cam->object_index[loop] = 0;
			}
			win->redraw();
			win->ShowObjects();
		}
	}
}

void	select_all_objects_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			for(loop = 0;loop < win->recognize_class_cnt;loop++)
			{
				cam->object_index[loop] = 1;
			}
			win->redraw();
			win->ShowObjects();
		}
	}
}

void	done_select_objects_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->HideObjects();
		win->toggle_objects_button->label("Select Objects");
	}
}

void	next_page_objects_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->object_page++;
		win->redraw();
		win->ShowObjects();
	}
}

void	prev_page_objects_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		if(win->object_page > 0)
		{
			win->object_page--;
		}
		win->redraw();
		win->ShowObjects();
	}
}

void	pulse_audio_select_cb(Fl_Widget *w, void *v)
{
	PulseAudioButton *b = (PulseAudioButton *)v;
	MyWin *win = b->my_window;
	if(b->button->value())
	{
		if(b->microphone != NULL)
		{
			win->pulse_mixer->recording = 1;
			b->microphone->stop = 0;
			b->microphone->Record();
		}
	}
	else
	{
		if(b->microphone != NULL)
		{
			b->microphone->Stop();
		}
	}
	b->redraw();
}

PulseMixer::PulseMixer(MyWin *in_win, int sz)
{
	my_window = in_win;
	buffer = (SAMPLE *)malloc(sz * sizeof(SAMPLE));
	memset(buffer, 0, sz * sizeof(SAMPLE));
	preserve = (SAMPLE *)malloc(sz * sizeof(SAMPLE));
	memset(preserve, 0, sz * sizeof(SAMPLE));
	size = sz;
	mix_ready = 0;
	recording = 0;
	first = 1;
	done = 0;
	mute = 0;
	out_fd = -1;
	continued = 0;

	monitor = 0;

	play_buffer = (SAMPLE *)malloc(1024 * sizeof(SAMPLE));
	pa_monitor = new PulseAudio(NULL, MODE_PLAY, 1024, 44100, 1, play_buffer);
	pa_monitor->sample_ready_cb = NULL;
	pa_monitor->Play();
	pa_monitor->Pause();
}

PulseMixer::~PulseMixer()
{
	done = 1;
	if(pa_monitor != NULL)
	{
		pa_monitor->Pause();
		pa_monitor->Stop();
		usleep(100000);
		delete pa_monitor;
	}
	if(buffer != NULL)
	{
		free(buffer);
	}
	if(preserve != NULL)
	{
		free(preserve);
	}
}

void	PulseMixer::Mix(PulseMicrophone *mic)
{
int	loop;

	if(mute == 0)
	{
		if(first == 1)
		{
			for(loop = 0;loop < size;loop++)
			{
				int n1 = (int)mic->buffer[loop];
				int nn = (int)((double)n1 * mic->volume);
				buffer[loop] = (SAMPLE)nn;
			}
		}
		else
		{
			for(loop = 0;loop < size;loop++)
			{
				int n1 = (int)buffer[loop];
				int n2 = (int)mic->buffer[loop];
				int n3 = (int)((double)n2 * mic->volume);
				int nn = (n1 + n3) / 2;
				buffer[loop] = (SAMPLE)nn;
			}
		}
	}
	else
	{
		memset(buffer, 0, mic->buffer_size);
	}
}

void	PulseMixer::Mute()
{
	mute = 1;
}

void	PulseMixer::Unmute()
{
	mute = 0;
}

void	PulseMixer::Stop()
{
	recording = 0;
}

void	PulseMixer::Resume()
{
	recording = 1;
}

void pulse_grab_sample(PulseAudio *pa)
{
int	loop;

	PulseMicrophone *pm = (PulseMicrophone *)pa;
	MyWin *win = pm->my_window;
	if(pm->stop == 0)
	{
		if(pm->my_window->pulse_mixer->recording == 1)
		{
			for(loop = 0;loop < pm->filter_plugin_cnt;loop++)
			{
				void (*filter_audio)(int, int, int, int, int, double, void *);
				filter_audio = (void (*)(int, int, int, int, int, double, void *))pm->filter_plugin[loop];
				if(filter_audio != NULL)
				{
					filter_audio(pm->number_of_samples, pm->number_of_channels, pm->sample_count, pm->hz, pm->buffer_size, pm->volume, (void *)pm->buffer);
				}
			}
			pm->my_window->pulse_mixer->Mix(pm);
		}
	}
}

PulseMicrophone::PulseMicrophone(MyWin *in_win, char *dev_name) : PulseAudio(dev_name, MODE_RECORD, FRAMES_PER_BUFFER, 44100, 1, NULL)
{
int	loop;

	my_window = in_win;
	int sz = FRAMES_PER_BUFFER * sizeof(SAMPLE);
	buffer = (SAMPLE *)malloc(sz);
	sample_ready_cb = pulse_grab_sample;
	strcpy(name, dev_name);
	filter_plugin_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		filter_plugin[loop] = NULL;
	}
}

PulseMicrophone::~PulseMicrophone()
{
	if(buffer != NULL)
	{
		free(buffer);
		buffer = NULL;
	}
}

int	pulse_play_all(int *flag)
{
int	pulse_play(int *flag);

	MyWin *in_win = (MyWin *)flag;
	if(in_win->pulse_mixer != NULL)
	{
		if(in_win->pulse_mixer->pa_monitor != NULL)
		{
			pulse_play((int *)in_win->pulse_mixer->pa_monitor);
		}
	}
	return(0);
}

int	MyWin::CountActiveMics()
{
int	loop;

	int cnt = 0;
	for(loop = 0;loop < pulse_microphone_cnt;loop++)
	{
		if(pulse_microphone[loop] != NULL)
		{
			if(pulse_microphone[loop]->failure == 0)
			{
				if(pulse_microphone[loop]->stop == 0)
				{
					cnt++;
				}
			}
		}
	}
	return(cnt);
}

int	 pulse_record_all(int *flag)
{
int		simple_record(int *flag);
void	read_pulse_mic(PulseAudio *pa, int any_recording);
int		loop;

	time_t start = 0;
	double accum = 0;
	double adjust = 0.01575;
	MyWin *my_window = (MyWin *)flag;
	while(my_window->pulse_mixer->done == 0)
	{
		int cnt = 0;
		int any_recording = 0;
		if(my_window->pulse_mixer->recording == 1)
		{
			if(start == 0)
			{
				start = time(0);
			}
			double elapsed = (double)(time(0) - start);
			accum += (double)((double)FRAMES_PER_BUFFER / 44100.0);
			if(accum > elapsed)
			{
				adjust += 0.0001;
			}
			else
			{
				adjust -= 0.0001;
			}
			any_recording = 1;
			PulseMixer *mix = my_window->pulse_mixer;
			mix->mix_ready = 0;
			mix->first = 1;
			memset(mix->buffer, 0, mix->size * sizeof(SAMPLE));
			for(loop = 0;loop < my_window->pulse_microphone_cnt;loop++)
			{
				if(my_window->pulse_microphone[loop] != NULL)
				{
					if(mix->done == 0)
					{
						if(my_window->pulse_microphone[loop]->failure == 0)
						{
							read_pulse_mic(my_window->pulse_microphone[loop], any_recording);
							mix->first = 0;
							if(my_window->pulse_microphone[loop]->stop == 0)
							{
								cnt++;
							}
						}
					}
				}
			}
			if(cnt > 0)
			{
				memcpy(mix->preserve, mix->buffer, mix->size * sizeof(SAMPLE));
			}
			else
			{
				int nn = (int)(1000000.0 * adjust);
				if(nn > 0)
				{
					usleep(nn);
				}
			}
			mix->mix_ready = 1;
			if(mix->monitor == 1)
			{
				if(mix->pa_monitor != NULL)
				{
					PulseAudio *pa = mix->pa_monitor;
					int error = 0;
					int n = pa_simple_write(pa->stream, mix->buffer, pa->buffer_size, &error);
				}
			}
			if(my_window->muxing == 1)
			{
				for(loop = 0;loop < 128;loop++)
				{
					if(my_window->my_muxer[loop] != NULL)
					{
						if(my_window->my_muxer[loop]->recording == 1)
						{
							simple_record((int *)my_window->my_muxer[loop]);
							my_window->recorded_frames = my_window->my_muxer[loop]->current_frame;
						}
					}
				}
				if(cnt == 0)
				{
					int local = 0;
					for(loop = 0;loop < 128;loop++)
					{
						if(my_window->my_muxer[loop] != NULL)
						{
							while((my_window->pulse_mixer->done == 0) && (my_window->my_muxer[loop]->fresh_image == 0) && (local < 100))
							{
								usleep(1000);
								local++;
							}
						}
					}
				}
			}
			else
			{
				if(mix->out_fd == -1)
				{
					int flags = O_WRONLY | O_CREAT | O_TRUNC;
					if((access("audio.bin", 0) == 0) && (mix->continued == 1))
					{
						flags = O_WRONLY | O_APPEND;
					}
					mix->out_fd = open("audio.bin", flags, 0666);
					if(mix->out_fd > -1)
					{
						if(mix->continued == 0)
						{
							int hz = 44100;
							int channels = 1;
							write(mix->out_fd, &channels, sizeof(int));
							write(mix->out_fd, &hz, sizeof(int));
						}
					}
				}
				if(mix->out_fd > -1)
				{
					write(mix->out_fd, mix->buffer, mix->size * sizeof(SAMPLE));
				}
			}
		}
		else
		{
			if(my_window->pulse_mixer->out_fd > -1)
			{
				close(my_window->pulse_mixer->out_fd);
				my_window->pulse_mixer->out_fd = -1;
				my_window->pulse_mixer->continued = 1;
			}
			if(my_window->pulse_mixer != NULL)
			{
				if(my_window->pulse_mixer->done == 0)
				{
					for(loop = 0;loop < my_window->pulse_microphone_cnt;loop++)
					{
						if(my_window->pulse_microphone[loop] != NULL)
						{
							if(my_window->pulse_microphone[loop]->failure == 0)
							{
								read_pulse_mic(my_window->pulse_microphone[loop], any_recording);
							}
						}
					}
				}
			}
			usleep(10000);
		}
	}
	my_window->pulse_mixer->done = -1;
	return(0);
}

void	pulse_volume_cb(Fl_Widget *w, void *v)
{
	PulseAudioButton *pab = (PulseAudioButton *)v;
	pab->microphone->volume = pab->volume->value();
}

void	update_audio_button_cb(void *v)
{
	PulseAudioButton *b = (PulseAudioButton *)v;
	b->redraw();
}

void	pulse_audio_button_repeat_cb(Fl_Widget *w, void *v)
{
	PulseAudioButton *b = (PulseAudioButton *)v;
	Fl_Toggle_Button *button = (Fl_Toggle_Button *)w;
	if(b != NULL)
	{
		int nn = button->value();
		if(b->microphone != NULL)
		{
			b->microphone->repeating = nn;
		}
	}
}

void	pulse_audio_button_delete_cb(Fl_Widget *w, void *v)
{
int	loop;
int	inner;

	PulseAudioButton *b = (PulseAudioButton *)v;
	int done = 0;
	for(loop = 0;((loop < b->my_window->audio_thumbnail_cnt) && (done == 0));loop++)
	{
		if(b->my_window->audio_thumbnail[loop] == b)
		{
			for(inner = 0;inner < 3;inner++)
			{
				Fl_Pack *pack = b->my_window->audio_thumbnail_pack[inner];
				pack->remove(b);
			}
			b->my_window->audio_thumbnail[loop] = NULL;
			b->my_window->CompressAudioThumbnailList();
			for(inner = 0;inner < 2;inner++)
			{
				Fl_Pack *pack1 = b->my_window->audio_thumbnail_pack[inner];
				Fl_Pack *pack2 = b->my_window->audio_thumbnail_pack[inner + 1];
				while((pack1->children() < 7) && (pack2->children() > 0))
				{
					PulseAudioButton *move = (PulseAudioButton *)pack2->child(0);
					pack1->add(move);
				}
			}
			b->hide();
			Fl::delete_widget(b);
			done = 1;
		}
	}
}

void	MyWin::CompressAudioThumbnailList()
{
int	loop;
PulseAudioButton	*new_list[128];

	for(loop = 0;loop < 128;loop++)
	{
		new_list[loop] = NULL;
	}
	int cnt = 0;
	for(loop = 0;loop < audio_thumbnail_cnt;loop++)
	{
		if(audio_thumbnail[loop] != NULL)
		{
			new_list[cnt] = audio_thumbnail[loop];
			cnt++;
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		audio_thumbnail[loop] = new_list[loop];
	}
	audio_thumbnail_cnt = cnt;
}

PulseAudioButton::PulseAudioButton(MyWin *in_win, char *in_dev_name, int xx, int yy, int ww, int hh, char *lbl) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	double gsf = in_win->gui_scale_factor;
	device_name = strdup(in_dev_name);

	box(FL_NO_BOX);

	button = new Fl_Toggle_Button(xx, yy, ww, hh - (10 * gsf), lbl);
	button->color(FL_BLACK);
	button->labelcolor(FL_GRAY);
	button->labelsize(9 * gsf);
	button->align(FL_ALIGN_LEFT | FL_ALIGN_WRAP | FL_ALIGN_INSIDE);
	button->box(FL_FLAT_BOX);
	button->callback(pulse_audio_select_cb, this);

	volume = new Fl_Hor_Fill_Slider(xx + 30, (yy + hh) - (10 * gsf), ww - 30, 10);
	volume->box(FL_FRAME_BOX);
	volume->color(FL_BLACK);
	volume->bounds(0.0, 1.0);
	volume->slider_size(4);
	volume->value(0.5);
	volume->callback(pulse_volume_cb, this);

	delete_button = new Fl_Button(xx, (yy + hh) - (10 * gsf), 11 * gsf, 11 * gsf, "x");
	delete_button->color(FL_BLACK);
	delete_button->labelcolor(FL_GRAY);
	delete_button->labelsize(9 * gsf);
	delete_button->align(FL_ALIGN_CENTER | FL_ALIGN_WRAP | FL_ALIGN_INSIDE);
	delete_button->box(FL_FRAME_BOX);
	delete_button->callback(pulse_audio_button_delete_cb, this);

	repeat_button = new Fl_Toggle_Button(xx + 13, (yy + hh) - (10 * gsf), 11 * gsf, 11 * gsf, "r");
	repeat_button->color(FL_BLACK);
	repeat_button->labelcolor(FL_GRAY);
	repeat_button->labelsize(9 * gsf);
	repeat_button->align(FL_ALIGN_CENTER | FL_ALIGN_WRAP | FL_ALIGN_INSIDE);
	repeat_button->box(FL_FRAME_BOX);
	repeat_button->callback(pulse_audio_button_repeat_cb, this);
	repeat_button->value(0);
	repeat_button->hide();

	microphone = new PulseMicrophone(my_window, device_name);
	if(microphone->failure != 1)
	{
		microphone->volume = 0.5;
		if(my_window->pulse_microphone_cnt < 128)
		{
			my_window->pulse_microphone[my_window->pulse_microphone_cnt] = microphone;
			my_window->pulse_microphone_cnt++;
		}
		if(microphone->is_microphone == 0)
		{
			repeat_button->show();
		}
	}
	else
	{
		delete microphone;
		microphone = NULL;
	}
	end();
	peak = 0;
}

PulseAudioButton::~PulseAudioButton()
{
	if(device_name != NULL)
	{
		free(device_name);
	}
	if(microphone != NULL)
	{
		microphone->shutdown = 1;
		usleep(10000);
		microphone->Stop();
		delete microphone;
		microphone = NULL;
	}
}

void	PulseAudioButton::draw()
{
int		loop;

	Fl_Group::draw();
	if(microphone != NULL)
	{
		double avg = microphone->average * microphone->volume;
		int ww = (int)(((double)w() / (32768.0 / 2.0)) * abs(avg));
		int red = (int)((255.0 / (32768.0 / 2.0)) * abs(avg));
		int green = 255 - (int)((255.0 / (32768.0 / 2.0)) * abs(avg));
		if(ww > peak) peak = ww;
		fl_color(FL_BLACK);
		fl_rectf(x(), y() + (h() - 18), w(), 5);
		for(loop = 0;loop < ww;loop += 3)
		{
			fl_color(fl_rgb_color(red, green, 0));
			fl_rectf(x() + loop, y() + (h() - 18), 2, 5);
		}
		fl_color(FL_RED);
		fl_rectf(x() + peak, y() + (h() - 18), 5, 5);
	}
}

void	MyWin::RunPulse(int mode)
{
	if(mode == MODE_RECORD)
	{
		pthread_t signal_thread = CreateTask((int (*)(int *))pulse_record_all, (void *)this);
	}
	else
	{
		pthread_t signal_thread = CreateTask((int (*)(int *))pulse_play_all, (void *)this);
	}
}

void	MyWin::OpenNamedPulse()
{
	ScanPulse(1);
}

void	MyWin::ScanPulse(int use_source_list)
{
int	loop;

	char *list[128];
	char *description[128];
	int index[128];
	int nn = 0;
	double gsf = gui_scale_factor;
	if(use_source_list == 0)
	{
		nn = pulse_list_devices(1, 128, list, description, index);
	}
	if(audio_source != NULL)
	{
		for(loop = 0;loop < audio_source_cnt;loop++)
		{
			if(audio_source[loop] != NULL)
			{
				list[nn] = strdup(audio_source[loop]);
				description[nn] = NULL;
				nn++;
			}
		}
	}
	int nyy = 10 * gsf;
	int nxx = 600 * gsf;
	pulse_mixer = new PulseMixer(this, FRAMES_PER_BUFFER);
	int at_cnt = 0;
	for(loop = 0;loop < nn;loop++)
	{
		if(list[loop] != NULL)
		{
			char *str = list[loop];
			if(str != NULL)
			{
				char *alias = NULL;
				char *cp = str;
				while(*cp != '\0')
				{
					if(strncmp(cp, "[alias=", strlen("[alias=")) == 0)
					{
						*cp = '\0';
						alias = cp + strlen("[alias=");
						char *cp2 = alias;
						while(*cp2 != '\0')
						{
							if(*cp2 == ']')
							{
								*cp2 = '\0';
							}
							cp2++;
						}
					}
					cp++;
				}
				if((nxx + 253) > w())
				{
					nxx = 600 * gsf;
					nyy += (40 * gsf);
				}
				char *use_str = NULL;
				if(alias == NULL)
				{
					use_str = strdup(str);
					cp = str;
					int cnt = 0;
					char last_cp = '\0';
					while(*cp != '\0')
					{
						if(isalnum(*cp))
						{
							use_str[cnt] = *cp;
							cnt++;
							last_cp = *cp;
						}
						else
						{
							if(last_cp != ' ')
							{
								use_str[cnt] = ' ';
								cnt++;
							}
							last_cp = ' ';
						}
						cp++;
					}
					use_str[cnt] = '\0';
				}
				else
				{
					use_str = strdup(alias);
				}
				PulseAudioButton *at = NULL;
				if((use_source_list == 1) || (description[loop] == NULL))
				{
					char buf[4096];
					sprintf(buf, "Initialize audio:\n%s", use_str);
					start_win->Update(buf);
					at = new PulseAudioButton(this, str, nxx, nyy, 150 * gsf, 60 * gsf, use_str);
				}
				else
				{
					char buf[4096];
					sprintf(buf, "Initialize audio:\n%s", description[loop]);
					start_win->Update(buf);
					at = new PulseAudioButton(this, str, nxx, nyy, 150 * gsf, 60 * gsf, strdup(description[loop]));
				}
				if(at != NULL)
				{
					if(at->microphone != NULL)
					{
						audio_thumbnail[at_cnt] = at;
						at_cnt++;
						nxx += (155 * gsf);
						int which = at_cnt / 7;
						if(which < 3)
						{
							audio_thumbnail_pack[which]->add(at);
						}
					}
					else
					{
						at->hide();
						Fl::delete_widget(at);
					}
				}
			}
			if(list[loop] != NULL)
			{
				free(list[loop]);
			}
			if(description[loop] != NULL)
			{
				free(description[loop]);
			}
		}
	}
	audio_thumbnail_cnt = at_cnt;
	if((nn > 0) || (muxing == 1))
	{
		RunPulse(MODE_RECORD);
		RunPulse(MODE_PLAY);
	}
}

void	MyWin::ViscaButtonCommands(Fl_Button *b, int state)
{
	if(state == FL_PUSH)
	{
		if(b == ptz_up_button)
		{
			ViscaCommand(PTZ_UP);
		}
		else if(b == ptz_down_button)
		{
			ViscaCommand(PTZ_DOWN);
		}
		else if(b == ptz_left_button)
		{
			ViscaCommand(PTZ_LEFT);
		}
		else if(b == ptz_right_button)
		{
			ViscaCommand(PTZ_RIGHT);
		}
		else if(b == ptz_down_right_button)
		{
			ViscaCommand(PTZ_DOWN_RIGHT);
		}
		else if(b == ptz_down_left_button)
		{
			ViscaCommand(PTZ_DOWN_LEFT);
		}
		else if(b == ptz_up_right_button)
		{
			ViscaCommand(PTZ_UP_RIGHT);
		}
		else if(b == ptz_up_left_button)
		{
			ViscaCommand(PTZ_UP_LEFT);
		}
		else if(b == ptz_zoom_in_button)
		{
			ViscaCommand(PTZ_ZOOM_IN);
		}
		else if(b == ptz_zoom_out_button)
		{
			ViscaCommand(PTZ_ZOOM_OUT);
		}
		else if(b == ptz_focus_far_button)
		{
			ViscaCommand(PTZ_FOCUS_FAR);
		}
		else if(b == ptz_focus_near_button)
		{
			ViscaCommand(PTZ_FOCUS_NEAR);
		}
		else if(b == ptz_aperture_open_button)
		{
			ViscaCommand(PTZ_APERTURE_OPEN);
		}
		else if(b == ptz_aperture_close_button)
		{
			ViscaCommand(PTZ_APERTURE_CLOSE);
		}
		else if(b == ptz_home_button)
		{
			ViscaCommand(PTZ_HOME);
		}
	}
	else if(state == FL_RELEASE)
	{
		if((b == ptz_up_button)
		|| (b == ptz_up_right_button)
		|| (b == ptz_up_left_button)
		|| (b == ptz_down_button)
		|| (b == ptz_down_right_button)
		|| (b == ptz_down_left_button)
		|| (b == ptz_left_button)
		|| (b == ptz_right_button))
		{
			ViscaCommand(PTZ_PAN_STOP);
		}
		else if((b == ptz_zoom_in_button) || (b == ptz_zoom_out_button))
		{
			ViscaCommand(PTZ_ZOOM_STOP);
		}
		else if((b == ptz_focus_far_button) || (b == ptz_focus_near_button))
		{
			ViscaCommand(PTZ_FOCUS_STOP);
		}
	}
}

void	ptz_select_camera_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		win->ptz_camera_select_button[loop]->labelcolor(FL_YELLOW);
		win->ptz_camera_select_button[loop]->box(FL_THIN_UP_BOX);
		win->ptz_camera_select_button[loop]->redraw();
	}
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		win->ptz_camera_preset_button[loop]->labelcolor(FL_YELLOW);
		win->ptz_camera_preset_button[loop]->box(FL_THIN_UP_BOX);
		win->ptz_camera_preset_button[loop]->redraw();
	}
	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		if(w == win->ptz_camera_select_button[loop])
		{
			win->ptz_current_camera_idx = loop;
			win->ptz_current_camera = &win->visca_camera[loop];
			win->ptz_camera_select_button[loop]->box(FL_THIN_DOWN_BOX);
			win->ptz_remember_camera[win->ptz_interface_index] = loop;
			win->ptz_camera_select_button[loop]->redraw();
		}
	}
	win->UpdatePresets();
	win->redraw();
}

void	ptz_set_preset_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Fl_Button *tb = (Fl_Button *)w;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(w == win->ptz_camera_set_button[loop])
		{
			if(win->ptz_position[win->ptz_interface_index][win->ptz_current_camera_idx][loop]->set == 0)
			{
				win->PTZ_RememberPosition(loop);
				tb->color(FL_YELLOW);
			}
			else
			{
				win->PTZ_UnRememberPosition(loop);
				tb->color(FL_BLACK);
			}
			tb->redraw();
		}
	}
	win->redraw();
}

void	ptz_select_preset_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		win->ptz_camera_preset_button[loop]->redraw();
	}
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(w == win->ptz_camera_preset_button[loop])
		{
			win->ptz_camera_preset_button[loop]->redraw();
			win->PTZ_RecallPosition(20, loop);
		}
	}
	win->redraw();
}

void	ptz_select_interface_cb(Fl_Widget *w, void *v)
{
int	loop;
int	inner;

	MyWin *win = (MyWin *)v;
	for(loop = 0;loop < win->ptz_device_cnt;loop++)
	{
		if(win->ptz_interface_select_button[loop] != NULL)
		{
			win->ptz_interface_select_button[loop]->labelcolor(FL_YELLOW);
			win->ptz_interface_select_button[loop]->box(FL_THIN_UP_BOX);
			win->ptz_interface_select_button[loop]->redraw();
		}
	}
	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		if(win->ptz_camera_select_button[loop] != NULL)
		{
			win->ptz_camera_select_button[loop]->labelcolor(FL_YELLOW);
			win->ptz_camera_select_button[loop]->box(FL_THIN_UP_BOX);
			win->ptz_camera_select_button[loop]->redraw();
		}
	}
	for(loop = 0;loop < win->ptz_device_cnt;loop++)
	{
		if(w == win->ptz_interface_select_button[loop])
		{
			win->ptz_interface_index = loop;
			win->ptz_current_interface = &win->iface[loop];
			win->ptz_interface_select_button[loop]->box(FL_THIN_DOWN_BOX);
			win->ptz_current_device_path = win->ptz_device_path[loop];
			if(win->ptz_lock_alias[loop] != NULL)
			{
				for(inner = 0;inner < win->source_cnt;inner++)
				{
					Camera *cam = win->camera[inner];
					if(cam != NULL)
					{
						if(strlen(cam->alias) > 0)
						{
							if(strcmp(cam->alias, win->ptz_lock_alias[loop]) == 0)
							{
								win->ptz_window->locked_camera = cam;
							}
						}
					}
				}
			}
			int cam_idx = win->ptz_remember_camera[win->ptz_interface_index];
			if(cam_idx > -1)
			{
				win->ptz_current_camera_idx = cam_idx;
				win->ptz_current_camera = &win->visca_camera[cam_idx];
				win->ptz_camera_select_button[cam_idx]->box(FL_THIN_DOWN_BOX);
				win->ptz_camera_select_button[cam_idx]->redraw();
			}
		}
	}
	win->UpdatePresets();
	win->redraw();
}

void	MyWin::UpdatePresets()
{
int	loop;

	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(ptz_position[ptz_interface_index][ptz_current_camera_idx][loop]->set == 1)
		{
			ptz_camera_set_button[loop]->value(1);
		}
		else
		{
			ptz_camera_set_button[loop]->value(0);
		}
		ptz_camera_set_button[loop]->redraw();
	}
}

void	v4l_zoom_out_cb(void *v)
{
	V4L_Button *b = (V4L_Button *)v;
	if(b->zooming == 1)
	{
		MyWin *main_win = b->my_win->my_win;
		if(main_win != NULL)
		{
			Camera *cam = main_win->camera[b->my_win->index];
			cam->V4L_Command(V4L_ZOOM_OUT);
			Fl::repeat_timeout(0.01, v4l_zoom_out_cb, b);
		}
	}
}

void	v4l_zoom_in_cb(void *v)
{
	V4L_Button *b = (V4L_Button *)v;
	if(b->zooming == 1)
	{
		MyWin *main_win = b->my_win->my_win;
		if(main_win != NULL)
		{
			Camera *cam = main_win->camera[b->my_win->index];
			cam->V4L_Command(V4L_ZOOM_IN);
			Fl::repeat_timeout(0.01, v4l_zoom_in_cb, b);
		}
	}
}

void	v4l_focus_far_cb(void *v)
{
	V4L_Button *b = (V4L_Button *)v;
	if(b->focusing == 1)
	{
		MyWin *main_win = b->my_win->my_win;
		if(main_win != NULL)
		{
			Camera *cam = main_win->camera[b->my_win->index];
			cam->V4L_Command(V4L_FOCUS_FAR);
			Fl::repeat_timeout(0.01, v4l_focus_far_cb, b);
		}
	}
}

void	v4l_focus_near_cb(void *v)
{
	V4L_Button *b = (V4L_Button *)v;
	if(b->focusing == 1)
	{
		MyWin *main_win = b->my_win->my_win;
		if(main_win != NULL)
		{
			Camera *cam = main_win->camera[b->my_win->index];
			cam->V4L_Command(V4L_FOCUS_NEAR);
			Fl::repeat_timeout(0.01, v4l_focus_near_cb, b);
		}
	}
}

V4L_Button::V4L_Button(ThumbGroup *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Button(xx, yy, ww, hh, lbl)
{
	my_win = in_win;
	zooming = 0;
	focusing = 0;
}

V4L_Button::~V4L_Button()
{
}

int	V4L_Button::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		if(event == FL_PUSH)
		{
			MyWin *main_win = my_win->my_win;
			if(main_win != NULL)
			{
				Camera *cam = main_win->camera[my_win->index];
				if(this == my_win->up_left)
				{
					cam->V4L_Motion(V4L_UP | V4L_LEFT);
				}
				else if(this == my_win->up)
				{
					cam->V4L_Motion(V4L_UP);
				}
				else if(this == my_win->up_right)
				{
					cam->V4L_Motion(V4L_UP | V4L_RIGHT);
				}
				else if(this == my_win->left)
				{
					cam->V4L_Motion(V4L_LEFT);
				}
				else if(this == my_win->right)
				{
					cam->V4L_Motion(V4L_RIGHT);
				}
				else if(this == my_win->down_left)
				{
					cam->V4L_Motion(V4L_DOWN | V4L_LEFT);
				}
				else if(this == my_win->down)
				{
					cam->V4L_Motion(V4L_DOWN);
				}
				else if(this == my_win->down_right)
				{
					cam->V4L_Motion(V4L_DOWN | V4L_RIGHT);
				}
				else if(this == my_win->zoom_out)
				{
					zooming = 1;
					Fl::add_timeout(0.01, v4l_zoom_out_cb, this);
				}
				else if(this == my_win->zoom_in)
				{
					zooming = 1;
					Fl::add_timeout(0.01, v4l_zoom_in_cb, this);
				}
				else if(this == my_win->focus_far)
				{
					focusing = 1;
					Fl::add_timeout(0.01, v4l_focus_far_cb, this);
				}
				else if(this == my_win->focus_near)
				{
					focusing = 1;
					Fl::add_timeout(0.01, v4l_focus_near_cb, this);
				}
			}
		}
		else if(event == FL_RELEASE)
		{
			MyWin *main_win = my_win->my_win;
			if(main_win != NULL)
			{
				Camera *cam = main_win->camera[my_win->index];
				if((this == my_win->up_left)
				|| (this == my_win->up)
				|| (this == my_win->up_right)
				|| (this == my_win->left)
				|| (this == my_win->right)
				|| (this == my_win->down_left)
				|| (this == my_win->down)
				|| (this == my_win->down_right)
				|| (this == my_win->zoom_in)
				|| (this == my_win->zoom_out))
				{
					cam->V4L_Motion(V4L_STOP);
				}
				zooming = 0;
				focusing = 0;
			}
		}
		flag = Fl_Button::handle(event);
	}
	return(flag);
}

PTZ_Button::PTZ_Button(MyWin *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Button(xx, yy, ww, hh, lbl)
{
	my_window = in_win;
}

PTZ_Button::~PTZ_Button()
{
}

int	PTZ_Button::handle(int event)
{
	int flag = 0;
	if(flag == 0)
	{
		if((event == FL_PUSH)
		|| (event == FL_RELEASE))
		{
			my_window->ViscaButtonCommands(this, event);
		}
		flag = Fl_Button::handle(event);
	}
	return(flag);
}

void	ptz_auto_focus_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	int val = b->value();
	win->AutoFocus(val);
}

void	ptz_auto_exp_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	int val = b->value();
	win->AutoExposure(val);
}

void	ptz_backlight_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	int val = b->value();
	win->BacklightCompensation(val);
}

void	ptz_dzoom_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	int val = b->value();
	win->DigitalZoom(val);
}

void	ptz_tour_cb(Fl_Widget *w, void *v)
{
void	ptz_tour_presets_cb(void *v);
int	loop;

	MyWin *win = (MyWin *)v;
	int cnt = 0;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(win->ptz_position[win->ptz_interface_index][win->ptz_current_camera_idx][loop]->set == 1)
		{
			cnt++;
		}
	}
	if(cnt > 1)
	{
		Fl_Light_Button *b = (Fl_Light_Button *)w;
		int val = b->value();
		if(val == 1)
		{
			win->ptz_tour_index = 0;
			Fl::repeat_timeout(0.0, ptz_tour_presets_cb, win);
		}
		else
		{
			Fl::remove_timeout(ptz_tour_presets_cb, win);
		}
	}
}

void	ptz_reverse_horizontal_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	int val = b->value();
	win->ptz_reverse_horizontal = val;
}

void	ptz_reverse_vertical_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	int val = b->value();
	win->ptz_reverse_vertical = val;
}

void	ptz_follow_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	int val = b->value();
	win->ptz_follow = val;
	if(val == 1)
	{
		win->ptz_follow_home_pan = win->ptz_pan_reading / 16;
		win->ptz_follow_home_tilt = win->ptz_tilt_reading / 16;
	}
}

void	ptz_show_joystick_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	int val = b->value();
	win->ptz_joystick = val;
}

void	ptz_soft_memory_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	int val = b->value();
	if((win->ptz_interface_index > -1) && (win->ptz_interface_index < NUMBER_OF_INTERFACES)
	&& (win->ptz_current_camera_idx > -1) && (win->ptz_current_camera_idx < NUMBER_OF_CAMERAS))
	{
		win->ptz_soft_memory[win->ptz_interface_index][win->ptz_current_camera_idx] = val;
	}
}

void	ptz_set_speed_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Hor_Fill_Slider *slider = (Fl_Hor_Fill_Slider *)w;
	double val = slider->value();
	MyVISCACamera *local_cam = win->ptz_current_camera;
	if(local_cam != NULL)
	{
		win->ptz_pan_speed = (int)((double)local_cam->param_pan_max_speed * val);
		win->ptz_tilt_speed = (int)((double)local_cam->param_tilt_max_speed * val);
		win->ptz_focus_speed = (int)((4.0) * val);
		if(win->ptz_zoomer_speed == 0)
		{
			win->ptz_zoom_speed = (int)((40959.0 / 1000.0) * val);
		}
		else
		{
			win->ptz_zoom_speed = win->ptz_zoomer_speed;
		}
	}
}

void	ptz_lock_camera_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	PTZ_Window *my_win = win->ptz_window;
	if(my_win != NULL)
	{
		Fl_Light_Button *b = (Fl_Light_Button *)w;
		int val = b->value();
		if(val == 1)
		{
			my_win->locked_camera = cam;
		}
		else
		{
			my_win->locked_camera = NULL;
		}
	}
}

void	ptz_zoom_speed_adjust_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Fl_Toggle_Button *b = (Fl_Toggle_Button *)w;
	win->ptz_adjust_speed_for_zoom = b->value();
}

PTZ_Position::PTZ_Position(int in_set, int in_pan, int in_tilt, int in_zoom, int in_focus)
{
	set = in_set;
	pan = in_pan;
	tilt = in_tilt;
	zoom = in_zoom;
	focus = in_focus;
}

PTZ_Position::~PTZ_Position()
{
}

void	PTZ_Position::Set(int in_pan, int in_tilt, int in_zoom, int in_focus)
{
	set = 1;
	pan = in_pan;
	tilt = in_tilt;
	zoom = in_zoom;
	focus = in_focus;
}

void	PTZ_Position::UnSet()
{
	set = 0;
	pan = 0;
	tilt = 0;
	zoom = 0;
	focus = 0;
}

void	MyWin::PTZ_RememberPosition(int num)
{
	PTZ_Position *pos = ptz_position[ptz_interface_index][ptz_current_camera_idx][num];
	if(pos != NULL)
	{
		pos->Set(ptz_pan_reading, ptz_tilt_reading, ptz_zoom_reading, ptz_focus_reading);
	}
	if(ptz_soft_memory[ptz_interface_index][ptz_current_camera_idx] == 0)
	{
		VISCA_memory_set(ptz_current_interface, ptz_current_camera, num);
	}
}

void	MyWin::PTZ_UnRememberPosition(int num)
{
	PTZ_Position *pos = ptz_position[ptz_interface_index][ptz_current_camera_idx][num];
	if(pos != NULL)
	{
		pos->UnSet();
	}
	if(ptz_soft_memory[ptz_interface_index][ptz_current_camera_idx] == 0)
	{
		VISCA_memory_reset(ptz_current_interface, ptz_current_camera, num);
	}
}

int	MyWin::PTZ_RecallPosition(int speed, int num)
{
	int r = 0;
	if(ptz_soft_memory[ptz_interface_index][ptz_current_camera_idx] == 1)
	{
		if((num > -1) && (num < NUMBER_OF_PRESETS))
		{
			PTZ_Position *pos = ptz_position[ptz_interface_index][ptz_current_camera_idx][num];
			if(pos->set == 1)
			{
				GoToPTZPosition(speed, pos->pan, pos->tilt, pos->zoom, pos->focus);
				r = 1;
			}
		}
	}
	else
	{
		VISCA_memory_recall(ptz_current_interface, ptz_current_camera, num);
		r = 1;
	}
	return(r);
}

void	MyWin::GoToPTZPosition(int speed, int in_pan, int in_tilt, int in_zoom, int in_focus)
{
	int done = 0;
	int attempts = 0;
	while((done == 0) && (attempts < 10))
	{
		int target_pan = in_pan / 16;
		int target_tilt = in_tilt / 16;
		ViscaCommand(PTZ_ABSOLUTE_POSITION, 4, speed, speed, target_pan, target_tilt);
		while(visca_command != 0)
		{
			Fl::check();
			usleep(10000);
		}
		int r_pan = ptz_pan_reading / 16;
		int r_tilt = ptz_tilt_reading / 16;
		int d_pan = abs(r_pan - target_pan);
		int d_tilt = abs(r_tilt - target_tilt);
		if((d_pan < 100) && (d_tilt < 100))
		{
			done = 1;
		}
		attempts++;
	}
	ViscaCommand(PTZ_ZOOM_AND_FOCUS, 2, in_zoom, in_focus);
	while(visca_command != 0)
	{
		Fl::check();
		usleep(10000);
	}
	Fl::check();
}

void	MyWin::SavePTZPositions()
{
int	aa, ab, ac;

	int fd = open("ptz_positions.bin", O_WRONLY | O_CREAT, 0666);
	if(fd != -1)
	{
		for(aa = 0;aa < NUMBER_OF_INTERFACES;aa++)
		{
			for(ab = 0;ab < NUMBER_OF_CAMERAS;ab++)
			{
				for(ac = 0;ac < NUMBER_OF_PRESETS;ac++)
				{
					if(ptz_position[aa][ab][ac] != NULL)
					{
						write(fd, ptz_position[aa][ab][ac], sizeof(PTZ_Position));
					}
				}
			}
		}
		close(fd);
	}
}

void	MyWin::LoadPTZPositions()
{
int	aa, ab, ac;

	int fd = open("ptz_positions.bin", O_RDONLY);
	if(fd != -1)
	{
		for(aa = 0;aa < NUMBER_OF_INTERFACES;aa++)
		{
			for(ab = 0;ab < NUMBER_OF_CAMERAS;ab++)
			{
				for(ac = 0;ac < NUMBER_OF_PRESETS;ac++)
				{
					if(ptz_position[aa][ab][ac] != NULL)
					{
						read(fd, ptz_position[aa][ab][ac], sizeof(PTZ_Position));
					}
				}
			}
		}
		close(fd);
	}
}

void	MyWin::ViscaSpecs(VISCAInterface_t *interface, MyVISCACamera *cam)
{
	VISCA_get_camera_info(interface, cam);
	char visca_filename[4096];
	sprintf(visca_filename, "VISCA_CAMERA_%x_%x.specs", cam->vendor, cam->model);
	FILE *fp = fopen(visca_filename, "r");
	if(fp != NULL)
	{
		fscanf(fp, "%d", &cam->param_pan_limit);
		fscanf(fp, "%d", &cam->param_tilt_up_limit);
		fscanf(fp, "%d", &cam->param_tilt_down_limit);
		fscanf(fp, "%d", &cam->param_zoom_limit);
		fscanf(fp, "%d", &cam->param_pan_max_speed);
		fscanf(fp, "%d", &cam->param_tilt_max_speed);
		if(cam->param_pan_max_speed < 20)
		{
			cam->param_pan_max_speed = 20;
		}
		if(cam->param_tilt_max_speed < 20)
		{
			cam->param_tilt_max_speed = 20;
		}
		fclose(fp);
	}
	else
	{
		FILE *fp = fopen(visca_filename, "w");
		if(fp != NULL)
		{
			VISCA_set_pantilt_home(interface, cam);
			VISCA_set_zoom_value(interface, cam, 0);
			int pan_limit = 0;
			int last_pan_limit = -1;
			while(pan_limit > last_pan_limit)
			{
				VISCA_set_pantilt_relative_position(interface, cam, 20, 20, 10, 0);
				int pan_reading = 0;
				int tilt_reading = 0;
				VISCA_get_pantilt_position(interface, cam, &pan_reading, &tilt_reading);
				last_pan_limit = pan_limit;
				pan_limit = pan_reading;
			}
			cam->param_pan_limit = last_pan_limit;
			VISCA_set_pantilt_home(interface, cam);
			int tilt_limit = 0;
			int last_tilt_limit = -1;
			while(tilt_limit > last_tilt_limit)
			{
				VISCA_set_pantilt_relative_position(interface, cam, 20, 20, 0, 10);
				int pan_reading = 0;
				int tilt_reading = 0;
				VISCA_get_pantilt_position(interface, cam, &pan_reading, &tilt_reading);
				last_tilt_limit = tilt_limit;
				tilt_limit = tilt_reading;
			}
			cam->param_tilt_up_limit = last_tilt_limit;
			VISCA_set_pantilt_home(interface, cam);
			tilt_limit = -1;
			last_tilt_limit = 0;
			while(tilt_limit < last_tilt_limit)
			{
				VISCA_set_pantilt_relative_position(interface, cam, 20, 20, 0, -10);
				int pan_reading = 0;
				int tilt_reading = 0;
				VISCA_get_pantilt_position(interface, cam, &pan_reading, &tilt_reading);
				last_tilt_limit = tilt_limit;
				tilt_limit = tilt_reading;
			}
			cam->param_tilt_down_limit = last_tilt_limit;
			VISCA_set_pantilt_home(interface, cam);
			VISCA_set_zoom_value(interface, cam, 0);
			int zoom_limit = 0;
			int last_zoom_limit = -1;
			int cnt = 10;
			while(zoom_limit > last_zoom_limit)
			{
				VISCA_set_zoom_value(interface, cam, cnt);
				int zoom_reading = 0;
				VISCA_get_zoom_value(interface, cam, (uint16_t *)&zoom_reading);
				last_zoom_limit = zoom_limit;
				zoom_limit = zoom_reading;
				cnt += 100;
			}
			VISCA_get_pantilt_maxspeed(interface, cam, (uint8_t *)&cam->param_pan_max_speed, (uint8_t *)&cam->param_tilt_max_speed);

			cam->param_zoom_limit = last_zoom_limit;
			fprintf(fp, "%d\n", cam->param_pan_limit);
			fprintf(fp, "%d\n", cam->param_tilt_up_limit);
			fprintf(fp, "%d\n", cam->param_tilt_down_limit);
			fprintf(fp, "%d\n", cam->param_zoom_limit);
			fprintf(fp, "%d\n", cam->param_pan_max_speed);
			fprintf(fp, "%d\n", cam->param_tilt_max_speed);
			fclose(fp);

			VISCA_set_pantilt_home(interface, cam);
			VISCA_set_zoom_value(interface, cam, 0);
		}
	}
}

void	MyWin::AutoFocus(int on)
{
	if(on == 1)
	{
		VISCA_set_focus_auto(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_FOCUS_AUTO_ON);
	}
	else
	{
		VISCA_set_focus_auto(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_FOCUS_AUTO_OFF);
	}
	ptz_auto_focus->value(on);
}

void	MyWin::DigitalZoom(int on)
{
	if(on == 1)
	{
		VISCA_set_dzoom(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_DZOOM_ON);
	}
	else
	{
		VISCA_set_dzoom(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_DZOOM_OFF);
	}
}

void	MyWin::AutoExposure(int on)
{
	if(on == 1)
	{
		VISCA_set_auto_exp_mode(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_AUTO_EXP_FULL_AUTO);
	}
	else
	{
		VISCA_set_auto_exp_mode(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_AUTO_EXP_MANUAL);
	}
}

void	MyWin::BacklightCompensation(int on)
{
	if(on == 1)
	{
		VISCA_set_backlight_comp(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_ON);
	}
	else
	{
		VISCA_set_backlight_comp(ptz_current_interface, ptz_current_camera, (uint8_t)VISCA_OFF);
	}
}

void	ptz_calibrate_cb(Fl_Widget *w, void *v)
{
void	MatchingMethod(int match_method, Mat img, Mat temp, int *xx, int *yy);
int	loop;
Mat	out;

	MyWin *win = (MyWin *)v;
	Mat local_mat = win->in_mat;

	int use_x = (local_mat.cols / 2) - 50;
	int use_y = (local_mat.rows / 2) - 50;
	win->CropFrame(win->in_mat, &out, use_x, use_y, 100, 100);

	for(loop = 0;loop < 250;loop++)
	{
		win->ViscaCommand(PTZ_RELATIVE_POSITION, 4, 1, 1, 1, 1);
		win->redraw();
		Fl::check();
		int xx = 0;
		int yy = 0;
		MatchingMethod(0, win->in_mat, out, &xx, &yy);
		win->magic_x = xx;
		win->magic_y = yy;
		win->ptz_travel_x = (double)(xx - use_x) / (double)loop;
		win->ptz_travel_y = (double)(yy - use_y) / (double)loop;
	}
}

void	ptz_preset_page_back_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->ptz_preset_page > 0)
	{
		int start = win->ptz_preset_page * 7;
		for(loop = start;loop < start + 7;loop++)
		{
			win->ptz_camera_preset_button[loop]->hide();
			win->ptz_camera_set_button[loop]->hide();
		}
		win->ptz_preset_page--;
		start = win->ptz_preset_page * 7;
		for(loop = start;loop < start + 7;loop++)
		{
			win->ptz_camera_preset_button[loop]->show();
			win->ptz_camera_set_button[loop]->show();
		}
	}
}

void	ptz_preset_page_forward_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	if(win->ptz_preset_page < 2)
	{
		int start = win->ptz_preset_page * 7;
		for(loop = start;loop < start + 7;loop++)
		{
			win->ptz_camera_preset_button[loop]->hide();
			win->ptz_camera_set_button[loop]->hide();
		}
		win->ptz_preset_page++;
		start = win->ptz_preset_page * 7;
		for(loop = start;loop < start + 7;loop++)
		{
			win->ptz_camera_preset_button[loop]->show();
			win->ptz_camera_set_button[loop]->show();
		}
	}
}

int	TestPTZPort(char *path)
{
VISCAInterface_t	iface;

	int rr = 0;
	memset(&iface, 0, sizeof(iface));
	int err = VISCA_open_serial(&iface, path);
	if(err == 0)
	{
		struct termios options;
		int result = tcgetattr(iface.port_fd, &options);
		if(!result)
		{
			int assigned = 0;
			iface.timeout = 30000;
			int nn = VISCA_set_address(&iface, &assigned);
			if((nn != -1) && (assigned != 0))
			{
				rr = 1;
			}
			iface.timeout = 0;
		}
		VISCA_close_serial(&iface);
	}
	return(rr);
}

int	ScanViableTTYPorts(char **final)
{
int	test_serial_ports(char **); 
int	loop;

	int cnt = 0;
	char *out_list[1024];
	int	out_nn = test_serial_ports(out_list);
	for(loop = 0;loop < out_nn;loop++)
	{
		int rr = 0;
		if(out_list[loop] != NULL)
		{
			rr = TestPTZPort(out_list[loop]);
			if(rr == 1)
			{
				final[cnt] = strdup(out_list[loop]);
				cnt++;
			}
			free(out_list[loop]);
		}
	}
	return(cnt);
}

void	MyWin::ViscaCommand(int command, int arg_cnt, int arg0, int arg1, int arg2, int arg3, int arg4)
{
	if((command == PTZ_RELATIVE_POSITION)
	|| (command == PTZ_ABSOLUTE_POSITION))
	{
		if(pthread_mutex_trylock(&visca_mutex) == 0)
		{
			visca_command = command;
			visca_arg_cnt = arg_cnt;
			visca_arg[0] = arg0;
			visca_arg[1] = arg1;
			visca_arg[2] = arg2;
			visca_arg[3] = arg3;
			visca_arg[4] = arg4;
			pthread_mutex_unlock(&visca_mutex);
			pthread_cond_signal(&visca_cond);
		}
	}
	else
	{
		pthread_mutex_lock(&visca_mutex);
		visca_command = command;
		visca_arg_cnt = arg_cnt;
		visca_arg[0] = arg0;
		visca_arg[1] = arg1;
		visca_arg[2] = arg2;
		visca_arg[3] = arg3;
		visca_arg[4] = arg4;
		pthread_mutex_unlock(&visca_mutex);
		pthread_cond_signal(&visca_cond);
	}
}

int	visca(int *flag)
{
	MyWin *win = (MyWin *)flag;
	if(win != NULL)
	{
		win->visca_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
		win->visca_cond = PTHREAD_COND_INITIALIZER;
		int done = 0;
		while(done == 0)
		{
			pthread_cond_wait(&win->visca_cond, &win->visca_mutex);
			pthread_mutex_lock(&win->visca_mutex);
			int vc = win->visca_command;
			int arg_cnt = win->visca_arg_cnt;
			int arg0 = win->visca_arg[0];
			int arg1 = win->visca_arg[1];
			int arg2 = win->visca_arg[2];
			int arg3 = win->visca_arg[3];
			int arg4 = win->visca_arg[4];
			if(vc == VISCA_QUIT)
			{
				done = 1;
			}
			else if(vc > 0)
			{
				win->PTZ_DoCommand(vc, arg_cnt, arg0, arg1, arg2, arg3, arg4);
				win->visca_command = 0;
				win->visca_arg_cnt = 0;
				win->visca_arg[0] = 0;
				win->visca_arg[1] = 0;
				win->visca_arg[2] = 0;
				win->visca_arg[3] = 0;
				win->visca_arg[4] = 0;
			}
			pthread_mutex_unlock(&win->visca_mutex);
			if(vc <= 0)
			{
				usleep(10000);
			}
		}
	}
	return(0);
}

void	MyWin::StartVisca()
{
	pthread_t signal_thread = CreateTask((int (*)(int *))visca, (void *)this);
}

PTZ_Window::PTZ_Window(MyWin *in_win, int xx, int yy, int ww, int hh) : Fl_Window(xx, yy, ww, hh)
{
int	loop;

	my_window = in_win;
	locked_camera = NULL;
};

PTZ_Window::~PTZ_Window()
{
};

void	MyWin::SetupPTZWindow(int home_on_launch)
{
int	loop;
int	inner;
int	aa, ab, ac;

	double gsf = gui_scale_factor;
	ptz_window = new PTZ_Window(this, 0, (h() - (370 * gsf)) - (NUMBER_OF_PRESETS * ptz_device_cnt) * gsf, 300 * gsf, (350 + (NUMBER_OF_PRESETS * ptz_device_cnt)) * gsf);
	ptz_window->box(FL_FLAT_BOX);
	ptz_window->color(FL_BLACK);
	ptz_window->hide();

	int yy = ptz_window->h() - (220 * gsf);

	Fl_Box *pt_label = new Fl_Box(0, yy, 100 * gsf, 20 * gsf, "Pan/Tilt");
	pt_label->box(FL_NO_BOX);
	pt_label->color(FL_YELLOW);
	pt_label->labelcolor(FL_YELLOW);
	pt_label->labelsize(9 * gsf);
	pt_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	yy += 21 * gsf;

	ptz_up_button = new PTZ_Button(this, 40 * gsf, yy + 5, 20 * gsf, 20 * gsf, "@#8>");
	ptz_up_button->box(FL_FRAME);
	ptz_up_button->color(FL_YELLOW);
	ptz_up_button->labelcolor(FL_YELLOW);
	ptz_up_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_up_right_button = new PTZ_Button(this, (40 + 25) * gsf, yy, 20 * gsf, 20 * gsf, "@#9>");
	ptz_up_right_button->box(FL_FRAME);
	ptz_up_right_button->color(FL_YELLOW);
	ptz_up_right_button->labelcolor(FL_YELLOW);
	ptz_up_right_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_up_left_button = new PTZ_Button(this, (40 - 25) * gsf, yy, 20 * gsf, 20 * gsf, "@#7>");
	ptz_up_left_button->box(FL_FRAME);
	ptz_up_left_button->color(FL_YELLOW);
	ptz_up_left_button->labelcolor(FL_YELLOW);
	ptz_up_left_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_down_button = new PTZ_Button(this, 40 * gsf, yy + (45 * gsf), 20 * gsf, 20 * gsf, "@#2>");
	ptz_down_button->box(FL_FRAME);
	ptz_down_button->color(DARK_BLUE);
	ptz_down_button->labelcolor(FL_YELLOW);
	ptz_down_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_down_right_button = new PTZ_Button(this, (40 + 25) * gsf, yy + (50 * gsf), 20 * gsf, 20 * gsf, "@#3>");
	ptz_down_right_button->box(FL_FRAME);
	ptz_down_right_button->color(DARK_BLUE);
	ptz_down_right_button->labelcolor(FL_YELLOW);
	ptz_down_right_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_down_left_button = new PTZ_Button(this, (40 - 25) * gsf, yy + (50 * gsf), 20 * gsf, 20 * gsf, "@#1>");
	ptz_down_left_button->box(FL_FRAME);
	ptz_down_left_button->color(DARK_BLUE);
	ptz_down_left_button->labelcolor(FL_YELLOW);
	ptz_down_left_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_left_button = new PTZ_Button(this, (40 - 20) * gsf, yy + (25 * gsf), 20 * gsf, 20 * gsf, "@#4>");
	ptz_left_button->box(FL_FRAME);
	ptz_left_button->color(DARK_BLUE);
	ptz_left_button->labelcolor(FL_YELLOW);
	ptz_left_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_home_button = new PTZ_Button(this, (40 + 1) * gsf, yy + (26 * gsf), 17 * gsf, 17 * gsf, "");
	ptz_home_button->box(FL_FRAME);
	ptz_home_button->color(DARK_BLUE);
	ptz_home_button->labelcolor(FL_YELLOW);
	ptz_home_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_right_button = new PTZ_Button(this, (40 + 20) * gsf, yy + (25 * gsf), 20 * gsf, 20 * gsf, "@#>");
	ptz_right_button->box(FL_FRAME);
	ptz_right_button->color(DARK_BLUE);
	ptz_right_button->labelcolor(FL_YELLOW);
	ptz_right_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	zoom_label = new Fl_Box(60 * gsf, yy, 100 * gsf, 20 * gsf, "Zoom");
	zoom_label->box(FL_NO_BOX);
	zoom_label->color(FL_YELLOW);
	zoom_label->labelcolor(FL_CYAN);
	zoom_label->labelsize(9 * gsf);
	zoom_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_zoom_in_button = new PTZ_Button(this, 100 * gsf, yy + (20 * gsf), 20 * gsf, 20 * gsf, "@#8>");
	ptz_zoom_in_button->box(FL_FRAME);
	ptz_zoom_in_button->color(DARK_BLUE);
	ptz_zoom_in_button->labelcolor(FL_YELLOW);
	ptz_zoom_in_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_zoom_out_button = new PTZ_Button(this, 100 * gsf, yy + (40 * gsf), 20 * gsf, 20 * gsf, "@#2>");
	ptz_zoom_out_button->box(FL_FRAME);
	ptz_zoom_out_button->color(DARK_BLUE);
	ptz_zoom_out_button->labelcolor(FL_YELLOW);
	ptz_zoom_out_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_zoom_value_label = new Fl_Box(100 * gsf, yy + (61 * gsf), 20 * gsf, 10 * gsf, "zoom");
	ptz_zoom_value_label->box(FL_NO_BOX);
	ptz_zoom_value_label->color(FL_YELLOW);
	ptz_zoom_value_label->labelcolor(FL_YELLOW);
	ptz_zoom_value_label->labelsize(7 * gsf);
	ptz_zoom_value_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	focus_label = new Fl_Box(100 * gsf, yy, 80 * gsf, 20 * gsf, "Focus");
	focus_label->box(FL_NO_BOX);
	focus_label->color(FL_YELLOW);
	focus_label->labelcolor(FL_YELLOW);
	focus_label->labelsize(9 * gsf);
	focus_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_focus_far_button = new PTZ_Button(this, 130 * gsf, yy + (20 * gsf), 20 * gsf, 20 * gsf, "@#8>");
	ptz_focus_far_button->box(FL_FRAME);
	ptz_focus_far_button->color(DARK_BLUE);
	ptz_focus_far_button->labelcolor(FL_YELLOW);
	ptz_focus_far_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_focus_near_button = new PTZ_Button(this, 130 * gsf, yy + (40 * gsf), 20 * gsf, 20 * gsf, "@#2>");
	ptz_focus_near_button->box(FL_FRAME);
	ptz_focus_near_button->color(DARK_BLUE);
	ptz_focus_near_button->labelcolor(FL_YELLOW);
	ptz_focus_near_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_focus_value_label = new Fl_Box(130 * gsf, yy + (61 * gsf), 20 * gsf, 10 * gsf, "focus");
	ptz_focus_value_label->box(FL_NO_BOX);
	ptz_focus_value_label->color(FL_YELLOW);
	ptz_focus_value_label->labelcolor(FL_YELLOW);
	ptz_focus_value_label->labelsize(7 * gsf);
	ptz_focus_value_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	aperture_label = new Fl_Box(130 * gsf, yy, 80 * gsf, 20 * gsf, "App");
	aperture_label->box(FL_NO_BOX);
	aperture_label->color(FL_YELLOW);
	aperture_label->labelcolor(FL_YELLOW);
	aperture_label->labelsize(9 * gsf);
	aperture_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_aperture_open_button = new PTZ_Button(this, 160 * gsf, yy + (20 * gsf), 20 * gsf, 20 * gsf, "@#8>");
	ptz_aperture_open_button->box(FL_FRAME);
	ptz_aperture_open_button->color(DARK_BLUE);
	ptz_aperture_open_button->labelcolor(FL_YELLOW);
	ptz_aperture_open_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_aperture_close_button = new PTZ_Button(this, 160 * gsf, yy + (40 * gsf), 20 * gsf, 20 * gsf, "@#2>");
	ptz_aperture_close_button->box(FL_FRAME);
	ptz_aperture_close_button->color(DARK_BLUE);
	ptz_aperture_close_button->labelcolor(FL_YELLOW);
	ptz_aperture_close_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_speed_slider = new Fl_Hor_Fill_Slider((40 - 25) * gsf, yy + (85 * gsf), 60 * gsf, 10 * gsf, "Speed");
	ptz_speed_slider->box(FL_FLAT_BOX);
	ptz_speed_slider->slider(FL_FLAT_BOX);
	ptz_speed_slider->color(FL_YELLOW);
	ptz_speed_slider->labelsize(9 * gsf);
	ptz_speed_slider->labelcolor(FL_YELLOW);
	ptz_speed_slider->align(FL_ALIGN_CENTER | FL_ALIGN_TOP);
	ptz_speed_slider->value(0.25);
	ptz_speed_slider->bounds(0.01, 1.0);
	ptz_speed_slider->callback(ptz_set_speed_cb, this);

	ptz_lock_to_camera_button = new Fl_Light_Button((40 - 25) * gsf, yy + (100 * gsf), 70 * gsf, 18 * gsf, "Lock Camera");
	ptz_lock_to_camera_button->box(FL_FLAT_BOX);
	ptz_lock_to_camera_button->color(FL_BLACK);
	ptz_lock_to_camera_button->labelcolor(FL_YELLOW);
	ptz_lock_to_camera_button->labelsize(8 * gsf);
	ptz_lock_to_camera_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	if(ptz_window->locked_camera == NULL)
	{
		ptz_lock_to_camera_button->value(0);
	}
	else
	{
		ptz_lock_to_camera_button->value(1);
	}
	ptz_lock_to_camera_button->callback(ptz_lock_camera_cb, this);

	ptz_zoom_speed_adjust_button = new Fl_Toggle_Button(((40 - 25) + 60) * gsf, yy + (85 * gsf), 10 * gsf, 10 * gsf, "Z");
	ptz_zoom_speed_adjust_button->box(FL_FLAT_BOX);
	ptz_zoom_speed_adjust_button->color(FL_BLACK);
	ptz_zoom_speed_adjust_button->labelcolor(FL_YELLOW);
	ptz_zoom_speed_adjust_button->labelsize(8 * gsf);
	ptz_zoom_speed_adjust_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_zoom_speed_adjust_button->value(1);
	ptz_zoom_speed_adjust_button->callback(ptz_zoom_speed_adjust_cb, this);

	ptz_auto_focus = new Fl_Light_Button(((40 - 25) + 80) * gsf, yy + (80 * gsf), 60 * gsf, 15 * gsf, "Auto Focus");
	ptz_auto_focus->box(FL_FLAT_BOX);
	ptz_auto_focus->color(FL_BLACK);
	ptz_auto_focus->labelcolor(FL_YELLOW);
	ptz_auto_focus->labelsize(8 * gsf);
	ptz_auto_focus->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_auto_focus->callback(ptz_auto_focus_cb, this);

	ptz_auto_exp = new Fl_Light_Button(((40 - 25) + 80) * gsf, yy + (95 * gsf), 60 * gsf, 15 * gsf, "Auto Exp");
	ptz_auto_exp->box(FL_FLAT_BOX);
	ptz_auto_exp->color(FL_BLACK);
	ptz_auto_exp->labelcolor(FL_YELLOW);
	ptz_auto_exp->labelsize(8 * gsf);
	ptz_auto_exp->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_auto_exp->value(1);
	ptz_auto_exp->callback(ptz_auto_exp_cb, this);

	ptz_backlight = new Fl_Light_Button(((40 - 25) + 80 + 60) * gsf, yy + (80 * gsf), 60 * gsf, 15 * gsf, "Backlight");
	ptz_backlight->box(FL_FLAT_BOX);
	ptz_backlight->color(FL_BLACK);
	ptz_backlight->labelcolor(FL_YELLOW);
	ptz_backlight->labelsize(8 * gsf);
	ptz_backlight->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_backlight->value(0);
	ptz_backlight->callback(ptz_backlight_cb, this);

	ptz_follow_button = new Fl_Light_Button(((40 - 25) + 80 + 60) * gsf, yy + (95 * gsf), 60 * gsf, 15 * gsf, "Follow");
	ptz_follow_button->box(FL_FLAT_BOX);
	ptz_follow_button->color(FL_BLACK);
	ptz_follow_button->labelcolor(FL_YELLOW);
	ptz_follow_button->labelsize(8 * gsf);
	ptz_follow_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_follow_button->value(0);
	ptz_follow_button->callback(ptz_follow_cb, this);

	ptz_dzoom_button = new Fl_Light_Button(((40 - 25) + 80) * gsf, yy + (110 * gsf), 60 * gsf, 15 * gsf, "Digital Zoom");
	ptz_dzoom_button->box(FL_FLAT_BOX);
	ptz_dzoom_button->color(FL_BLACK);
	ptz_dzoom_button->labelcolor(FL_YELLOW);
	ptz_dzoom_button->labelsize(8 * gsf);
	ptz_dzoom_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_dzoom_button->value(0);
	ptz_dzoom_button->callback(ptz_dzoom_cb, this);

	ptz_tour_button = new Fl_Light_Button(((40 - 25) + 80 + 60) * gsf, yy + (110 * gsf), 60 * gsf, 15 * gsf, "Tour");
	ptz_tour_button->box(FL_FLAT_BOX);
	ptz_tour_button->color(FL_BLACK);
	ptz_tour_button->labelcolor(FL_YELLOW);
	ptz_tour_button->labelsize(8 * gsf);
	ptz_tour_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_tour_button->value(0);
	ptz_tour_button->callback(ptz_tour_cb, this);

	ptz_reverse_horizontal_button = new Fl_Light_Button(((40 - 25) + 80) * gsf, yy + (125 * gsf), 60 * gsf, 15 * gsf, "Rev Hor");
	ptz_reverse_horizontal_button->box(FL_FLAT_BOX);
	ptz_reverse_horizontal_button->color(FL_BLACK);
	ptz_reverse_horizontal_button->labelcolor(FL_YELLOW);
	ptz_reverse_horizontal_button->labelsize(8 * gsf);
	ptz_reverse_horizontal_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_reverse_horizontal_button->value(0);
	ptz_reverse_horizontal_button->callback(ptz_reverse_horizontal_cb, this);

	ptz_reverse_vertical_button = new Fl_Light_Button(((40 - 25) + 80 + 60) * gsf, yy + (125 * gsf), 60 * gsf, 15 * gsf, "Rev Vert");
	ptz_reverse_vertical_button->box(FL_FLAT_BOX);
	ptz_reverse_vertical_button->color(FL_BLACK);
	ptz_reverse_vertical_button->labelcolor(FL_YELLOW);
	ptz_reverse_vertical_button->labelsize(8 * gsf);
	ptz_reverse_vertical_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_reverse_vertical_button->value(0);
	ptz_reverse_vertical_button->callback(ptz_reverse_vertical_cb, this);

	ptz_joystick_button = new Fl_Light_Button(((40 - 25) + 80) * gsf, yy + (140 * gsf), 60 * gsf, 15 * gsf, "Joystick");
	ptz_joystick_button->box(FL_FLAT_BOX);
	ptz_joystick_button->color(FL_BLACK);
	ptz_joystick_button->labelcolor(FL_YELLOW);
	ptz_joystick_button->labelsize(8 * gsf);
	ptz_joystick_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_joystick_button->value(0);
	ptz_joystick_button->shortcut("j");
	ptz_joystick_button->callback(ptz_show_joystick_cb, this);

	ptz_soft_memory_button = new Fl_Light_Button(((40 - 25) + 80 + 60) * gsf, yy + (140 * gsf), 60 * gsf, 15 * gsf, "Soft Memory");
	ptz_soft_memory_button->box(FL_FLAT_BOX);
	ptz_soft_memory_button->color(FL_BLACK);
	ptz_soft_memory_button->labelcolor(FL_YELLOW);
	ptz_soft_memory_button->labelsize(8 * gsf);
	ptz_soft_memory_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	ptz_soft_memory_button->value(0);
	ptz_soft_memory_button->callback(ptz_soft_memory_cb, this);

	yy = ptz_window->h() - (290 * gsf);
	Fl_Box *camera_label = new Fl_Box(0, yy, 150 * gsf, 20 * gsf, "Cameras");
	camera_label->box(FL_NO_BOX);
	camera_label->color(FL_YELLOW);
	camera_label->labelcolor(FL_YELLOW);
	camera_label->labelsize(9 * gsf);
	camera_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		char buf[128];
		sprintf(buf, "%d", loop + 1);
		ptz_camera_select_button[loop] = new Fl_Button((10 + (loop * 20)) * gsf, yy + (20 * gsf), 18 * gsf, 18 * gsf, strdup(buf));
		ptz_camera_select_button[loop]->box(FL_THIN_UP_FRAME);
		ptz_camera_select_button[loop]->color(DARK_BLUE);
		ptz_camera_select_button[loop]->labelcolor(FL_YELLOW);
		ptz_camera_select_button[loop]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		ptz_camera_select_button[loop]->labelsize(11 * gsf);
		ptz_camera_select_button[loop]->callback(ptz_select_camera_cb, this);
	}
	yy += (40 * gsf);
	Fl_Box *preset_label = new Fl_Box(0, yy, 150 * gsf, 20 * gsf, "Presets");
	preset_label->box(FL_NO_BOX);
	preset_label->color(FL_YELLOW);
	preset_label->labelcolor(FL_YELLOW);
	preset_label->labelsize(9 * gsf);
	preset_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	ptz_preset_page = 0;
	ptz_camera_preset_page_back_button = new Fl_Button(5 * gsf, yy + (20 * gsf), 10 * gsf, 18 * gsf, "@4>");
	ptz_camera_preset_page_back_button->box(FL_THIN_UP_BOX);
	ptz_camera_preset_page_back_button->color(DARK_BLUE);
	ptz_camera_preset_page_back_button->labelcolor(FL_YELLOW);
	ptz_camera_preset_page_back_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_camera_preset_page_back_button->labelsize(11 * gsf);
	ptz_camera_preset_page_back_button->callback(ptz_preset_page_back_cb, this);
	int cnt = 0;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		char buf[128];
		sprintf(buf, "%d", loop + 1);
		ptz_camera_preset_button[loop] = new Fl_Button((15 + (cnt * 20)) * gsf, yy + (20 * gsf), 18 * gsf, 18 * gsf, strdup(buf));
		ptz_camera_preset_button[loop]->box(FL_THIN_UP_BOX);
		ptz_camera_preset_button[loop]->color(DARK_BLUE);
		ptz_camera_preset_button[loop]->labelcolor(FL_YELLOW);
		ptz_camera_preset_button[loop]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		ptz_camera_preset_button[loop]->labelsize(11 * gsf);
		ptz_camera_preset_button[loop]->callback(ptz_select_preset_cb, this);
		if(loop > 6)
		{
			ptz_camera_preset_button[loop]->hide();
		}
		ptz_camera_set_button[loop] = new Fl_Toggle_Button((15 + (cnt * 20)) * gsf, yy + (38 * gsf), 18 * gsf, 8 * gsf);
		ptz_camera_set_button[loop]->box(FL_THIN_UP_BOX);
		ptz_camera_set_button[loop]->color(DARK_BLUE);
		ptz_camera_set_button[loop]->down_color(FL_YELLOW);
		ptz_camera_set_button[loop]->labelcolor(FL_YELLOW);
		ptz_camera_set_button[loop]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		ptz_camera_set_button[loop]->labelsize(11 * gsf);
		ptz_camera_set_button[loop]->callback(ptz_set_preset_cb, this);
		if(loop > 6)
		{
			ptz_camera_set_button[loop]->hide();
		}
		cnt++;
		if(cnt > 6)
		{
			cnt = 0;
		}
	}
	ptz_camera_preset_page_forward_button = new Fl_Button((15 + (7 * 20)) * gsf, yy + (20 * gsf), 10 * gsf, 18 * gsf, "@6>");
	ptz_camera_preset_page_forward_button->box(FL_THIN_UP_BOX);
	ptz_camera_preset_page_forward_button->color(DARK_BLUE);
	ptz_camera_preset_page_forward_button->labelcolor(FL_YELLOW);
	ptz_camera_preset_page_forward_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	ptz_camera_preset_page_forward_button->labelsize(11 * gsf);
	ptz_camera_preset_page_forward_button->callback(ptz_preset_page_forward_cb, this);
	if(ptz_device_path != NULL)
	{
		for(aa = 0;aa < NUMBER_OF_INTERFACES;aa++)
		{
			for(ab = 0;ab < NUMBER_OF_CAMERAS;ab++)
			{
				for(ac = 0;ac < NUMBER_OF_PRESETS;ac++)
				{
					ptz_position[aa][ab][ac] = new PTZ_Position(0, 0, 0, 0, 0);
				}
			}
		}
		LoadPTZPositions();

		int yy = ptz_window->h() - (310 * gsf);
		int camera_num = 0;
		int err = 0;
		ptz_current_interface = NULL;
		ptz_current_camera = NULL;
		ptz_interface_index = 0;

		int start_y = yy - ((21 * ptz_device_cnt) * gsf);
		Fl_Box *interface_label = new Fl_Box(10 * gsf, start_y, 160 * gsf, 20 * gsf, "Interfaces");
		interface_label->box(FL_NO_BOX);
		interface_label->color(FL_YELLOW);
		interface_label->labelcolor(FL_YELLOW);
		interface_label->labelsize(9 * gsf);
		interface_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
		start_y += (18 * gsf);

		for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
		{
			ptz_remember_camera[inner] = -1;
		}
		ptz_current_device_path = NULL;
		for(loop = 0;loop < ptz_device_cnt;loop++)
		{
			memset(&iface[loop], 0, sizeof(iface[loop]));
			if(start_win != NULL)
			{
				if(start_win->visible())
				{
					char buf[8192];
					sprintf(buf, "Initialize PTZ:\n%s", ptz_device_path[loop]);
					start_win->Update(buf);
				}
			}
			err = VISCA_open_serial(&iface[loop], ptz_device_path[loop]);
			if(err == 0)
			{
				char *use_path = ptz_device_path[loop];
				if(ptz_alias[loop] != NULL)
				{
					if(strlen(ptz_alias[loop]) > 0)
					{
						use_path = ptz_alias[loop];
					}
				}
				ptz_interface_select_button[loop] = new Fl_Button(10 * gsf, start_y, 140 * gsf, 20 * gsf, use_path);
				ptz_interface_select_button[loop]->box(FL_THIN_UP_FRAME);
				ptz_interface_select_button[loop]->color(DARK_BLUE);
				ptz_interface_select_button[loop]->labelcolor(FL_YELLOW);
				ptz_interface_select_button[loop]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
				ptz_interface_select_button[loop]->labelsize(11 * gsf);
				ptz_interface_select_button[loop]->callback(ptz_select_interface_cb, this);
				start_y += (21 * gsf);

				if(ptz_current_interface == NULL)
				{
					ptz_current_interface = &iface[loop];
					ptz_current_device_path = ptz_device_path[loop];
					if(ptz_lock_alias[loop] != NULL)
					{
						for(inner = 0;inner < source_cnt;inner++)
						{
							Camera *cam = camera[loop];
							if(cam != NULL)
							{
								if(strlen(cam->alias) > 0)
								{
									if(strcmp(cam->alias, ptz_lock_alias[loop]) == 0)
									{
										ptz_window->locked_camera = cam;
									}
								}
							}
						}
					}
					ptz_interface_select_button[loop]->box(FL_THIN_DOWN_BOX);
					ptz_interface_index = loop;
				}
				for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
				{
					memset(&visca_camera[inner], 0, sizeof(visca_camera[inner]));
					int assigned = 0;
					int nn = VISCA_set_address(&iface[loop], &assigned);
					visca_camera[inner].address = assigned;
					if(ptz_current_camera == NULL)
					{
						ptz_current_camera = &visca_camera[inner];
						ptz_camera_select_button[inner]->box(FL_THIN_DOWN_BOX);
						ptz_remember_camera[ptz_interface_index] = inner;
					}
				}
				ptz_current_camera = &visca_camera[0];
				ptz_mode = 1;
				StartVisca();
				DigitalZoom(0);
				AutoExposure(1);
				BacklightCompensation(0);
				PTZ_DoCommand(0);
				for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
				{
					ViscaSpecs(&iface[loop], &visca_camera[inner]);
				}
				if(home_on_launch == 1)
				{
					ViscaCommand(PTZ_HOME);
				}
			}
			else
			{
				fprintf(stderr, "Error: Cannot open VISCA device at: [%s]\n", ptz_device_path[loop]);
			}
		}
		ptz_window->end();
		UpdatePresets();
	}
	else
	{
		ptz_window->end();
	}
}

void	codec_selection_window_cb(Fl_Widget *in_csw, void *v)
{
	CodecSelectionWindow *csw = (CodecSelectionWindow *)in_csw;
	strcpy(csw->container_selected, "");
	strcpy(csw->extension_selected, "");
	strcpy(csw->video_codec_selected, "");
	strcpy(csw->audio_codec_selected, "");
	csw->outcome->hide();
	csw->hide();
}

void	csw_outcome_cancel_cb(Fl_Widget *w, void *v)
{
	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	strcpy(csw->container_selected, "");
	strcpy(csw->extension_selected, "");
	strcpy(csw->video_codec_selected, "");
	strcpy(csw->audio_codec_selected, "");
	csw->outcome->hide();
	csw->hide();
}

void	clear_window_cb(Fl_Widget *w, void *v)
{
	Fl_Window *win = (Fl_Window *)v;
	win->hide();
	Fl::delete_widget(win);
}

void	csw_outcome_accept_cb(Fl_Widget *w, void *v)
{
int		my_find_codec_by_name(int type, char *format_name, char *in_name);
char		buf[256];

	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	int video_id = my_find_codec_by_name(0, csw->container_selected, csw->video_codec_selected);
	int audio_id = my_find_codec_by_name(1, csw->container_selected, csw->audio_codec_selected);
	if((video_id != 0) && (audio_id != 0))
	{
		csw->video_codec_id = (AVCodecID)video_id;
		csw->audio_codec_id = (AVCodecID)audio_id;
		strcpy(buf, csw->extension_selected);
		char *cp = buf;
		while((*cp != '\0') && (*cp != ','))
		{
			cp++;
		}
		if(*cp == ',')
		{
			*cp = '\0';
		}
		strcpy(csw->extension_selected, buf);
		csw->outcome->hide();
		csw->hide();
	}
	else
	{
		static char buf[1024];
		Fl_Window *win = new Fl_Window(csw->x() + (csw->w() / 2) - 150, csw->y() + (csw->h() / 2) - 30, 300, 60);
		win->box(FL_FLAT_BOX);
		win->color(FL_WHITE);
		win->border(0);
			if((csw->video_codec_selected != NULL)
			&& (csw->audio_codec_selected != NULL))
			{
				if((strlen(csw->video_codec_selected) > 0) && (strlen(csw->audio_codec_selected) > 0))
				{
					if((video_id == 0) && (audio_id == 0))
					{
						sprintf(buf, "%s and %s are not valid codecs.", csw->video_codec_selected, csw->audio_codec_selected);
					}
					else if(video_id == 0)
					{
						sprintf(buf, "%s is not a valid video codec.", csw->video_codec_selected);
					}
					else if(audio_id == 0)
					{
						sprintf(buf, "%s is not a valid audio codec.", csw->audio_codec_selected);
					}
				}
				else
				{
					sprintf(buf, "Invalid codecs selected.");
				}
			}
			else
			{
				sprintf(buf, "Invalid codecs selected.");
			}
			Fl_Button *button = new Fl_Button(1, 1, 298, 58);
			button->label(buf);
			button->color(DARK_RED);
			button->box(FL_FLAT_BOX);
			button->labelcolor(FL_WHITE);
			button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			button->callback(clear_window_cb, win);
		win->end();
		win->set_modal();
		win->show();
	}
}

ListMenu::ListMenu(void *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Window(xx, yy, ww, hh)
{
	my_window = in_win;
	item_cnt = 0;
	current_item = -1;
	box(FL_FRAME_BOX);
	color(FL_BLACK);
	border(0);
		scroll = new Fl_Scroll(2, 24, ww - 4, h() - 26, lbl);
		scroll->align(FL_ALIGN_TOP);
		scroll->labelcolor(FL_WHITE);
		scroll->scrollbar_size(4);
		scroll->box(FL_FLAT_BOX);
		scroll->color(FL_BLACK);
		scroll->type(Fl_Scroll::VERTICAL);
		scroll->end();
		scroll->hscrollbar.hide();
	end();
}

ListMenu::~ListMenu()
{
}

void	ListMenu::ScrollToItem(Fl_Widget *wid)
{
	int extent = wid->y() + wid->h();
	if(extent > scroll->y() + scroll->h())
	{
		scroll->scroll_to(0, scroll->yposition() + wid->h());
	}
	if(wid->y() < scroll->y())
	{
		scroll->scroll_to(0, scroll->yposition() - wid->h());
	}
}

int	ListMenu::handle(int event)
{
int	loop;

	int flag = 0;
	switch(event)
	{
		case(FL_FOCUS):
		{
			color(DARK_RED);
			if(item_cnt > 0)
			{
				if(current_item < 0)
				{
					current_item = 0;
				}
				if(current_item > -1)
				{
					if(item[current_item]->color() != DARK_GRAY)
					{
						item[current_item]->color(DARK_GRAY);
						item[current_item]->do_callback(item[current_item], my_window);
					}
				}
			}
			redraw();
			flag = 1;
		}
		break;
		case(FL_UNFOCUS):
		{
			color(FL_BLACK);
			redraw();
			flag = 1;
		}
		break;
		case(FL_KEYBOARD):
		{
			int key = Fl::event_key();
			if(key == FL_Down)
			{
				if(current_item < (item_cnt - 1))
				{
					item[current_item]->color(FL_BLACK);
					current_item++;
					item[current_item]->color(DARK_GRAY);
					ScrollToItem(item[current_item]);
					item[current_item]->do_callback(item[current_item], my_window);
					redraw();
				}
				flag = 1;
			}
			else if(key == FL_Up)
			{
				if(current_item > 0)
				{
					item[current_item]->color(FL_BLACK);
					current_item--;
					item[current_item]->color(DARK_GRAY);
					ScrollToItem(item[current_item]);
					item[current_item]->do_callback(item[current_item], my_window);
					redraw();
				}
				flag = 1;
			}
		}
		break;
		case(FL_PUSH):
		{
			for(loop = 0;loop < item_cnt;loop++)
			{
				if(Fl::event_inside(item[loop]))
				{
					item[current_item]->color(FL_BLACK);
					current_item = loop;
					item[current_item]->color(DARK_GRAY);
					item[current_item]->do_callback(item[current_item], my_window);
					redraw();
					take_focus();
				}
			}
			flag = 1;
		}
		break;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	ListMenu::Add(Fl_Widget *wid)
{
	scroll->add(wid);
	item[item_cnt] = wid;
	item_cnt++;
	current_item = 0;
}

void	ListMenu::Clear()
{
	scroll->clear();
	current_item = -1;
	item_cnt = 0;
}

CodecSelectionWindow::CodecSelectionWindow() : Fl_Double_Window(300, 100, 620, Fl::h() - 200)
{
	strcpy(container_selected, "");
	strcpy(extension_selected, "");
	strcpy(audio_codec_selected, "");
	strcpy(video_codec_selected, "");

	audio_codec_id = (AVCodecID)0;
	video_codec_id = (AVCodecID)0;

	color(FL_BLACK);
	box(FL_FLAT_BOX);
	border(0);
	
	container = new ListMenu(this, 0, 0, 200, h() - 2, "Container Format");
	video_codec = new ListMenu(this, 210, 0, 200, h() - 2, "Video Codec");
	video_codec->hide();
	audio_codec = new ListMenu(this, 420, 0, 200, h() - 2, "Audio Codec");
	audio_codec->hide();

	end();

	outcome = new Fl_Double_Window(x() + 220, y() + 20, 80, 40);
	outcome->box(FL_FLAT_BOX);
	outcome->border(0);
	outcome->color(FL_BLACK);
		cancel = new Fl_Button(0, 0, 80, 20, "Cancel");
		cancel->box(FL_FLAT_BOX);
		cancel->labelcolor(FL_YELLOW);
		cancel->color(FL_BLACK);
		cancel->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		cancel->callback(csw_outcome_cancel_cb, this);
		cancel->show();

		accept = new Fl_Button(0, 20, 80, 20, "Accept");
		accept->box(FL_FLAT_BOX);
		accept->labelcolor(FL_YELLOW);
		accept->color(FL_BLACK);
		accept->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		accept->callback(csw_outcome_accept_cb, this);
		accept->show();
	outcome->end();
	outcome->show();

	callback(codec_selection_window_cb, this);
}

CodecSelectionWindow::~CodecSelectionWindow()
{
	outcome->hide();
}

void	select_audio_codec_cb(Fl_Widget *w, void *v)
{
int	loop;

	Fl_Button *b = (Fl_Button *)w;
	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	strcpy(csw->audio_codec_selected, b->label());
}

void	select_video_codec_cb(Fl_Widget *w, void *v)
{
int	loop;

	Fl_Button *b = (Fl_Button *)w;
	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	strcpy(csw->video_codec_selected, b->label());
}

void	codecs_menu_cb(Fl_Widget *w, void *v)
{
int	loop;

	Fl_Button *b = (Fl_Button *)w;
	CodecSelectionWindow *csw = (CodecSelectionWindow *)v;
	if(csw != NULL)
	{
		char *format_name = (char *)b->label();
		int done = -1;
		MyFormat *mf = NULL;
		for(loop = 0;((loop < global_my_format_cnt) && (done == -1));loop++)
		{
			MyFormat *test_mf = global_my_format[loop];
			if(strcmp(format_name, test_mf->name) == 0)
			{
				done = loop;
				mf = test_mf;
			}
		}
		if(mf != NULL)
		{
			strcpy(csw->container_selected, mf->name);
			strcpy(csw->extension_selected, mf->extensions);
			strcpy(csw->video_codec_selected, "");
			strcpy(csw->audio_codec_selected, "");
			csw->resize(csw->x(), csw->y(), 620, csw->h());
			int yy = 26;
			csw->video_codec->Clear();
			for(loop = 0;loop < mf->video_codec_cnt;loop++)
			{
				if(mf->video_id[loop] != 0)
				{
					Fl_Toggle_Button *video_button = new Fl_Toggle_Button(4, yy, 192, 20, mf->video_codec[loop]);
					video_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					video_button->box(FL_FLAT_BOX);
					video_button->color(FL_BLACK);
					video_button->down_color(DARK_GRAY);
					video_button->labelcolor(FL_YELLOW);
					video_button->type(FL_RADIO_BUTTON);
					video_button->clear_visible_focus();
					video_button->callback(select_video_codec_cb, csw);
					csw->video_codec->Add(video_button);
					if(mf->video_codec_cnt == 1)
					{
						video_button->value(1);
						select_video_codec_cb(video_button, csw);
					}
					yy += 20;
				}
			}
			csw->video_codec->redraw();
			csw->video_codec->show();
			yy = 26;
			csw->audio_codec->Clear();
			for(loop = 0;loop < mf->audio_codec_cnt;loop++)
			{
				if(mf->audio_id[loop] != 0)
				{
					Fl_Toggle_Button *audio_button = new Fl_Toggle_Button(4, yy, 192, 20, mf->audio_codec[loop]);
					audio_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					audio_button->box(FL_FLAT_BOX);
					audio_button->color(FL_BLACK);
					audio_button->labelcolor(FL_YELLOW);
					audio_button->down_color(FL_GRAY);
					audio_button->type(FL_RADIO_BUTTON);
					audio_button->clear_visible_focus();
					audio_button->callback(select_audio_codec_cb, csw);
					csw->audio_codec->Add(audio_button);
					if(mf->audio_codec_cnt == 1)
					{
						audio_button->value(1);
						select_audio_codec_cb(audio_button, csw);
					}
					yy += 20;
				}
			}
			csw->audio_codec->redraw();
			csw->audio_codec->show();
			csw->outcome->resize(csw->x() + csw->w() + 20, csw->y() + 20, 80, 40);
		}
	}
}

void	container_menu_cb(Fl_Widget *w, void *v)
{
int		loop;

	MyWin *win = (MyWin *)v;
	if(win->codec_selection_window == NULL)
	{
		win->codec_selection_window = new CodecSelectionWindow();
	}
	CodecSelectionWindow *cs = win->codec_selection_window;
	strcpy(cs->container_selected, "");
	strcpy(cs->extension_selected, "");
	strcpy(cs->audio_codec_selected, "");
	strcpy(cs->video_codec_selected, "");
	cs->container->Clear();
	int yy = 26;
	for(loop = 0;loop < global_my_format_cnt;loop++)
	{
		MyFormat *mf = global_my_format[loop];
		if(mf->invalid == 0)
		{
			Fl_Toggle_Button *button = new Fl_Toggle_Button(4, yy, 176, 20, mf->name);
			button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
			button->box(FL_FLAT_BOX);
			button->color(FL_BLACK);
			button->down_color(FL_GRAY);
			button->labelcolor(FL_YELLOW);
			button->type(FL_RADIO_BUTTON);
			button->clear_visible_focus();
			button->callback(codecs_menu_cb, cs);
			button->redraw();
			cs->container->Add(button);
			yy += 20;
		}
	}
	cs->resize(cs->x(), cs->y(), 200, cs->h());
	cs->show();
	cs->video_codec->hide();
	cs->audio_codec->hide();
	cs->outcome->show();
}

void	encode_speed_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Fl_Button *b = (Fl_Button *)w;
	char *lbl = (char *)b->label();
	if(lbl != NULL)
	{
		int nn = atoi(lbl);
		for(loop = 0;loop < 128;loop++)
		{
			if(win->my_muxer[loop] != NULL)
			{
				win->my_muxer[loop]->realtime_factor = nn;
			}
		}
	}
}

EncodeSpeedWindow::EncodeSpeedWindow(MyWin *in_win, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
int	loop;

	box(FL_NO_BOX);
	my_window = in_win;
	int px = xx;
	int val = -32;
	for(loop = 0;loop < 11;loop++)
	{
		if(val == 0) val = 1;
		sprintf(label_buf[loop], "%d", val);
		button[loop] = new Fl_Button(px, yy, 16, 16, label_buf[loop]);
		button[loop]->labelsize(8);
		button[loop]->color(DARK_GRAY);
		button[loop]->labelcolor(FL_WHITE);
		button[loop]->down_color(FL_GRAY);
		button[loop]->box(FL_FLAT_BOX);
		button[loop]->type(FL_RADIO_BUTTON);
		button[loop]->clear_visible_focus();
		button[loop]->callback(encode_speed_cb, my_window);
		if(val == 1)
		{
			button[loop]->value(1);
		}
		px += 15;
		if(val < 0)
		{
			val += abs(val) / 2;
			if(val == -1) val = 0;
		}
		else
		{
			val += abs(val);
		}
	}
	end();
	hide();
}

EncodeSpeedWindow::~EncodeSpeedWindow()
{
}

void	EncodeSpeedWindow::Reset()
{
int	loop;

	for(loop = 0;loop < 11;loop++)
	{
		button[loop]->value(0);
	}
	button[5]->value(1);
	for(loop = 0;loop < 128;loop++)
	{
		if(my_window->my_muxer[loop] != NULL)
		{
			my_window->my_muxer[loop]->realtime_factor = 1;
		}
	}
}

void	open_standalone_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	Camera *now_cam = win->DisplayedCamera();
	if(now_cam != NULL)
	{
		StandaloneDisplay *sd = new StandaloneDisplay(now_cam, now_cam->width, now_cam->height, "Standalone");
		sd->end();
		sd->show();
		now_cam->standalone_display = sd;
	}
}

void	command_key_value_button_cb(Fl_Widget *w, void *v)
{
	CommandKeyGroup *ckg = (CommandKeyGroup *)v;
	ckg->my_window->CloseAll();
	ckg->value_button->hide();
	ckg->value_input->show();
	ckg->value_menu->show();
	ckg->redraw();
}

void	command_key_input_cb(Fl_Widget *w, void *v)
{
	CommandKeyGroup *ckg = (CommandKeyGroup *)v;
	ckg->my_window->CloseAll();
	ckg->value_button->label(ckg->value_input->value());
	ckg->value_menu->value(-1);
	ckg->redraw();
}

void	command_key_menu_cb(Fl_Widget *w, void *v)
{
	CommandKeyGroup *ckg = (CommandKeyGroup *)v;
	ckg->my_window->CloseAll();
	ckg->value_button->label(ckg->value_menu->text(ckg->value_menu->value()));
	ckg->value_input->value("");
	ckg->redraw();
}

CommandKeyGroup::CommandKeyGroup(CommandKeySettingsWindow *in_win, int xx, int yy, int in_ww, int in_hh, char *lbl, char *val) : Fl_Group(xx, yy, in_ww, in_hh)
{
	my_window = in_win;
	if(val == NULL) val = "";
	int ww = in_ww - 40;
	int hh = in_hh;
	lbl_box = new Fl_Box(xx + 20, yy, ww / 2, hh, lbl);
	lbl_box->labelsize(9);
	lbl_box->labelcolor(FL_WHITE);
	lbl_box->align(FL_ALIGN_INSIDE | FL_ALIGN_RIGHT);
	value_input = new Fl_Input(xx + ((ww / 2) + 25), yy + 1, 50 - 2, hh - 2);
	value_input->textsize(9);
	value_input->box(FL_FLAT_BOX);
	value_input->callback(command_key_input_cb, this);
	value_input->hide();
	if(strlen(val) == 1)
	{
		value_input->value(val);
	}
	value_menu = new Fl_Choice(xx + ((ww / 2) + 75), yy + 1, (ww / 4) - 2, hh - 2);
	value_menu->textsize(9);
	value_menu->box(FL_FLAT_BOX);
	value_menu->callback(command_key_menu_cb, this);
	value_menu->hide();

	// Cover both of the other widgets until it is pressed
	value_button = new Fl_Button(xx + ((ww / 2) + 25) + 1, yy + 1, 50 + (ww / 4) - 2, hh - 2);
	value_button->labelsize(11);
	value_button->box(FL_FLAT_BOX);
	value_button->color(FL_WHITE);
	value_button->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	value_button->label(strdup(val));
	value_button->callback(command_key_value_button_cb, this);

	int cnt = 0;
	int done = 0;
	while(done == 0)
	{
		if(named_key[cnt].val != 0)
		{
			char *str = named_key[cnt].name;
			value_menu->add(str);
		}
		else
		{
			done = 1;
		}
		cnt++;
	}
	if(strlen(val) > 1)
	{
		int nn = value_menu->find_index(val);
		if(nn > -1)
		{
			value_menu->value(nn);
		}
	}
	end();
}

CommandKeyGroup::~CommandKeyGroup()
{
}

void	CommandKeyGroup::value(char *val)
{
	if(strlen(val) == 1)
	{
		value_input->value(val);
	}
	if(strlen(val) > 1)
	{
		int nn = value_menu->find_index(val);
		if(nn > -1)
		{
			value_menu->value(nn);
		}
	}
	value_button->label(strdup(val));
}

void	CommandKeyGroup::Close()
{
	value_button->show();
	value_input->hide();
	value_menu->hide();
}

void	command_key_window_accept(Fl_Widget *w, void *v)
{
	CommandKeySettingsWindow *cksw = (CommandKeySettingsWindow *)v;
	cksw->hide();
}

void	command_key_window_cancel(Fl_Widget *w, void *v)
{
	CommandKeySettingsWindow *cksw = (CommandKeySettingsWindow *)v;
	cksw->hide();
}

void	command_key_window_reset(Fl_Widget *w, void *v)
{
int	loop;

	CommandKeySettingsWindow *cksw = (CommandKeySettingsWindow *)v;
	for(loop = 0;loop < cksw->command_key_cnt;loop++)
	{
		char *str = cksw->my_window->CommandKeyName(cksw->my_window->command_key[loop]);
		if(str != NULL)
		{
			cksw->command_key_group[loop]->value(str);
			cksw->command_key_group[loop]->redraw();
		}
	}
	cksw->redraw();
}

CommandKeySettingsWindow::CommandKeySettingsWindow(MyWin *in_win, int ww, int hh) : Fl_Window(ww, hh, "Key Bindings")
{
	my_window = in_win;
	int cnt = 0;
	int y_pos = 20;
	box(FL_FLAT_BOX);
	color(FL_BLACK);
	char *str = NULL;
	ww = 280;
	str = my_window->CommandKeyName(my_window->command_key[KEY_TOGGLE_RECORD]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "TOGGLE RECORD", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DELETE_IMMEDIATE]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DELETE IMMEDIATE", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_TOGGLE_PTZ_JOYSTICK]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "TOGGLE PTZ JOYSTICK", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_INCREASE_PTZ_LITTLE_SPEED]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "INCREASE PTZ LITTLE SPEED", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DECREASE_PTZ_LITTLE_SPEED]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DECREASE PTZ LITTLE SPEED", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_CYCLE_PTZ_LITTLE_MODE]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "CYCLE PTZ LITTLE MODE", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_PTZ_HOME]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "PTZ HOME", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_CYCLE_DOWN_THUMBGROUP]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "CYCLE DOWN THUMBGROUP", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_CYCLE_UP_THUMBGROUP]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "CYCLE UP THUMBGROUP", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_0]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 0", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_1]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 1", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_2]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 2", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_3]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 3", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_4]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 4", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_5]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 5", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_6]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 6", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_7]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 7", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_8]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 8", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_THUMBGROUP_9]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY THUMBGROUP 9", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_1]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 1", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_2]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 2", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_3]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 3", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_4]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 4", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_5]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 5", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_6]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 6", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_7]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 7", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_8]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION 8", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_1]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 1", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_2]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 2", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_3]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 3", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_4]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 4", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_5]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 5", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_6]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 6", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_7]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 7", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LITTLE_MOTION_OTHER_8]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LITTLE MOTION OTHER 8", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LOCAL_ZOOM_IN]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LOCAL ZOOM IN", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_LOCAL_ZOOM_OUT]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "LOCAL ZOOM OUT", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_REVIEW]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "REVIEW", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_TOGGLE_FROZEN]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "TOGGLE FROZEN", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SNAPSHOT]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SNAPSHOT", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SNAPSHOT_OTHER]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SNAPSHOT OTHER", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SCALE_VIDEO_RESET]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SCALE VIDEO RESET", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SCALE_VIDEO_UP]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SCALE VIDEO UP", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_SCALE_VIDEO_DOWN]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "SCALE VIDEO DOWN", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_0]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 0", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_1]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 1", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_2]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 2", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_3]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 3", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_4]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 4", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_5]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 5", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_6]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 6", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_7]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 7", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_8]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 8", str); cnt++; y_pos += 18;

	str = my_window->CommandKeyName(my_window->command_key[KEY_DISPLAY_SPLIT_SELECTION_9]);
	command_key_group[cnt] = new CommandKeyGroup(this, 10, y_pos, ww, 18, "DISPLAY SPLIT SELECTION 9", str); cnt++; y_pos += 18;

	command_key_cnt = cnt;

	int ny_pos = 21;
	accept = new Fl_Button(270, ny_pos, 80, 16, "Accept");
	accept->box(FL_FLAT_BOX);
	accept->color(FL_YELLOW);
	accept->labelsize(11);
	accept->callback(command_key_window_accept, this);
	ny_pos += 18;
	
	cancel = new Fl_Button(270, ny_pos, 80, 16, "Cancel");
	cancel->box(FL_FLAT_BOX);
	cancel->color(FL_YELLOW);
	cancel->labelsize(11);
	cancel->callback(command_key_window_cancel, this);
	ny_pos += 18;

	reset = new Fl_Button(270, ny_pos, 80, 16, "Reset");
	reset->box(FL_FLAT_BOX);
	reset->color(FL_YELLOW);
	reset->labelsize(11);
	reset->callback(command_key_window_reset, this);

	resize(x(), y(), w(), y_pos + 20);
	end();
}

CommandKeySettingsWindow::~CommandKeySettingsWindow()
{
}

void	CommandKeySettingsWindow::CloseAll()
{
int	loop;

	for(loop = 0;loop < command_key_cnt;loop++)
	{
		command_key_group[loop]->Close();
	}
}

void	MyWin::ResetCommandKeys()
{
	command_key[KEY_TOGGLE_RECORD] = ' ';
	command_key[KEY_DELETE_IMMEDIATE] = FL_Delete;
	command_key[KEY_TOGGLE_PTZ_JOYSTICK] = 'j';
	command_key[KEY_INCREASE_PTZ_LITTLE_SPEED] = FL_KP + '+';
	command_key[KEY_DECREASE_PTZ_LITTLE_SPEED] = FL_KP + '-';
	command_key[KEY_CYCLE_PTZ_LITTLE_MODE] = FL_KP_Enter;
	command_key[KEY_PTZ_HOME] = FL_Home;
	command_key[KEY_CYCLE_DOWN_THUMBGROUP] = FL_Down;
	command_key[KEY_CYCLE_UP_THUMBGROUP] = FL_Up;
	command_key[KEY_DISPLAY_THUMBGROUP_0] = '0';
	command_key[KEY_DISPLAY_THUMBGROUP_1] = '1';
	command_key[KEY_DISPLAY_THUMBGROUP_2] = '2';
	command_key[KEY_DISPLAY_THUMBGROUP_3] = '3';
	command_key[KEY_DISPLAY_THUMBGROUP_4] = '4';
	command_key[KEY_DISPLAY_THUMBGROUP_5] = '5';
	command_key[KEY_DISPLAY_THUMBGROUP_6] = '6';
	command_key[KEY_DISPLAY_THUMBGROUP_7] = '7';
	command_key[KEY_DISPLAY_THUMBGROUP_8] = '8';
	command_key[KEY_DISPLAY_THUMBGROUP_9] = '9';
	command_key[KEY_LITTLE_MOTION_1] = FL_KP + '1';
	command_key[KEY_LITTLE_MOTION_2] = FL_KP + '2';
	command_key[KEY_LITTLE_MOTION_3] = FL_KP + '3';
	command_key[KEY_LITTLE_MOTION_4] = FL_KP + '4';
	command_key[KEY_LITTLE_MOTION_5] = FL_KP + '6';
	command_key[KEY_LITTLE_MOTION_6] = FL_KP + '7';
	command_key[KEY_LITTLE_MOTION_7] = FL_KP + '8';
	command_key[KEY_LITTLE_MOTION_8] = FL_KP + '9';
	command_key[KEY_LITTLE_MOTION_OTHER_1] = 'w';
	command_key[KEY_LITTLE_MOTION_OTHER_2] = 'a';
	command_key[KEY_LITTLE_MOTION_OTHER_3] = 's';
	command_key[KEY_LITTLE_MOTION_OTHER_4] = 'd';
	command_key[KEY_LITTLE_MOTION_OTHER_5] = 'q';
	command_key[KEY_LITTLE_MOTION_OTHER_6] = 'e';
	command_key[KEY_LITTLE_MOTION_OTHER_7] = 'z';
	command_key[KEY_LITTLE_MOTION_OTHER_8] = 'x';
	command_key[KEY_LOCAL_ZOOM_IN] = '='; // NOTE: SHIFTED TO PRODUCE '+'
	command_key[KEY_LOCAL_ZOOM_OUT] = '-';
	command_key[KEY_REVIEW] = '.';
	command_key[KEY_TOGGLE_FROZEN] = FL_Pause;
	command_key[KEY_SNAPSHOT] = FL_Print;
	command_key[KEY_SNAPSHOT_OTHER] = 'p';
	command_key[KEY_SCALE_VIDEO_UP] = FL_Page_Up;
	command_key[KEY_SCALE_VIDEO_DOWN] = FL_Page_Down;
	command_key[KEY_SCALE_VIDEO_RESET] = FL_End;
	command_key[KEY_DISPLAY_SPLIT_SELECTION_0] = '0';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_1] = '1';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_2] = '2';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_3] = '3';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_4] = '4';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_5] = '5';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_6] = '6';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_7] = '7';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_8] = '8';
	command_key[KEY_DISPLAY_SPLIT_SELECTION_9] = '9';
}

int	MyWin::CheckCommandTitle(char *name)
{
	int nn = -1;
	if(strcasecmp("TOGGLE RECORD", name) == 0) nn = KEY_TOGGLE_RECORD;
	if(strcasecmp("DELETE IMMEDIATE", name) == 0) nn = KEY_DELETE_IMMEDIATE;
	if(strcasecmp("TOGGLE PTZ JOYSTICK", name) == 0) nn = KEY_TOGGLE_PTZ_JOYSTICK;
	if(strcasecmp("INCREASE PTZ LITTLE SPEED", name) == 0) nn = KEY_INCREASE_PTZ_LITTLE_SPEED;
	if(strcasecmp("DECREASE PTZ LITTLE SPEED", name) == 0) nn = KEY_DECREASE_PTZ_LITTLE_SPEED;
	if(strcasecmp("CYCLE PTZ LITTLE MODE", name) == 0) nn = KEY_CYCLE_PTZ_LITTLE_MODE;
	if(strcasecmp("PTZ HOME", name) == 0) nn = KEY_PTZ_HOME;
	if(strcasecmp("CYCLE DOWN THUMBGROUP", name) == 0) nn = KEY_CYCLE_DOWN_THUMBGROUP;
	if(strcasecmp("CYCLE UP THUMBGROUP", name) == 0) nn = KEY_CYCLE_UP_THUMBGROUP;
	if(strcasecmp("DISPLAY THUMBGROUP 0", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_0;
	if(strcasecmp("DISPLAY THUMBGROUP 1", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_1;
	if(strcasecmp("DISPLAY THUMBGROUP 2", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_2;
	if(strcasecmp("DISPLAY THUMBGROUP 3", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_3;
	if(strcasecmp("DISPLAY THUMBGROUP 4", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_4;
	if(strcasecmp("DISPLAY THUMBGROUP 5", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_5;
	if(strcasecmp("DISPLAY THUMBGROUP 6", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_6;
	if(strcasecmp("DISPLAY THUMBGROUP 7", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_7;
	if(strcasecmp("DISPLAY THUMBGROUP 8", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_8;
	if(strcasecmp("DISPLAY THUMBGROUP 9", name) == 0) nn = KEY_DISPLAY_THUMBGROUP_9;
	if(strcasecmp("LITTLE MOTION 1", name) == 0) nn = KEY_LITTLE_MOTION_1;
	if(strcasecmp("LITTLE MOTION 2", name) == 0) nn = KEY_LITTLE_MOTION_2;
	if(strcasecmp("LITTLE MOTION 3", name) == 0) nn = KEY_LITTLE_MOTION_3;
	if(strcasecmp("LITTLE MOTION 4", name) == 0) nn = KEY_LITTLE_MOTION_4;
	if(strcasecmp("LITTLE MOTION 5", name) == 0) nn = KEY_LITTLE_MOTION_5;
	if(strcasecmp("LITTLE MOTION 6", name) == 0) nn = KEY_LITTLE_MOTION_6;
	if(strcasecmp("LITTLE MOTION 7", name) == 0) nn = KEY_LITTLE_MOTION_7;
	if(strcasecmp("LITTLE MOTION 8", name) == 0) nn = KEY_LITTLE_MOTION_8;
	if(strcasecmp("LITTLE MOTION OTHER 1", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_1;
	if(strcasecmp("LITTLE MOTION OTHER 2", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_2;
	if(strcasecmp("LITTLE MOTION OTHER 3", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_3;
	if(strcasecmp("LITTLE MOTION OTHER 4", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_4;
	if(strcasecmp("LITTLE MOTION OTHER 5", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_5;
	if(strcasecmp("LITTLE MOTION OTHER 6", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_6;
	if(strcasecmp("LITTLE MOTION OTHER 7", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_7;
	if(strcasecmp("LITTLE MOTION OTHER 8", name) == 0) nn = KEY_LITTLE_MOTION_OTHER_8;
	if(strcasecmp("LOCAL ZOOM IN", name) == 0) nn = KEY_LOCAL_ZOOM_IN;
	if(strcasecmp("LOCAL ZOOM OUT", name) == 0) nn = KEY_LOCAL_ZOOM_OUT;
	if(strcasecmp("REVIEW", name) == 0) nn = KEY_REVIEW;
	if(strcasecmp("TOGGLE FROZEN", name) == 0) nn = KEY_TOGGLE_FROZEN;
	if(strcasecmp("SNAPSHOT", name) == 0) nn = KEY_SNAPSHOT;
	if(strcasecmp("SNAPSHOT OTHER", name) == 0) nn = KEY_SNAPSHOT_OTHER;
	if(strcasecmp("DISPLAY SPLIT SELECTION 0", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_0;
	if(strcasecmp("DISPLAY SPLIT SELECTION 1", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_1;
	if(strcasecmp("DISPLAY SPLIT SELECTION 2", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_2;
	if(strcasecmp("DISPLAY SPLIT SELECTION 3", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_3;
	if(strcasecmp("DISPLAY SPLIT SELECTION 4", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_4;
	if(strcasecmp("DISPLAY SPLIT SELECTION 5", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_5;
	if(strcasecmp("DISPLAY SPLIT SELECTION 6", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_6;
	if(strcasecmp("DISPLAY SPLIT SELECTION 7", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_7;
	if(strcasecmp("DISPLAY SPLIT SELECTION 8", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_8;
	if(strcasecmp("DISPLAY SPLIT SELECTION 9", name) == 0) nn = KEY_DISPLAY_SPLIT_SELECTION_9;
	return(nn);
}

char	*MyWin::CommandKeyName(int nn)
{
static char	buf[32];

	char *str = NULL;
	int cnt = 0;
	int done = 0;
	while(done == 0)
	{
		if(named_key[cnt].val != 0)
		{
			if(named_key[cnt].val == nn)
			{
				str = named_key[cnt].name;
				done = 1;
			}
		}
		else
		{
			done = 1;
		}
		cnt++;
	}
	if(str == NULL)
	{
		sprintf(buf, "%c", nn);
		str = buf;
	}
	return(str);
}

void	MyWin::SaveCommandKeyDefinitions(char *filename)
{
	FILE *fp = fopen(filename, "w");
	if(fp != NULL)
	{
		fprintf(fp, "TOGGLE RECORD\t%s\n", CommandKeyName(command_key[KEY_TOGGLE_RECORD]));
		fprintf(fp, "DELETE IMMEDIATE\t%s\n", CommandKeyName(command_key[KEY_DELETE_IMMEDIATE]));
		fprintf(fp, "TOGGLE PTZ JOYSTICK\t%s\n", CommandKeyName(command_key[KEY_TOGGLE_PTZ_JOYSTICK]));
		fprintf(fp, "INCREASE PTZ LITTLE SPEED\t%s\n", CommandKeyName(command_key[KEY_INCREASE_PTZ_LITTLE_SPEED]));
		fprintf(fp, "DECREASE PTZ LITTLE SPEED\t%s\n", CommandKeyName(command_key[KEY_DECREASE_PTZ_LITTLE_SPEED]));
		fprintf(fp, "CYCLE PTZ LITTLE MODE\t%s\n", CommandKeyName(command_key[KEY_CYCLE_PTZ_LITTLE_MODE]));
		fprintf(fp, "PTZ HOME\t%s\n", CommandKeyName(command_key[KEY_PTZ_HOME]));
		fprintf(fp, "CYCLE DOWN THUMBGROUP\t%s\n", CommandKeyName(command_key[KEY_CYCLE_DOWN_THUMBGROUP]));
		fprintf(fp, "CYCLE UP THUMBGROUP\t%s\n", CommandKeyName(command_key[KEY_CYCLE_UP_THUMBGROUP]));
		fprintf(fp, "DISPLAY THUMBGROUP 0\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_0]));
		fprintf(fp, "DISPLAY THUMBGROUP 1\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_1]));
		fprintf(fp, "DISPLAY THUMBGROUP 2\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_2]));
		fprintf(fp, "DISPLAY THUMBGROUP 3\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_3]));
		fprintf(fp, "DISPLAY THUMBGROUP 4\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_4]));
		fprintf(fp, "DISPLAY THUMBGROUP 5\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_5]));
		fprintf(fp, "DISPLAY THUMBGROUP 6\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_6]));
		fprintf(fp, "DISPLAY THUMBGROUP 7\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_7]));
		fprintf(fp, "DISPLAY THUMBGROUP 8\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_8]));
		fprintf(fp, "DISPLAY THUMBGROUP 9\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_THUMBGROUP_9]));
		fprintf(fp, "LITTLE MOTION 1\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_1]));
		fprintf(fp, "LITTLE MOTION 2\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_2]));
		fprintf(fp, "LITTLE MOTION 3\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_3]));
		fprintf(fp, "LITTLE MOTION 4\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_4]));
		fprintf(fp, "LITTLE MOTION 5\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_5]));
		fprintf(fp, "LITTLE MOTION 6\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_6]));
		fprintf(fp, "LITTLE MOTION 7\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_7]));
		fprintf(fp, "LITTLE MOTION 8\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_8]));
		fprintf(fp, "LITTLE MOTION OTHER 1\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_1]));
		fprintf(fp, "LITTLE MOTION OTHER 2\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_2]));
		fprintf(fp, "LITTLE MOTION OTHER 3\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_3]));
		fprintf(fp, "LITTLE MOTION OTHER 4\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_4]));
		fprintf(fp, "LITTLE MOTION OTHER 5\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_5]));
		fprintf(fp, "LITTLE MOTION OTHER 6\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_6]));
		fprintf(fp, "LITTLE MOTION OTHER 7\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_7]));
		fprintf(fp, "LITTLE MOTION OTHER 8\t%s\n", CommandKeyName(command_key[KEY_LITTLE_MOTION_OTHER_8]));
		fprintf(fp, "LOCAL ZOOM IN\t%s\n", CommandKeyName(command_key[KEY_LOCAL_ZOOM_IN]));
		fprintf(fp, "LOCAL ZOOM OUT\t%s\n", CommandKeyName(command_key[KEY_LOCAL_ZOOM_OUT]));
		fprintf(fp, "REVIEW\t%s\n", CommandKeyName(command_key[KEY_REVIEW]));
		fprintf(fp, "TOGGLE FROZEN\t%s\n", CommandKeyName(command_key[KEY_TOGGLE_FROZEN]));
		fprintf(fp, "SNAPSHOT\t%s\n", CommandKeyName(command_key[KEY_SNAPSHOT]));
		fprintf(fp, "SNAPSHOT OTHER\t%s\n", CommandKeyName(command_key[KEY_SNAPSHOT_OTHER]));
		fprintf(fp, "SCALE VIDEO UP\t%s\n", CommandKeyName(command_key[KEY_SCALE_VIDEO_UP]));
		fprintf(fp, "SCALE VIDEO DOWN\t%s\n", CommandKeyName(command_key[KEY_SCALE_VIDEO_DOWN]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 0\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 1\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 2\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 3\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 4\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 5\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 6\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 7\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 8\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fprintf(fp, "DISPLAY SPLIT SELECTION 9\t%s\n", CommandKeyName(command_key[KEY_DISPLAY_SPLIT_SELECTION_0]));
		fclose(fp);
	}
}

void	MyWin::ReadCommandKeyDefinitions(char *filename)
{
char	buf[256];

	FILE *fp = fopen(filename, "r");
	if(fp != NULL)
	{
		while(fgets(buf, 255, fp) != NULL)
		{
			strip_lf(buf);
			char *cp = buf;
			char *definition = NULL;
			char *title = cp;
			int shifted = 0;
			int alted = 0;
			int ctrled = 0;
			int done = 0;
			while((definition == NULL) && (done == 0))
			{
				while((*cp != '\t') && (*cp != '\0'))
				{
					cp++;
				}
				if(*cp == '\t')
				{
					*cp = '\0';
					cp++;
					char *str = cp;
					if(strncasecmp(str, "[shift]", strlen("[shift]")) == 0)
					{
						shifted = 1;
					}
					else if(strncasecmp(str, "[alt]", strlen("[alt]")) == 0)
					{
						alted = 1;
					}
					else if(strncasecmp(str, "[ctrl]", strlen("[ctrl]")) == 0)
					{
						ctrled = 1;
					}
					else
					{
						definition = cp;
					}
				}
				else if(*cp == '\0')
				{
					done = 1;
				}
			}
			if(strlen(title) > 0)
			{
				int nn = CheckCommandTitle(title);
				if(nn > -1)
				{
					if(definition != NULL)
					{
						if(strlen(definition) == 1)
						{
							command_key[nn] = *definition;
						}
						else if(strlen(definition) > 1)
						{
							if(strcasecmp(definition, "Alt L") == 0) command_key[nn] = 0xffe9;
							if(strcasecmp(definition, "Alt R") == 0) command_key[nn] = 0xffea;
							if(strcasecmp(definition, "Back") == 0) command_key[nn] = 0xEF26;
							if(strcasecmp(definition, "BackSpace") == 0) command_key[nn] = 0xff08;
							if(strcasecmp(definition, "Button") == 0) command_key[nn] = 0xfee8;
							if(strcasecmp(definition, "Caps Lock") == 0) command_key[nn] = 0xffe5;
							if(strcasecmp(definition, "Control L") == 0) command_key[nn] = 0xffe3;
							if(strcasecmp(definition, "Control R") == 0) command_key[nn] = 0xffe4;
							if(strcasecmp(definition, "Delete") == 0) command_key[nn] = 0xffff;
							if(strcasecmp(definition, "Down") == 0) command_key[nn] = 0xff54;
							if(strcasecmp(definition, "Eisu") == 0) command_key[nn] = 0xff2f;
							if(strcasecmp(definition, "End") == 0) command_key[nn] = 0xff57;
							if(strcasecmp(definition, "Enter") == 0) command_key[nn] = 0xff0d;
							if(strcasecmp(definition, "Escape") == 0) command_key[nn] = 0xff1b;
							if(strcasecmp(definition, "Function 1") == 0) command_key[nn] = 0xffbd;
							if(strcasecmp(definition, "Function 2") == 0) command_key[nn] = 0xffbd+1;
							if(strcasecmp(definition, "Function 3") == 0) command_key[nn] = 0xffbd+2;
							if(strcasecmp(definition, "Function 4") == 0) command_key[nn] = 0xffbd+3;
							if(strcasecmp(definition, "Function 5") == 0) command_key[nn] = 0xffbd+4;
							if(strcasecmp(definition, "Function 6") == 0) command_key[nn] = 0xffbd+5;
							if(strcasecmp(definition, "Function 7") == 0) command_key[nn] = 0xffbd+6;
							if(strcasecmp(definition, "Function 8") == 0) command_key[nn] = 0xffbd+7;
							if(strcasecmp(definition, "Function 9") == 0) command_key[nn] = 0xffbd+8;
							if(strcasecmp(definition, "Function 10") == 0) command_key[nn] = 0xffbd+9;
							if(strcasecmp(definition, "Function 11") == 0) command_key[nn] = 0xffbd+10;
							if(strcasecmp(definition, "Function 12") == 0) command_key[nn] = 0xffbd+11;
							if(strcasecmp(definition, "Favorites") == 0) command_key[nn] = 0xEF30;
							if(strcasecmp(definition, "Forward") == 0) command_key[nn] = 0xEF27;
							if(strcasecmp(definition, "Help") == 0) command_key[nn] = 0xff68;
							if(strcasecmp(definition, "Home") == 0) command_key[nn] = 0xff50;
							if(strcasecmp(definition, "Home Page") == 0) command_key[nn] = 0xEF18;
							if(strcasecmp(definition, "Insert") == 0) command_key[nn] = 0xff63;
							if(strcasecmp(definition, "Iso Key") == 0) command_key[nn] = 0xff0c;
							if(strcasecmp(definition, "JIS Underscore") == 0) command_key[nn] = 0xff31;
							if(strcasecmp(definition, "Kana") == 0) command_key[nn] = 0xff2e;
							if(strcasecmp(definition, "KP 1") == 0) command_key[nn] = 0xff80 + '1';
							if(strcasecmp(definition, "KP 2") == 0) command_key[nn] = 0xff80 + '2';
							if(strcasecmp(definition, "KP 3") == 0) command_key[nn] = 0xff80 + '3';
							if(strcasecmp(definition, "KP 4") == 0) command_key[nn] = 0xff80 + '4';
							if(strcasecmp(definition, "KP 5") == 0) command_key[nn] = 0xff80 + '5';
							if(strcasecmp(definition, "KP 6") == 0) command_key[nn] = 0xff80 + '6';
							if(strcasecmp(definition, "KP 7") == 0) command_key[nn] = 0xff80 + '7';
							if(strcasecmp(definition, "KP 8") == 0) command_key[nn] = 0xff80 + '8';
							if(strcasecmp(definition, "KP 9") == 0) command_key[nn] = 0xff80 + '9';
							if(strcasecmp(definition, "KP 0") == 0) command_key[nn] = 0xff80 + '0';
							if(strcasecmp(definition, "KP +") == 0) command_key[nn] = 0xff80 + '+';
							if(strcasecmp(definition, "KP -") == 0) command_key[nn] = 0xff80 + '-';
							if(strcasecmp(definition, "KP Enter") == 0) command_key[nn] = 0xff8d;
							if(strcasecmp(definition, "Left") == 0) command_key[nn] = 0xff51;
							if(strcasecmp(definition, "Mail") == 0) command_key[nn] = 0xEF19;
							if(strcasecmp(definition, "Media Next") == 0) command_key[nn] = 0xEF17;
							if(strcasecmp(definition, "Media Play") == 0) command_key[nn] = 0xEF14;
							if(strcasecmp(definition, "Media Prev") == 0) command_key[nn] = 0xEF16;
							if(strcasecmp(definition, "Media Stop") == 0) command_key[nn] = 0xEF15;
							if(strcasecmp(definition, "Menu") == 0) command_key[nn] = 0xff67;
							if(strcasecmp(definition, "Meta L") == 0) command_key[nn] = 0xffe7;
							if(strcasecmp(definition, "Meta R") == 0) command_key[nn] = 0xffe8;
							if(strcasecmp(definition, "Num Lock") == 0) command_key[nn] = 0xff7f;
							if(strcasecmp(definition, "Page Down") == 0) command_key[nn] = 0xff56;
							if(strcasecmp(definition, "Page Up") == 0) command_key[nn] = 0xff55;
							if(strcasecmp(definition, "Pause") == 0) command_key[nn] = 0xff13;
							if(strcasecmp(definition, "Print") == 0) command_key[nn] = 0xff61;
							if(strcasecmp(definition, "Refresh") == 0) command_key[nn] = 0xEF29;
							if(strcasecmp(definition, "Right") == 0) command_key[nn] = 0xff53;
							if(strcasecmp(definition, "Scroll Lock") == 0) command_key[nn] = 0xff14;
							if(strcasecmp(definition, "Search") == 0) command_key[nn] = 0xEF1B;
							if(strcasecmp(definition, "Shift L") == 0) command_key[nn] = 0xffe1;
							if(strcasecmp(definition, "Shift R") == 0) command_key[nn] = 0xffe2;
							if(strcasecmp(definition, "Sleep") == 0) command_key[nn] = 0xEF2F;
							if(strcasecmp(definition, "Stop") == 0) command_key[nn] = 0xEF28;
							if(strcasecmp(definition, "Tab") == 0) command_key[nn] = 0xff09;
							if(strcasecmp(definition, "Up") == 0) command_key[nn] = 0xff52;
							if(strcasecmp(definition, "Volume Down") == 0) command_key[nn] = 0xEF11;
							if(strcasecmp(definition, "Volume Mute") == 0) command_key[nn] = 0xEF12;
							if(strcasecmp(definition, "Volume Up") == 0) command_key[nn] = 0xEF13;
							if(strcasecmp(definition, "Yen") == 0) command_key[nn] = 0xff30;
						}
					}
				}
			}
		}
		fclose(fp);
	}
}

int		MenuButton::handle(int event)
{
	int flag = 0;
	if(event == FL_ENTER)
	{
		hover = 1;
		redraw();
		window()->redraw();
		flag = 1;
	}
	else if(event == FL_LEAVE)
	{
		hover = 0;
		redraw();
		window()->redraw();
		flag = 1;
	}
	else if(event == FL_PUSH)
	{
		hover = 1;
		redraw();
		window()->redraw();
	}
	if(flag == 0)
	{
		flag = Fl_Button::handle(event);
	}
	return(flag);
}

void	MenuButton::draw()
{
	if(hover == 1)
	{
		labelcolor(FL_WHITE);
	}
	else
	{
		labelcolor(FL_YELLOW);
	}
	Fl_Button::draw();
}

void	MenuButton::show()
{
	Fl_Button::show();
	hover = 0;
}

void	MenuButton::hide()
{
	Fl_Button::hide();
	hover = 0;
}

void	MyWin::BuildMainMenu()
{
int	loop;

	int y_pos = 10;
	int y_inc = 22;
	start_win->Update("Initialize main menu");
	int font_sz = (int)(14.0 * gui_scale_factor);
	int button_height = (int)(20.0 * gui_scale_factor);

	int button_sz = (int)(180.0 * gui_scale_factor);
	button_panel_sz = (int)(200.0 * gui_scale_factor);
	button_group = new Fl_Window(w() - button_panel_sz, 0, button_panel_sz, h());
	button_group->box(FL_FLAT_BOX);
	button_group->color(DARK_GRAY);

	Fl_Pack *button_group_pack = new Fl_Pack(8, 0, button_panel_sz, h() - 30);
	button_group_pack->spacing(3);

	Fl_Box *spacer = new Fl_Box(8, y_pos, button_sz, button_height / 2);
	spacer->box(FL_NO_BOX);
	y_pos += (y_inc / 2);

	record_button = new MenuButton(8, y_pos, button_sz, button_height, "Record");
	record_button->box(FL_NO_BOX);
	record_button->labelcolor(FL_YELLOW);
	record_button->labelsize(font_sz);
	record_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	record_button->callback(record_button_cb, this);
	if(use_old == 1)
	{
		record_button->hide();
	}
	y_pos += button_height;

	encode_speed_window = new EncodeSpeedWindow(this, 8, y_pos, button_sz, 16);
	y_pos += y_inc;

	motion_button = new MenuButton(8, y_pos, button_sz, button_height, "Detect Motion");
	motion_button->box(FL_NO_BOX);
	motion_button->labelcolor(FL_YELLOW);
	motion_button->labelsize(font_sz);
	motion_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	motion_button->callback(motion_button_cb, this);
	if(use_old == 1)
	{
		motion_button->hide();
	}
	y_pos += y_inc;
	object_button = new MenuButton(8, y_pos, button_sz, button_height, "Detect Objects");
	object_button->box(FL_NO_BOX);
	object_button->labelcolor(FL_YELLOW);
	object_button->labelsize(font_sz);
	object_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_button->callback(object_button_cb, this);
	if(use_old == 1)
	{
		object_button->hide();
	}
	y_pos += y_inc;
	if((requested_w >= w()) && (requested_h >= h()))
	{
		follow_button = new MenuButton(8, y_pos, button_sz, button_height, "Follow Motion");
		follow_button->box(FL_NO_BOX);
		follow_button->labelcolor(FL_YELLOW);
		follow_button->labelsize(font_sz);
		follow_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		follow_button->callback(follow_button_cb, this);
		if(use_old == 1)
		{
			follow_button->hide();
		}
		y_pos += y_inc;
		follow_objects_button = new MenuButton(8, y_pos, button_sz, button_height, "Follow Objects");
		follow_objects_button->box(FL_NO_BOX);
		follow_objects_button->labelcolor(FL_YELLOW);
		follow_objects_button->labelsize(font_sz);
		follow_objects_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		follow_objects_button->callback(follow_objects_button_cb, this);
		if(use_old == 1)
		{
			follow_objects_button->hide();
		}
		y_pos += y_inc;
	}
	else
	{
		follow_button = NULL;
		follow_objects_button = NULL;
	}
	y_pos += y_inc;

	trigger_button = new MenuButton(8, y_pos, button_sz, button_height, "Trigger Camera");
	trigger_button->box(FL_NO_BOX);
	trigger_button->labelcolor(FL_YELLOW);
	trigger_button->labelsize(font_sz);
	trigger_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	trigger_button->callback(trigger_camera_button_cb, this);
	y_pos += y_inc;

	snapshot_button = new MenuButton(8, y_pos, button_sz, button_height, "Snap Photo");
	snapshot_button->box(FL_NO_BOX);
	snapshot_button->labelcolor(FL_YELLOW);
	snapshot_button->labelsize(font_sz);
	snapshot_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	snapshot_button->callback(snapshot_button_cb, this);
	y_pos += y_inc;

	settings_button = new MenuButton(8, y_pos, button_sz, button_height, "Video Settings");
	settings_button->box(FL_NO_BOX);
	settings_button->labelcolor(FL_YELLOW);
	settings_button->labelsize(font_sz);
	settings_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	settings_button->callback(settings_button_cb, this);
	y_pos += y_inc;

	snapshot_settings_button = new MenuButton(8, y_pos, button_sz, button_height, "Snapshot Settings");
	snapshot_settings_button->box(FL_NO_BOX);
	snapshot_settings_button->labelcolor(FL_YELLOW);
	snapshot_settings_button->labelsize(font_sz);
	snapshot_settings_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	snapshot_settings_button->callback(snapshot_settings_button_cb, this);
	y_pos += y_inc;

	zoom_box_button = new MenuButton(8, y_pos, button_sz, button_height, "Box Zoom");
	zoom_box_button->box(FL_NO_BOX);
	zoom_box_button->labelcolor(FL_YELLOW);
	zoom_box_button->labelsize(font_sz);
	zoom_box_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	zoom_box_button->callback(zoom_box_button_cb, this);
	y_pos += y_inc;

	alias_button = new MenuButton(8, y_pos, button_sz, button_height, "Set Camera Alias");
	alias_button->box(FL_NO_BOX);
	alias_button->labelcolor(FL_YELLOW);
	alias_button->labelsize(font_sz);
	alias_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	alias_button->callback(alias_button_cb, this);
	y_pos += y_inc;

	flip_horizontal_button = new MenuButton(8, y_pos, button_sz, button_height, "Flip Horizontal");
	flip_horizontal_button->box(FL_NO_BOX);
	flip_horizontal_button->labelcolor(FL_YELLOW);
	flip_horizontal_button->labelsize(font_sz);
	flip_horizontal_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	flip_horizontal_button->callback(flip_horizontal_button_cb, this);
	y_pos += y_inc;

	flip_vertical_button = new MenuButton(8, y_pos, button_sz, button_height, "Flip Vertical");
	flip_vertical_button->box(FL_NO_BOX);
	flip_vertical_button->labelcolor(FL_YELLOW);
	flip_vertical_button->labelsize(font_sz);
	flip_vertical_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	flip_vertical_button->callback(flip_vertical_button_cb, this);
	y_pos += y_inc;

	filter_built_in_button = new MenuButton(8, y_pos, button_sz, button_height, "Filters");
	filter_built_in_button->box(FL_NO_BOX);
	filter_built_in_button->labelcolor(FL_YELLOW);
	filter_built_in_button->labelsize(font_sz);
	filter_built_in_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	filter_built_in_button->callback(filter_built_in_button_cb, this);
	y_pos += y_inc;

	if(global_potential_filter_cnt > 0)
	{
		filter_plugins_button = new MenuButton(8, y_pos, button_sz, button_height, "Filter Plugins");
		filter_plugins_button->box(FL_NO_BOX);
		filter_plugins_button->labelcolor(FL_YELLOW);
		filter_plugins_button->labelsize(font_sz);
		filter_plugins_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		filter_plugins_button->callback(filter_plugins_button_cb, this);
		y_pos += y_inc;
	}
	else
	{
		filter_plugins_button = NULL;
	}
	external_pgm_button = new MenuButton(8, y_pos, button_sz, button_height, "External PGM");
	external_pgm_button->box(FL_NO_BOX);
	external_pgm_button->labelcolor(FL_YELLOW);
	external_pgm_button->labelsize(font_sz);
	external_pgm_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	external_pgm_button->callback(external_pgm_button_cb, this);
	y_pos += y_inc;

	fltk_plugin_button = new MenuButton(8, y_pos, button_sz, button_height, "FLTK Plugin");
	fltk_plugin_button->box(FL_NO_BOX);
	fltk_plugin_button->labelcolor(FL_YELLOW);
	fltk_plugin_button->labelsize(font_sz);
	fltk_plugin_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	fltk_plugin_button->callback(fltk_plugin_button_cb, this);
	y_pos += y_inc;

	immediate_drawing_button = new MenuButton(8, y_pos, button_sz, button_height, "Immediate Drawing");
	immediate_drawing_button->box(FL_NO_BOX);
	immediate_drawing_button->labelcolor(FL_YELLOW);
	immediate_drawing_button->labelsize(font_sz);
	immediate_drawing_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	immediate_drawing_button->callback(immediate_drawing_button_cb, this);
	y_pos += y_inc;

	dynamic_coloring_button = new MenuButton(8, y_pos, button_sz, button_height, "Dynamic Coloring");
	dynamic_coloring_button->box(FL_NO_BOX);
	dynamic_coloring_button->labelcolor(FL_YELLOW);
	dynamic_coloring_button->labelsize(font_sz);
	dynamic_coloring_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	dynamic_coloring_button->callback(dynamic_coloring_button_cb, this);
	y_pos += y_inc;

	save_camera_button = new MenuButton(8, y_pos, button_sz, button_height, "Save Camera");
	save_camera_button->box(FL_NO_BOX);
	save_camera_button->labelcolor(FL_YELLOW);
	save_camera_button->labelsize(font_sz);
	save_camera_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	save_camera_button->callback(save_camera_button_cb, this);
	y_pos += y_inc;

	hide_video_button = new MenuButton(8, y_pos, button_sz, button_height, "Hide Video");
	hide_video_button->box(FL_NO_BOX);
	hide_video_button->labelcolor(FL_YELLOW);
	hide_video_button->labelsize(font_sz);
	hide_video_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	hide_video_button->callback(hide_video_button_cb, this);
	y_pos += y_inc;

	freeze_button = new MenuButton(8, y_pos, button_sz, button_height, "Freeze");
	freeze_button->box(FL_NO_BOX);
	freeze_button->labelcolor(FL_YELLOW);
	freeze_button->labelsize(font_sz);
	freeze_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	freeze_button->callback(freeze_button_cb, this);
	y_pos += y_inc;

	mute_video_button = new MenuButton(8, y_pos, button_sz, button_height, "Mute Video");
	mute_video_button->box(FL_NO_BOX);
	mute_video_button->labelcolor(FL_YELLOW);
	mute_video_button->labelsize(font_sz);
	mute_video_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	mute_video_button->callback(mute_video_button_cb, this);
	y_pos += y_inc;

	power_button = new MenuButton(8, y_pos, button_sz, button_height, "Turn Off");
	power_button->box(FL_NO_BOX);
	power_button->labelcolor(FL_YELLOW);
	power_button->labelsize(font_sz);
	power_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	power_button->callback(power_button_cb, this);
	y_pos += y_inc;

	Fl_Box *spacer2 = new Fl_Box(8, y_pos, button_sz, button_height / 2);
	spacer2->box(FL_NO_BOX);
	y_pos += (y_inc / 2);

	audio_mute_button = new MenuButton(8, y_pos, button_sz, button_height, "Mute Audio");
	audio_mute_button->box(FL_NO_BOX);
	audio_mute_button->labelcolor(FL_YELLOW);
	audio_mute_button->labelsize(font_sz);
	audio_mute_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	audio_mute_button->callback(audio_mute_button_cb, this);
	y_pos += y_inc;

	monitor_audio_button = new MenuButton(8, y_pos, button_sz, button_height, "Monitor Audio");
	monitor_audio_button->box(FL_NO_BOX);
	monitor_audio_button->labelcolor(FL_YELLOW);
	monitor_audio_button->labelsize(font_sz);
	monitor_audio_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	monitor_audio_button->callback(monitor_audio_button_cb, this);
	y_pos += y_inc;

	if(global_potential_audio_filter_cnt > 0)
	{
		audio_filter_plugins_button = new MenuButton(8, y_pos, button_sz, button_height, "Audio Filter Plugins");
		audio_filter_plugins_button->box(FL_NO_BOX);
		audio_filter_plugins_button->labelcolor(FL_YELLOW);
		audio_filter_plugins_button->labelsize(font_sz);
		audio_filter_plugins_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		audio_filter_plugins_button->callback(audio_filter_plugins_button_cb, this);
		y_pos += y_inc;
	}
	else
	{
		audio_filter_plugins_button = NULL;
	}
	Fl_Box *spacer3 = new Fl_Box(8, y_pos, button_sz, button_height / 2);
	spacer3->box(FL_NO_BOX);
	y_pos += (y_inc / 2);

	new_source_button = new MenuButton(8, y_pos, button_sz, button_height, "New Source");
	new_source_button->box(FL_NO_BOX);
	new_source_button->labelcolor(FL_YELLOW);
	new_source_button->labelsize(font_sz);
	new_source_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	new_source_button->callback(new_source_button_cb, this);
	y_pos += y_inc;

	edit_source_button = new MenuButton(8, y_pos, button_sz, button_height, "Edit Source");
	edit_source_button->box(FL_NO_BOX);
	edit_source_button->labelcolor(FL_YELLOW);
	edit_source_button->labelsize(font_sz);
	edit_source_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	edit_source_button->callback(edit_source_button_cb, this);
	y_pos += y_inc;

	select_output_button = new MenuButton(8, y_pos, button_sz, button_height, "Select Output");
	select_output_button->box(FL_NO_BOX);
	select_output_button->labelcolor(FL_YELLOW);
	select_output_button->labelsize(font_sz);
	select_output_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	select_output_button->callback(select_output_button_cb, this);
	y_pos += y_inc;

	set_output_button = new MenuButton(8, y_pos, button_sz, button_height, "Edit Outputs");
	set_output_button->box(FL_NO_BOX);
	set_output_button->labelcolor(FL_YELLOW);
	set_output_button->labelsize(font_sz);
	set_output_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	set_output_button->callback(set_output_button_cb, this);
	y_pos += y_inc;

	load_setup_button = new MenuButton(8, y_pos, button_sz, button_height, "Load Setup");
	load_setup_button->box(FL_NO_BOX);
	load_setup_button->labelcolor(FL_YELLOW);
	load_setup_button->labelsize(font_sz);
	load_setup_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	load_setup_button->callback(load_setup_button_cb, this);
	y_pos += y_inc;

	save_setup_button = new MenuButton(8, y_pos, button_sz, button_height, "Save Setup");
	save_setup_button->box(FL_NO_BOX);
	save_setup_button->labelcolor(FL_YELLOW);
	save_setup_button->labelsize(font_sz);
	save_setup_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	save_setup_button->callback(save_setup_button_cb, this);
	y_pos += y_inc;

	transitions_button = new MenuButton(8, y_pos, button_sz, button_height, "Transitions");
	transitions_button->box(FL_NO_BOX);
	transitions_button->labelcolor(FL_YELLOW);
	transitions_button->labelsize(font_sz);
	transitions_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	transitions_button->callback(transitions_button_cb, this);
	y_pos += y_inc;

	timestamp_button = new MenuButton(8, y_pos, button_sz, button_height, "Timestamp");
	timestamp_button->box(FL_NO_BOX);
	timestamp_button->labelcolor(FL_YELLOW);
	timestamp_button->labelsize(font_sz);
	timestamp_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	timestamp_button->callback(timestamp_button_cb, this);
	y_pos += y_inc;

	dump_button = new MenuButton(8, y_pos, button_sz, button_height, "Dump Frames");
	dump_button->box(FL_NO_BOX);
	dump_button->labelcolor(FL_YELLOW);
	dump_button->labelsize(font_sz);
	dump_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	dump_button->callback(dump_button_cb, this);
	y_pos += y_inc;

	encode_button = new MenuButton(8, y_pos, button_sz, button_height, "Force Encode");
	encode_button->box(FL_NO_BOX);
	encode_button->labelcolor(FL_YELLOW);
	encode_button->labelsize(font_sz);
	encode_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	encode_button->callback(encode_button_cb, this);
	encode_button->hide();
	if(direct_recording == 0)
	{
		y_pos += y_inc;
	}
	main_detail_button = NULL;
	if((requested_w >= w()) && (requested_h >= h()))
	{
		main_detail_button = new MenuButton(8, y_pos, button_sz, button_height, "Record to Main");
		if(stream == 1)
		{
			main_detail_button->label("Record to Detail");
		}
		main_detail_button->box(FL_NO_BOX);
		main_detail_button->labelcolor(FL_YELLOW);
		main_detail_button->labelsize(font_sz);
		main_detail_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		main_detail_button->callback(main_detail_button_cb, this);
		y_pos += y_inc;
	}
	else
	{
		main_detail_button = NULL;
	}
	show_debug_button = new MenuButton(8, y_pos, button_sz, button_height, "Record Debug");
	show_debug_button->box(FL_NO_BOX);
	show_debug_button->labelcolor(FL_YELLOW);
	show_debug_button->labelsize(font_sz);
	show_debug_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	show_debug_button->callback(show_debug_button_cb, this);
	y_pos += y_inc;

	show_motion_debug_button = new MenuButton(8, y_pos, button_sz, button_height, "Show Motion Debug");
	show_motion_debug_button->box(FL_NO_BOX);
	show_motion_debug_button->labelcolor(FL_YELLOW);
	show_motion_debug_button->labelsize(font_sz);
	show_motion_debug_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	show_motion_debug_button->callback(show_motion_debug_button_cb, this);
	y_pos += y_inc;

	review_button = new MenuButton(8, y_pos, button_sz, button_height, "Review Footage");
	review_button->box(FL_NO_BOX);
	review_button->labelcolor(FL_YELLOW);
	review_button->labelsize(font_sz);
	review_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	review_button->callback(review_button_cb, this);
	y_pos += y_inc;

	review_muxed_button = new MenuButton(8, y_pos, button_sz, button_height, "Review Muxed");
	review_muxed_button->box(FL_NO_BOX);
	review_muxed_button->labelcolor(FL_YELLOW);
	review_muxed_button->labelsize(font_sz);
	review_muxed_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	review_muxed_button->callback(review_muxed_button_cb, this);
	review_muxed_button->hide();
	y_pos += y_inc;

	jpeg_streaming_button = NULL;
	if(jpeg_streaming != NULL)
	{
		jpeg_streaming_button = new MenuButton(8, y_pos, button_sz, button_height, "JPEG Stream");
		jpeg_streaming_button->box(FL_NO_BOX);
		jpeg_streaming_button->labelcolor(FL_YELLOW);
		jpeg_streaming_button->labelsize(font_sz);
		jpeg_streaming_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		jpeg_streaming_button->callback(jpeg_streaming_button_cb, this);
		jpeg_streaming_button->hide();
		y_pos += y_inc;
	}
	resize_detail_button = NULL;
	if((requested_w >= w()) && (requested_h >= h()))
	{
		resize_detail_button = new MenuButton(8, y_pos, button_sz, button_height, "Resize Detail");
		resize_detail_button->box(FL_NO_BOX);
		resize_detail_button->labelcolor(FL_YELLOW);
		resize_detail_button->labelsize(font_sz);
		resize_detail_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		resize_detail_button->callback(resize_detail_button_cb, this);
		y_pos += 15;

		Fl_Box *box = new Fl_Box(8, y_pos, button_sz, button_height, "(Forces a reset)");
		box->box(FL_NO_BOX);
		box->labelcolor(FL_GRAY);
		box->labelsize(font_sz);
		box->labelsize(9);
		box->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		y_pos += y_inc;
	}
	else
	{
		resize_detail_button = NULL;
	}
	set_interest_button = new MenuButton(8, y_pos, button_sz, button_height, "Set Interest");
	set_interest_button->box(FL_NO_BOX);
	set_interest_button->labelcolor(FL_YELLOW);
	set_interest_button->labelsize(font_sz);
	set_interest_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	set_interest_button->callback(set_interest_button_cb, this);
	y_pos += y_inc;

	clear_interest_button = new MenuButton(8, y_pos, button_sz, button_height, "Clear Interest");
	clear_interest_button->box(FL_NO_BOX);
	clear_interest_button->labelcolor(FL_YELLOW);
	clear_interest_button->labelsize(font_sz);
	clear_interest_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	clear_interest_button->callback(clear_interest_button_cb, this);
	y_pos += y_inc;

	reset_button = new MenuButton(8, y_pos, button_sz, button_height, "Reset Recording");
	reset_button->box(FL_NO_BOX);
	reset_button->labelcolor(FL_YELLOW);
	reset_button->labelsize(font_sz);
	reset_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	reset_button->callback(reset_button_cb, this);
	y_pos += y_inc;

	reset_cameras_button = new MenuButton(8, y_pos, button_sz, button_height, "Reset Cameras");
	reset_cameras_button->box(FL_NO_BOX);
	reset_cameras_button->labelcolor(FL_YELLOW);
	reset_cameras_button->labelsize(font_sz);
	reset_cameras_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	reset_cameras_button->callback(reset_cameras_button_cb, this);
	y_pos += y_inc;

	split_button = new MenuButton(8, y_pos, button_sz, button_height, "Split Screen");
	split_button->box(FL_NO_BOX);
	split_button->labelcolor(FL_YELLOW);
	split_button->labelsize(font_sz);
	split_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	split_button->callback(split_button_cb, this);
	y_pos += y_inc;

	open_standalone_button = new MenuButton(8, y_pos, button_sz, button_height, "Open Standalone");
	open_standalone_button->box(FL_NO_BOX);
	open_standalone_button->labelcolor(FL_YELLOW);
	open_standalone_button->labelsize(font_sz);
	open_standalone_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	open_standalone_button->callback(open_standalone_cb, this);
	y_pos += y_inc;

	resize_capture_button = new MenuButton(8, y_pos, button_sz, button_height, "Resize Capture (reset)");
	resize_capture_button->box(FL_NO_BOX);
	resize_capture_button->labelcolor(FL_YELLOW);
	resize_capture_button->labelsize(font_sz);
	resize_capture_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	resize_capture_button->callback(resize_capture_button_cb, this);
	y_pos += y_inc;

	load_camera_button = new MenuButton(8, y_pos, button_sz, button_height, "Load Camera");
	load_camera_button->box(FL_NO_BOX);
	load_camera_button->labelcolor(FL_YELLOW);
	load_camera_button->labelsize(font_sz);
	load_camera_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	load_camera_button->callback(load_camera_button_cb, this);
	y_pos += y_inc;

	keyboard_settings_button = new MenuButton(8, y_pos, button_sz, button_height, "Keyboard Settings");
	keyboard_settings_button->box(FL_NO_BOX);
	keyboard_settings_button->labelcolor(FL_YELLOW);
	keyboard_settings_button->labelsize(font_sz);
	keyboard_settings_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	keyboard_settings_button->callback(keyboard_settings_button_cb, this);
	y_pos += y_inc;

	gui_settings_button = new MenuButton(8, y_pos, button_sz, button_height, "GUI Settings");
	gui_settings_button->box(FL_NO_BOX);
	gui_settings_button->labelcolor(FL_YELLOW);
	gui_settings_button->labelsize(font_sz);
	gui_settings_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	gui_settings_button->callback(gui_settings_button_cb, this);
	y_pos += y_inc;

	codecs_button = new MenuButton(8, y_pos, button_sz, button_height, "Codecs");
	codecs_button->box(FL_NO_BOX);
	codecs_button->labelcolor(FL_YELLOW);
	codecs_button->labelsize(font_sz);
	codecs_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	codecs_button->callback(container_menu_cb, this);
	if(global_my_format_cnt > 0)
	{
		codecs_button->show();
	}
	else
	{
		codecs_button->hide();
	}
	y_pos += y_inc;

	toggle_objects_button = new MenuButton(8, y_pos, button_sz, button_height, "Select Objects");
	toggle_objects_button->box(FL_NO_BOX);
	toggle_objects_button->labelcolor(FL_YELLOW);
	toggle_objects_button->labelsize(font_sz);
	toggle_objects_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	toggle_objects_button->callback(toggle_objects_button_cb, this);
	y_pos += y_inc;

	load_interest_button = new MenuButton(8, y_pos, button_sz, button_height, "Load Interest");
	load_interest_button->box(FL_NO_BOX);
	load_interest_button->labelcolor(FL_YELLOW);
	load_interest_button->labelsize(font_sz);
	load_interest_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	load_interest_button->callback(load_interest_button_cb, this);
	y_pos += y_inc;

	save_interest_button = new MenuButton(8, y_pos, button_sz, button_height, "Save Interest");
	save_interest_button->box(FL_NO_BOX);
	save_interest_button->labelcolor(FL_YELLOW);
	save_interest_button->labelsize(font_sz);
	save_interest_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	save_interest_button->callback(save_interest_button_cb, this);
	y_pos += y_inc;

	Fl_Box *spacer4 = new Fl_Box(8, y_pos, button_sz, button_height / 2);
	spacer4->box(FL_NO_BOX);
	y_pos += (y_inc / 2);

	quit_button = new Fl_Button(8, y_pos, button_sz, button_height, "Exit");
	quit_button->box(FL_NO_BOX);
	quit_button->labelcolor(FL_CYAN);
	quit_button->labelsize(font_sz);
	quit_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	quit_button->callback(quit_cb, this);
	y_pos += y_inc;

	button_group_pack->end();
	button_group->end();
	button_group->hide();

	int starting_y_inc = y_inc;
	if(y_pos > (h() - 32))
	{
		int new_h = button_height;
		int number_of_buttons = button_group_pack->children();
		int calced_height = y_pos;
		while(calced_height > (h() - 32))
		{
			y_inc--;
			new_h--;
			calced_height = number_of_buttons * y_inc;
		}
		int new_y = 10;
		for(loop = 0;loop < button_group_pack->children();loop++)
		{
			Fl_Widget *child = button_group_pack->child(loop);
			if(child != NULL)
			{
				child->resize(child->x(), new_y, child->w(), new_h);
				child->labelsize(new_h - 6);
				new_y += y_inc;
			}
		}
	}
	double factor = (double)y_inc / (double)starting_y_inc;
	if(scale_gui == 1)
	{
		gui_scale_factor = factor;
	}
	HideButtons();
	ShowButtons();
}

void	clipboard_notify(int source, void *v)
{
	MyWin *win = (MyWin *)v;
	win->clipboard_changed = 1;
}

MyWin::MyWin(
	int in_w
	, int in_h
	, int in_source_cnt
	, char **in_source
	, int in_audio_source_cnt
	, char **in_audio_source
	, int in_direct
	, int ww
	, int hh
	, int output_ww
	, int output_hh
	, int display_ww
	, int display_hh
	, int in_fps
	, double in_interval
	, int in_split
	, int in_main
	, int in_muxing
	, int in_flip
	, int use_audio
	, char *in_mux_format
	, int in_use_old
	, int in_no_scan
	, int in_no_audio_scan
	, int in_record_all
	, int in_record_desktop
	, int in_desktop_x
	, int in_desktop_y
	, int in_desktop_w
	, int in_desktop_h
	, int in_single_stream
	, int in_display_recording_camera
	, int in_transition
	, int in_ptz_device_path_cnt
	, char *in_ptz_device_path[NUMBER_OF_INTERFACES]
	, char *in_ptz_lock_alias[NUMBER_OF_INTERFACES]
	, char *in_ptz_alias[NUMBER_OF_INTERFACES]
	, int in_ptz_home_on_launch
	, int in_use_yolo_model
	, char *in_yolo_cfg
	, char *in_yolo_weights
	, char *in_yolo_names
	, char *in_jpeg_streaming
	, int in_streaming
	, char *in_stream_url
	, int in_stream_only
	, int in_streaming_audio_quality
	, int in_embed_pip
	, double in_pip_x_position
	, double in_pip_y_position
	, int in_pip_red
	, int in_pip_green
	, int in_pip_blue
	, double in_pip_size
	, int in_multipip
	, int in_grid_size
	, char *use_desktop_monitor
	, int use_detect
	, int use_timestamp
	, int use_frame_scaling
	, int use_scale_gui
	, char *load_file
	, int use_retain_commands
	, int use_retain_cameras
	, int use_retain_audio
	, int use_retain_ptz
	, int use_hide_status
	, int use_auto_scale
	, int crop_output
	, int use_disregard_settings
	, char *lbl)
	: Fl_Double_Window(in_w, in_h, lbl)
{
int	loop;
int	inner;
int	outer;

	resizable(this);
	resize_grp = new Fl_Group(0, 0, w(), h());
	resize_grp->resizable(0);
	size_range(w() / 4, h() / 4, 0, 0, 0, 0, 1);
	original_w = w();
	original_h = h();
	auto_scale = use_auto_scale;

	disregard_settings = use_disregard_settings;

	direct_recording = in_direct;
	direct_recorder = NULL;
	video_count = 0;
	strcpy(last_used_filename, "");
	strcpy(mux_format, "mov");
	if(in_mux_format != NULL)
	{
		if(strlen(in_mux_format) < 255)
		{
			strcpy(mux_format, in_mux_format);
		}
	}
	current_source = 0;
	displayed_source = 0;
	alt_displayed_source = -1;
	split = in_split;
	for(loop = 0;loop < 1024;loop++)
	{
		source[loop] = NULL;
	}
	for(loop = 0;loop < in_source_cnt;loop++)
	{
		source[loop] = in_source[loop];
	}
	source_cnt = in_source_cnt;
	audio_source = in_audio_source;
	audio_source_cnt = in_audio_source_cnt;
	requested_w = ww;
	requested_h = hh;
	display_video = 1;
	last_cam = NULL;
	im_drawing_mode = 0;
	if(output_ww > -1)
	{
		output_width = output_ww;
	}
	else
	{
		output_width = ww;
	}
	if(output_hh > -1)
	{
		output_height = output_hh;
	}
	else
	{
		output_height = hh;
	}
	if(display_ww > -1)
	{
		display_width = display_ww;
	}
	else
	{
		display_width = ww;
	}
	if(display_hh > -1)
	{
		display_height = display_hh;
	}
	else
	{
		display_height = hh;
	}
	init_detect = use_detect;
	recording = 0;
	use_mousewheel = 1;
	refreshed = 0;
	mute_audio = 0;
	stream = in_main;
	muxing = in_muxing;
	recorded_frames = 0;
	forced_fps = in_fps;
	forced_interval = in_interval;
	restore_forced_interval = in_interval;
	record_all_cnt = 0;
	record_all_start = 0;
	clipboard_changed = 1;
	resize_capture = 0;
	no_scan = in_no_scan;
	no_audio_scan = in_no_audio_scan;
	use_old = in_use_old;
	settings_window = NULL;
	snapshot_settings_window = NULL;
	gui_settings_window = NULL;
	transitions_window = NULL;
	immediate_drawing_window = NULL;
	new_source_window = NULL;
	alias_window = NULL;
	trigger_window = NULL;
	dumped_frames = 0;
	dumped_limit = -1;
	zoom_boxing = 0;
	dump_type = NULL;

	strcpy(mux_format, in_mux_format);
	for(loop = 0;loop < 128;loop++)
	{
		my_muxer[loop] = NULL;
	}
	muxer_cnt = 0;

	extracting = 0;
	frozen = 0;
	speed_factor = 1.0;
	minimum_fps = 20.0;
	all_fd = -1;
	actively_loading = 0;
	record_all = in_record_all;
	image_window_button = 0;
	grid_size = in_grid_size;
	mux_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
	desktop_monitor = use_desktop_monitor;
	start_thumbgroup = 0;
	last_resize_drag_x = -1;
	last_resize_drag_y = -1;
	last_push_x = -1;
	last_push_y = -1;
	embedded_app_cnt = 0;
	evaluate_focus = 0;
	retain_commands = use_retain_commands;
	retain_cameras = use_retain_cameras;
	retain_audio = use_retain_audio;
	retain_ptz = use_retain_ptz;
	hide_status = use_hide_status;
	image_origin_x = 0;
	image_origin_y = 0;
	selecting_colors = 0;

	rubberband_mode = 0;
	rubber_band_x = -1;
	rubber_band_y = -1;
	rubber_band_w = -1;
	rubber_band_h = -1;

	popup = NULL;
	misc_copy = NULL;
	misc_copy_cnt = 0;
	editing_misc_outer = -1;
	editing_misc_inner = -1;
	editing_misc_mode = -1;

	shape = NULL;
	shape_cnt = 0;

	for(loop = 0;loop < 128;loop++)
	{
		output_name[loop] = NULL;
		output_path[loop] = NULL;
		output_active[loop] = 0;
	}
	output_path_cnt = 0;
	for(loop = 0;loop < 10;loop++)
	{
		embedded_app[loop] = NULL;
	}
	for(loop = 0;loop < 64;loop++)
	{
		last_muxed_list[loop] = NULL;
	}
	for(loop = 0;loop < 128;loop++)
	{
		audio_thumbnail[loop] = NULL;
	}
	audio_thumbnail_cnt = 0;
	if(in_record_all == 1)
	{
		start_win->Update("Opening record all file");
		record_all_start = time(0);
		all_fd = open("global.bin", O_CREAT | O_WRONLY | O_TRUNC, 0777);
		int uw = original_w;
		int uh = original_h;
		int depth = 4;
		int ufps = 25;
		write(all_fd, &uw, sizeof(int));
		write(all_fd, &uh, sizeof(int));
		write(all_fd, &depth, sizeof(int));
		write(all_fd, &ufps, sizeof(int));
	}
	record_desktop = in_record_desktop;
	desktop_x = in_desktop_x;
	desktop_y = in_desktop_y;
	desktop_w = in_desktop_w;
	desktop_h = in_desktop_h;
	codec_selection_window = NULL;

	dragging_thumb = NULL;
	dragging_thumb_x = -1;
	dragging_thumb_y = -1;

	single_stream = in_single_stream;
	display_recording_camera = in_display_recording_camera;

	for(loop = 0;loop < 128;loop++)
	{
		pulse_microphone[loop] = NULL;
	}
	pulse_microphone_cnt = 0;
	for(outer = 0;outer < NUMBER_OF_INTERFACES;outer++)
	{
		for(inner = 0;inner < NUMBER_OF_CAMERAS;inner++)
		{
			ptz_soft_memory[outer][inner] = 0;
		}
	}
	for(loop = 0;loop < NUMBER_OF_INTERFACES;loop++)
	{
		ptz_interface_select_button[loop] = NULL;
	}
	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		ptz_camera_select_button[loop] = NULL;
	}
	for(loop = 0;loop < 10;loop++)
	{
		split_bx[loop] = -1;
		split_by[loop] = -1;
		split_rx[loop] = -1;
		split_ry[loop] = -1;
	}
	tag_recognized = 0;
	tag_fp = NULL;
	for(loop = 0;loop < 1024;loop++)
	{
		recognize_class_name[loop] = NULL;
	}
	if(in_use_yolo_model == USE_YOLO_MODEL_OPEN_IMAGES)
	{
		strcpy(yolo_cfg_filename, YOLO_CFG_FILENAME);
		strcpy(yolo_weights_filename, YOLO_WEIGHTS_FILENAME);
		strcpy(yolo_names_filename, YOLO_NAMES_FILENAME);
	}
	else
	{
		strcpy(yolo_cfg_filename, YOLO_ALT_CFG_FILENAME);
		strcpy(yolo_weights_filename, YOLO_ALT_WEIGHTS_FILENAME);
		strcpy(yolo_names_filename, YOLO_ALT_NAMES_FILENAME);
	}
	if((in_yolo_cfg != NULL) && (in_yolo_weights != NULL) && (in_yolo_names != NULL))
	{
		strcpy(yolo_cfg_filename, in_yolo_cfg);
		strcpy(yolo_weights_filename, in_yolo_weights);
		strcpy(yolo_names_filename, in_yolo_names);
	}
	jpeg_streaming = in_jpeg_streaming;
	jpeg_streaming_port = 20000;
	if(jpeg_streaming != NULL)
	{
		char *cp = jpeg_streaming;
		while(*cp != '\0')
		{
			if(*cp == ':')
			{
				*cp = '\0';
				jpeg_streaming_port = atoi(cp + 1);
			}
			cp++;
		}
	}
	immediate_list = NULL;
	immediate_cnt = 0;

	streaming = in_streaming;
	stream_only = in_stream_only;
	streaming_audio_quality = in_streaming_audio_quality;
	strcpy(stream_url, "");
	if(in_stream_url != NULL)
	{
		strcpy(stream_url, in_stream_url);
	}
	else
	{
		streaming = 0;
	}
	embed_pip = in_embed_pip;
	pip_x_position = in_pip_x_position;
	pip_y_position = in_pip_y_position;
	pip_red = in_pip_red;
	pip_green = in_pip_green;
	pip_blue = in_pip_blue;
	pip_size = in_pip_size;
	multipip = in_multipip;
	recognize_class_cnt = 0;
	ReadClasses();
	if(init_detect == 1)
	{
		start_win->Update("Setup object detection");
		SetupObjectDetection();
	}
	pulse_mixer = NULL;
	review_muxed = NULL;

	start_win->Update("Open cameras");
	ResetCameras(0, in_source, in_source_cnt);

	timestamp = use_timestamp;
	strcpy(timestamp_format, "%Y/%M/%D %h:%m:%s (%frame) [%source]");
	timestamp_rr = 255;
	timestamp_gg = 240;
	timestamp_bb = 128;
	timestamp_aa = 255;
	timestamp_background_rr = 0;
	timestamp_background_gg = 0;
	timestamp_background_bb = 0;
	timestamp_background_aa = 0;
	timestamp_font_sz = 11;
	timestamp_position_x = 10;
	timestamp_position_y = 21;
	frame_scaling = use_frame_scaling;
	crop_scaling = crop_output;

	scale_gui = use_scale_gui;
	image_display_scale = 1.0;
	start_time = 0;
	encoding = 0;
	force_center_x = w() / 2;
	force_center_y = h() / 2;
	visible_debug = 0;
	nominal_interest_x = -1;
	nominal_interest_y = -1;
	interest_cnt = 0;
	mark_interest = 0;
	review = NULL;
	buttons_shown = 0;
	all_frames = 0;
	ready_to_average = 0;
	grid_sz = 1;
	detail = NULL;
	detail_x = -1;
	detail_y = -1;
	detail_width = Fl::w() / 4;
	detail_height = Fl::h() / 4;
	detect_time = 0;
	resizing_detail = 0;
	drag_start_x = -1;
	drag_start_y = -1;
	offset_x = 0;
	offset_y = 0;
	start_offset_x = -1;
	start_offset_y = -1;
	save_offset_x = 0;
	save_offset_y = 0;
	dragging = 0;
	motion_debug = 0;
	showing_new_source_window = 0;;
	showing_alias_window = 0;;
	redraw_cnt = 0;
	encoding_frame_cnt = 0;
	transition_cnt = 0.0;
	transition = in_transition;
	ptz_mode = 0;
	for(loop = 0;loop < NUMBER_OF_INTERFACES;loop++)
	{
		ptz_device_path[loop] = NULL;
		ptz_lock_alias[loop] = NULL;
		ptz_alias[loop] = NULL;
	}
	ptz_device_cnt = in_ptz_device_path_cnt;
	for(loop = 0;loop < ptz_device_cnt;loop++)
	{
		ptz_device_path[loop] = in_ptz_device_path[loop];
		ptz_lock_alias[loop] = in_ptz_lock_alias[loop];
		ptz_alias[loop] = in_ptz_alias[loop];
	}
	ptz_current_camera_idx = 0;
	ptz_zoom = 0;
	ptz_panning = 0;
	ptz_zooming = 0;
	ptz_focusing = 0;
	old_ptz_zoom = 1;
	start_ptz_drag_x = 0;
	start_ptz_drag_y = 0;
	ptz_middle_mouse = 0;
	ptz_focus_reading = 0;
	ptz_zoom_reading = -1;
	ptz_pan_reading = 0;
	ptz_tilt_reading = 0;
	ptz_pan_speed = 24.0;
	ptz_tilt_speed = 20.0;
	ptz_dragged = 0;
	use_pan_speed = 0;
	use_tilt_speed = 0;
	visca_command = 0;
	visca_arg_cnt = 0;
	ptz_travel_x = 0.294355;
	ptz_travel_y = 0.290323;
	ptz_focus_speed = 1;
	ptz_zoom_speed = 1;
	ptz_follow = 0;
	ptz_follow_home_pan = 0;
	ptz_follow_home_tilt = 0;
	ptz_adjust_speed_for_zoom = 1;
	ptz_little_speed = 10;
	ptz_little_mode = 0;
	center_message_timer = 0;
	ptz_reverse_horizontal = 0;
	ptz_reverse_vertical = 0;
	ptz_zoomer = 0;
	ptz_zoomer_speed = 0;
	ptz_joystick = 0;
	ptz_joystick_x = 0;
	ptz_joystick_y = 0;
	ptz_last_joystick_x = 0;
	ptz_last_joystick_y = 0;
	magic_x = -1;
	magic_y = -1;
	transmitting = 0;
	move_corner = 0;
	resize_corner = 0;
	restore_corner = 0;
	camera_caps_cnt = 0;

	start_win->Update("Initialize command keys");
	start_win->image_mat_cnt = 0;
	ResetCommandKeys();
	if(access("./Setups/key_definitions.txt", 0) == 0)
	{
		ReadCommandKeyDefinitions("./Setups/key_definitions.txt");
	}
	render_mouse = 1;
	tutorial_mode = 1;

	image_memory.ptr = NULL;
	image_memory.size = 0;
	image_memory.ready = 0;
	image_memory.done = 0;
	image_memory.ptz = 0;

	trigger_select_mode = 0;
	buttonized_visible = 0;

	use_video_codec = (AVCodecID)AV_CODEC_ID_H264,
	use_audio_codec = (AVCodecID)AV_CODEC_ID_AAC,
	strcpy(use_extension, "flv");

	box(FL_NO_BOX);

	start_win->Update("Initialize audio thumbnails");
	gui_scale_factor = 1.0;
	audio_thumbnail_group = new Fl_Group((int)(600 * gui_scale_factor), (int)(10 * gui_scale_factor), (int)(w() - (600 * gui_scale_factor)), (int)(180 * gui_scale_factor));
	for(loop = 0;loop < 3;loop++)
	{
		audio_thumbnail_pack[loop] = new Fl_Pack((int)(600 * gui_scale_factor), (int)((10 * gui_scale_factor) + (60 * gui_scale_factor * loop)), (int)(w() - (600 * gui_scale_factor)), (int)(60 * gui_scale_factor));
		audio_thumbnail_pack[loop]->box(FL_NO_BOX);
		audio_thumbnail_pack[loop]->type(Fl_Pack::HORIZONTAL);
		audio_thumbnail_pack[loop]->spacing(10);
		audio_thumbnail_pack[loop]->end();
	}
	audio_thumbnail_group->end();
	audio_thumbnail_group->hide();
	if(use_audio == 1)
	{
		start_win->Update("Initialize audio");
		if(no_audio_scan == 0)
		{
			ScanPulse(0);
		}
		else
		{
			OpenNamedPulse();
		}
		audio = 1;
	}
	BuildMainMenu();

	start_win->Update("Initialize video thumbnails");
	int nxx = 20;
	int nyy = 100;
	video_thumbnail_group = new Fl_Group(0, 0, (nxx + 253) * gui_scale_factor, 10000);
	for(loop = 0;loop < 128;loop++)
	{
		thumbnail[loop] = new ThumbGroup(this, loop, nxx * gui_scale_factor, nyy * gui_scale_factor, 253 * gui_scale_factor, 88 * gui_scale_factor);
		nyy += 100;
	}
	video_thumbnail_group->end();

	start_win->Update("Initialize object menu");
	SetupObjectMenu();

	start_win->Update("Initialize PTZ window");
	SetupPTZWindow(in_ptz_home_on_launch);
	progress_scrubber = new ProgressScrubber(this, NULL, 0, 0, Fl::w(), Fl::h());

	color_it_window = new ColorItWindow(this);
	color_it_window->hide();

	number_of_fonts = Fl::set_fonts();
	if(load_file != NULL)
	{
		start_win->Update("Load setup");
		Load(load_file);
	}
	Fl::add_clipboard_notify(clipboard_notify, this);
	show();
	start_win->Update("Read external programs");
	ReadInExternalPrograms();
	resize_grp->end();
}

MyWin::~MyWin()
{
	Shutdown();
	if(shape != NULL)
	{
		free(shape);
		shape = NULL;
	}
	shape_cnt = 0;
	if(new_source_window != NULL)
	{
		new_source_window->hide();
		Fl::delete_widget(new_source_window);
	}
	if(color_it_window != NULL)
	{
		color_it_window->hide();
		Fl::delete_widget(color_it_window);
	}
	if(transitions_window != NULL)
	{
		transitions_window->hide();
		Fl::delete_widget(transitions_window);
	}
	if(immediate_drawing_window != NULL)
	{
		immediate_drawing_window->hide();
		Fl::delete_widget(immediate_drawing_window);
	}
	if(filter_plugins_window != NULL)
	{
		filter_plugins_window->hide();
		Fl::delete_widget(filter_plugins_window);
	}
	if(audio_filter_plugins_window != NULL)
	{
		audio_filter_plugins_window->hide();
		Fl::delete_widget(audio_filter_plugins_window);
	}
}

void	MyWin::Shutdown()
{
int	loop;
int	aa, ab, ac;
void	my_window_cb(void *v);

	if(select_output_window != NULL)
	{
		select_output_window->hide();
		delete select_output_window;
		select_output_window = NULL;
	}
	if(set_output_window != NULL)
	{
		set_output_window->hide();
		delete set_output_window;
		set_output_window = NULL;
	}
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			Fl::delete_widget(immediate_list[loop]);
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(output_name[loop] != NULL)
		{
			free(output_name[loop]);
		}
		if(output_path[loop] != NULL)
		{
			free(output_path[loop]);
		}
	}
	for(loop = 0;loop < 64;loop++)
	{
		if(last_muxed_list[loop] != NULL)
		{
			free(last_muxed_list[loop]);
		}
	}
	if(pulse_mixer != NULL)
	{
		pulse_mixer->done = 1;
		usleep(10000);
	}
	for(loop = 0;loop < 128;loop++)
	{
		if(audio_thumbnail[loop] != NULL)
		{
			audio_thumbnail[loop]->hide();
			remove(audio_thumbnail[loop]);
			Fl::delete_widget(audio_thumbnail[loop]);
			audio_thumbnail[loop] = NULL;
		}
	}
	if(codec_selection_window != NULL)
	{
		codec_selection_window->hide();
		Fl::delete_widget(codec_selection_window);
		codec_selection_window = NULL;
	}
	if(ptz_mode == 1)
	{
		for(loop = 0;loop < ptz_device_cnt;loop++)
		{
			VISCA_close_serial(&iface[loop]);
		}
	}
	Fl::remove_timeout(my_window_cb);
	int have_audio = 0;
	if(pulse_mixer != NULL)
	{
		pulse_mixer->Stop();
	}
	if(pulse_mixer != NULL)
	{
		if(pulse_mixer->done != -1)
		{
			pulse_mixer->done = 1;
			int cnt = 0;
			while((pulse_mixer->done == 1) && (cnt < 1000))
			{
				usleep(10000);
				cnt++;
			}
		}
		delete pulse_mixer;
	}
	ClearMuxerArray();
	muxer_cnt = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			if(cam->fd[0] > -1)
			{
				close(cam->fd[0]);
			}
			if(cam->fd[1] > -1)
			{
				close(cam->fd[1]);
			}
		}
	}
	if(direct_recorder != NULL)
	{
		direct_recorder->release();
		direct_recorder = NULL;
	}
	for(loop = 0;loop < recognize_class_cnt;loop++)
	{
		if(recognize_class_name[loop] != NULL)
		{
			free(recognize_class_name[loop]);
		}
	}
	recognize_class_cnt = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		if(camera[loop] != NULL)
		{
			delete camera[loop];
			camera[loop] = NULL;
		}
	}
	SavePTZPositions();
	for(aa = 0;aa < NUMBER_OF_INTERFACES;aa++)
	{
		for(ab = 0;ab < NUMBER_OF_CAMERAS;ab++)
		{
			for(ac = 0;ac < NUMBER_OF_PRESETS;ac++)
			{
				if(ptz_position[aa][ab][ac] != NULL)
				{
					delete ptz_position[aa][ab][ac];
					ptz_position[aa][ab][ac] = NULL;
				}
			}
		}
	}
	if(record_all == 1)
	{
		if(all_fd > -1)
		{
			SetCodec();
			close(all_fd);
			double fps = 25.0;
			int total_time = (int)(time(0) - record_all_start);
			if(total_time > 0)
			{
				fps = (double)record_all_cnt / (double)total_time;
			}
			char out_filename[4096];
			sprintf(out_filename, "global.%s", use_extension);
			Muxer *use_muxer = new Muxer(this, NULL, 1);
			use_muxer->InitMux(audio, use_video_codec, use_audio_codec, "global.bin", NULL, out_filename, NULL, desktop_monitor, pulse_mixer, -1, original_w, original_h, fps, 8000.0, -1, NULL, NULL);
			AddLastMuxed(out_filename);
			delete use_muxer;
		}
	}
	ClearCameraCaps();
}

void	MyWin::LoadOutputPathList(char *filename)
{
char	buf[4096];
int		loop;

	int cnt = 0;
	FILE *fp = fopen(filename, "r");
	if(fp != NULL)
	{
		while(fgets(buf, 4096, fp) != NULL)
		{
			strip_lf(buf);
			if(buf[0] == '*')
			{
				output_active[cnt] = 1;
			}
			char *cp = buf;
			while((*cp != '[') && (*cp != '\0'))
			{
				cp++;
			}
			if(*cp == '[')
			{
				cp++;
				output_name[cnt] = strdup(cp);
				char *cp2 = output_name[cnt];
				while((*cp2 != ']') && (*cp2 != '\0'))
				{
					cp2++;
				}
				*cp2 = '\0';
				while((*cp != ']') && (*cp != '\0'))
				{
					cp++;
				}
				if(*cp == ']')
				{
					*cp = '\0';
					cp++;
					output_path[cnt] = strdup(cp);
					cnt++;
				}
			}
		}
		fclose(fp);
	}
	output_path_cnt = cnt;
}

void	MyWin::SaveOutputPathList(char *filename)
{
int	loop;

	FILE *fp = fopen(filename, "w");
	if(fp != NULL)
	{
		for(loop = 0;loop < output_path_cnt;loop++)
		{
			char cc = ' ';
			if(output_active[loop] == 1)
			{
				cc = '*';
			}
			fprintf(fp, "%c[%s]%s\n", cc, output_name[loop], output_path[loop]);
		}
		fclose(fp);
	}
}

void	set_output_select_cb(Fl_Widget *w, void *v)
{
int	loop;

	SetOutputWindow *win = (SetOutputWindow *)v;
	win->redraw();
}

void	set_output_accept_cb(Fl_Widget *w, void *v)
{
	SetOutputWindow *win = (SetOutputWindow *)v;
	win->Debrief();
	win->my_window->SaveOutputPathList("outputs.txt");
	win->hide();
	reset_button_cb(NULL, win->my_window);
}

void	set_output_cancel_cb(Fl_Widget *w, void *v)
{
	SetOutputWindow *win = (SetOutputWindow *)v;
	win->hide();
	win->Populate();
}

void	set_output_rescan_cb(Fl_Widget *w, void *v)
{
	SetOutputWindow *win = (SetOutputWindow *)v;
	Fl_Input *in = (Fl_Input *)w;
	char *val = (char *)in->value();
	if(strlen(val) < 1)
	{
		in->parent()->hide();
	}
	else
	{
		char out[4096];
		int	streaming = interpret_output_path(NULL, val, out);
		if(streaming == 1)
		{
			in->color(DARK_RED);
			in->label("URL:");
		}
		else
		{
			in->label("File:");
		}
		in->redraw();
		in->parent()->redraw();
	}
}

void	set_output_add_cb(Fl_Widget *w, void *v)
{
	SetOutputWindow *win = (SetOutputWindow *)v;
	int num = win->pack->children();
	int y_pos = 5 + (num * 22);
	Fl_Group *grp = new Fl_Group(0, y_pos, win->w(), 20);
	grp->box(FL_FLAT_BOX);
	grp->color(FL_BLACK);
		win->button[num] = new Fl_Light_Button(15, y_pos, 20, 20);
		win->button[num]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		win->button[num]->box(FL_FLAT_BOX);
		win->button[num]->color(FL_BLACK);
		win->button[num]->down_color(FL_YELLOW);
		win->button[num]->labelcolor(FL_YELLOW);
		win->button[num]->value(0);

		win->name[num] = new Fl_Input(60, y_pos, 120, 20);
		win->name[num]->color(FL_BLACK);
		win->name[num]->textcolor(FL_WHITE);
		win->name[num]->textsize(11);
		win->name[num]->cursor_color(FL_WHITE);
		win->name[num]->labelcolor(FL_YELLOW);
		win->name[num]->labelsize(9);
		win->name[num]->box(FL_FRAME_BOX);

		win->preset[num] = new Fl_Input(181, y_pos, 520, 20);
		win->preset[num]->color(FL_BLACK);
		win->preset[num]->textcolor(FL_WHITE);
		win->preset[num]->textsize(11);
		win->preset[num]->cursor_color(FL_WHITE);
		win->preset[num]->labelcolor(FL_YELLOW);
		win->preset[num]->labelsize(9);
		win->preset[num]->box(FL_FRAME_BOX);
		win->preset[num]->callback(set_output_rescan_cb, win);
	grp->end();
	win->pack->add(grp);
	win->redraw();
}

void	MyWin::ClearMuxerArray()
{
int	loop;

	reset_button_cb(NULL, this);
	for(loop = 0;loop < 128;loop++)
	{
		if(my_muxer[loop] != NULL)
		{
			my_muxer[loop]->Pause();
			my_muxer[loop]->Stop();
			my_muxer[loop]->FinishMux();
			delete my_muxer[loop];
			my_muxer[loop] = NULL;
		}
	}
}

void	SetOutputWindow::Debrief()
{
int	loop;

	my_window->ClearMuxerArray();
	int cnt = my_window->output_path_cnt;
	for(loop = 0;loop < cnt;loop++)
	{
		if(my_window->output_path[loop] != NULL)
		{
			free(my_window->output_path[loop]);
			my_window->output_path[loop] = NULL;
		}
	}
	int num = pack->children();
	cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		my_window->output_active[loop] = 0;
	}
	for(loop = 0;loop < num;loop++)
	{
		if(preset[loop] != NULL)
		{
			char *str = (char *)name[loop]->value();
			if(str != NULL)
			{
				if(strlen(str) > 0)
				{
					my_window->output_name[cnt] = strdup(str);
				}
			}
			str = (char *)preset[loop]->value();
			if(str != NULL)
			{
				if(strlen(str) > 0)
				{
					my_window->output_path[cnt] = strdup(str);
					my_window->output_active[cnt] = button[loop]->value();
					cnt++;
				}
			}
		}
	}
	my_window->output_path_cnt = cnt;
}

void	SetOutputWindow::Populate()
{
int	loop;
int	inner;

	pack->clear();
	int cnt = my_window->output_path_cnt;
	int y_pos = 5;
	for(loop = 0;loop < cnt;loop++)
	{
		Fl_Group *grp = new Fl_Group(0, y_pos, w(), 20);
		grp->box(FL_FLAT_BOX);
		grp->color(FL_BLACK);
			button[loop] = new Fl_Light_Button(15, y_pos, 20, 20);
			button[loop]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
			button[loop]->box(FL_FLAT_BOX);
			button[loop]->color(FL_BLACK);
			button[loop]->down_color(FL_YELLOW);
			button[loop]->labelcolor(FL_YELLOW);
			button[loop]->value(0);
			button[loop]->callback(set_output_select_cb, this);
			button[loop]->value(my_window->output_active[loop]);

			name[loop] = new Fl_Input(60, y_pos, 120, 20);
			name[loop]->color(FL_BLACK);
			name[loop]->textcolor(FL_WHITE);
			name[loop]->textsize(11);
			name[loop]->cursor_color(FL_WHITE);
			name[loop]->labelcolor(FL_YELLOW);
			name[loop]->labelsize(9);
			name[loop]->box(FL_FRAME_BOX);
			name[loop]->value(my_window->output_name[loop]);

			preset[loop] = new Fl_Input(181, y_pos, 520, 20);
			preset[loop]->color(FL_BLACK);
			preset[loop]->textcolor(FL_WHITE);
			preset[loop]->textsize(11);
			preset[loop]->cursor_color(FL_WHITE);
			preset[loop]->labelcolor(FL_YELLOW);
			preset[loop]->labelsize(9);
			preset[loop]->box(FL_FRAME_BOX);
			preset[loop]->value(my_window->output_path[loop]);
			preset[loop]->callback(set_output_rescan_cb, this);
			char out[4096];
			int	streaming = interpret_output_path(my_window, my_window->output_path[loop], out);
			if(streaming == 1)
			{
				preset[loop]->color(DARK_RED);
			}
		grp->end();
		pack->add(grp);
		y_pos += 22;
	}
}

void	set_output_repopulate_cb(void *v)
{
	SetOutputWindow *win = (SetOutputWindow *)v;
	win->Populate();
	win->redraw();
}

SetOutputWindow::SetOutputWindow(MyWin *in_win, int xx, int yy, int ww, int hh) : Fl_Window(xx, yy, ww, hh, "Set Output")
{
void	hide_window_cb(Fl_Widget *w, void *v);

	my_window = in_win;
	last_x = 0;
	last_y = 0;
	box(FL_FLAT_BOX);
	color(FL_BLACK);
	border(0);
	my_window->LoadOutputPathList("outputs.txt");
	int cnt = my_window->output_path_cnt;

	Fl_Box *box1 = new Fl_Box(0, 0, 50, 20, "Active");
	box1->color(FL_BLACK);
	box1->labelsize(11);
	box1->labelcolor(FL_YELLOW);
	box1->box(FL_FLAT_BOX);
	Fl_Box *box2 = new Fl_Box(60, 0, 120, 20, "Name");
	box2->color(FL_BLACK);
	box2->labelsize(11);
	box2->labelcolor(FL_YELLOW);
	box2->box(FL_FLAT_BOX);
	Fl_Box *box3 = new Fl_Box(180, 0, 520, 20, "Path/URL");
	box3->color(FL_BLACK);
	box3->labelsize(11);
	box3->labelcolor(FL_YELLOW);
	box3->box(FL_FLAT_BOX);

	scroll = new Fl_Scroll(0, 25, ww, hh - 160);
	scroll->box(FL_FLAT_BOX);
	scroll->scrollbar_size(4);
	scroll->box(FL_FLAT_BOX);
	scroll->color(FL_BLACK);
	scroll->type(Fl_Scroll::VERTICAL);
	scroll->hscrollbar.hide();
	scroll->end();
	pack = new Fl_Pack(0, 25, ww, hh);
	pack->box(FL_NO_BOX);
	pack->color(FL_GRAY);
	pack->end();
	Populate();
	scroll->add(pack);

	Fl_Box *instruction = new Fl_Box(10, hh - 130, ww - 20, 100);
	instruction->box(FL_FLAT_BOX);
	instruction->color(FL_BLACK);
	instruction->labelsize(9);
	instruction->labelcolor(FL_WHITE);
	instruction->labelfont(FL_SCREEN);
	instruction->align(FL_ALIGN_TOP | FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	instruction->label(
		"Insert into the path:\n\n"
		"%home = home directory\t\t\t"
		"%cwd = current working directory\n"
		"%Y = current year\t\t\t"
		"%M = current month\t\t\t"
		"%D = current day\n"
		"%h = hour\t\t\t\t"
		"%m = minute\t\t\t\t"
		"%s = second\n"
		"%u = microsecond\t\t\t"
		"%U = millisecond\t\t\t"
		"%S = current time in seconds\n\n"
		"So: \"video_%Y_%M_%D_%h_%m_%s.flv\" will produce \"video_2024_1_22_13_6_31.flv\" on January 22nd, 2024");

	Fl_Button *add = new Fl_Button(35, hh - 30, 80, 20, "Add");
	add->box(FL_NO_BOX);
	add->color(FL_WHITE);
	add->labelcolor(FL_YELLOW);
	add->labelsize(12);
	add->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	add->callback(set_output_add_cb, this);

	Fl_Button *accept = new Fl_Button(430, hh - 30, 80, 20, "Accept");
	accept->box(FL_NO_BOX);
	accept->color(FL_WHITE);
	accept->labelcolor(FL_YELLOW);
	accept->labelsize(12);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->callback(set_output_accept_cb, this);

	Fl_Button *cancel = new Fl_Button(500, hh - 30, 80, 20, "Cancel");
	cancel->box(FL_NO_BOX);
	cancel->color(FL_WHITE);
	cancel->labelcolor(FL_YELLOW);
	cancel->labelsize(12);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->callback(set_output_cancel_cb, this);
	end();
}

SetOutputWindow::~SetOutputWindow()
{
}

int	SetOutputWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		last_x = Fl::event_x_root();
		last_y = Fl::event_y_root();
	}
	else if(event == FL_RELEASE)
	{
		flag = 1;
	}
	else if(event == FL_DRAG)
	{
		int xx = Fl::event_x_root();
		int yy = Fl::event_y_root();
		int dx = last_x - xx;
		int dy = last_y - yy;
		resize(x() - dx, y() - dy, w(), h());
		last_x = xx;
		last_y = yy;
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

SelectOutputWindow::SelectOutputWindow(MyWin *in_win, int xx, int yy, int ww, int hh) : Fl_Window(xx, yy, ww, hh, "Select Output")
{
void	hide_window_cb(Fl_Widget *w, void *v);

	my_window = in_win;
	last_x = 0;
	last_y = 0;
	box(FL_FLAT_BOX);
	color(FL_BLACK);
	border(0);
	Fl_Box *box = new Fl_Box(0, 0, 130, 20, "Outputs");
	box->color(FL_BLACK);
	box->box(FL_FLAT_BOX);
	box->labelcolor(FL_WHITE);
	box->labelsize(11);

	pack = new Fl_Pack(5, 25, 120, hh - 60);
	pack->box(FL_FRAME);
	pack->color(FL_GRAY);
	pack->end();

	close = new Fl_Button((w() / 2) - 30, y() - 25, 60, 20, "Close");
	close->box(FL_FLAT_BOX);
	close->color(FL_BLACK);
	close->labelcolor(FL_YELLOW);
	close->labelsize(11);
	close->callback(hide_window_cb, this);

	end();
}

SelectOutputWindow::~SelectOutputWindow()
{
}

int	SelectOutputWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		last_x = Fl::event_x_root();
		last_y = Fl::event_y_root();
	}
	else if(event == FL_RELEASE)
	{
		flag = 1;
	}
	else if(event == FL_DRAG)
	{
		int xx = Fl::event_x_root();
		int yy = Fl::event_y_root();
		int dx = last_x - xx;
		int dy = last_y - yy;
		resize(x() - dx, y() - dy, w(), h());
		last_x = xx;
		last_y = yy;
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	select_specific_output_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	SelectOutputWindow *here = (SelectOutputWindow *)w->window();
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Fl_Toggle_Button *b = (Fl_Toggle_Button *)w;
		char *str = (char *)b->label();
		if(str != NULL)
		{
			int done = 0;
			for(loop = 0;((loop < win->output_path_cnt) && (done == 0));loop++)
			{
				if(strcmp(str, win->output_name[loop]) == 0)
				{
					win->output_active[loop] = b->value();
					reset_button_cb(NULL, win);
					done = 1;
				}
			}
		}
	}
	here->Populate();
	here->redraw();
}

void	SelectOutputWindow::Populate()
{
int	loop;

	pack->clear();
	int yp = 0;
	for(loop = 0;loop < my_window->output_path_cnt;loop++)
	{
		Fl_Toggle_Button *button = new Fl_Toggle_Button(10, yp, 100, 18, my_window->output_name[loop]);
		button->color(FL_BLACK);
		button->labelcolor(FL_YELLOW);
		button->labelsize(9);
		button->box(FL_FLAT_BOX);
		button->value(my_window->output_active[loop]);
		button->down_color(FL_DARK_BLUE);
		button->callback(select_specific_output_button_cb, my_window);
		pack->add(button);
		yp += 19;
	}
	pack->resize(5, 22, 120, yp);
	resize(x(), y(), 130, yp + 50);
	close->resize(close->x(), h() - 25, close->w(), 20);
}

void	MyWin::BuildSetOutputWindow()
{
	set_output_window = new SetOutputWindow(this, 400, 240, 720, 500);
	set_output_window->hide();
	set_output_window->set_non_modal();
}

void	MyWin::BuildSelectOutputWindow()
{
	select_output_window = new SelectOutputWindow(this, 400, 240, 130, 40);
	select_output_window->hide();
	select_output_window->set_non_modal();
}

void	MyWin::SetupObjectMenu()
{
int		loop;
char	*sorted_list[1024];

	int nxx = 300;
	int nyy = 100;
	object_box = new Fl_Box(290, 90, 600, 920);
	object_box->box(FL_FRAME_BOX);
	object_box->color(FL_BLACK);
	object_box->hide();
	for(loop = 0;loop < recognize_class_cnt;loop++)
	{
		sorted_list[loop] = recognize_class_name[loop];
	}
	object_page = 0;
	qsort(sorted_list, recognize_class_cnt, sizeof(char *), cmpstringp);
	for(loop = 0;loop < recognize_class_cnt;loop++)
	{
		object_name_button[loop] = new Fl_Button(nxx, nyy, 200, 22, strdup(sorted_list[loop]));
		object_name_button[loop]->box(FL_NO_BOX);
		object_name_button[loop]->labelcolor(FL_YELLOW);
		object_name_button[loop]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		object_name_button[loop]->callback(select_objects_cb, this);
		object_name_button[loop]->hide();
		nyy += 22;
		if(nyy > 980)
		{
			nyy = 100;
			nxx += 200;
			if(nxx > 700)
			{
				nxx = 300;
			}
		}
	}
	object_clear_button = new Fl_Button(nxx + 200, 110, 200, 26, "Clear");
	object_clear_button->box(FL_FRAME_BOX);
	object_clear_button->color(FL_BLACK);
	object_clear_button->labelcolor(FL_YELLOW);
	object_clear_button->labelsize(18);
	object_clear_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_clear_button->callback(clear_select_objects_cb, this);
	object_clear_button->hide();

	object_all_button = new Fl_Button(nxx + 200, 140, 200, 26, "Select All");
	object_all_button->box(FL_FRAME_BOX);
	object_all_button->color(FL_BLACK);
	object_all_button->labelcolor(FL_YELLOW);
	object_all_button->labelsize(18);
	object_all_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_all_button->callback(select_all_objects_cb, this);
	object_all_button->hide();

	object_done_button = new Fl_Button(nxx + 200, 170, 200, 26, "Done");
	object_done_button->box(FL_FRAME_BOX);
	object_done_button->color(FL_BLACK);
	object_done_button->labelcolor(FL_YELLOW);
	object_done_button->labelsize(18);
	object_done_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_done_button->callback(done_select_objects_cb, this);
	object_done_button->hide();

	object_next_button = new Fl_Button(nxx + 200, 220, 200, 26, "Next Page");
	object_next_button->box(FL_FRAME_BOX);
	object_next_button->color(FL_BLACK);
	object_next_button->labelcolor(FL_YELLOW);
	object_next_button->labelsize(18);
	object_next_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_next_button->callback(next_page_objects_cb, this);
	object_next_button->hide();

	object_prev_button = new Fl_Button(nxx + 200, 250, 200, 26, "Prev Page");
	object_prev_button->box(FL_FRAME_BOX);
	object_prev_button->color(FL_BLACK);
	object_prev_button->labelcolor(FL_YELLOW);
	object_prev_button->labelsize(18);
	object_prev_button->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	object_prev_button->callback(prev_page_objects_cb, this);
	object_prev_button->hide();
}

void	MyWin::ReadInExternalPrograms()
{
int	loop;

	FILE *fp = fopen("external_programs.txt", "r");
	if(fp != NULL)
	{
		char buf[4096];
		char *path[10];
		int width[10];
		int height[10];
		char *arg[10][10];
		int entry = -1;
		int arg_cnt = 0;
		int inner;
		while((fgets(buf, 4096, fp) != NULL) && (entry < 9))
		{
			strip_lf(buf);
			if(strncasecmp(buf, "PATH=", strlen("PATH=")) == 0)
			{
				entry++;
				arg_cnt = 0;
				for(inner = 0;inner < 10;inner++)
				{
					arg[entry][inner] = NULL;
				}
				char *cp = buf + strlen("PATH=");
				path[entry] = strdup(cp);
			}
			if(strncasecmp(buf, "WIDTH=", strlen("WIDTH=")) == 0)
			{
				char *cp = buf + strlen("WIDTH=");
				width[entry] = atoi(cp);;
			}
			if(strncasecmp(buf, "HEIGHT=", strlen("HEIGHT=")) == 0)
			{
				char *cp = buf + strlen("HEIGHT=");
				height[entry] = atoi(cp);;
			}
			if(strncasecmp(buf, "ARG=", strlen("ARG=")) == 0)
			{
				char *cp = buf + strlen("ARG=");
				arg[entry][arg_cnt] = strdup(cp);
				if(arg_cnt < 10)
				{
					arg_cnt++;
				}
			}
		}
		fclose(fp);
		for(loop = 0;loop <= entry;loop++)
		{
			printf("%02d PATH: [%s]\n", loop, path[loop]);
			printf("%02d WIDTH: [%d]\n", loop, width[loop]);
			printf("%02d HEIGHT: [%d]\n", loop, height[loop]);
			for(inner = 0;inner < 10;inner++)
			{
				printf("%02d|%02d ARG: [%s]\n", loop, inner, arg[loop][inner]);
			}
			int x_pos = 0;
			int y_pos = 0;
			CalcEmbeddedWindowPosition(width[loop], height[loop], x_pos, y_pos);
			EmbedAppWindow *embed = new EmbedAppWindow(x_pos, y_pos, width[loop], height[loop]);
			AddEmbeddedWindow(embed);
			embed->set_non_modal();
			embed->show();
			embed->EmbedApp(path[loop], arg[loop]);
		}
	}
}

StoredMyWin::StoredMyWin()
{
}

StoredMyWin::StoredMyWin(MyWin *in_win)
{
int	loop;

	for(loop = 0;loop < in_win->source_cnt;loop++)
	{
		int go = 1;
		Camera *cam = in_win->camera[loop];
		if(cam != NULL)
		{
			if(strlen(cam->original_path) > 0)
			{
				strcpy(source[loop], cam->original_path);
				go = 0;
			}
		}
		if(go == 1)
		{
			if(in_win->source[loop] != NULL)
			{
				strcpy(source[loop], in_win->source[loop]);
			}
			else
			{
				strcpy(source[loop], "");
			}
		}
	}
	for(loop = in_win->source_cnt;loop < 128;loop++)
	{
		strcpy(source[loop], "");
	}
	source_cnt = in_win->source_cnt;
	for(loop = 0;loop < 128;loop++)
	{
		strcpy(audio_source[loop], "");
	}
	audio_source_cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		if(in_win->audio_thumbnail[loop] != NULL)
		{
			PulseAudioButton *audio = in_win->audio_thumbnail[loop];
			if(strlen(audio->device_name) > 0)
			{
				strcpy(audio_source[loop], audio->device_name);
				audio_source_cnt++;
			}
		}
	}
	for(loop = 0;loop < 10;loop++)
	{
		split_bx[loop] = in_win->split_bx[loop];
		split_by[loop] = in_win->split_by[loop];
		split_rx[loop] = in_win->split_rx[loop];
		split_ry[loop] = in_win->split_ry[loop];
	}
	requested_w = in_win->requested_w;
	requested_h = in_win->requested_h;
	output_width = in_win->output_width;
	output_height = in_win->output_height;
	display_width = in_win->display_width;
	display_height = in_win->display_height;
	image_sx = in_win->image_sx;
	image_sy = in_win->image_sy;
	use_mousewheel = in_win->use_mousewheel;
	direct_recording = in_win->direct_recording;
	muxing = in_win->muxing;
	no_scan = in_win->no_scan;
	no_audio_scan = in_win->no_audio_scan;
	speed_factor = in_win->speed_factor;

	strcpy(yolo_cfg_filename, in_win->yolo_cfg_filename);
	strcpy(yolo_weights_filename, in_win->yolo_weights_filename);
	strcpy(yolo_names_filename, in_win->yolo_names_filename);

	forced_fps = in_win->forced_fps;
	forced_interval = in_win->forced_interval;
	restore_forced_interval = in_win->forced_interval;
	minimum_fps = in_win->minimum_fps;
	if(in_win->jpeg_streaming != NULL)
	{
		strcpy(jpeg_streaming, in_win->jpeg_streaming);
	}
	else
	{
		strcpy(jpeg_streaming, "");
	}
	jpeg_streaming_port = in_win->jpeg_streaming_port;
	streaming = in_win->streaming;
	strcpy(stream_url, in_win->stream_url);
	stream_only = in_win->stream_only;
	streaming_audio_quality = in_win->streaming_audio_quality;
	embed_pip = in_win->embed_pip;
	pip_x_position = in_win->pip_x_position;
	pip_y_position = in_win->pip_y_position;
	pip_red = in_win->pip_red;
	pip_green = in_win->pip_green;
	pip_blue = in_win->pip_blue;
	pip_size = in_win->pip_size;
	multipip = in_win->multipip;
	grid_size = in_win->grid_size;
	if(in_win->desktop_monitor != NULL)
	{
		strcpy(desktop_monitor, in_win->desktop_monitor);
	}
	else
	{
		strcpy(desktop_monitor, "");
	}
	audio = in_win->audio;
	mute_audio = in_win->mute_audio;
	strcpy(mux_format, in_win->mux_format);

	retain_commands = in_win->retain_commands;
	retain_cameras = in_win->retain_cameras;
	retain_audio = in_win->retain_audio;
	retain_ptz = in_win->retain_ptz;

	encoding = in_win->encoding;
	stream = in_win->stream;
	visible_debug = in_win->visible_debug;
	for(loop = 0;loop < 100;loop++)
	{
		interest_x[loop] = in_win->interest_x[loop];
		interest_y[loop] = in_win->interest_y[loop];
	}
	interest_cnt = in_win->interest_cnt;
	timestamp = in_win->timestamp;
	resizing_detail = in_win->resizing_detail;
	drag_start_x = in_win->drag_start_x;
	drag_start_y = in_win->drag_start_y;
	motion_debug = in_win->motion_debug;
	split = in_win->split;

	record_all = in_win->record_all;
	record_desktop = in_win->record_desktop;
	desktop_x = in_win->desktop_x;
	desktop_y = in_win->desktop_y;
	desktop_w = in_win->desktop_w;
	desktop_h = in_win->desktop_h;
	single_stream = in_win->single_stream;
	display_recording_camera = in_win->display_recording_camera;
	transition = in_win->transition;
	
	for(loop = 0;loop < NUMBER_OF_INTERFACES;loop++)
	{
		if(in_win->ptz_device_path[loop] != NULL)
		{
			strcpy(ptz_device_path[loop], in_win->ptz_device_path[loop]);
			if(in_win->ptz_lock_alias[loop] != NULL)
			{
				strcpy(ptz_lock_alias[loop], in_win->ptz_lock_alias[loop]);
			}
			else
			{
				strcpy(ptz_lock_alias[loop], "");
			}
			if(in_win->ptz_alias[loop] != NULL)
			{
				strcpy(ptz_alias[loop], in_win->ptz_alias[loop]);
			}
			else
			{
				strcpy(ptz_alias[loop], "");
			}
		}
		else
		{
			strcpy(ptz_device_path[loop], "");
		}
	}
	ptz_device_cnt = in_win->ptz_device_cnt;
	ptz_zoom = in_win->ptz_zoom;
	old_ptz_zoom = in_win->old_ptz_zoom;
	ptz_panning = in_win->ptz_panning;
	ptz_zooming = in_win->ptz_zooming;
	ptz_focusing = in_win->ptz_focusing;
	ptz_pan_speed = in_win->ptz_pan_speed;
	ptz_tilt_speed = in_win->ptz_tilt_speed;
	use_pan_speed = in_win->use_pan_speed;
	use_tilt_speed = in_win->use_tilt_speed;
	ptz_focus_speed = in_win->ptz_focus_speed;
	ptz_zoom_speed = in_win->ptz_zoom_speed;
	ptz_follow = in_win->ptz_follow;
	ptz_adjust_speed_for_zoom = in_win->ptz_adjust_speed_for_zoom;
	ptz_tour_index = in_win->ptz_tour_index;
	ptz_little_speed = in_win->ptz_little_speed;
	ptz_little_mode = in_win->ptz_little_mode;
	ptz_reverse_horizontal = in_win->ptz_reverse_horizontal;
	ptz_reverse_vertical = in_win->ptz_reverse_vertical;
	ptz_joystick = in_win->ptz_joystick;
	transmitting = in_win->transmitting;
	image_memory = in_win->image_memory;

	use_video_codec = in_win->use_video_codec;
	use_audio_codec = in_win->use_audio_codec;
	strcpy(use_extension, in_win->use_extension);
}

StoredMyWin::~StoredMyWin()
{
}

void	MyWin::Save(char *filename)
{
int	loop;

	int fd = open(filename, O_CREAT | O_WRONLY, 0655);
	if(fd > -1)
	{
		StoredMyWin *stored = new StoredMyWin(this);
		int camera_cnt = 0;
		for(loop = 0;loop < source_cnt;loop++)
		{
			Camera *cam = camera[loop];
			if(cam != NULL)
			{
				camera_cnt++;
			}
		}
		write(fd, &camera_cnt, sizeof(int));
		for(loop = 0;loop < source_cnt;loop++)
		{
			Camera *cam = camera[loop];
			if(cam != NULL)
			{
				cam->Save(fd);
			}
		}
		stored->Save(fd);
		delete stored;
		close(fd);
	}
}

void	MyWin::Load(char *filename)
{
int	loop;

	actively_loading = 1;
	int fd = open(filename, O_RDONLY);
	if(fd > -1)
	{
		StoredMyWin *stored = new StoredMyWin();
		int camera_cnt = 0;
		read(fd, &camera_cnt, sizeof(int));
		Cleanup();
		source_cnt = 0;
		for(loop = 0;loop < camera_cnt;loop++)
		{
			LoadCamera(fd);
		}
		stored->Load(fd);
		RestoreFromStored(stored);
		delete stored;
		close(fd);
		SetupPTZWindow(0);
		add(ptz_window);
		BuildSetOutputWindow();
		recognize_class_cnt = 0;
		ReadClasses();
	}
	actively_loading = 0;
}

void	StoredMyWin::Save(char *filename)
{
	int fd = open(filename, O_CREAT | O_WRONLY, 0655);
	if(fd > -1)
	{
		write(fd, this, sizeof(StoredMyWin));
		close(fd);
	}
}

void	StoredMyWin::Save(int fd)
{
	write(fd, this, sizeof(StoredMyWin));
}

void	StoredMyWin::Load(char *filename)
{
	int fd = open(filename, O_RDONLY);
	if(fd > -1)
	{
		read(fd, this, sizeof(StoredMyWin));
		close(fd);
	}
}

void	StoredMyWin::Load(int fd)
{
	read(fd, this, sizeof(StoredMyWin));
}

void	MyWin::Cleanup()
{
int	loop;

	Shutdown();
	pulse_microphone_cnt = 0;
	for(loop = 0;loop < NUMBER_OF_INTERFACES;loop++)
	{
		ptz_interface_select_button[loop] = NULL;
	}
	for(loop = 0;loop < NUMBER_OF_CAMERAS;loop++)
	{
		ptz_camera_select_button[loop] = NULL;
	}
	for(loop = 0;loop < 10;loop++)
	{
		split_bx[loop] = -1;
		split_by[loop] = -1;
		split_rx[loop] = -1;
		split_ry[loop] = -1;
	}
	for(loop = 0;loop < 1024;loop++)
	{
		recognize_class_name[loop] = NULL;
	}
	if(ptz_window != NULL)
	{
		ptz_window->hide();
		remove(ptz_window);
		delete ptz_window;
		ptz_window = NULL;
	}
}

void	MyWin::RestoreFromStored(StoredMyWin *in_win)
{
void	my_window_cb(void *v);
int	loop;
static int repeat = 0;

	source_cnt = 0;
	for(loop = 0;loop < in_win->source_cnt;loop++)
	{
		if(strlen(in_win->source[loop]) > 0)
		{
			source[loop] = strdup(in_win->source[loop]);
		}
	}
	source_cnt = in_win->source_cnt;
	audio_source_cnt = 0;
	for(loop = 0;loop < in_win->audio_source_cnt;loop++)
	{
		if(strlen(in_win->audio_source[loop]) > 0)
		{
			audio_source[loop] = strdup(in_win->audio_source[loop]);
		}
	}
	source_cnt = in_win->source_cnt;
	for(loop = 0;loop < 10;loop++)
	{
		split_bx[loop] = in_win->split_bx[loop];
		split_by[loop] = in_win->split_by[loop];
		split_rx[loop] = in_win->split_rx[loop];
		split_ry[loop] = in_win->split_ry[loop];
	}
	requested_w = in_win->requested_w;
	requested_h = in_win->requested_h;
	output_width = in_win->output_width;
	output_height = in_win->output_height;
	display_width = in_win->display_width;
	display_height = in_win->display_height;
	speed_factor = in_win->speed_factor;
	image_sx = in_win->image_sx;
	image_sy = in_win->image_sy;
	use_mousewheel = in_win->use_mousewheel;
	direct_recording = in_win->direct_recording;
	muxing = in_win->muxing;
	no_scan = in_win->no_scan;
	no_audio_scan = in_win->no_audio_scan;

	retain_commands = in_win->retain_commands;
	retain_cameras = in_win->retain_cameras;
	retain_audio = in_win->retain_audio;
	retain_ptz = in_win->retain_ptz;

	strcpy(yolo_cfg_filename, in_win->yolo_cfg_filename);
	strcpy(yolo_weights_filename, in_win->yolo_weights_filename);
	strcpy(yolo_names_filename, in_win->yolo_names_filename);

	forced_fps = in_win->forced_fps;
	forced_interval = in_win->forced_interval;
	restore_forced_interval = in_win->forced_interval;
	minimum_fps = in_win->minimum_fps;
	if(strlen(in_win->jpeg_streaming) > 0)
	{
		jpeg_streaming = strdup(in_win->jpeg_streaming);
	}
	else
	{
		jpeg_streaming = NULL;
	}
	jpeg_streaming_port = in_win->jpeg_streaming_port;
	streaming = in_win->streaming;
	strcpy(stream_url, in_win->stream_url);
	stream_only = in_win->stream_only;
	streaming_audio_quality = in_win->streaming_audio_quality;
	embed_pip = in_win->embed_pip;
	pip_x_position = in_win->pip_x_position;
	pip_y_position = in_win->pip_y_position;
	pip_red = in_win->pip_red;
	pip_green = in_win->pip_green;
	pip_blue = in_win->pip_blue;
	pip_size = in_win->pip_size;
	multipip = in_win->multipip;
	grid_size = in_win->grid_size;
	if(strlen(in_win->desktop_monitor) > 0)
	{
		desktop_monitor = strdup(in_win->desktop_monitor);
	}
	else
	{
		desktop_monitor = NULL;
	}
	audio = in_win->audio;
	mute_audio = in_win->mute_audio;
	strcpy(mux_format, in_win->mux_format);

	encoding = in_win->encoding;
	stream = in_win->stream;
	visible_debug = in_win->visible_debug;
	for(loop = 0;loop < 100;loop++)
	{
		interest_x[loop] = in_win->interest_x[loop];
		interest_y[loop] = in_win->interest_y[loop];
	}
	interest_cnt = in_win->interest_cnt;
	timestamp = in_win->timestamp;
	resizing_detail = in_win->resizing_detail;
	drag_start_x = in_win->drag_start_x;
	drag_start_y = in_win->drag_start_y;
	motion_debug = in_win->motion_debug;
	split = in_win->split;

	record_all = in_win->record_all;
	record_desktop = in_win->record_desktop;
	desktop_x = in_win->desktop_x;
	desktop_y = in_win->desktop_y;
	desktop_w = in_win->desktop_w;
	desktop_h = in_win->desktop_h;
	single_stream = in_win->single_stream;
	display_recording_camera = in_win->display_recording_camera;
	transition = in_win->transition;
	
	for(loop = 0;loop < NUMBER_OF_INTERFACES;loop++)
	{
		if(strlen(in_win->ptz_device_path[loop]) > 0)
		{
			ptz_device_path[loop] = strdup(in_win->ptz_device_path[loop]);
			if(strlen(in_win->ptz_lock_alias[loop]) > 0)
			{
				ptz_lock_alias[loop] = strdup(in_win->ptz_lock_alias[loop]);
			}
			else
			{
				ptz_lock_alias[loop] = NULL;
			}
			if(strlen(in_win->ptz_alias[loop]) > 0)
			{
				ptz_alias[loop] = strdup(in_win->ptz_alias[loop]);
			}
			else
			{
				ptz_alias[loop] = NULL;
			}
		}
		else
		{
			ptz_device_path[loop] = NULL;
		}
	}
	ptz_device_cnt = in_win->ptz_device_cnt;
	ptz_zoom = in_win->ptz_zoom;
	old_ptz_zoom = in_win->old_ptz_zoom;
	ptz_panning = in_win->ptz_panning;
	ptz_zooming = in_win->ptz_zooming;
	ptz_focusing = in_win->ptz_focusing;
	ptz_pan_speed = in_win->ptz_pan_speed;
	ptz_tilt_speed = in_win->ptz_tilt_speed;
	use_pan_speed = in_win->use_pan_speed;
	use_tilt_speed = in_win->use_tilt_speed;
	ptz_focus_speed = in_win->ptz_focus_speed;
	ptz_zoom_speed = in_win->ptz_zoom_speed;
	ptz_follow = in_win->ptz_follow;
	ptz_adjust_speed_for_zoom = in_win->ptz_adjust_speed_for_zoom;
	ptz_tour_index = in_win->ptz_tour_index;
	ptz_little_speed = in_win->ptz_little_speed;
	ptz_little_mode = in_win->ptz_little_mode;
	ptz_reverse_horizontal = in_win->ptz_reverse_horizontal;
	ptz_reverse_vertical = in_win->ptz_reverse_vertical;
	ptz_joystick = in_win->ptz_joystick;
	transmitting = in_win->transmitting;
	image_memory = in_win->image_memory;

	use_video_codec = in_win->use_video_codec;
	use_audio_codec = in_win->use_audio_codec;
	strcpy(use_extension, in_win->use_extension);

	for(loop = 0;loop < 128;loop++)
	{
		output_name[loop] = NULL;
		output_path[loop] = NULL;
		output_active[loop] = 0;
	}
	recognize_class_cnt = 0;
	ReadClasses();
	if(init_detect == 1)
	{
		SetupObjectDetection();
	}
	pulse_mixer = NULL;
	if(audio == 1)
	{
		if(no_audio_scan == 0)
		{
			ScanPulse(0);
		}
		else
		{
			OpenNamedPulse();
		}
	}
	HideButtons();
	ShowButtons();
	int nxx = 20;
	int nyy = 100;
	video_thumbnail_group->clear();
	for(loop = 0;loop < 128;loop++)
	{
		thumbnail[loop] = new ThumbGroup(this, loop, nxx * gui_scale_factor, nyy * gui_scale_factor, 253 * gui_scale_factor, 88 * gui_scale_factor);
		nyy += 100;
		video_thumbnail_group->add(thumbnail[loop]);
	}
	Fl::add_timeout(0.1, my_window_cb, this);
}

void	MyWin::LoadCamera(char *filename)
{
	StoredCamera *stored = new StoredCamera();
	int fd = open(filename, O_RDONLY);
	if(fd > -1)
	{
		read(fd, stored, sizeof(StoredCamera));
		int cam_num = SetupCamera(stored->original_path, stored->alias, stored->width, stored->height, stored->font_sz);
		if(cam_num > -1)
		{
			Camera *cam = camera[cam_num];
			if(cam != NULL)
			{
				cam->RestoreFromStoredCamera(stored);
				cam->LoadImmediate(fd);
			}
		}
	}
	delete stored;
}

void	MyWin::LoadCamera(int fd)
{
	StoredCamera *stored = new StoredCamera();
	read(fd, stored, sizeof(StoredCamera));
	int cam_num = -1;
	if(strlen(stored->original_path) > 0)
	{
		cam_num = SetupCamera(stored->original_path, stored->alias, stored->width, stored->height, stored->font_sz);
	}
	else
	{
		cam_num = SetupCamera(stored->path, stored->alias, stored->width, stored->height, stored->font_sz);
	}
	if(cam_num > -1)
	{
		Camera *cam = camera[cam_num];
		if(cam != NULL)
		{
			cam->RestoreFromStoredCamera(stored);
			cam->LoadImmediate(fd);
		}
	}
	delete stored;
}

int	MyWin::SetCodec()
{
	int rr = 0;
	use_video_codec = (AVCodecID)AV_CODEC_ID_H264,
	use_audio_codec = (AVCodecID)AV_CODEC_ID_AAC,

	strcpy(use_extension, mux_format);
	if(codec_selection_window != NULL)
	{
		if(codec_selection_window->video_codec_id != 0)
		{
			use_video_codec = codec_selection_window->video_codec_id;
			rr = 1;
		}
		if(codec_selection_window->audio_codec_id != 0)
		{
			use_audio_codec = codec_selection_window->audio_codec_id;
			rr = 2;
		}
		if(strlen(codec_selection_window->extension_selected) > 0)
		{
			strcpy(use_extension, codec_selection_window->extension_selected);
			rr = 4;
		}
	}
	return(rr);
}

void	MyWin::RemoveCamera(Camera *cam)
{
Camera	*list[128];
int	loop;
int	inner;

	for(loop = 0;loop < 128;loop++)
	{
		if(camera[loop] != NULL)
		{
			for(inner = 0;inner < camera[loop]->image_window_cnt;inner++)
			{
				if(camera[loop]->image_window[inner] != NULL)
				{
					ImageWindow *iw = camera[loop]->image_window[inner];
					if(iw->camera == cam)
					{
						iw->hide();
						remove(iw);
						camera[loop]->image_window[inner] = NULL;
						Fl::delete_widget(iw);
					}
				}
			}
			camera[loop]->CompressImageWindowList();
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		list[loop] = NULL;
		if(cam == camera[loop])
		{
			camera[loop] = NULL;
			delete cam;
		}
		if(camera[loop] != NULL)
		{
			if(camera[loop]->source_camera == cam)
			{
				delete camera[loop];
				camera[loop] = NULL;
			}
		}
	}
	int cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		if(camera[loop] != NULL)
		{
			list[cnt] = camera[loop];
			cnt++;
		}
	}
	for(loop = 0;loop < 128;loop++)
	{
		camera[loop] = list[loop];
	}
	source_cnt = cnt;
	UpdateThumbButtons();
}

int	MyWin::ScanForDuplicateCameras(char *in_path)
{
int	inner;

	int rr = 0;
	char path1[PATH_MAX];
	char path2[PATH_MAX];
	realpath(in_path, path1);
	for(inner = 0;((inner < 128) && (rr == 0));inner++)
	{
		if(camera[inner] != NULL)
		{
			if(camera[inner]->path != NULL)
			{
				char path2[PATH_MAX];
				realpath(camera[inner]->path, path2);
				if(strcmp(path1, path2) == 0)
				{
					rr = 1;
				}
			}
		}
	}
	return(rr);
}

void	MyWin::ResetCameras(int reset_existing, char **in_source, int in_source_cnt)
{
int	loop;
int	inner;

	if(reset_existing == 1)
	{
		for(loop = 0;loop < 128;loop++)
		{
			if(camera[loop] != NULL)
			{
				delete camera[loop];
				camera[loop] = NULL;
			}
		}
		start_time = 0;
	}
	for(loop = 0;loop < 128;loop++)
	{
		camera[loop] = NULL;
	}
	source_cnt = 0;
	if(in_source != NULL)
	{
		for(loop = 0;loop < in_source_cnt;loop++)
		{
			if(in_source[loop] != NULL)
			{
				if(atoi(in_source[loop]) == 0)
				{
					if(strlen(in_source[loop]) > 0)
					{
						SetupCamera(in_source[loop], NULL, requested_w, requested_h, 32);
					}
				}
			}
		}
		if(record_desktop == 1)
		{
			SetupCamera("desktop://", "Desktop", requested_w, requested_h, 32);
		}
	}
	if(no_scan == 0)
	{
		ScanForCameras();
	}
}

Camera	*MyWin::CurrentCamera()
{
	Camera *cam = camera[current_source];
	return(cam);
}

Camera	*MyWin::DisplayedCamera()
{
	Camera *cam = camera[displayed_source];
	return(cam);
}

void	MyWin::HideObjects()
{
int	loop;

	object_box->hide();
	for(loop = 0;loop < recognize_class_cnt;loop++)
	{
		object_name_button[loop]->hide();
	}
	object_clear_button->hide();
	object_all_button->hide();
	object_done_button->hide();
	object_next_button->hide();
	object_prev_button->hide();
	redraw();
}

void	MyWin::ShowObjects()
{
int	loop;
int	inner;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		object_box->show();
		object_box->redraw();
		int cnt = 0;
		for(loop = 0;loop < recognize_class_cnt;loop++)
		{
			int start = 123 * object_page;
			int end = 123 * (object_page + 1);
			if((cnt >= start) && (cnt < end))
			{
				object_name_button[loop]->show();
				object_name_button[loop]->redraw();
				for(inner = 0;inner < recognize_class_cnt;inner++)
				{
					if(strcmp(recognize_class_name[inner], object_name_button[loop]->label()) == 0)
					{
						if(cam->object_index[inner] == 1)
						{
							object_name_button[loop]->labelcolor(FL_WHITE);
						}
						else
						{
							object_name_button[loop]->labelcolor(FL_YELLOW);
						}
					}
				}
			}
			else
			{
				object_name_button[loop]->hide();
			}
			cnt++;
		}
		object_clear_button->show();
		object_all_button->show();
		object_done_button->show();
		if(recognize_class_cnt > 123)
		{
			if((recognize_class_cnt / 123) > object_page)
			{
				object_next_button->show();
			}
			else
			{
				object_next_button->hide();
			}
			if(object_page > 0)
			{
				object_prev_button->show();
			}
			else
			{
				object_prev_button->hide();
			}
		}
		redraw();
	}
}

void	MyWin::ScanForCameras()
{
int	loop;

	for(loop = 0;loop < 10;loop++)
	{
		int success = 0;
		Camera *cam = new Camera(this, source_cnt, NULL, loop, forced_fps, requested_w, requested_h);
		if(cam->cap != NULL)
		{
			if(cam->cap->isOpened())
			{
				camera[source_cnt] = cam;
				source_cnt++;
				success = 1;
			}
		}
		if(success == 0)
		{
			delete cam;
		}
	}
	if(record_desktop == 1)
	{
		Camera *cam = new Camera(this, source_cnt, "desktop://", loop, forced_fps, requested_w, requested_h);
		camera[source_cnt] = cam;
		source_cnt++;
	}
}

int	MyWin::SetupCamera(char *source, char *in_alias, int r_ww, int r_hh, int fz, char *font_name, int irr, int igg, int ibb, int iaa, int t_rr, int t_gg, int t_bb, int t_aa, int use_chroma)
{
	int rr = -1;
	Camera *cam = new Camera(this, source_cnt, source, -1, forced_fps, r_ww, r_hh, irr, igg, ibb, iaa, t_rr, t_gg, t_bb, t_aa, use_chroma);
	if(cam != NULL)
	{
		cam->font_sz = fz;
		if(font_name != NULL)
		{
			strcpy(cam->font_name, font_name);
		}
		else
		{
			strcpy(cam->font_name, "Sans");
		}
		int success = 0;
		if(cam->cap != NULL)
		{
			if(cam->cap->isOpened())
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_TEXT)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_PIPED)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_SINGLE_FRAME_FILE)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_OSG)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_DESKTOP)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_WINDOW)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_PSEUDO)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_PLUGIN)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_BLANK)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_AV)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_HTML)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_SOURCED)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_EDGE_DETECT)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_CHROMAKEY)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_ALTERNATING)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
			else if(cam->type == CAMERA_TYPE_ALL)
			{
				camera[source_cnt] = cam;
				rr = source_cnt;
				source_cnt++;
				success = 1;
			}
		}
		else if(cam->type == CAMERA_TYPE_IMAGE)
		{
			camera[source_cnt] = cam;
			rr = source_cnt;
			source_cnt++;
			success = 1;
		}
		if(success == 0)
		{
			delete cam;
		}
		else
		{
			if(in_alias != NULL)
			{
				strcpy(cam->alias, in_alias);
			}
			else
			{
				strcpy(cam->alias, source);
			}
		}
	}
	return(rr);
}

void	review_win_cb(void *v)
{
	ReviewWin *rw = (ReviewWin *)v;
	rw->redraw();
	if(rw->playing == 1)
	{
		Fl::repeat_timeout(rw->delay, review_win_cb, rw);
	}
}

void	MyWin::PTZ_DoCommand(int button, int arg_cnt, int arg0, int arg1, int arg2, int arg3, int arg4)
{
static char	buf1[256];
static char	buf2[256];

	int zoom_factor = 0;
	use_pan_speed = -1;
	use_tilt_speed = -1;

	if((button < 20) && (arg_cnt > 1))
	{
		use_pan_speed = arg0;
		use_tilt_speed = arg1;
	}
	else
	{
		if(ptz_zoom_reading < 0)
		{
			ptz_zoom_reading = 0;
			VISCA_get_zoom_value(ptz_current_interface, ptz_current_camera, (uint16_t *)&ptz_zoom_reading);
			sprintf(buf2, "%05d", ptz_zoom_reading);
			ptz_zoom_value_label->label(buf2);
		}
		ptz_set_speed_cb(ptz_speed_slider, this);

		double use = (double)1.0;
		if(ptz_adjust_speed_for_zoom == 1)
		{
			zoom_factor = ptz_zoom_reading;
			if(zoom_factor < 1) zoom_factor = 1;
			if(zoom_factor > 16384) zoom_factor = 16384;
			use = (double)(16384 - zoom_factor) / 16384.0;
		}
		use_tilt_speed = (int)(ptz_tilt_speed * use);
		use_pan_speed = (int)(ptz_pan_speed * use);
		if(use_tilt_speed < 0) use_tilt_speed = 0;
		if(use_pan_speed < 0) use_pan_speed = 0;
	}
	int acquire_position = 0;
	int acquire_zoom = 0;
	int acquire_focus = 0;

	if(ptz_reverse_horizontal == 1)
	{
		if(button == PTZ_RIGHT) button = PTZ_LEFT;
		else if(button == PTZ_LEFT) button = PTZ_RIGHT;
		else if(button == PTZ_DOWN_RIGHT) button = PTZ_DOWN_LEFT;
		else if(button == PTZ_DOWN_LEFT) button = PTZ_DOWN_RIGHT;
		else if(button == PTZ_UP_RIGHT) button = PTZ_UP_LEFT;
		else if(button == PTZ_UP_LEFT) button = PTZ_UP_RIGHT;
	}
	if(ptz_reverse_vertical == 1)
	{
		if(button == PTZ_UP) button = PTZ_DOWN;
		else if(button == PTZ_DOWN) button = PTZ_UP;
		else if(button == PTZ_DOWN_RIGHT) button = PTZ_UP_RIGHT;
		else if(button == PTZ_DOWN_LEFT) button = PTZ_UP_LEFT;
		else if(button == PTZ_UP_RIGHT) button = PTZ_DOWN_RIGHT;
		else if(button == PTZ_UP_LEFT) button = PTZ_DOWN_LEFT;
	}
	if(button == PTZ_UP_LEFT)
	{
		VISCA_set_pantilt_upleft(ptz_current_interface, ptz_current_camera, use_pan_speed, use_tilt_speed);
		ptz_panning = button;
	}
	else if(button == PTZ_UP_RIGHT)
	{
		VISCA_set_pantilt_upright(ptz_current_interface, ptz_current_camera, use_pan_speed, use_tilt_speed);
		ptz_panning = button;
	}
	else if(button == PTZ_DOWN_RIGHT)
	{
		VISCA_set_pantilt_downright(ptz_current_interface, ptz_current_camera, use_pan_speed, use_tilt_speed);
		ptz_panning = button;
	}
	else if(button == PTZ_DOWN_LEFT)
	{
		VISCA_set_pantilt_downleft(ptz_current_interface, ptz_current_camera, use_pan_speed, use_tilt_speed);
		ptz_panning = button;
	}
	else if(button == PTZ_UP)
	{
		VISCA_set_pantilt_up(ptz_current_interface, ptz_current_camera, use_pan_speed, use_tilt_speed);
		ptz_panning = button;
	}
	else if(button == PTZ_DOWN)
	{
		VISCA_set_pantilt_down(ptz_current_interface, ptz_current_camera, use_pan_speed, use_tilt_speed);
		ptz_panning = button;
	}
	else if(button == PTZ_RIGHT)
	{
		VISCA_set_pantilt_right(ptz_current_interface, ptz_current_camera, use_pan_speed, use_tilt_speed);
		ptz_panning = button;
	}
	else if(button == PTZ_LEFT)
	{
		VISCA_set_pantilt_left(ptz_current_interface, ptz_current_camera, use_pan_speed, use_tilt_speed);
		ptz_panning = button;
	}
	else if(button == PTZ_ZOOM_IN)
	{
		VISCA_set_zoom_tele_speed(ptz_current_interface, ptz_current_camera, ptz_zoom_speed);
		ptz_zooming = 1;
	}
	else if(button == PTZ_ZOOM_OUT)
	{
		VISCA_set_zoom_wide_speed(ptz_current_interface, ptz_current_camera, ptz_zoom_speed);
		ptz_zooming = -1;
	}
	else if(button == PTZ_ZOOM)
	{
		VISCA_set_zoom_value(ptz_current_interface, ptz_current_camera, arg0);
		ptz_zooming = -1;
	}
	else if(button == PTZ_FOCUS)
	{
		VISCA_set_focus_value(ptz_current_interface, ptz_current_camera, arg0);
		ptz_focusing = 1;
	}
	else if(button == PTZ_ZOOM_AND_FOCUS)
	{
		VISCA_set_zoom_and_focus_value(ptz_current_interface, ptz_current_camera, arg0, arg1);
		ptz_zooming = 1;
		ptz_focusing = 1;
		acquire_zoom = 1;
		acquire_focus = 1;
	}
	else if(button == PTZ_FOCUS_FAR)
	{
		VISCA_set_focus_far_speed(ptz_current_interface, ptz_current_camera, ptz_focus_speed);
		ptz_focusing = 1;
	}
	else if(button == PTZ_FOCUS_NEAR)
	{
		VISCA_set_focus_near_speed(ptz_current_interface, ptz_current_camera, ptz_focus_speed);
		ptz_focusing = -1;
	}
	else if(button == PTZ_APERTURE_OPEN)
	{
		VISCA_set_iris_up(ptz_current_interface, ptz_current_camera);
		ptz_focusing = 1;
	}
	else if(button == PTZ_APERTURE_CLOSE)
	{
		VISCA_set_iris_down(ptz_current_interface, ptz_current_camera);
		ptz_focusing = -1;
	}
	else if(button == PTZ_HOME)
	{
		VISCA_set_pantilt_home(ptz_current_interface, ptz_current_camera);
		VISCA_set_zoom_value(ptz_current_interface, ptz_current_camera, 0);
		VISCA_set_focus_value(ptz_current_interface, ptz_current_camera, 20000);
		acquire_position = 1;
		acquire_zoom = 1;
		acquire_focus = 1;
	}
	else if(button == PTZ_PAN_STOP)
	{
		VISCA_set_pantilt_stop(ptz_current_interface, ptz_current_camera, 0, 0);
		ptz_panning = 0;
		acquire_position = 1;
	}
	else if(button == PTZ_ZOOM_STOP)
	{
		VISCA_set_zoom_stop(ptz_current_interface, ptz_current_camera);
		ptz_zooming = 0;
		acquire_zoom = 1;
	}
	else if(button == PTZ_FOCUS_STOP)
	{
		VISCA_set_focus_stop(ptz_current_interface, ptz_current_camera);
		ptz_focusing = 0;
		acquire_focus = 1;
	}
	else if(button == PTZ_RELATIVE_POSITION)
	{
		VISCA_set_pantilt_relative_position(ptz_current_interface, ptz_current_camera, arg0, arg1, arg2, arg3);
		acquire_position = 1;
	}
	else if(button == PTZ_ABSOLUTE_POSITION)
	{
		VISCA_set_pantilt_absolute_position(ptz_current_interface, ptz_current_camera, arg0, arg1, arg2, arg3);
		acquire_position = 1;
	}
	else
	{
		acquire_position = 1;
		acquire_zoom = 1;
		acquire_focus = 1;
	}
	if(acquire_focus == 1)
	{
		ptz_focus_reading = 0;
		char nn = -1;
		while(nn == -1)
		{
			nn = VISCA_get_focus_value(ptz_current_interface, ptz_current_camera, (uint16_t *)&ptz_focus_reading);
		}
		sprintf(buf1, "%05d", ptz_focus_reading);
		ptz_focus_value_label->label(buf1);
	}
	if(acquire_zoom == 1)
	{
		ptz_zoom_reading = 0;
		char nn = -1;
		while(nn == -1)
		{
			nn = VISCA_get_zoom_value(ptz_current_interface, ptz_current_camera, (uint16_t *)&ptz_zoom_reading);
		}
		sprintf(buf2, "%05d", ptz_zoom_reading);
		ptz_zoom_value_label->label(buf2);
	}
	if(acquire_position == 1)
	{
		ptz_pan_reading = 0;
		ptz_tilt_reading = 0;
		char nn = -1;
		while(nn == -1)
		{
			nn = (char)VISCA_get_pantilt_position(ptz_current_interface, ptz_current_camera, &ptz_pan_reading, &ptz_tilt_reading);
		}
	}
}

void	ptz_zoom_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	win->ViscaCommand(PTZ_ZOOM_STOP);
}

void	ptz_focus_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	win->ViscaCommand(PTZ_FOCUS_STOP);
}

void	ptz_drag_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	win->ViscaCommand(PTZ_PAN_STOP);
}

void	MyWin::PTZ_MoveTo(int spd_x, int spd_y, int xx, int yy)
{
	int dx = ((w() / 2) - xx) * -1;
	int dy = (h() / 2) - yy;
	dx *= 3;
	dy *= 3;
	int zoom_factor = ptz_zoom_reading;
	if(zoom_factor < 1) zoom_factor = 1;
	if(zoom_factor > 15000) zoom_factor = 15000;
	double use = (double)(16384 - zoom_factor) / 16384.0;
	double ddx = (double)dx * use;
	double ddy = (double)dy * use;
	dx = (int)ddx;
	dy = (int)ddy;
	ViscaCommand(PTZ_RELATIVE_POSITION, 4, spd_x, spd_y, dx, dy);
}

void	ptz_tour_presets_cb(void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	int cnt = 0;
	for(loop = 0;loop < NUMBER_OF_PRESETS;loop++)
	{
		if(win->ptz_position[win->ptz_interface_index][win->ptz_current_camera_idx][loop]->set == 1)
		{
			cnt++;
		}
	}
	if(cnt > 1)
	{
		int r = 0;
		double val = win->ptz_speed_slider->value();
		if(win->ptz_position[win->ptz_interface_index][win->ptz_current_camera_idx][win->ptz_tour_index]->set == 1)
		{
			r = win->PTZ_RecallPosition((int)(20.0 * val), win->ptz_tour_index);
		}
		win->ptz_tour_index++;
		if(win->ptz_tour_index > 20)
		{
			win->ptz_tour_index = 0;
		}
		if(r == 1)
		{
			Fl::repeat_timeout(10.0 * (1.0 - val), ptz_tour_presets_cb, win);
		}
		else
		{
			Fl::repeat_timeout(0.01, ptz_tour_presets_cb, win);
		}
	}
}

void	MyWin::ZoomALittle(int key)
{
	if(visca_command == 0)
	{
		int zoom_reading = 0;
		VISCA_get_zoom_value(ptz_current_interface, ptz_current_camera, (uint16_t *)&zoom_reading);
		if((key == 'w') || (key == FL_KP + '8'))
		{
			ViscaCommand(PTZ_ZOOM, 1, zoom_reading + ptz_little_speed);
		}
		else if((key == 's') || (key == FL_KP + '2'))
		{
			if(zoom_reading > ptz_little_speed)
			{
				ViscaCommand(PTZ_ZOOM, 1, zoom_reading - ptz_little_speed);
			}
		}
	}
}

void	Camera::SetFocus(int num)
{
	if(my_window->visca_command == 0)
	{
		if(num < 4096) num = 4096;
		if(num > 50431) num = 50431;
		my_window->ViscaCommand(PTZ_FOCUS, 1, num);
		int done = 0;
		while(done == 0)
		{
			int focus_reading = 0;
			VISCA_get_focus_value(my_window->ptz_current_interface, my_window->ptz_current_camera, (uint16_t *)&focus_reading);
			if(focus_reading == num)
			{
				done = 1;
			}
		}
		while(my_window->visca_command != 0)
		{
			usleep(10000);
		}
	}
}

double	Camera::FocusScore(Mat use_mat)
{
Mat	CropSection(Mat source, Mat& cropped, int xx, int yy, int ww, int hh);
Mat image, src_gray, detected_edges, dst;

	use_mat.copyTo(image);
	CropSection(image, image, image.cols / 3, image.rows / 3, image.cols / 3, image.rows / 3);
	cvtColor(image, src_gray, COLOR_BGR2GRAY);
	blur(src_gray, detected_edges, Size(3, 3));
	Canny(detected_edges, detected_edges, 10, 10 * 3, 3);
	dst = Scalar::all(0);
	image.copyTo(dst, detected_edges);
	cvtColor(dst, dst, COLOR_BGR2GRAY);
	focus_score = 0.0;
	if((dst.rows > 0) && (dst.cols > 0))
	{
		focus_score = sum(dst)[0];
		focus_score /= (dst.rows * dst.cols);
	}
	return(focus_score);
}

void	MyWin::FocusALittle(int key)
{
	if(visca_command == 0)
	{
		int focus_reading = 0;
		VISCA_get_focus_value(ptz_current_interface, ptz_current_camera, (uint16_t *)&focus_reading);
		if((key == 'w') || (key == FL_KP + '8'))
		{
			ViscaCommand(PTZ_FOCUS, 1, focus_reading + ptz_little_speed);
		}
		else if((key == 's') || (key == FL_KP + '2'))
		{
			if(focus_reading > ptz_little_speed)
			{
				ViscaCommand(PTZ_FOCUS, 1, focus_reading - ptz_little_speed);
			}
		}
	}
}

void	MyWin::ZoomAndFocusALittle(int key)
{
	if(visca_command == 0)
	{
		int zoom_reading = 0;
		int focus_reading = 0;
		VISCA_get_zoom_value(ptz_current_interface, ptz_current_camera, (uint16_t *)&zoom_reading);
		VISCA_get_focus_value(ptz_current_interface, ptz_current_camera, (uint16_t *)&focus_reading);
		if((key == 'w') || (key == FL_KP + '8'))
		{
			ViscaCommand(PTZ_ZOOM_AND_FOCUS, 2, zoom_reading + ptz_little_speed, focus_reading + ptz_little_speed);
		}
		else if((key == 's') || (key == FL_KP + '2'))
		{
			if((zoom_reading > ptz_little_speed)
			&& (focus_reading > ptz_little_speed))
			{
				ViscaCommand(PTZ_ZOOM_AND_FOCUS, 2, zoom_reading - ptz_little_speed, focus_reading - ptz_little_speed);
			}
		}
	}
}

void	MyWin::CenterMessage(char *str, int timer)
{
	strcpy(center_message, str);
	center_message_timer = timer;
}

void	MyWin::MoveALittle(int key)
{
	if((key == 'w') || (key == FL_KP + '8'))
	{
		ViscaCommand(PTZ_RELATIVE_POSITION, 4, 1, 1, 0, ptz_little_speed);
	}
	else if((key == 'a') || (key == FL_KP + '4'))
	{
		ViscaCommand(PTZ_RELATIVE_POSITION, 4, 1, 1, -ptz_little_speed, 0);
	}
	else if((key == 's') || (key == FL_KP + '2'))
	{
		ViscaCommand(PTZ_RELATIVE_POSITION, 4, 1, 1, 0, -ptz_little_speed);
	}
	else if((key == 'd') || (key == FL_KP + '6'))
	{
		ViscaCommand(PTZ_RELATIVE_POSITION, 4, 1, 1, ptz_little_speed, 0);
	}
	else if((key == 'q') || (key == FL_KP + '7'))
	{
		ViscaCommand(PTZ_RELATIVE_POSITION, 4, 1, 1, -ptz_little_speed, ptz_little_speed);
	}
	else if((key == 'e') || (key == FL_KP + '9'))
	{
		ViscaCommand(PTZ_RELATIVE_POSITION, 4, 1, 1, ptz_little_speed, ptz_little_speed);
	}
	else if((key == 'z') || (key == FL_KP + '1'))
	{
		ViscaCommand(PTZ_RELATIVE_POSITION, 4, 1, 1, -ptz_little_speed, -ptz_little_speed);
	}
	else if((key == 'x') || (key == FL_KP + '3'))
	{
		ViscaCommand(PTZ_RELATIVE_POSITION, 4, 1, 1, ptz_little_speed, -ptz_little_speed);
	}
}

void	ptz_joystick_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	int r = win->ptz_joystick_handler();
	if(r == 1)
	{
		Fl::repeat_timeout(0.01, ptz_joystick_cb, win);
	}
}

int	MyWin::ptz_joystick_handler()
{
	int r = 0;
	if((ptz_joystick_x != ptz_last_joystick_x)
	|| (ptz_joystick_y != ptz_last_joystick_y))
	{
		int test_x = ptz_joystick_x / 10;
		int test_y = ptz_joystick_y / 10;
		ptz_last_joystick_x = ptz_joystick_x;
		ptz_last_joystick_y = ptz_joystick_y;
		int x_speed = abs(test_x);
		int y_speed = abs(test_y);
		if(x_speed > 20) x_speed = 20;
		if(y_speed > 20) y_speed = 20;
		if((test_x > 0) && (test_y > 0))
		{
			ViscaCommand(PTZ_DOWN_RIGHT, 2, x_speed, y_speed);
		}
		else if((test_x > 0) && (test_y < 0))
		{
			ViscaCommand(PTZ_UP_RIGHT, 2, x_speed, y_speed);
		}
		else if((test_x < 0) && (test_y > 0))
		{
			ViscaCommand(PTZ_DOWN_LEFT, 2, x_speed, y_speed);
		}
		else if((test_x < 0) && (test_y < 0))
		{
			ViscaCommand(PTZ_UP_LEFT, 2, x_speed, y_speed);
		}
		else if(test_x > 0)
		{
			ViscaCommand(PTZ_RIGHT, 2, x_speed, y_speed);
		}
		else if(test_x < 0)
		{
			ViscaCommand(PTZ_LEFT, 2, x_speed, y_speed);
		}
		else if(test_y > 0)
		{
			ViscaCommand(PTZ_DOWN, 2, x_speed, y_speed);
		}
		else if(test_y < 0)
		{
			ViscaCommand(PTZ_UP, 2, x_speed, y_speed);
		}
		r = 1;
	}
	return(r);
}

void	iconize_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	char *raw = (char *)grab_raw_desktop_image();
	if(raw != NULL)
	{
		FakeWindow *fake = new FakeWindow(win, raw);
		fake->show();
		win->hide();
		while(fake->visible())
		{
			Fl::wait(1);
		}
		win->show();
		Fl::delete_widget(fake);
		win->showing_new_source_window = 0;
	}
}

int	MyWin::ImageWindowButtonHit(int xx, int yy)
{
int	loop;

	int done = 0;
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;((loop < cam->image_window_cnt) && (done == 0));loop++)
		{
			if(cam->image_window[loop] != NULL)
			{
				if(cam->image_window[loop]->buttonize == 1)
				{
					if(cam->image_window[loop]->AsButton(xx, yy) == 1)
					{
						done = 1;
					}
				}
			}
		}
	}
	return(done);
}

void	draw_line(BLContext ctx, double x0, double y0, double x1, double y1)
{
	double x{x1 - x0}, y{y1 - y0};
	double max{ std::max(std::fabs(x), std::fabs(y)) };
	x /= max; y /= max;
	int cnt = 0;
	for(double n{0}; n < max; ++n)
	{
		int ww = 4;
		int hh = 10;
		x0 += x; y0 += y;
		if((cnt % 20) == 0)
		{
			if(abs(x) > abs(y))
			{
				ww = 10;
				hh = 4;
			}
			ctx.fillRect(x0, y0, ww, hh);
		}
		cnt++;
	}
}

int	Camera::RemoveImmediate(Immediate *ptr)
{
	int rr = 0;
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->immediate_list != NULL)
		{
			int idx = cam->FindImmediate(ptr);
			if((idx > -1) && (idx < cam->immediate_cnt))
			{
				Immediate *ptr = cam->immediate_list[idx];
				my_window->remove(ptr);
				cam->immediate_list[idx] = NULL;
				rr = 1;
			}
		}
	}
	return(rr);
}

ImDefault::ImDefault()
{
	my_window = NULL;
	my_immediate = NULL;
	cnt = 0;
	xx = NULL;
	yy = NULL;
	pt_type = NULL;
	strcpy(font_name, "Sans");
	strcpy(image_file_path, "");
}

ImDefault::~ImDefault()
{
}

void	ImDefault::Copy(Immediate *in_im, ImDefault *source)
{
	my_window = source->my_window;
	my_immediate = in_im;
	width = source->width;
	red = source->red;
	green = source->green;
	blue = source->blue;
	alpha = source->alpha;
	style = source->style;
	shape = source->shape;
	use_size = source->use_size;
	filled = source->filled;
	selecting = source->selecting;
	erase = source->erase;
	box_type = source->box_type;

	xx = NULL;
	yy = NULL;
	pt_type = NULL;
	cnt = source->cnt;
	if(cnt > 0)
	{
		if((source->xx != NULL) && (source->yy != NULL) && (source->pt_type != NULL))
		{
			xx = (int *)malloc(cnt * sizeof(int));
			memcpy(xx, source->xx, cnt * sizeof(int));
			yy = (int *)malloc(cnt * sizeof(int));
			memcpy(yy, source->yy, cnt * sizeof(int));
			pt_type = (int *)malloc(cnt * sizeof(int));
			memcpy(pt_type, source->pt_type, cnt * sizeof(int));
		}
		else
		{
			cnt = 0;
		}
	}
	key = source->key;

	freehand_mat = source->freehand_mat.clone();
	my_mat = source->my_mat.clone();

	italic = source->italic;
	bold = source->bold;
	outline = source->outline;
	font_alpha = source->font_alpha;
	background_alpha = source->background_alpha;
	outline_alpha = source->outline_alpha;
}

ImRectangle::ImRectangle(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	my_immediate = in_im;
	width = 1;
	red = 255;
	green = 255;
	blue = 255;
	style = 0;
	filled = 0;
	erase = 0;
}

ImRectangle::~ImRectangle()
{
}

void	ImRectangle::draw()
{
	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		int sx = x() - my_window->image_origin_x;
		int sy = y() - my_window->image_origin_y;
		my_cairo_set_line_style(cam->cairo_context, style, width);
		if(erase == 1)
		{
			rectangle(cam->mat, Point(sx, sy), Point(sx + w(), sy + h()), Vec4b(0, 0, 0, 0), cv::FILLED);
		}
		else
		{
			int use_alpha = (int)((double)alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cam->cairo_context, red, green, blue, use_alpha);
			cairo_rectangle(cam->cairo_context, sx, sy, w(), h());
			if(filled == 0)
			{
				cairo_stroke(cam->cairo_context);
			}
			else
			{
				cairo_fill(cam->cairo_context);
			}
		}
	}
}

ImPixelate::ImPixelate(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	my_immediate = in_im;
	use_size = 10;
	style = PIXELATE_MODE_PIXELATE;
}

ImPixelate::~ImPixelate()
{
}

void	ImPixelate::draw()
{
Mat	CropSection(Mat source, Mat& cropped, int xx, int yy, int ww, int hh);
int	xx, yy;

	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		cairo_t *cr = cam->cairo_context;
		if(style == PIXELATE_MODE_PIXELATE)
		{
			Mat use = cam->reserve_mat.clone();
			cvtColor(use, use, COLOR_RGBA2RGB);
			for(yy = y();yy < y() + h();yy += use_size)
			{
				for(xx = x();xx < x() + w();xx += use_size)
				{
					int nx = xx - cam->image_sx;
					int ny = yy - cam->image_sy;
					Vec3b colour = use.at<Vec3b>(Point(nx, ny));
					int r = colour[0];
					int g = colour[1];
					int b = colour[2];
					my_cairo_set_source_rgb(cr, r, g, b);
					cairo_rectangle(cr, nx, ny, use_size, use_size);
					cairo_fill(cr);
				}
			}
		}
		else if(style == PIXELATE_MODE_BLUR)
		{
			if((w() > 0) && (h() > 0))
			{
				Mat mat;
				CropSection(cam->reserve_mat, mat, x() - cam->image_sx, y() - cam->image_sy, w(), h());
				blur(mat, mat, Size(use_size, use_size));
				cairo_surface_t *surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
				if(surface != NULL)
				{
					cairo_set_source_surface(cr, surface, x() - my_window->image_origin_x, y() - my_window->image_origin_y);
					cairo_paint(cr);
					cairo_surface_destroy(surface);
				}
			}
		}
	}
}

ImRectangleSelect::ImRectangleSelect(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	my_immediate = in_im;
	selecting = 0;
}

ImRectangleSelect::~ImRectangleSelect()
{
}

void	ImRectangleSelect::draw()
{
Mat	CropSection(Mat source, Mat& cropped, int xx, int yy, int ww, int hh);

	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		cairo_t *cr = cam->cairo_context;
		if(selecting == 1)
		{
			fl_color(FL_WHITE);
			fl_rect(x(), y(), w(), h());
		}
		if((w() > 0) && (h() > 0))
		{
			Mat mat;
			CropSection(cam->reserve_mat, mat, x() - cam->image_sx, y() - cam->image_sy, w(), h());
			cairo_surface_t *surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
			if(surface != NULL)
			{
				cairo_set_source_surface(cr, surface, x() - cam->image_sx, y() - cam->image_sy);
				cairo_paint(cr);
				cairo_surface_destroy(surface);
			}
		}
	}
}

ImImage::ImImage(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	my_immediate = in_im;
	if((in_im->idw->image_mat.rows > 0) && (in_im->idw->image_mat.cols > 0) && (!in_im->idw->image_mat.empty()))
	{
		char *filename = (char *)in_im->idw->image_file_path->value();
		strcpy(image_file_path, filename);
	}
}

ImImage::~ImImage()
{
}

void	ImImage::draw()
{
	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		cairo_t *cr = cam->cairo_context;
		Mat local_mat;
		if(my_mat.empty())
		{
			my_mat = imread(image_file_path);
			cvtColor(my_mat, my_mat, COLOR_BGR2RGBA);
		}
		if(!my_mat.empty())
		{
			if((my_mat.rows > 0) && (my_mat.cols > 0))
			{
				int xx = x() - my_window->image_origin_x;
				int yy = y() - my_window->image_origin_y;
				int ww = w();
				int hh = h();
				if((ww > 0) && (hh > 0))
				{
					int orig_w = my_mat.cols;
					int orig_h = my_mat.rows;
					double scale = (double)ww / orig_w;
					int nw = orig_w * scale;
					int nh = orig_h * scale;
					if((nw > 0) && (nh > 0))
					{
						cv::resize(my_mat, local_mat, cv::Size(nw, nh));
						cairo_surface_t *surface = cairo_image_surface_create_for_data(local_mat.ptr(), CAIRO_FORMAT_ARGB32, local_mat.cols, local_mat.rows, local_mat.step);
						if(surface != NULL)
						{
							cairo_set_source_surface(cr, surface, xx, yy);
							cairo_paint(cr);
							cairo_surface_destroy(surface);
						}
					}
				}
			}
		}
	}
}

ImEllipse::ImEllipse(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	my_immediate = in_im;
	width = 1;
	red = 255;
	green = 255;
	blue = 255;
	style = 0;
	filled = 0;
	erase = 0;
}

ImEllipse::~ImEllipse()
{
}

void	ImEllipse::draw()
{
	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		if(erase == 1)
		{
			int sx = x() - my_window->image_origin_x;
			int sy = y() - my_window->image_origin_y;
			ellipse(cam->mat, Point(sx, sy), Size(w(), h()), 0, 0, 360, Scalar(0, 0, 0, 0), -1, LINE_AA);
		}
		else
		{
			cairo_t *cr = cam->cairo_context;
			int use_alpha = (int)((double)alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cr, red, green, blue, use_alpha);
			double cx = (double)((x() + (w() / 2.0)) - my_window->image_origin_x);
			double cy = (double)((y() + (h() / 2.0)) - my_window->image_origin_y);
			cairo_matrix_t save_matrix;
			cairo_get_matrix(cr, &save_matrix);
			cairo_translate(cr, cx, cy);
			double sy = 1.0;
			if(w() > 0)
			{
				sy = (double)h() / (double)w();
			}
			cairo_scale(cr, 1.0, sy);
			cairo_arc(cr, 0, 0, w(), 0.0, 2 * M_PI);
			cairo_set_matrix(cr, &save_matrix);
			my_cairo_set_line_style(cam->cairo_context, style, width);
			if(filled == 0)
			{
				cairo_stroke(cr);
			}
			else
			{
				cairo_fill(cr);
			}
		}
	}
}

ImFreehand::ImFreehand(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	my_immediate = in_im;
	width = 1;
	red = 255;
	green = 255;
	blue = 255;
	style = 0;
}

ImFreehand::~ImFreehand()
{
}

void	ImFreehand::draw()
{
	fl_color(fl_rgb_color(red, green, blue));
}

ImLine::ImLine(MyWin *in_win, Immediate *in_im, int in_type, int in_x, int in_y, int ww, int hh) : Fl_Group(in_x, in_y, ww, hh)
{
	my_window = in_win;
	my_immediate = in_im;
	shape = in_type;
	cnt = 0;
	width = 1;
	red = 255;
	green = 255;
	blue = 255;
	alpha = 255;
	style = 0;
	xx = NULL;
	yy = NULL;
	pt_type = NULL;
	erase = 0;
}

ImLine::~ImLine()
{
	if(xx != NULL)
	{
		free(xx);
		xx = NULL;
	}
	if(yy != NULL)
	{
		free(yy);
		yy = NULL;
	}
	if(pt_type != NULL)
	{
		free(pt_type);
		pt_type = NULL;
	}
	cnt = 0;
}

void	ImLine::Revise(int in_x, int in_y)
{
int	loop;

	for(loop = 0;loop < cnt;loop++)
	{
		xx[loop] -= in_x;
		yy[loop] -= in_y;
		if(my_immediate->idw->grid_size > 1)
		{
			xx[loop] = force_to_grid(my_immediate->idw->grid_size, xx[loop] - my_immediate->my_camera->image_sx);
			yy[loop] = force_to_grid2(my_immediate->idw->grid_size, yy[loop] - my_immediate->my_camera->image_sy);
			xx[loop] += my_immediate->my_camera->image_sx;
			yy[loop] += my_immediate->my_camera->image_sy;
		}
	}
}

void	ImLine::AddPoint(int in_x, int in_y)
{
	xx = (int *)realloc(xx, sizeof(int) * (cnt + 1));
	yy = (int *)realloc(yy, sizeof(int) * (cnt + 1));
	pt_type = (int *)realloc(pt_type, sizeof(int) * (cnt + 1));
	if((xx != NULL) && (yy != NULL))
	{
		xx[cnt] = in_x;
		yy[cnt] = in_y;
		pt_type[cnt] = 0;
		if((style & MY_TYPE_CURVES) == MY_TYPE_CURVES)
		{
			pt_type[cnt] = POINT_TYPE_CURVE;
		}
		cnt++;
	}
}

void	ImLine::ImageLine(cairo_t *cr, int x0, int y0, int x1, int y1, int in_sz)
{
int	xx, yy;

	int dx = abs(x1 - x0);
	int sx = x0 < x1 ? 1 : -1;
	int dy = abs(y1 - y0);
	int sy = y0 < y1 ? 1 : -1;
	int err = (dx > dy ? dx : -dy) / 2;
	int e2;
	int sz = (in_sz / 2) + 1;
	if(sz < 1)
	{
		sz = 1;
	}
	for(;;)
	{
		if(sz > 1)
		{
			for(yy = -sz;yy < sz;yy++)
			{
				for(xx = -sz;xx < sz;xx++)
				{
					DoStamp(cr, x0 + xx, y0 + yy);
				}
			}
		}
		else
		{
			DoStamp(cr, x0, y0);
		}
		if((x0 == x1) && (y0 == y1))
		{
			break;
		}
		e2 = err;
		if(e2 > -dx)
		{
			err -= dy;
			x0 += sx;
		}
		if(e2 < dy)
		{
			err += dx;
			y0 += sy;
		}
	}
}

void	ImLine::draw()
{
void	drawTransparency(Mat frame, Mat transp, int xPos, int yPos);
int		loop;

	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		if(shape != DRAWING_MODE_FREEHAND)
		{
			if(my_immediate != NULL)
			{
				if(my_immediate->idw != NULL)
				{
					if(my_immediate->idw->selected_widget == my_immediate)
					{
						for(loop = 0;loop < cnt;loop++)
						{
							if(pt_type[loop] == POINT_TYPE_CURVE)
							{
								my_cairo_set_source_rgb(cam->cairo_context, 255, 240, 180);
								int nx = xx[loop] - my_window->image_origin_x;
								int ny = yy[loop] - my_window->image_origin_y;
								cairo_rectangle(cam->cairo_context, nx - 5, ny - 5, 10, 10);
								cairo_fill(cam->cairo_context);
							}
						}
					}
				}
			}
			int use_alpha = (int)((double)alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cam->cairo_context, red, green, blue, use_alpha);
			my_cairo_set_line_style(cam->cairo_context, style, width);
			if((shape == DRAWING_MODE_LINE)
			|| (shape == DRAWING_MODE_LOOP)
			|| (shape == DRAWING_MODE_POLYGON))
			{
				if((shape == DRAWING_MODE_POLYGON) && (erase == 1))
				{
					if(cnt > 2)
					{
						int a_xx[1024];
						int a_yy[1024];
						for(loop = 0;loop < cnt;loop++)
						{
							a_xx[loop] = xx[loop] - cam->image_sx;
							a_yy[loop] = yy[loop] - cam->image_sy;
						}
						erase_polygon(cam->mat, cnt, a_xx, a_yy);
					}
				}
				else
				{
					loop = 0;
					while(loop < cnt)
					{
						int nx = xx[loop] - my_window->image_origin_x;
						int ny = yy[loop] - my_window->image_origin_y;
						if(loop == 0)
						{
							cairo_move_to(cam->cairo_context, nx, ny);
							loop++;
						}
						else
						{
							if(pt_type[loop] == POINT_TYPE_CURVE)
							{
								if((cnt > 3) && ((loop + 2) < cnt))
								{
									int nx1 = xx[loop] - my_window->image_origin_x;
									int ny1 = yy[loop] - my_window->image_origin_y;
									int nx2 = xx[loop + 1] - my_window->image_origin_x;
									int ny2 = yy[loop + 1] - my_window->image_origin_y;
									int nx3 = xx[loop + 2] - my_window->image_origin_x;
									int ny3 = yy[loop + 2] - my_window->image_origin_y;
									cairo_curve_to(cam->cairo_context, nx1, ny1, nx2, ny2, nx3, ny3);
									loop += 3;
								}
								else
								{
									loop++;
								}
							}
							else
							{
								cairo_line_to(cam->cairo_context, nx, ny);
								loop++;
							}
						}
					}
					if((shape == DRAWING_MODE_LOOP)
					|| (shape == DRAWING_MODE_POLYGON))
					{
						if(cnt > 2)
						{
							cairo_close_path(cam->cairo_context);
						}
					}
					if(shape == DRAWING_MODE_POLYGON)
					{
						cairo_fill(cam->cairo_context);
					}
					else
					{
						cairo_stroke(cam->cairo_context);
					}
					if(shape == DRAWING_MODE_LINE)
					{
						if((style & MY_CAP_ARROW) == MY_CAP_ARROW)
						{
							if(cnt > 1)
							{
								int nn = 3 * width;
								if(nn < 10) nn = 10;
								int nx1 = xx[cnt - 1] - my_window->image_origin_x;
								int ny1 = yy[cnt - 1] - my_window->image_origin_y;
								int nx2 = xx[cnt - 2] - my_window->image_origin_x;
								int ny2 = yy[cnt - 2] - my_window->image_origin_y;
								my_cairo_draw_arrow(cam->cairo_context, nx1, ny1, nx2, ny2, nn, nn);
							}
						}
					}
				}
			}
			else if(shape == DRAWING_MODE_POLYGON_SELECT)
			{
				if(my_immediate->idw->mode == DRAWING_MODE_POLYGON_SELECT)
				{
					fl_color(FL_WHITE);
					fl_begin_loop();
					for(loop = 0;loop < cnt;loop++)
					{
						int nx = xx[loop];
						int ny = yy[loop];
						fl_vertex(nx, ny);
					}
					fl_end_loop();
				}
				if(cnt > 2)
				{
					int a_xx[1024];
					int a_yy[1024];
					for(loop = 0;loop < cnt;loop++)
					{
						a_xx[loop] = xx[loop] - cam->image_sx;
						a_yy[loop] = yy[loop] - cam->image_sy;
					}
					Mat out;
					mask_it(cam->reserve_mat, out, cnt, a_xx, a_yy);
					cairo_surface_t *surface = cairo_image_surface_create_for_data(out.ptr(), CAIRO_FORMAT_ARGB32, out.cols, out.rows, out.step);
					if((surface != NULL) && (cam->cairo_surface != NULL))
					{
						cairo_set_source_surface(cam->cairo_context, surface, 0, 0);
						cairo_paint(cam->cairo_context);
						cairo_surface_destroy(surface);
					}
				}
			}
		}
		else
		{
			int use_alpha = (int)((double)alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cam->cairo_context, red, green, blue, use_alpha);
			for(loop = 0;loop < cnt;loop++)
			{
				if(loop < (cnt - 1))
				{
					int cx1 = xx[loop] - my_window->image_origin_x;
					int cy1 = yy[loop] - my_window->image_origin_y;
					int cx2 = xx[loop + 1] - my_window->image_origin_x;
					int cy2 = yy[loop + 1] - my_window->image_origin_y;
					ImageLine(cam->cairo_context, cx1, cy1, cx2, cy2, 1);
				}
				else
				{
					double cx = (double)xx[loop] - my_window->image_origin_x;
					double cy = (double)yy[loop] - my_window->image_origin_y;
					DoStamp(cam->cairo_context, cx, cy);
				}
			}
		}
	}
}

void	ImLine::DoStamp(cairo_t *cr, double in_x, double in_y)
{
	int cx = in_x;
	int cy = in_y;
	if(style == FREEHAND_SHAPE_SQUARE)
	{
		cairo_rectangle(cr, cx - (width / 2), cy - (width / 2), width, width);
		cairo_fill(cr);
	}
	else if(style == FREEHAND_SHAPE_CIRCLE)
	{
		cairo_arc(cr, cx, cy, (width / 2) + 1, 0.0, 2 * M_PI);
		cairo_fill(cr);
	}
	else if(style == FREEHAND_SHAPE_ERASE_SQUARE)
	{
		Camera *cam = my_immediate->my_camera;
		int x1 = cx - (width / 2);
		int y1 = cy - (width / 2);
		int x2 = x1 + width;
		int y2 = y1 + width;
		rectangle(cam->mat, Point(x1, y1), Point(x2, y2), Vec4b(0, 0, 0, 0), cv::FILLED);
	}
	else if(style == FREEHAND_SHAPE_ERASE_CIRCLE)
	{
		Camera *cam = my_immediate->my_camera;
		ellipse(cam->mat, Point(cx, cy), Size(width, width), 0, 0, 360, Scalar(0, 0, 0, 0), -1, LINE_AA);
	}
	else if(style == FREEHAND_SHAPE_STAMP)
	{
		if(freehand_mat.empty())
		{
			freehand_mat = imread(freehand_filename);
		}
		if(!freehand_mat.empty())
		{
			if((freehand_mat.cols > 0) && (freehand_mat.rows > 0))
			{
				Mat local_mat;
				cv::resize(freehand_mat, local_mat, cv::Size(width, width));
				cvtColor(local_mat, local_mat, COLOR_RGB2RGBA);
				cairo_surface_t *surface = cairo_image_surface_create_for_data(local_mat.ptr(), CAIRO_FORMAT_ARGB32, local_mat.cols, local_mat.rows, local_mat.step);
				if(surface != NULL)
				{
					cairo_set_source_surface(cr, surface, cx - (width / 2), cy - (width / 2));
					cairo_paint(cr);
					cairo_surface_destroy(surface);
				}
			}
		}
	}
	else if(style == FREEHAND_SHAPE_KEY)
	{
		char buf[2];
		buf[0] = key;
		buf[1] = '\0';
		cairo_font_slant_t slant = CAIRO_FONT_SLANT_NORMAL;
		cairo_font_weight_t bold = CAIRO_FONT_WEIGHT_NORMAL;
		cairo_select_font_face(cr, "Sans", slant, bold);
		cairo_set_font_size(cr, width);
		cairo_move_to(cr, cx - (width / 4), cy + (width / 4));
		cairo_show_text(cr, buf);
	}
}

void	ImLine::Extent(int& x1, int& y1, int& x2, int& y2)
{
int	loop;

	int lx1 = 1000000;
	int ly1 = 1000000;
	int lx2 = -1000000;
	int ly2 = -1000000;
	int nn = width / 2;
	if((shape == DRAWING_MODE_LINE)
	|| (shape == DRAWING_MODE_POLYGON)
	|| (shape == DRAWING_MODE_POLYGON_SELECT)
	|| (shape == DRAWING_MODE_LOOP))
	{
		nn = 0;
	}
	if(cnt > 1)
	{
		for(loop = 0;loop < cnt;loop++)
		{
			if((xx[loop] - nn) < lx1)
			{
				lx1 = (xx[loop] - nn);
			}
			if((yy[loop] - nn) < ly1)
			{
				ly1 = (yy[loop] - nn);
			}
			if((xx[loop] + nn) > lx2)
			{
				lx2 = (xx[loop] + nn);
			}
			if((yy[loop] + nn) > ly2)
			{
				ly2 = (yy[loop] + nn);
			}
		}
	}
	else if(cnt == 1)
	{
		lx1 = xx[0] - nn;
		ly1 = yy[0] - nn;
		lx2 = xx[0] + nn;
		ly2 = yy[0] + nn;
	}
	x1 = lx1;
	y1 = ly1;
	x2 = lx2;
	y2 = ly2;
}

QuickText::QuickText(Camera *in_cam, char *init_text, int xx, int yy, int ww, int hh) : Fl_Multiline_Input(xx, yy, ww, hh)
{
	my_camera = in_cam;
	textcolor(FL_WHITE);
	textsize(32);
	value(init_text);
	focused = 0;
	alpha = 255;
	bold = 0;
	italic = 0;
	outline = 0;
}

QuickText::~QuickText()
{
}

int	QuickText::handle(int event)
{
	int flag = 0;
	if(event == FL_DRAG)
	{
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Multiline_Input::handle(event);
		if(event == FL_FOCUS)
		{
			focused = 1;
		}
		if(event == FL_UNFOCUS)
		{
			focused = 0;
		}
	}
	return(flag);
}

void	QuickText::draw()
{
int		 loop;
char	*line[4096];

	char *str = (char *)value();
	int pos = insert_position();

	Camera *cam = my_camera;
	int font_sz = textsize();

	uchar rr, gg, bb;
	Fl_Color font_color = textcolor();
	Fl::get_color(font_color, rr, gg, bb);

	int style = 0;
	int outline_r = 0;
	int outline_g = 0;
	int outline_b = 0;
	if(italic == 1) style |= FONT_STYLE_ITALIC;
	if(bold == 1) style |= FONT_STYLE_BOLD;
	if(outline == 1) 
	{
		style |= FONT_STYLE_OUTLINE;
		outline_r = 255 - rr;
		outline_g = 255 - gg;
		outline_b = 255 - bb;
	}
	int xx = x() - cam->image_sx;
	int yy = y() - cam->image_sy;
	if(strlen(str) > 0)
	{
		if(focused == 0) pos = -1;
		my_cairo_draw_text(cam->cairo_context, xx, yy + font_sz, str, "Sans", style, font_sz, pos, rr, gg, bb, alpha, outline_r, outline_g, outline_b, alpha);
	}
}

ImText::ImText(MyWin *in_win, Immediate *in_im, int xx, int yy, int ww, int hh) : ImDefault(), Fl_Multiline_Input(xx, yy, ww, hh)
{
	my_window = in_win;
	my_immediate = in_im;
	italic = my_immediate->idw->text_italic_button->value();
	bold = my_immediate->idw->text_bold_button->value();
	outline = my_immediate->idw->text_outline_button->value();
	font_alpha = my_immediate->idw->font_color_alpha;
	background_alpha = my_immediate->idw->back_color_alpha;
	outline_alpha = my_immediate->idw->outline_color_alpha;
	box_type = my_immediate->idw->text_box_type;

	strcpy(font_name, my_immediate->idw->selected_font);
	if(strlen(font_name) < 1)
	{
		strcpy(font_name, "Sans");
	}
	char *initial_text = (char *)my_immediate->idw->text_initial_text->value();
	value(initial_text);
	focused = 0;
}

ImText::~ImText()
{
}

int	ImText::handle(int event)
{
	int flag = 0;
	if(event == FL_DRAG)
	{
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Multiline_Input::handle(event);
		if((event == FL_FOCUS)
		|| (event == FL_UNFOCUS)
		|| (event == FL_KEYBOARD))
		{
			int ww = 0;
			int hh = 0;
			fl_font(textfont(), textsize());
			fl_measure(value(), ww, hh);
			resize(x(), y(), ww + 20, hh + 20);
			if(FL_UNFOCUS)
			{
				my_immediate->resize(x(), y(), ww + 20, hh + 20);
			}
			if(event == FL_FOCUS)
			{
				focused = 1;
			}
			if(event == FL_UNFOCUS)
			{
				focused = 0;
			}
		}
	}
	return(flag);
}

void	ImText::draw()
{
int		 loop;
char	*line[4096];

	Camera *cam = my_immediate->my_camera;
	if(cam->cairo_context != NULL)
	{
		char *str = (char *)value();
		char *use = strdup(str);
		int pos = insert_position();

		int font_sz = use_size;
		uchar rr, gg, bb;
		alpha = font_alpha;
		uchar back_r, back_g, back_b;

		back_r = background_red;
		back_g = background_green;
		back_b = background_blue;

		int sx = x() - my_window->image_origin_x;
		int sy = y() - my_window->image_origin_y;
		if(box_type == FL_FLAT_BOX)
		{
			int use_alpha = (int)((double)background_alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cam->cairo_context, back_r, back_g, back_b, use_alpha);
			cairo_rectangle(cam->cairo_context, sx, sy, w(), h());
			cairo_fill(cam->cairo_context);
		}
		else if(box_type == FL_FRAME)
		{
			int use_alpha = (int)((double)background_alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cam->cairo_context, back_r, back_g, back_b, use_alpha);
			cairo_rectangle(cam->cairo_context, sx, sy, w(), h());
			cairo_stroke(cam->cairo_context);
		}
		else if(box_type == FL_FRAME_BOX)
		{
			int use_alpha = (int)((double)background_alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cam->cairo_context, back_r, back_g, back_b, use_alpha);
			cairo_rectangle(cam->cairo_context, sx, sy, w(), h());
			cairo_fill(cam->cairo_context);

			use_alpha = (int)((double)font_alpha * my_immediate->overall_alpha);
			my_cairo_set_source_rgba(cam->cairo_context, red, green, blue, use_alpha);
			cairo_rectangle(cam->cairo_context, sx, sy, w(), h());
			cairo_stroke(cam->cairo_context);
		}
		int y_pos = sy;
		if(strlen(use) > 0)
		{
			int style = 0;
			int outline_r = 0;
			int outline_g = 0;
			int outline_b = 0;
			if(italic == 1) style |= FONT_STYLE_ITALIC;
			if(bold == 1) style |= FONT_STYLE_BOLD;
			if(outline == 1) 
			{
				style |= FONT_STYLE_OUTLINE;
				outline_r = my_immediate->idw->outline_color_red;
				outline_g = my_immediate->idw->outline_color_green;
				outline_b = my_immediate->idw->outline_color_blue;
			}
			int use_alpha = (int)((double)font_alpha * my_immediate->overall_alpha);
			if(focused == 0) pos = -1;
			my_cairo_draw_text(cam->cairo_context, sx, y_pos + font_sz, use, font_name, style, font_sz, pos, red, green, blue, use_alpha, outline_r, outline_g, outline_b, outline_alpha);
		}
		free(use);
	}
}

Immediate::Immediate(MyWin *in_win, Camera *in_cam, ImmediateDrawingWindow *in_idw, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	my_camera = in_cam;
	idw = in_idw;
	immediate_type = idw->mode;
	layer = my_camera->edit_layer;
	draw_it = 1;
	initial_x = 0;
	initial_y = 0;
	last_x = 0;
	last_y = 0;
	dragging = 0;
	drag_mode = DRAG_MODE_MOVE;
	popup = NULL;
	overall_alpha = 1.0;
	box(FL_NO_BOX);
	mw_mode = MW_MODE_TRANSPARENCY;

	text = NULL;
	line = NULL;
	rectangle = NULL;
	rectangle_select = NULL;
	ellipse = NULL;
	freehand = NULL;
	pixelate = NULL;
	image_im = NULL;
	if(immediate_type == DRAWING_MODE_TEXT)
	{
		text = new ImText(my_window, this, xx, yy, ww, hh);
		text->textfont(idw->font_num);
		text->textsize(idw->font_size);
		text->use_size = idw->font_size;

		text->textcolor(fl_rgb_color(idw->font_color_red, idw->font_color_green, idw->font_color_blue));
		text->red = idw->font_color_red;
		text->green = idw->font_color_green;
		text->blue = idw->font_color_blue;
		text->alpha = idw->font_color_alpha;

		text->color(fl_rgb_color(idw->back_color_red, idw->back_color_green, idw->back_color_blue));
		text->background_red = idw->back_color_red;
		text->background_green = idw->back_color_green;
		text->background_blue = idw->back_color_blue;
		text->background_alpha = idw->back_color_alpha;

		text->box(idw->text_box_type);
		text->box_type = idw->text_box_type;
		text->show();
		text->take_focus();
		im_type = IM_TEXT;
	}
	else if((immediate_type == DRAWING_MODE_LINE)
	|| (immediate_type == DRAWING_MODE_POLYGON)
	|| (immediate_type == DRAWING_MODE_POLYGON_SELECT)
	|| (immediate_type == DRAWING_MODE_FREEHAND)
	|| (immediate_type == DRAWING_MODE_LOOP))
	{
		line = new ImLine(my_window, this, immediate_type, xx, yy, ww, hh);
		strcpy(line->freehand_filename, idw->freehand_filename);
		line->freehand_mat = idw->freehand_mat.clone();
		line->erase = idw->erase;
		im_type = IM_LINE;
	}
	else if(immediate_type == DRAWING_MODE_RECTANGLE)
	{
		rectangle = new ImRectangle(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		im_type = IM_RECTANGLE;
	}
	else if(immediate_type == DRAWING_MODE_RECTANGLE_SELECT)
	{
		rectangle_select = new ImRectangleSelect(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		im_type = IM_RECTANGLE_SELECT;
	}
	else if(immediate_type == DRAWING_MODE_PIXELATE)
	{
		pixelate = new ImPixelate(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		pixelate->style = idw->line_style;
		pixelate->use_size = idw->pixelate_size;
		im_type = IM_PIXELATE;
	}
	else if(immediate_type == DRAWING_MODE_ELLIPSE)
	{
		ellipse = new ImEllipse(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		im_type = IM_ELLIPSE;
	}
	else if(immediate_type == DRAWING_MODE_IMAGE)
	{
		image_im = new ImImage(my_window, this, xx, yy, ww, hh);
		initial_x = xx;
		initial_y = yy;
		im_type = IM_IMAGE;
	}
	end();
}

Immediate::Immediate(MyWin *in_win, Camera *in_cam, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	my_camera = in_cam;
	idw = NULL;
	immediate_type = -1;
	layer = my_camera->edit_layer;
	draw_it = 1;
	initial_x = 0;
	initial_y = 0;
	last_x = 0;
	last_y = 0;
	dragging = 0;
	drag_mode = DRAG_MODE_MOVE;
	popup = NULL;
	overall_alpha = 1.0;
	box(FL_NO_BOX);
	mw_mode = MW_MODE_TRANSPARENCY;

	text = NULL;
	line = NULL;
	rectangle = NULL;
	rectangle_select = NULL;
	ellipse = NULL;
	freehand = NULL;
	pixelate = NULL;
	image_im = NULL;

	end();
}

Immediate::Immediate(Immediate *old, Camera *in_cam) : Fl_Group(old->x(), old->y(), old->w(), old->h())
{
	int xx = old->x();
	int yy = old->y();
	int ww = old->w();
	int hh = old->h();
	my_window = old->my_window;
	my_camera = in_cam;
	idw = old->idw;
	immediate_type = old->immediate_type;
	layer = 0;
	if(my_camera != NULL)
	{
		layer = my_camera->edit_layer;
	}
	draw_it = 1;
	initial_x = 0;
	initial_y = 0;
	last_x = 0;
	last_y = 0;
	dragging = 0;
	drag_mode = DRAG_MODE_MOVE;
	popup = NULL;
	overall_alpha = 1.0;
	box(FL_NO_BOX);
	mw_mode = MW_MODE_TRANSPARENCY;

	text = NULL;
	line = NULL;
	rectangle = NULL;
	rectangle_select = NULL;
	ellipse = NULL;
	freehand = NULL;
	pixelate = NULL;
	if(immediate_type == DRAWING_MODE_TEXT)
	{
		text = new ImText(my_window, this, xx, yy, ww, hh);
		text->Copy(this, old->text);
		text->show();
		text->take_focus();
		im_type = IM_TEXT;
	}
	else if((immediate_type == DRAWING_MODE_LINE)
	|| (immediate_type == DRAWING_MODE_POLYGON)
	|| (immediate_type == DRAWING_MODE_POLYGON_SELECT)
	|| (immediate_type == DRAWING_MODE_FREEHAND)
	|| (immediate_type == DRAWING_MODE_LOOP))
	{
		line = new ImLine(my_window, this, immediate_type, xx, yy, ww, hh);
		line->Copy(this, old->line);
		im_type = IM_LINE;
	}
	else if(immediate_type == DRAWING_MODE_RECTANGLE)
	{
		rectangle = new ImRectangle(my_window, this, xx, yy, ww, hh);
		rectangle->Copy(this, old->rectangle);
		im_type = IM_RECTANGLE;
	}
	else if(immediate_type == DRAWING_MODE_RECTANGLE_SELECT)
	{
		rectangle_select = new ImRectangleSelect(my_window, this, xx, yy, ww, hh);
		rectangle_select->Copy(this, old->rectangle_select);
		im_type = IM_RECTANGLE_SELECT;
	}
	else if(immediate_type == DRAWING_MODE_PIXELATE)
	{
		pixelate = new ImPixelate(my_window, this, xx, yy, ww, hh);
		pixelate->Copy(this, old->pixelate);
		im_type = IM_PIXELATE;
	}
	else if(immediate_type == DRAWING_MODE_ELLIPSE)
	{
		ellipse = new ImEllipse(my_window, this, xx, yy, ww, hh);
		ellipse->Copy(this, old->ellipse);
		im_type = IM_ELLIPSE;
	}
	else if(immediate_type == DRAWING_MODE_IMAGE)
	{
		image_im = new ImImage(my_window, this, xx, yy, ww, hh);
		image_im->Copy(this, old->image_im);
		im_type = IM_IMAGE;
	}
	end();
}

void	Immediate::draw()
{
int		loop;
char	buf[256];

	if(draw_it == 1)
	{
		Fl_Group::draw();
	}
	if((hovering == 1) || (dragging == 1))
	{
		if(my_camera == my_window->DisplayedCamera())
		{
			fl_color(FL_WHITE);
			fl_rect(x(), y(), w(), h());
			if(mw_mode == MW_MODE_STACKING_ORDER)
			{
				fl_font(FL_HELVETICA, 24);
				sprintf(buf, "%d", layer);
				fl_draw(buf, x(), y(), w(), h(), FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
			}
		}
	}
	if(idw != NULL)
	{
		if(idw->grid_size > 1)
		{
			fl_color(FL_GRAY);
			int sx = my_camera->image_sx;
			int sy = my_camera->image_sy;
			fl_line_style(FL_DOT);
			for(loop = 0;loop < my_camera->mat.cols;loop += idw->grid_size)
			{
				fl_line(sx + loop, sy, sx + loop, sy + my_camera->mat.rows);
			}
			for(loop = 0;loop < my_camera->mat.rows;loop += idw->grid_size)
			{
				fl_line(sx, sy + loop, sx + my_camera->mat.cols, sy + loop);
			}
			fl_line_style(FL_SOLID);
		}
	}
}

void	Immediate::Hide()
{
	draw_it = 0;
}

void	Immediate::Show()
{
	draw_it = 1;
}

void	Immediate::Copy()
{
	if(my_window != NULL)
	{
		Immediate *new_im = new Immediate(this, NULL);
		my_window->AddImmediate(new_im);
		if(my_window->immediate_drawing_window != NULL)
		{
			my_window->immediate_drawing_window->paste_button->show();
			my_window->immediate_drawing_window->clear_copy_buffer_button->show();
			my_window->immediate_drawing_window->redraw();
		}
	}
}

void	immediate_popup_cb(Fl_Widget *w, void *v)
{
	Immediate *iw = (Immediate *)v;
	if(iw != NULL)
	{
		if(iw->popup != NULL)
		{
			iw->popup->hide();
		}
		Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
		char *str = (char *)browser->text(browser->value());
		if(str != NULL)
		{
			if(strcmp(str, "Delete") == 0)
			{
				iw->Delete();
			}
			else if(strcmp(str, "Hide") == 0)
			{
				iw->Hide();
			}
			else if(strcmp(str, "Show") == 0)
			{
				iw->Show();
			}
			else if(strcmp(str, "Copy") == 0)
			{
				iw->Copy();
			}
			else if(strcmp(str, "Zip Left") == 0)
			{
				iw->ZipLeft();
			}
			else if(strcmp(str, "Zip Right") == 0)
			{
				iw->ZipRight();
			}
			else if(strcmp(str, "Zip Up") == 0)
			{
				iw->ZipUp();
			}
			else if(strcmp(str, "Zip Down") == 0)
			{
				iw->ZipDown();
			}
			else if(strcmp(str, "MW Transparency") == 0)
			{
				iw->mw_mode = MW_MODE_TRANSPARENCY;
				iw->redraw();
			}
			else if(strcmp(str, "MW Stacking Order") == 0)
			{
				iw->mw_mode = MW_MODE_STACKING_ORDER;
				iw->redraw();
			}
			else if(strcmp(str, "Make Transparent") == 0)
			{
				iw->overall_alpha = 0.0;
			}
			else if(strcmp(str, "Make Opaque") == 0)
			{
				iw->overall_alpha = 1.0;
			}
		}
	}
}

int	Camera::FindLeft(void *sample, int layer, int xx, int yy, int ww, int hh)
{
int	loop;

	int val = -1000000;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop] != sample)
			{
				if(immediate_list[loop]->layer == layer)
				{
					int edge = immediate_list[loop]->x() + immediate_list[loop]->w();
					int y1 = immediate_list[loop]->y();
					int y2 = immediate_list[loop]->y() + immediate_list[loop]->h();
					if(((yy > y1) && (yy <= y2))
					|| ((yy + hh > y1) && (yy + hh <= y2))
					|| ((yy + hh > y2) && (yy < y2)))
					{
						if(edge < xx)
						{
							if(edge > val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop] != sample)
			{
				if(image_window[loop]->layer == layer)
				{
					int edge = image_window[loop]->x() + image_window[loop]->w();
					int y1 = image_window[loop]->y();
					int y2 = image_window[loop]->y() + image_window[loop]->h();
					if(((yy > y1) && (yy <= y2))
					|| ((yy + hh > y1) && (yy + hh <= y2))
					|| ((yy + hh > y2) && (yy < y2)))
					{
						if(edge < xx)
						{
							if(edge > val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	return(val);
}

int	Camera::FindRight(void *sample, int layer, int xx, int yy, int ww, int hh)
{
int	loop;

	int val = 1000000;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop] != sample)
			{
				if(immediate_list[loop]->layer == layer)
				{
					int edge = immediate_list[loop]->x();
					int y1 = immediate_list[loop]->y();
					int y2 = immediate_list[loop]->y() + immediate_list[loop]->h();
					if(((yy > y1) && (yy <= y2))
					|| ((yy + hh > y1) && (yy + hh <= y2))
					|| ((yy + hh > y2) && (yy < y2)))
					{
						if(edge > xx + ww)
						{
							if(edge < val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop] != sample)
			{
				if(image_window[loop]->layer == layer)
				{
					int edge = image_window[loop]->x();
					int y1 = image_window[loop]->y();
					int y2 = image_window[loop]->y() + image_window[loop]->h();
					if(((yy > y1) && (yy <= y2))
					|| ((yy + hh > y1) && (yy + hh <= y2))
					|| ((yy + hh > y2) && (yy < y2)))
					{
						if(edge > xx + ww)
						{
							if(edge < val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	return(val);
}

int	Camera::FindTop(void *sample, int layer, int xx, int yy, int ww, int hh)
{
int	loop;

	int val = -1000000;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop] != sample)
			{
				if(immediate_list[loop]->layer == layer)
				{
					int edge = immediate_list[loop]->y() + immediate_list[loop]->h();
					int x1 = immediate_list[loop]->x();
					int x2 = immediate_list[loop]->x() + immediate_list[loop]->w();
					if(((xx > x1) && (xx <= x2))
					|| ((xx + ww > x1) && (xx + ww <= x2))
					|| ((xx + ww > x2) && (xx < x2)))
					{
						if(edge < yy)
						{
							if(edge > val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop] != sample)
			{
				if(image_window[loop]->layer == layer)
				{
					int edge = image_window[loop]->y() + image_window[loop]->h();
					int x1 = image_window[loop]->x();
					int x2 = image_window[loop]->x() + image_window[loop]->w();
					if(((xx > x1) && (xx <= x2))
					|| ((xx + ww > x1) && (xx + ww <= x2))
					|| ((xx + ww > x2) && (xx < x2)))
					{
						if(edge < yy)
						{
							if(edge > val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	return(val);
}

int	Camera::FindBottom(void *sample, int layer, int xx, int yy, int ww, int hh)
{
int	loop;

	int val = 1000000;
	for(loop = 0;loop < immediate_cnt;loop++)
	{
		if(immediate_list[loop] != NULL)
		{
			if(immediate_list[loop] != sample)
			{
				if(immediate_list[loop]->layer == layer)
				{
					int edge = immediate_list[loop]->y();
					int x1 = immediate_list[loop]->x();
					int x2 = immediate_list[loop]->x() + immediate_list[loop]->w();
					if(((xx > x1) && (xx <= x2))
					|| ((xx + ww > x1) && (xx + ww <= x2))
					|| ((xx + ww > x2) && (xx < x2)))
					{
						if(edge > yy + hh)
						{
							if(edge < val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop] != sample)
			{
				if(image_window[loop]->layer == layer)
				{
					int edge = image_window[loop]->y();
					int x1 = image_window[loop]->x();
					int x2 = image_window[loop]->x() + image_window[loop]->w();
					if(((xx > x1) && (xx <= x2))
					|| ((xx + ww > x1) && (xx + ww <= x2))
					|| ((xx + ww > x2) && (xx < x2)))
					{
						if(edge > yy + hh)
						{
							if(edge < val)
							{
								val = edge;
							}
						}
					}
				}
			}
		}
	}
	return(val);
}

void	Immediate::ZipLeft()
{
	Camera *cam = my_camera;
	if(cam != NULL)
	{
		int	val = cam->FindLeft(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			resize(val, y(), w(), h());
		}
		else
		{
			resize(cam->image_sx, y(), w(), h());
		}
	}
}

void	Immediate::ZipRight()
{
	Camera *cam = my_camera;
	if(cam != NULL)
	{
		int	val = cam->FindRight(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			resize(val - w(), y(), w(), h());
		}
		else
		{
			resize((cam->image_sx + cam->width) - w(), y(), w(), h());
		}
	}
}

void	Immediate::ZipUp()
{
	Camera *cam = my_camera;
	if(cam != NULL)
	{
		int	val = cam->FindTop(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			resize(x(), val, w(), h());
		}
		else
		{
			resize(x(), cam->image_sy, w(), h());
		}
	}
}

void	Immediate::ZipDown()
{
	Camera *cam = my_camera;
	if(cam != NULL)
	{
		int	val = cam->FindBottom(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			resize(x(), val - h(), w(), h());
		}
		else
		{
			resize(x(), (cam->image_sy + cam->height) - h(), w(), h());
		}
	}
}

void	Immediate::Move()
{
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	int dx = xx - initial_x;
	int dy = yy - initial_y;
	int nx = x() - dx;
	int ny = y() - dy;

	int xxx = Fl::event_x_root();
	int yyy = Fl::event_y_root();
	int ddx = last_x - xxx;
	int ddy = last_y - yyy;
	resize(x() - ddx, y() - ddy, w(), h());
	last_x = xxx;
	last_y = yyy;

	if((immediate_type == DRAWING_MODE_LINE)
	|| (immediate_type == DRAWING_MODE_POLYGON)
	|| (immediate_type == DRAWING_MODE_POLYGON_SELECT)
	|| (immediate_type == DRAWING_MODE_FREEHAND)
	|| (immediate_type == DRAWING_MODE_LOOP))
	{
		line->Revise(nx, ny);
	}
	child(0)->resize(x(), y(), w(), h());
}

void	Immediate::Delete()
{
	if((idw != NULL) && (my_camera != NULL))
	{
		idw->selected_widget = NULL;
		my_camera->RemoveImmediate(this);
		Fl::delete_widget(this);
	}
}

void	Immediate::ShowPopup()
{
	if(my_camera == my_window->DisplayedCamera())
	{
		if(popup == NULL)
		{
			popup = new PopupMenu(Fl::event_x_root() - 10, Fl::event_y_root() - 10, 120, 170);
			popup->browser->callback(immediate_popup_cb, this);
		}
		else
		{
			popup->resize(Fl::event_x_root() - 10, Fl::event_y_root() - 10, popup->w(), popup->h());
		}
		if(popup != NULL)
		{
			popup->browser->clear();
			popup->browser->add("Delete");
			popup->browser->add("Hide");
			popup->browser->add("Show");
			popup->browser->add("Copy");
			popup->browser->add("");
			popup->browser->add("Zip Left");
			popup->browser->add("Zip Right");
			popup->browser->add("Zip Up");
			popup->browser->add("Zip Down");
			popup->browser->add("");
			popup->browser->add("MW Transparency");
			popup->browser->add("MW Stacking Order");
			popup->browser->add("Make Transparent");
			popup->browser->add("Make Opaque");
			popup->set_non_modal();
			popup->Fit();
			popup->show();
		}
	}
}

int	Immediate::handle(int event)
{
	int flag = 0;
	if(my_camera != NULL)
	{
		if(my_camera->edit_layer == layer)
		{
			if(event == FL_ENTER)
			{
				my_window->use_mousewheel = 0;
				hovering = 1;
				flag = 1;
			}
			else if(event == FL_LEAVE)
			{
				my_window->use_mousewheel = 1;
				hovering = 0;
				flag = 1;
			}
			else if(event == FL_PUSH)
			{
				if(Fl::event_button() == FL_LEFT_MOUSE)
				{
					initial_x = Fl::event_x() - x();
					initial_y = Fl::event_y() - y();
					last_x = Fl::event_x_root();
					last_y = Fl::event_y_root();
					hovering = 0;
					dragging = 1;
					flag = 1;
				}
				else if(Fl::event_button() == FL_RIGHT_MOUSE)
				{
					ShowPopup();
				}
			}
			else if(event == FL_RELEASE)
			{
				if(Fl::event_button() == FL_LEFT_MOUSE)
				{
					initial_x = 0;
					initial_y = 0;
					dragging = 0;
					flag = 1;
				}
				else if(Fl::event_button() == FL_RIGHT_MOUSE)
				{
					ShowPopup();
				}
			}
			else if(event == FL_DRAG)
			{
				if(dragging == 1)
				{
					if(Fl::event_inside(this))
					{
						Move();
						flag = 1;
					}
				}
			}
			else if(event == FL_MOUSEWHEEL)
			{
				if(mw_mode == MW_MODE_TRANSPARENCY)
				{
					int nn = Fl::event_dy();
					if(nn > 0)
					{
						if(overall_alpha < 1.0)
						{
							overall_alpha += 0.01;
						}
					}
					else if(nn < 0)
					{
						if(overall_alpha > 0.0)
						{
							overall_alpha -= 0.01;
						}
					}
				}
				else if(mw_mode == MW_MODE_STACKING_ORDER)
				{
					int nn = Fl::event_dy();
					if(nn > 0)
					{
						if(layer < 7)
						{
							layer++;
							my_camera->edit_layer = layer;
						}
					}
					else if(nn < 0)
					{
						if(layer > 0)
						{
							layer--;
							my_camera->edit_layer = layer;
						}
					}
				}
				flag = 1;
			}
		}
	}
	if(flag == 0)
	{
		flag = Fl_Group::handle(event);
	}
	if(my_camera != NULL)
	{
		if(my_camera->edit_layer == layer)
		{
			if(flag == 1)
			{
				if((immediate_type == DRAWING_MODE_TEXT) && (text != NULL))
				{
					if((event == FL_FOCUS)
					|| (event == FL_UNFOCUS)
					|| (event == FL_KEYBOARD))
					{
						int ww = 0;
						int hh = 0;
						fl_font(text->textfont(), text->textsize());
						fl_measure(text->value(), ww, hh);
						resize(x(), y(), ww + 20, hh + 20);
						text->resize(x(), y(), w(), h());
						text->redraw();
					}
				}
			}
			if((immediate_type == DRAWING_MODE_LINE)
			|| (immediate_type == DRAWING_MODE_POLYGON)
			|| (immediate_type == DRAWING_MODE_POLYGON_SELECT)
			|| (immediate_type == DRAWING_MODE_FREEHAND)
			|| (immediate_type == DRAWING_MODE_LOOP))
			{
				if(line != NULL)
				{
					int x1, y1, x2, y2;
					line->Extent(x1, y1, x2, y2);
					int ww = x2 - x1;
					int hh = y2 - y1;
					if((ww > 0) && (hh > 0))
					{
						resize(x1, y1, ww, hh);
					}
				}
			}
		}
	}
	if(flag == 2)
	{
		flag = 1;
	}
	return(flag);
}

void	Immediate::CompleteRectangle(int xx, int yy)
{
	int use_x = initial_x;
	int use_y = initial_y;
	int use_w = 0;
	int use_h = 0;
	if((xx > initial_x) && (yy > initial_y))
	{
		use_x = initial_x;
		use_y = initial_y;
		use_w = xx - initial_x;
		use_h = yy - initial_y;
	}
	else if((xx < initial_x) && (yy > initial_y))
	{
		use_x = xx;
		use_y = initial_y;
		use_w = initial_x - xx;
		use_h = yy - initial_y;
	}
	else if((xx < initial_x) && (yy < initial_y))
	{
		use_x = xx;
		use_y = yy;
		use_w = initial_x - xx;
		use_h = initial_y - yy;
	}
	else if((xx > initial_x) && (yy < initial_y))
	{
		use_x = initial_x;
		use_y = yy;
		use_w = xx - initial_x;
		use_h = initial_y - yy;
	}
	resize(use_x, use_y, use_w, use_h);
	if(immediate_type == DRAWING_MODE_RECTANGLE)
	{
		rectangle->resize(use_x, use_y, use_w, use_h);
		rectangle->redraw();
	}
	if(immediate_type == DRAWING_MODE_RECTANGLE_SELECT)
	{
		rectangle_select->resize(use_x, use_y, use_w, use_h);
		rectangle_select->redraw();
	}
	if(immediate_type == DRAWING_MODE_PIXELATE)
	{
		pixelate->resize(use_x, use_y, use_w, use_h);
		pixelate->redraw();
	}
	if(immediate_type == DRAWING_MODE_ELLIPSE)
	{
		ellipse->resize(use_x, use_y, use_w, use_h);
		ellipse->redraw();
	}
	if(immediate_type == DRAWING_MODE_IMAGE)
	{
		if(idw != NULL)
		{
			int orig_w = idw->image_mat.cols;
			int orig_h = idw->image_mat.rows;
			double scale = (double)use_w / orig_w;
			if(use_h > use_w)
			{
				scale = (double)use_h / orig_h;
			}
			int nw = orig_w * scale;
			int nh = orig_h * scale;
			if((nw > 0) && (nh > 0))
			{
				image_im->resize(use_x, use_y, nw, nh);
				image_im->redraw();
			}
		}
	}
}

int	Camera::FindImmediate(Immediate *ptr)
{
int loop;

	int done = -1;
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->immediate_list != NULL)
		{
			for(loop = 0;((loop < cam->immediate_cnt) && (done == -1));loop++)
			{
				if(cam->immediate_list[loop] == ptr)
				{
					done = loop;
				}
			}
		}
	}
	return(done);
}

void	MyWin::DeleteImmediate()
{
int	loop;

	Fl_Widget *foc = Fl::focus();
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->immediate_list != NULL)
		{
			for(loop = 0;loop < cam->immediate_cnt;loop++)
			{
				Immediate *wid = cam->immediate_list[loop];
				if(wid != NULL)
				{
					if(wid != foc)
					{
						if((xx > wid->x())
						&& (yy > wid->y())
						&& (xx < (wid->x() + wid->w()))
						&& (yy < (wid->y() + wid->h())))
						{
							immediate_drawing_window->selected_widget = NULL;
							cam->RemoveImmediate(wid);
							Fl::delete_widget(wid);
						}
					}
				}
			}
		}
	}
}

void	MyWin::ToggleRecord(Camera *cam)
{
	if(cam->record == 0)
	{
		RecordOn();
	}
	else
	{
		RecordOff();
	}
}

int	MyWin::DoDeleteImmediate()
{
	int flag = 0;
	if(im_drawing_mode == 1)
	{
		DeleteImmediate();
	}
	return(flag);
}

int	MyWin::TogglePTZJoystick()
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		if(ptz_joystick == 0)
		{
			ptz_joystick = 1;
			ptz_joystick_button->value(1);
		}
		else
		{
			ptz_joystick = 0;
			ptz_joystick_button->value(0);
		}
		flag = 1;
	}
	return(flag);
}

int	MyWin::IncreasePTZLittleSpeed()
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		ptz_little_speed++;
		char buf[256];
		sprintf(buf, "Speed: %d", ptz_little_speed);
		CenterMessage(buf, 100);
		flag = 1;
	}
	return(flag);
}

int	MyWin::DecreasePTZLittleSpeed()
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		if(ptz_little_speed > 1)
		{
			ptz_little_speed--;
			char buf[256];
			sprintf(buf, "Speed: %d", ptz_little_speed);
			CenterMessage(buf, 100);
			flag = 1;
		}
	}
	return(flag);
}

int	MyWin::CyclePTZLittleMode()
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		ptz_little_mode++;
		if(ptz_little_mode > PTZ_LITTLE_ZOOM_AND_FOCUS_MODE)
		{
			ptz_little_mode = PTZ_LITTLE_MOTION_MODE;
		}
		if(ptz_little_mode == PTZ_LITTLE_MOTION_MODE)
		{
			CenterMessage("Motion", 100);
		}
		else if(ptz_little_mode == PTZ_LITTLE_ZOOM_MODE)
		{
			CenterMessage("Zoom", 100);
		}
		else if(ptz_little_mode == PTZ_LITTLE_FOCUS_MODE)
		{
			CenterMessage("Focus", 100);
		}
		else if(ptz_little_mode == PTZ_LITTLE_ZOOM_AND_FOCUS_MODE)
		{
			CenterMessage("Zoom and Focus", 100);
		}
		flag = 1;	
	}
	return(flag);
}

int	MyWin::PTZHome()
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		ViscaCommand(PTZ_HOME);
		flag = 1;
	}
	return(flag);
}

void	MyWin::CycleDownThumbgroup()
{
	displayed_source++;
	if(displayed_source >= source_cnt)
	{
		displayed_source = 0;
		start_thumbgroup = 0;
	}
	if(displayed_source >= (start_thumbgroup + DISPLAYED_THUMB_CNT))
	{
		start_thumbgroup++;
	}
	Display(displayed_source);
}

void	MyWin::CycleUpThumbgroup()
{
	displayed_source--;
	if(displayed_source < 0)
	{
		displayed_source = source_cnt - 1;
		while(displayed_source >= (start_thumbgroup + DISPLAYED_THUMB_CNT))
		{
			start_thumbgroup++;
		}
	}
	if(displayed_source < start_thumbgroup)
	{
		start_thumbgroup = displayed_source;
	}
	Display(displayed_source);
}

int	MyWin::DisplayThumbgroup(int nn)
{
	int flag = 0;
	if((nn >= 0) && (nn < source_cnt))
	{
		displayed_source = nn;
		while(displayed_source < start_thumbgroup)
		{
			start_thumbgroup--;
		}
		while(displayed_source >= (start_thumbgroup + DISPLAYED_THUMB_CNT))
		{
			start_thumbgroup++;
		}
		Display(displayed_source);
		flag = 1;
	}
	return(flag);
}

int	MyWin::LittleMotion(int key)
{
	int flag = 0;
	if(ptz_mode == 1)
	{
		if(ptz_little_mode == PTZ_LITTLE_MOTION_MODE)
		{
			MoveALittle(key);
		}
		else if(ptz_little_mode == PTZ_LITTLE_ZOOM_MODE)
		{
			ZoomALittle(key);
		}
		else if(ptz_little_mode == PTZ_LITTLE_FOCUS_MODE)
		{
			FocusALittle(key);
		}
		else if(ptz_little_mode == PTZ_LITTLE_ZOOM_AND_FOCUS_MODE)
		{
			ZoomAndFocusALittle(key);
		}
		flag = 1;	
	}
	return(flag);
}

void	MyWin::Review()
{
	review_button_cb(NULL, this);
}

void	MyWin::LocalZoomIn(Camera *cam)
{
	cam->zoom += 0.01;
	if(cam->zoom > 4.0)
	{
		cam->zoom = 4.0;
	}
}

void	MyWin::LocalZoomOut(Camera *cam)
{
	cam->zoom -= 0.01;
	if(cam->zoom <= 1.0)
	{
		cam->zoom = 1.0;
		offset_x = 0;
		offset_y = 0;
	}
}

void	MyWin::ToggleFrozen()
{
	if(frozen == 0)
	{
		frozen = 1;
	}
	else
	{
		frozen = 0;
	}
}

void	MyWin::DoSnapshot()
{
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		cam->snapshot = 1;
	}
}

void	MyWin::ScaleVideoReset()
{
	image_display_scale = 1.0;
}

void	MyWin::ScaleVideoUp()
{
	if(image_display_scale < 10.0)
	{
		image_display_scale += 0.01;
	}
}

void	MyWin::ScaleVideoDown()
{
	if(image_display_scale > 0.01)
	{
		image_display_scale -= 0.01;
	}
}

int	MyWin::DisplaySplitSelection(int nn)
{
	int flag = 0;
	if((nn >= 0) && (nn < source_cnt))
	{
		Display(nn);
		split = 0;
		flag = 1;
	}
	return(flag);
}

int	MyWin::HandleKeyboard(int event, Camera *cam)
{
	int flag = 0;
	int key = Fl::event_key();
	int ctrl = Fl::event_state(FL_CTRL);
	int alt = Fl::event_state(FL_ALT);
	int shift = Fl::event_state(FL_SHIFT);
	if(split == 0)
	{
		if((key == command_key[KEY_TOGGLE_RECORD]) && (!ctrl) && (!alt) && (!shift))
		{
			if(cam->power == 1)
			{
				ToggleRecord(cam);
			}
			flag = 1;
		}
		else if((key == command_key[KEY_DELETE_IMMEDIATE]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DoDeleteImmediate();
		}
		else if((key == command_key[KEY_TOGGLE_PTZ_JOYSTICK]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = TogglePTZJoystick();
		}
		else if((key == command_key[KEY_INCREASE_PTZ_LITTLE_SPEED]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = IncreasePTZLittleSpeed();
		}
		else if((key == command_key[KEY_DECREASE_PTZ_LITTLE_SPEED]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DecreasePTZLittleSpeed();
		}
		else if((key == command_key[KEY_CYCLE_PTZ_LITTLE_MODE]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = CyclePTZLittleMode();
		}
		else if((key == command_key[KEY_PTZ_HOME]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = PTZHome();
		}
		else if((key == command_key[KEY_CYCLE_DOWN_THUMBGROUP]) && (!ctrl) && (!alt) && (!shift))
		{
			CycleDownThumbgroup();
			flag = 1;
		}
		else if((key == command_key[KEY_CYCLE_UP_THUMBGROUP]) && (!ctrl) && (!alt) && (!shift))
		{
			CycleUpThumbgroup();
			flag = 1;
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_0]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(0);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_1]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(1);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_2]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(2);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_3]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(3);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_4]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(4);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_5]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(5);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_6]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(6);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_7]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(7);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_8]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(8);
		}
		else if((key == command_key[KEY_DISPLAY_THUMBGROUP_9]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplayThumbgroup(9);
		}
		else if(((key == command_key[KEY_LITTLE_MOTION_1]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_1]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_2]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_2]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_3]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_3]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_4]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_4]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_5]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_5]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_6]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_6]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_7]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_7]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_8]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_LITTLE_MOTION_OTHER_8]) && (!ctrl) && (!alt) && (!shift)))
		{
			flag = LittleMotion(key);
		}
		else if((key == command_key[KEY_REVIEW]) && (!ctrl) && (!alt) && (!shift))
		{
			Review();
			flag = 1;
		}
		else if((key == command_key[KEY_LOCAL_ZOOM_IN]) && (!ctrl) && (!alt) && (shift))
		{
			LocalZoomIn(cam);
			flag = 1;
		}
		else if((key == command_key[KEY_LOCAL_ZOOM_OUT]) && (!ctrl) && (!alt) && (!shift))
		{
			LocalZoomOut(cam);
			flag = 1;
		}
		else if((key == command_key[KEY_TOGGLE_FROZEN]) && (!ctrl) && (!alt) && (!shift))
		{
			ToggleFrozen();
			flag = 1;
		}
		else if((key == command_key[KEY_SCALE_VIDEO_RESET]) && (!ctrl) && (!alt) && (!shift))
		{
			ScaleVideoReset();
			flag = 1;
		}
		else if((key == command_key[KEY_SCALE_VIDEO_UP]) && (!ctrl) && (!alt) && (!shift))
		{
			ScaleVideoUp();
			flag = 1;
		}
		else if((key == command_key[KEY_SCALE_VIDEO_DOWN]) && (!ctrl) && (!alt) && (!shift))
		{
			ScaleVideoDown();
			flag = 1;
		}
		else if(((key == command_key[KEY_SNAPSHOT]) && (!ctrl) && (!alt) && (!shift))
		|| ((key == command_key[KEY_SNAPSHOT_OTHER]) && (!ctrl) && (!alt) && (!shift)))
		{
			DoSnapshot();
			flag = 1;
		}
	}
	else
	{
		if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_0]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(0);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_1]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(1);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_2]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(2);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_3]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(3);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_4]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(4);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_5]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(5);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_6]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(6);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_7]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(7);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_8]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(8);
		}
		else if((key == command_key[KEY_DISPLAY_SPLIT_SELECTION_9]) && (!ctrl) && (!alt) && (!shift))
		{
			flag = DisplaySplitSelection(9);
		}
	}
	return(flag);
}

int	MyWin::HandlePushForSplit()
{
	int flag = 0;
	int sz_w = w();
	int sz_h = h();
	int cols = 1;
	if(source_cnt == 1)
	{
		sz_w = w();
		sz_h = h();
		cols = 1;
	}
	else if(source_cnt < 5)
	{
		sz_w = w() / 2;
		sz_h = h() / 2;
		cols = 2;
	}
	else if(source_cnt < 10)
	{
		sz_w = w() / 3;
		sz_h = h() / 3;
		cols = 3;
	}
	int actual_x = Fl::event_x();
	int actual_y = Fl::event_y();
	int xx = actual_x / sz_w;
	int yy = actual_y / sz_h;
	int position = (yy * cols) + xx;
	if((position > -1) && (position < source_cnt))
	{
		if((actual_x > split_bx[position]) && (actual_x < split_bx[position] + 20)
		&& (actual_y > split_by[position]) && (actual_y < split_by[position] + 20))
		{
			RemoveSource(position);
		}
		if((actual_x > split_rx[position]) && (actual_x < split_rx[position] + 14)
		&& (actual_y > split_ry[position]) && (actual_y < split_ry[position] + 14))
		{
			ToggleRecord(position);
		}
		else
		{
			Display(position);
			split = 0;
		}
		flag = 1;
	}
	return(flag);
}

int	MyWin::HandlePushToSelectImmediate(Camera *cam)
{
int	loop;

	int newly_selected = 0;
	if((immediate_drawing_window->selected_widget == NULL)
	|| (((immediate_drawing_window->mode != DRAWING_MODE_LINE))
		&& (immediate_drawing_window->mode != DRAWING_MODE_POLYGON)
		&& (immediate_drawing_window->mode != DRAWING_MODE_POLYGON_SELECT)
		&& (immediate_drawing_window->mode != DRAWING_MODE_RECTANGLE_SELECT)
		&& (immediate_drawing_window->mode != DRAWING_MODE_LOOP)))
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		if(cam->immediate_list != NULL)
		{
			Immediate *s_wid = NULL;
			for(loop = 0;loop < cam->immediate_cnt;loop++)
			{
				Immediate *wid = cam->immediate_list[loop];
				if(wid != NULL)
				{
					if(wid->layer == cam->edit_layer)
					{
						if((xx > wid->x())
						&& (yy > wid->y())
						&& (xx < (wid->x() + wid->w()))
						&& (yy < (wid->y() + wid->h())))
						{
							if(((immediate_drawing_window->mode == wid->immediate_type))
							|| (immediate_drawing_window->mode == DRAWING_MODE_DELETE)
							|| (immediate_drawing_window->mode == DRAWING_MODE_HIDE))
							{
								if(wid->draw_it == 1)
								{
									s_wid = wid;
								}
							}
						}
					}
				}
			}
			if((immediate_drawing_window->selected_widget == NULL) && (s_wid != NULL))
			{
				newly_selected = 1;
			}
			immediate_drawing_window->selected_widget = s_wid;
		}
	}
	return(newly_selected);
}

int	MyWin::HandlePushToEditImmediate(Camera *cam)
{
	int flag = 0;
	immediate_drawing_window->Color(DARK_GRAY);
	immediate_drawing_window->redraw();
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	if((xx > cam->image_sx)
	&& (yy > cam->image_sy)
	&& (xx < cam->image_sx + cam->width)
	&& (yy < cam->image_sy + cam->height))
	{
		int grid_sz = immediate_drawing_window->grid_size;
		xx = force_to_grid(grid_sz, xx - cam->image_sx);
		yy = force_to_grid(grid_sz, yy - cam->image_sy);
		xx += cam->image_sx;
		yy += cam->image_sy;
		if((immediate_drawing_window->mode == DRAWING_MODE_LINE)
		|| (immediate_drawing_window->mode == DRAWING_MODE_POLYGON)
		|| (immediate_drawing_window->mode == DRAWING_MODE_POLYGON_SELECT)
		|| (immediate_drawing_window->mode == DRAWING_MODE_FREEHAND)
		|| (immediate_drawing_window->mode == DRAWING_MODE_LOOP))
		{
			if(Fl::event_button() == FL_RIGHT_MOUSE)
			{
				immediate_drawing_window->selected_widget = NULL;
			}
			else if(immediate_drawing_window->selected_widget == NULL)
			{
				ImmediateDrawingWindow *idw = immediate_drawing_window;
				Immediate *im = new Immediate(this, cam, idw, cam->image_sx, cam->image_sy, cam->width, cam->height);
				immediate_drawing_window->selected_widget = im;
				cam->AddImmediate(im);
				add(im);
				im->line->width = idw->line_size;
				im->line->red = idw->line_color_red;
				im->line->green = idw->line_color_green;
				im->line->blue = idw->line_color_blue;
				im->line->alpha = idw->line_color_alpha;
				im->line->style = idw->line_style;
				im->line->key = idw->freehand_key;
				im->line->freehand_mat = idw->freehand_mat.clone();
				im->line->AddPoint(xx, yy);
				flag = 1;
			}
			else
			{
				ImmediateDrawingWindow *idw = immediate_drawing_window;
				Immediate *im = (Immediate *)idw->selected_widget;
				if(im->layer == cam->edit_layer)
				{
					if(im->line != NULL)
					{
						im->line->width = idw->line_size;
						im->line->red = idw->line_color_red;
						im->line->green = idw->line_color_green;
						im->line->blue = idw->line_color_blue;
						im->line->alpha = idw->line_color_alpha;
						im->line->style = idw->line_style;
						im->line->key = idw->freehand_key;
						if(immediate_drawing_window->mode != DRAWING_MODE_FREEHAND)
						{
							im->line->AddPoint(xx, yy);
						}
						flag = 1;
					}
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_TEXT)
		{
			if(immediate_drawing_window->selected_widget == NULL)
			{
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					int dist_w = cam->width - (xx - cam->image_sx);
					int dist_h = cam->height - (yy - cam->image_sy);
					Immediate *im = new Immediate(this, cam, idw, xx, yy, dist_w, dist_h);
					immediate_drawing_window->selected_widget = im;
					cam->AddImmediate(im);
					add(im);
					flag = 1;
				}
			}
			else
			{
				ImmediateDrawingWindow *idw = immediate_drawing_window;
				Immediate *im = (Immediate *)idw->selected_widget;
				if(im->layer == cam->edit_layer)
				{
					if(im->text != NULL)
					{
						im->text->italic = idw->text_italic_button->value();
						im->text->bold = idw->text_bold_button->value();
						im->text->outline = idw->text_outline_button->value();
						im->text->font_alpha = idw->font_color_alpha;
						im->text->background_alpha = idw->back_color_alpha;
						im->text->outline_alpha = idw->outline_color_alpha;

						im->text->textfont(idw->font_num);
						im->text->textsize(idw->font_size);
						im->text->textcolor(fl_rgb_color(idw->font_color_red, idw->font_color_green, idw->font_color_blue));
						im->text->color(fl_rgb_color(idw->back_color_red, idw->back_color_green, idw->back_color_blue));
						im->text->box(idw->text_box_type);
						im->text->box_type = idw->text_box_type;
						im->text->take_focus();
					}
					im->redraw();
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE)
		{
			ImmediateDrawingWindow *idw = immediate_drawing_window;
			if(idw->selected_widget == NULL)
			{
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
					immediate_drawing_window->selected_widget = im;
					cam->AddImmediate(im);
					add(im);
					flag = 1;
				}
			}
			Immediate *im = (Immediate *)idw->selected_widget;
			if(im->layer == cam->edit_layer)
			{
				if(im->rectangle != NULL)
				{
					im->rectangle->width = idw->rectangle_size;
					im->rectangle->red = idw->rectangle_color_red;
					im->rectangle->green = idw->rectangle_color_green;
					im->rectangle->blue = idw->rectangle_color_blue;
					im->rectangle->alpha = idw->rectangle_color_alpha;
					im->rectangle->style = idw->rectangle_style;
					im->rectangle->filled = idw->rectangle_filled;
					im->rectangle->erase = idw->rectangle_erase;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE_SELECT)
		{
			ImmediateDrawingWindow *idw = immediate_drawing_window;
			if(idw->selected_widget == NULL)
			{
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
					immediate_drawing_window->selected_widget = im;
					cam->AddImmediate(im);
					add(im);
					flag = 1;
				}
			}
			Immediate *im = (Immediate *)idw->selected_widget;
			if(im->layer == cam->edit_layer)
			{
				if(im->rectangle != NULL)
				{
					im->rectangle->width = 1;
					im->rectangle->red = 255;
					im->rectangle->green = 255;
					im->rectangle->blue = 255;
					im->rectangle->alpha = 255;
					im->rectangle->style = FL_SOLID;
					im->rectangle->filled = 0;
					im->rectangle->erase = 0;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_ELLIPSE)
		{
			ImmediateDrawingWindow *idw = immediate_drawing_window;
			if(idw->selected_widget == NULL)
			{
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
					immediate_drawing_window->selected_widget = im;
					cam->AddImmediate(im);
					add(im);
					flag = 1;
				}
			}
			Immediate *im = (Immediate *)idw->selected_widget;
			if(im->layer == cam->edit_layer)
			{
				if(im->ellipse != NULL)
				{
					im->ellipse->width = idw->rectangle_size;
					im->ellipse->red = idw->rectangle_color_red;
					im->ellipse->green = idw->rectangle_color_green;
					im->ellipse->blue = idw->rectangle_color_blue;
					im->ellipse->alpha = idw->rectangle_color_alpha;
					im->ellipse->style = idw->rectangle_style;
					im->ellipse->filled = idw->rectangle_filled;
					im->ellipse->erase = idw->rectangle_erase;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_IMAGE)
		{
			ImmediateDrawingWindow *idw = immediate_drawing_window;
			if(idw->selected_widget == NULL)
			{
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
					immediate_drawing_window->selected_widget = im;
					cam->AddImmediate(im);
					add(im);
					flag = 1;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_PIXELATE)
		{
			ImmediateDrawingWindow *idw = immediate_drawing_window;
			if(idw->selected_widget == NULL)
			{
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					Immediate *im = new Immediate(this, cam, idw, xx, yy, 0, 0);
					immediate_drawing_window->selected_widget = im;
					cam->AddImmediate(im);
					add(im);
					flag = 1;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_DELETE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				Immediate *wid = immediate_drawing_window->selected_widget;
				if(wid->layer == cam->edit_layer)
				{
					immediate_drawing_window->selected_widget = NULL;
					cam->RemoveImmediate(wid);
					Fl::delete_widget(wid);
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_HIDE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				Immediate *wid = immediate_drawing_window->selected_widget;
				if(wid->layer == cam->edit_layer)
				{
					immediate_drawing_window->selected_widget = NULL;
					wid->Hide();
					wid->redraw();
				}
			}
		}
	}
	return(flag);
}

void	MyWin::ImmediateNewlySelectedHighlight()
{
	immediate_drawing_window->Color(DARK_GRAY);
	immediate_drawing_window->redraw();
}

int	MyWin::DoMarkInterest()
{
int	loop;

	int flag = 0;
	if(interest_cnt < 100)
	{
		int off_x = (w() / 2) - (camera[current_source]->width / 2);
		int off_y = (h() / 2) - (camera[current_source]->height / 2);
		int xx = Fl::event_x();
		int yy = Fl::event_y();

		if((xx > off_x)
		&& (yy > off_y)
		&& (xx < off_x + camera[current_source]->width)
		&& (yy < off_y + camera[current_source]->height))
		{
			int nx = (10.0 / (double)camera[current_source]->width) * (double)(xx - off_x);
			int ny = (10.0 / (double)camera[current_source]->height) * (double)(yy - off_y);
			int no_go = 0;
			for(loop = 0;loop < interest_cnt;loop++)
			{
				if((interest_x[loop] == nx)
				&& (interest_y[loop] == ny))
				{
					no_go = 1;
				}
			}
			if(no_go == 0)
			{
				interest_x[interest_cnt] = nx;
				interest_y[interest_cnt] = ny;
				interest_cnt++;
			}
			flag = 1;
		}
	}
	return(flag);
}

int	MyWin::HandlePushForPTZ(Camera *cam)
{
int	loop;

	int flag = 0;
	if((ptz_window->locked_camera == NULL) || (ptz_window->locked_camera == cam))
	{
		int no_go = 0;
		if(use_mousewheel == 0)
		{
			no_go = 1;
		}
		if(no_go == 0)
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				if(ImageWindowButtonHit(Fl::event_x(), Fl::event_y()) == 0)
				{
					if(ptz_joystick == 1)
					{
						int xx = Fl::event_x() - (w() / 2);
						int yy = Fl::event_y() - (h() / 2);
						if((xx > -100) && (yy > -100)
						&& (xx < 100) && (yy < 100))
						{
							ptz_joystick_x = xx;
							ptz_joystick_y = yy;
							Fl::add_timeout(0.01, ptz_joystick_cb, this);
							flag = 1;
						}
					}
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					start_ptz_drag_x = xx;
					start_ptz_drag_y = yy;
					ptz_dragged = 0;
				}
				else
				{
					image_window_button = 1;
				}
			}
			else if(Fl::event_button() == FL_MIDDLE_MOUSE)
			{
				ptz_middle_mouse++;
				if(ptz_middle_mouse > 3)
				{
					ptz_middle_mouse = 0;
				}
				if(ptz_middle_mouse == 1)
				{
					CenterMessage("Zoom", 100);
					zoom_label->labelcolor(FL_CYAN);
					focus_label->labelcolor(FL_YELLOW);
					ptz_zoomer = 0;
					ptz_zoomer_speed = 0;
					ViscaCommand(PTZ_ZOOM_STOP);
				}
				else if(ptz_middle_mouse == 2)
				{
					CenterMessage("Focus", 100);
					zoom_label->labelcolor(FL_YELLOW);
					focus_label->labelcolor(FL_CYAN);
					ptz_zoomer = 0;
					ptz_zoomer_speed = 0;
					ViscaCommand(PTZ_ZOOM_STOP);
				}
				else if(ptz_middle_mouse == 3)
				{
					CenterMessage("Zoom with speed control", 100);
					zoom_label->labelcolor(FL_CYAN);
					focus_label->labelcolor(FL_YELLOW);
				}
				else
				{
					CenterMessage("Digital Scaling", 100);
				}
				flag = 1;
			}
		}
	}
	return(flag);
}

int	MyWin::HandleReleaseForImmediate(Camera *cam)
{
	int flag = 0;
	if(im_drawing_mode == 1)
	{
		if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->rectangle != NULL)
					{
						im->CompleteRectangle(xx, yy);
						idw->selected_widget = NULL;
					}
					im->redraw();
				}
				flag = 1;
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE_SELECT)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->rectangle_select != NULL)
					{
						im->CompleteRectangle(xx, yy);
						im->rectangle_select->selecting = 0;
						idw->selected_widget = NULL;
					}
					im->redraw();
				}
				flag = 1;
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_ELLIPSE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->ellipse != NULL)
					{
						im->CompleteRectangle(xx, yy);
						idw->selected_widget = NULL;
					}
					im->redraw();
					flag = 1;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_IMAGE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->image_im != NULL)
					{
						im->CompleteRectangle(xx, yy);
						idw->selected_widget = NULL;
					}
					im->redraw();
					flag = 1;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_PIXELATE)
		{
			if(immediate_drawing_window->selected_widget != NULL)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx)
				&& (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width)
				&& (yy < cam->image_sy + cam->height))
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->pixelate != NULL)
					{
						im->CompleteRectangle(xx, yy);
						idw->selected_widget = NULL;
					}
					im->redraw();
					flag = 1;
				}
			}
		}
		else if(immediate_drawing_window->mode == DRAWING_MODE_FREEHAND)
		{
			ImmediateDrawingWindow *idw = immediate_drawing_window;
			idw->selected_widget = NULL;
			flag = 1;
		}
	}
	return(flag);
}

int	MyWin::HandleRelease(Camera *cam)
{
	int flag = 0;
	if(((resizing_detail == 1) || (zoom_boxing == 1))
	&& (drag_start_x > -1)
	&& (drag_start_y > -1)
	&& (move_corner == 0)
	&& (resize_corner == 0)
	&& (restore_corner == 0))
	{
		reset_button_cb(NULL, this);
		int drag_stop_x = Fl::event_x();
		int drag_stop_y = Fl::event_y();
		if(drag_stop_x < drag_start_x)
		{
			int tmp = drag_stop_x;
			drag_stop_x = drag_start_x;
			drag_start_x = tmp;
		}
		if(drag_stop_y < drag_start_y)
		{
			int tmp = drag_stop_y;
			drag_stop_y = drag_start_y;
			drag_start_y = tmp;
		}
		int diff_x = abs(drag_stop_x - drag_start_x);
		int diff_y = abs(drag_stop_y - drag_start_y);
		while((diff_x % 16) != 0)
		{
			diff_x++;
		}
		while((diff_y % 16) != 0)
		{
			diff_y++;
		}
		if(diff_x < 320) diff_x = 320;
		if(diff_x > w()) diff_x = w();
		if(diff_y < 240) diff_y = 240;
		if(diff_y > h()) diff_y = h();
		if(resizing_detail == 1)
		{
			detail_width = diff_x;
			detail_height = diff_y;
			resizing_detail = 0;

			detail->hide();
			DetailWin *save = detail;
			detail = NULL;
			delete save;
			
			detail = new DetailWin(detail_width, detail_height, "Detail");
			detail->end();
			detail->hide();

			detail->resize(detail->x(), detail->y(), detail_width, detail_height);
		}
		else if(zoom_boxing == 1)
		{
			zoom_boxing = 0;
			if((drag_start_x >= cam->image_sx)
			&& (drag_start_y >= cam->image_sy)
			&& (drag_start_x + diff_x <= cam->image_sx + camera[current_source]->width)
			&& (drag_start_y + diff_y <= cam->image_sy + camera[current_source]->height))
			{
				cam->zoom_box_display = 1;
				cam->zoom_box_x = drag_start_x;
				cam->zoom_box_y = drag_start_y;
				cam->zoom_box_w = diff_x;
				cam->zoom_box_h = diff_y;
			}
		}
		flag = 1;
	}
	dragging = 0;
	save_offset_x += offset_x;
	save_offset_y += offset_y;
	offset_x = 0;
	offset_y = 0;
	fl_cursor(FL_CURSOR_DEFAULT);
	return(flag);
}

int	MyWin::HandleReleaseForPTZ(Camera *cam)
{
	int flag = 0;
	if((mark_interest == 0) && (move_corner == 0) && (resize_corner == 0) && (restore_corner == 0))
	{
		if(ptz_joystick == 1)
		{
			VISCA_set_pantilt_stop(ptz_current_interface, ptz_current_camera, 0, 0);
			ptz_joystick_x = 0;
			ptz_joystick_y = 0;
		}
		else
		{
			if(Fl::event_button() == FL_LEFT_MOUSE)
			{
				if((ptz_dragged == 0) && (image_window_button == 0))
				{
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					if((xx >= cam->image_sx)
					&& (yy >= cam->image_sy)
					&& (xx <= (cam->image_sx + cam->width))
					&& (yy <= (cam->image_sy + cam->height)))
					{
						PTZ_MoveTo(20, 20, xx, yy);
					}
				}
				image_window_button = 0;
			}
		}
		flag = 1;
	}
	return(flag);
}

void	MyWin::ShowPTZ(Camera *cam, int xx, int yy)
{
	if((ptz_mode == 1) && (ptz_window != NULL))
	{
		if(retain_ptz == 0)
		{
			if((xx < (200 * gui_scale_factor)) && (yy > (h() - ptz_window->h())))
			{
				if((ptz_window->locked_camera == NULL) || (ptz_window->locked_camera == cam))
				{
					ptz_window->show();
				}
				else
				{
					ptz_window->hide();
				}
			}
			else
			{
				ptz_window->hide();
			}
		}
		else
		{
			ptz_window->show();
		}
	}
}

void	MyWin::ShowAudio(int xx, int yy)
{
	if(audio == 1)
	{
		if(retain_audio == 0)
		{
			int bars = (audio_thumbnail_cnt / 7) + 1;
			int lower_edge = 10 + (bars * 70);
			if((xx > (600 * gui_scale_factor)) && (yy < (lower_edge * gui_scale_factor)))
			{
				audio_thumbnail_group->show();
			}
			else
			{
				audio_thumbnail_group->hide();
			}
		}
		else
		{
			audio_thumbnail_group->show();
		}
	}
}

void	MyWin::ShowVideoThumbs(int xx, int yy)
{
	if(retain_cameras == 0)
	{
		if(xx < (280 * gui_scale_factor))
		{
			video_thumbnail_group->show();
		}
		else
		{
			video_thumbnail_group->hide();
		}
	}
	else
	{
		video_thumbnail_group->show();
	}
}

int	MyWin::HandleMove(Camera *cam)
{
int	loop;

	int flag = 0;
	if(split == 0)
	{
		move_corner = 0;
		resize_corner = 0;
		restore_corner = 0;
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		if(mark_interest == 1)
		{
			int off_x = image_origin_x;
			int off_y = image_origin_y;

			if((xx > off_x)
			&& (yy > off_y)
			&& (xx < off_x + camera[current_source]->width)
			&& (yy < off_y + camera[current_source]->height))
			{
				int nx = (10.0 / (double)camera[current_source]->width) * (double)(xx - off_x);
				int ny = (10.0 / (double)camera[current_source]->height) * (double)(yy - off_y);
				nominal_interest_x = nx;
				nominal_interest_y = ny;
			}
			else
			{
				nominal_interest_x = -1;
				nominal_interest_y = -1;
			}
		}
		if((xx < cam->image_sx) || (xx > (cam->image_sx + cam->width))
		|| (yy < cam->image_sy) || (yy > (cam->image_sy + cam->height)))
		{
			fl_cursor(FL_CURSOR_DEFAULT);
		}
		if(cam->fps > 0.0)
		{
			buttonized_visible = 0;
			int edge = button_panel_sz;
			if((mark_interest == 1) && (!button_group->visible()))
			{
				edge = 60;
			}
			if(xx > w() - edge)
			{
				if(buttons_shown == 0)
				{
					HideButtons();
					ShowButtons();
					button_group->resize(w() - button_group->w(), button_group->y(), button_group->w(), button_group->h());
					button_group->show();
					buttons_shown = 1;
				}
			}
			else
			{
				if(retain_commands == 1)
				{
					if(buttons_shown == 0)
					{
						HideButtons();
						ShowButtons();
						button_group->resize(w() - button_group->w(), button_group->y(), button_group->w(), button_group->h());
						button_group->show();
						buttons_shown = 1;
					}
				}
				if((xx > 280) && (yy > (Fl::h() - 180)))
				{
					buttonized_visible = 1;
				}
				if(buttons_shown == 1)
				{
					if(retain_commands == 0)
					{
						button_group->hide();
						buttons_shown = 0;
					}
				}
				ShowVideoThumbs(xx, yy);
				ShowPTZ(cam, xx, yy);
				ShowAudio(xx, yy);
				if(embedded_app_cnt > 0)
				{
					for(loop = 0;loop < 10;loop++)
					{
						EmbedAppWindow *eaw = embedded_app[loop];
						if(eaw != NULL)
						{
							if(eaw->viz == 1)
							{
								if((xx > eaw->my_x)
								&& (yy > eaw->my_y)
								&& (xx < (eaw->my_x + eaw->my_w))
								&& (yy < (eaw->my_y + eaw->my_h)))
								{
									eaw->my_show();
									eaw->redraw();
								}
								else
								{
									eaw->my_hide();
								}
							}
							else
							{
								if((xx > eaw->my_x)
								&& (yy > h() - 25)
								&& (xx < (eaw->my_x + eaw->my_w)))
								{
									eaw->my_show();
									eaw->redraw();
								}
							}
						}
					}
				}
				if((cam->image_sx > 0) && (cam->image_sy > 0))
				{
					int diff_x = xx - cam->image_sx;
					int diff_y = yy - cam->image_sy;
					if((diff_x < 25) && (diff_y < 25)
					&& (diff_x >= 0) && (diff_y >= 0))
					{
						move_corner = 1;
					}
				}
				if((cam->display_width < w()) && (cam->display_height < h()))
				{
					int diff_x = (cam->image_sx + cam->display_width) - xx;
					int diff_y = (cam->image_sy + cam->display_height) - yy;
					if((diff_x < 25) && (diff_y < 25)
					&& (diff_x >= 0) && (diff_y >= 0))
					{
						resize_corner = 1;
					}
				}
				if((cam->display_width != cam->width) && (cam->display_height != cam->height))
				{
					int diff_x = xx - cam->image_sx;
					int diff_y = (cam->image_sy + cam->display_height) - yy;
					if((diff_x < 25) && (diff_y < 25)
					&& (diff_x >= 0) && (diff_y >= 0))
					{
						restore_corner = 1;
					}
				}
			}
		}
	}
	else
	{
		if(buttons_shown == 1)
		{
			button_group->hide();
			buttons_shown = 0;
		}
	}
	return(flag);
}

int	MyWin::HandleImmediateDrag(Camera *cam)
{
	int flag = 0;
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	if((xx > cam->image_sx)
	&& (yy > cam->image_sy)
	&& (xx < cam->image_sx + cam->width)
	&& (yy < cam->image_sy + cam->height))
	{
		if(im_drawing_mode == 1)
		{
			if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->rectangle != NULL)
					{
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_RECTANGLE_SELECT)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->rectangle_select != NULL)
					{
						im->rectangle_select->selecting = 1;
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_ELLIPSE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->ellipse != NULL)
					{
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_IMAGE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->image_im != NULL)
					{
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_PIXELATE)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->pixelate != NULL)
					{
						im->CompleteRectangle(xx, yy);
					}
					im->redraw();
					flag = 1;
				}
			}
			else if(immediate_drawing_window->mode == DRAWING_MODE_FREEHAND)
			{
				if(immediate_drawing_window->selected_widget != NULL)
				{
					ImmediateDrawingWindow *idw = immediate_drawing_window;
					Immediate *im = (Immediate *)idw->selected_widget;
					if(im->line != NULL)
					{
						im->line->width = idw->line_size;
						im->line->red = idw->line_color_red;
						im->line->green = idw->line_color_green;
						im->line->blue = idw->line_color_blue;
						im->line->style = idw->line_style;
						im->line->key = idw->freehand_key;
						im->line->AddPoint(xx, yy);
						flag = 1;
					}
				}
			}
		}
	}
	return(flag);
}

int	MyWin::HandlePTZDrag()
{
	int flag = 0;
	int xx = Fl::event_x() - (w() / 2);
	int yy = Fl::event_y() - (h() / 2);
	if((xx > -100) && (yy > -100)
	&& (xx < 100) && (yy < 100))
	{
		ptz_joystick_x = xx;
		ptz_joystick_y = yy;
		Fl::add_timeout(0.01, ptz_joystick_cb, this);
		flag = 1;
	}
	return(flag);
}

int	MyWin::HandleDrag(Camera *cam)
{
	int flag = 0;
	if(move_corner == 1)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		int off_x = xx - cam->image_sx;
		int off_y = yy - cam->image_sy;
		cam->OffsetPositionImageWindows(off_x, off_y);
		cam->image_sx = xx;
		cam->image_sy = yy;
		flag = 1;
	}
	else if(resize_corner == 1)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		if((last_resize_drag_x > -1) && (last_resize_drag_y > -1))
		{
			int diff_x = xx - last_resize_drag_x;
			double factor = (double)(cam->display_width + diff_x) / (double)cam->display_width;
			double use_x = (double)cam->display_width * factor;
			double use_y = (double)cam->display_height * factor;
			if((use_x > 50) && (use_y > 50))
			{
				double factor_w = use_x / cam->display_width;
				double factor_h = use_y / cam->display_height;
				cam->display_width = use_x;
				cam->display_height = use_y;
			}
		}
		last_resize_drag_x = xx;
		last_resize_drag_y = yy;
	}
	else
	{
		if(stream == 0)
		{
			force_center_x = Fl::event_x();
			force_center_y = Fl::event_y();
		}
		else if(cam->zoom > 1.0)
		{
			if((start_offset_x > -1) && (start_offset_y > -1))
			{
				offset_x = start_offset_x - Fl::event_x();
				offset_y = start_offset_y - Fl::event_y();
				dragging = 1;
			}
			flag = 1;
			fl_cursor(FL_CURSOR_MOVE);
		}
		else if(rubberband_mode == 1)
		{
			int x1 = last_push_x;
			int y1 = last_push_y;
			int x2 = Fl::event_x();
			int y2 = Fl::event_y();
			if(editing_misc_mode == EDITING_MISC_MOVE)
			{
				if(editing_misc_outer > -1)
				{
					if(misc_copy[editing_misc_outer] != NULL)
					{
						int ddx = x2 - last_push_x;
						int ddy = y2 - last_push_y;
						if(editing_misc_inner == -1)
						{
							misc_copy[editing_misc_outer]->xx += ddx;
							misc_copy[editing_misc_outer]->yy += ddy;
						}
						else if(editing_misc_inner > -1)
						{
							misc_copy[editing_misc_outer]->dest_x[editing_misc_inner] += ddx;
							misc_copy[editing_misc_outer]->dest_y[editing_misc_inner] += ddy;
						}
					}
				}
				last_push_x = x2;
				last_push_y = y2;
			}
			else if(editing_misc_mode == EDITING_MISC_RESIZE)
			{
				if(editing_misc_outer > -1)
				{
					if(misc_copy[editing_misc_outer] != NULL)
					{
						int ddx = x2 - last_push_x;
						int ddy = y2 - last_push_y;
						if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
						{
							misc_copy[editing_misc_outer]->ww += ddx;
							misc_copy[editing_misc_outer]->hh += ddx;
						}
						else
						{
							misc_copy[editing_misc_outer]->ww += ddx;
							misc_copy[editing_misc_outer]->hh += ddy;
						}
						int sw = misc_copy[editing_misc_outer]->ww;
						int sh = misc_copy[editing_misc_outer]->hh;
						if(!misc_copy[editing_misc_outer]->mat.empty())
						{
							cv::resize(misc_copy[editing_misc_outer]->mat, misc_copy[editing_misc_outer]->mat, cv::Size(sw, sh));
						}
					}
				}
				last_push_x = x2;
				last_push_y = y2;
			}
			else
			{
				if(x1 > x2)
				{
					int tmp = x1;
					x1 = x2;
					x2 = tmp;
				}
				if(y1 > y2)
				{
					int tmp = y1;
					y1 = y2;
					y2 = tmp;
				}
				rubber_band_x = x1;
				rubber_band_y = y1;
				rubber_band_w = x2 - x1;
				rubber_band_h = y2 - y1;
			}
		}
	}
	return(flag);
}

void	MyWin::MiscRemoveAll()
{
int	loop;
int	inner;

	Camera *cam = DisplayedCamera();
	for(loop = 0;loop < misc_copy_cnt;loop++)
	{
		if(misc_copy[loop] != NULL)
		{
			if(misc_copy[loop]->source == cam)
			{
				delete misc_copy[loop];
				misc_copy[loop] = NULL;
			}
		}
	}
}

int	MyWin::InMiscPasted(int xx, int yy, int& r_outer, int& r_inner)
{
int	loop;
int	inner;

	int hit = 0;
	Camera *cam = DisplayedCamera();
	xx -= cam->image_sx;
	yy -= cam->image_sy;
	for(loop = 0;loop < misc_copy_cnt;loop++)
	{
		if(misc_copy[loop] != NULL)
		{
			if(misc_copy[loop]->display == 1)
			{
				if((misc_copy[loop]->type == MISC_COPY_STATIC)
				|| (misc_copy[loop]->type == MISC_COPY_DYNAMIC))
				{
					for(inner = 0;inner < misc_copy[loop]->destination_cnt;inner++)
					{
						if(misc_copy[loop]->destination[inner] == cam)
						{
							if(!misc_copy[loop]->mat.empty())
							{
								int use_x = misc_copy[loop]->dest_x[inner];
								int use_y = misc_copy[loop]->dest_y[inner];
								int use_w = misc_copy[loop]->ww;
								int use_h = misc_copy[loop]->hh;
								if((xx >= use_x) && (xx <= (use_x + use_w))
								&& (yy >= use_y) && (yy <= (use_y + use_h)))
								{
									hit = 1;
									r_outer = loop;
									r_inner = inner;
								}
							}
						}
					}
				}
				else
				{
					int use_x = misc_copy[loop]->xx;
					int use_y = misc_copy[loop]->yy;
					int use_w = misc_copy[loop]->ww;
					int use_h = misc_copy[loop]->hh;
					if((xx >= use_x) && (xx <= (use_x + use_w))
					&& (yy >= use_y) && (yy <= (use_y + use_h)))
					{
						hit = 1;
						r_outer = loop;
						r_inner = -1;
					}
				}
			}
		}
	}
	return(hit);
}

int	MyWin::HandleMousewheelResizeCapture(Camera *cam)
{
	int flag = 0;
	int suggest_w = camera[current_source]->width;
	int suggest_h = camera[current_source]->height;
	int ow = camera[current_source]->width;
	int oh = camera[current_source]->height;
	int nw = camera[current_source]->width;
	int nh = camera[current_source]->height;
	int direction = Fl::event_dy();
	if(direction > 0)
	{
		if(ow < w())
		{
			while((ow == nw) && (oh == nh) && (suggest_w < w()))
			{
				suggest_w *= 1.1;
				suggest_h *= 1.1;
				camera[current_source]->Resize(suggest_w, suggest_h);
				nw = camera[current_source]->width;
				nh = camera[current_source]->height;
			}
		}
	}
	else if(direction < 0)
	{
		if(ow > 320)
		{
			while((ow == nw) && (oh == nh) && (suggest_w > 320))
			{
				suggest_w *= 0.9;
				suggest_h *= 0.9;
				camera[current_source]->Resize(suggest_w, suggest_h);
				nw = camera[current_source]->width;
				nh = camera[current_source]->height;
			}
		}
	}
	flag = 1;
	return(flag);
}

int	MyWin::HandleMousewheelPTZ(Camera *cam)
{
	int flag = 0;
	if(ptz_middle_mouse == 1)
	{
		int direction = Fl::event_dy();
		if(direction > 0)
		{
			if(ptz_zooming == 0)
			{
				ViscaCommand(PTZ_ZOOM_IN);
				Fl::add_timeout(0.5, ptz_zoom_cb, this);
				flag = 1;
			}
		}
		else if(direction < 0)
		{
			if(ptz_zooming == 0)
			{
				ViscaCommand(PTZ_ZOOM_OUT);
				Fl::add_timeout(0.5, ptz_zoom_cb, this);
				flag = 1;
			}
		}
	}
	else if(ptz_middle_mouse == 2)
	{
		int direction = Fl::event_dy();
		if(direction > 0)
		{
			ViscaCommand(PTZ_FOCUS_FAR);
			Fl::add_timeout(0.1, ptz_focus_cb, this);
			flag = 1;
		}
		else if(direction < 0)
		{
			ViscaCommand(PTZ_FOCUS_NEAR);
			Fl::add_timeout(0.1, ptz_focus_cb, this);
			flag = 1;
		}
	}
	else if(ptz_middle_mouse == 3)
	{
		ptz_zoomer += Fl::event_dy();
		if(ptz_zoomer > 0)
		{
			ptz_zoomer_speed = abs(ptz_zoomer);
			if(ptz_zoomer_speed > 20)
			{
				ptz_zoomer_speed = 20;
			}
			ViscaCommand(PTZ_ZOOM_IN);
		}
		else if(ptz_zoomer < 0)
		{
			ptz_zoomer_speed = abs(ptz_zoomer);
			if(ptz_zoomer_speed > 20)
			{
				ptz_zoomer_speed = 20;
			}
			ViscaCommand(PTZ_ZOOM_OUT);
		}
		else
		{
			ptz_zoomer_speed = 0;
			ViscaCommand(PTZ_ZOOM_STOP);
		}
		flag = 1;
	}
	return(flag);
}

int	MyWin::HandleMousewheel(Camera *cam)
{
	int flag = 0;
	if(cam != NULL)
	{
		int direction = Fl::event_dy();
		if(direction > 0)
		{
			cam->zoom += 0.01;
			if(cam->zoom > 4.0)
			{
				cam->zoom = 4.0;
			}
			flag = 1;
		}
		else if(direction < 0)
		{
			cam->zoom -= 0.1;
			if(cam->zoom <= 1.0)
			{
				cam->zoom = 1.0;
				offset_x = 0;
				offset_y = 0;
			}
			flag = 1;
		}
	}
	return(flag);
}

ColorSlider::ColorSlider(int xx, int yy, int ww, int hh, double val, char *lbl) : Fl_Value_Slider(xx, yy, ww, hh, lbl)
{
	color(FL_BLACK);
	box(FL_FRAME_BOX);
	align(FL_ALIGN_LEFT);
	labelcolor(FL_WHITE);
	labelsize(9);
	textcolor(FL_WHITE);
	textsize(9);
	value(val);
	range(0, 255);
	step(1);
	type(FL_HOR_SLIDER);
}

void	color_it_set_all_cb(Fl_Widget *w, void *v)
{
	ColorItWindow *ciw = (ColorItWindow *)v;
	MyWin *win = ciw->my_window;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		int nn = 0;
		if(cam->color_it_cnt > 0)
		{
			nn = cam->color_it_cnt - 1;
		}
		cam->color_it_tolerance_r[nn] = (int)ciw->red_tolerance->value();
		cam->color_it_tolerance_g[nn] = (int)ciw->green_tolerance->value();
		cam->color_it_tolerance_b[nn] = (int)ciw->blue_tolerance->value();

		cam->color_it_replace_r[nn] = (int)ciw->red_replace->value();
		cam->color_it_replace_g[nn] = (int)ciw->green_replace->value();
		cam->color_it_replace_b[nn] = (int)ciw->blue_replace->value();
		cam->color_it_replace_a[nn] = (int)ciw->alpha_replace->value();
	}
}

void	color_it_clear_last_cb(Fl_Widget *w, void *v)
{
	ColorItWindow *ciw = (ColorItWindow *)v;
	MyWin *win = ciw->my_window;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->color_it_cnt > 0)
		{
			cam->color_it_cnt--;
		}
	}
}

void	color_it_clear_all_cb(Fl_Widget *w, void *v)
{
	ColorItWindow *ciw = (ColorItWindow *)v;
	MyWin *win = ciw->my_window;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		cam->color_it_cnt = 0;
	}
}

ColorSlider::~ColorSlider()
{
}

ColorItWindow::ColorItWindow(MyWin *in_win) : Fl_Double_Window(425, 240, "Color It")
{
	my_window = in_win;
	double gsf = my_window->gui_scale_factor;
	box(FL_FLAT_BOX);
	color(FL_BLACK);
	set_non_modal();

	int y_pos = 20;
	red_tolerance = new ColorSlider(100, y_pos, 300, 20, 24, "Red Tolerance");
	red_tolerance->callback(color_it_set_all_cb, this);
	y_pos += 22;
	green_tolerance = new ColorSlider(100, y_pos, 300, 20, 24, "Green Tolerance");
	green_tolerance->callback(color_it_set_all_cb, this);
	y_pos += 22;
	blue_tolerance = new ColorSlider(100, y_pos, 300, 20, 24, "Blue Tolerance");
	blue_tolerance->callback(color_it_set_all_cb, this);
	y_pos += 32;

	red_replace = new ColorSlider(100, y_pos, 300, 20, 0, "Red Replace");
	red_replace->callback(color_it_set_all_cb, this);
	y_pos += 22;
	green_replace = new ColorSlider(100, y_pos, 300, 20, 0, "Green Replace");
	green_replace->callback(color_it_set_all_cb, this);
	y_pos += 22;
	blue_replace = new ColorSlider(100, y_pos, 300, 20, 0, "Blue Replace");
	blue_replace->callback(color_it_set_all_cb, this);
	y_pos += 22;
	alpha_replace = new ColorSlider(100, y_pos, 300, 20, 0, "Alpha Replace");
	alpha_replace->callback(color_it_set_all_cb, this);
	y_pos += 32;

	Fl_Button *clear_last_button = new Fl_Button(100, y_pos, 70, 20, "Clear Last");
	clear_last_button->box(FL_FLAT_BOX);
	clear_last_button->color(FL_BLACK);
	clear_last_button->labelcolor(FL_YELLOW);
	clear_last_button->labelsize(11);
	clear_last_button->align(FL_ALIGN_CENTER);
	clear_last_button->callback(color_it_clear_last_cb, this);
	Fl_Button *clear_all_button = new Fl_Button(325, y_pos, 70, 20, "Clear All");
	clear_all_button->box(FL_FLAT_BOX);
	clear_all_button->color(FL_BLACK);
	clear_all_button->labelcolor(FL_YELLOW);
	clear_all_button->labelsize(11);
	clear_all_button->align(FL_ALIGN_CENTER);
	clear_all_button->callback(color_it_clear_all_cb, this);
	end();
}

ColorItWindow::~ColorItWindow()
{
}

void	ColorItWindow::hide()
{
	my_window->selecting_colors = 0;
	Fl_Double_Window::hide();
}

void	ColorItWindow::show()
{
	my_window->selecting_colors = 1;
	Fl_Double_Window::show();
}

void	blend_two(Mat one, Mat two, int xx, int yy, double alpha)
{
int	row, col;

	if(alpha < 1.0)
	{
		double beta = (1.0 - alpha);
		for(row = 0;row < two.rows;row++)
		{
			for(col = 0;col < two.cols;col++)
			{
				unsigned char *color1 = one.ptr(row + yy, col + xx);
				unsigned char *color2 = two.ptr(row, col);

				double r1 = (double)color1[0] * beta;
				double g1 = (double)color1[1] * beta;
				double b1 = (double)color1[2] * beta;

				double r2 = (double)color2[0] * alpha;
				double g2 = (double)color2[1] * alpha;
				double b2 = (double)color2[2] * alpha;

				color2[0] = r1 + r2;
				color2[1] = g1 + g2;
				color2[2] = b1 + b2;
			}
		}
	}
}

void	Camera::ColorIt()
{
int	row, col;
int	loop;

	if(color_it_cnt > 0)
	{
		int cnt = 0;
		for(row = 0;row < mat.rows;row++)
		{
			for(col = 0;col < mat.cols;col++)
			{
				unsigned char *colour = mat.ptr(row, col);
				int r = colour[0];
				int g = colour[1];
				int b = colour[2];
				for(loop = 0;loop < color_it_cnt;loop++)
				{
					int diff_r = abs(r - color_it_r[loop]);
					int diff_g = abs(g - color_it_g[loop]);
					int diff_b = abs(b - color_it_b[loop]);
					if((diff_r < color_it_tolerance_r[loop])
					&& (diff_g < color_it_tolerance_g[loop])
					&& (diff_b < color_it_tolerance_b[loop]))
					{
						colour[0] = color_it_replace_r[loop];
						colour[1] = color_it_replace_g[loop];
						colour[2] = color_it_replace_b[loop];
						colour[3] = color_it_replace_a[loop];
						cnt++;
					}
				}
			}
		}
	}
}

int	MyWin::PushToSelectColors(Camera *cam)
{
	int flag = 0;
	if(cam != NULL)
	{
		if(Fl::event_button() == 1)
		{
			if(cam->color_it_cnt < 128)
			{
				int nx = Fl::event_x();
				int ny = Fl::event_y();
				int ii = nx - image_origin_x; 
				int jj = ny - image_origin_y; 
				if((ii > -1) && (ii < cam->width)
				&& (jj > -1) && (jj < cam->height))
				{
					unsigned char *colour = cam->mat.ptr(jj, ii);
					int r = colour[0];
					int g = colour[1];
					int b = colour[2];
					int a = colour[3];
					cam->color_it_r[cam->color_it_cnt] = r;
					cam->color_it_g[cam->color_it_cnt] = g;
					cam->color_it_b[cam->color_it_cnt] = b;
					cam->color_it_cnt++;
					if(color_it_window != NULL)
					{
						color_it_set_all_cb(NULL, color_it_window);
					}
					flag = 1;
				}
			}
		}
		else if(Fl::event_button() == 3)
		{
			if(cam->color_it_cnt > 0)
			{
				cam->color_it_cnt--;
			}
		}
	}
	return(flag);
}

MatrixState::MatrixState()
{
	strcpy(name, "");
	type = -1;
	command = -1;
	current_frame = 0;

	start_x = 0.0;
	start_y = 0.0;
	start_z = 0.0;
	end_x = 0.0;
	end_y = 0.0;
	end_z = 0.0;
	current_x = 0.0;
	current_y = 0.0;
	current_z = 0.0;
	
	node = NULL;
}

MatrixState::~MatrixState()
{
}

void	instrument_cb(Fl_Widget *w, void *v)
{
int	loop;

	InstrumentWindow *iw = (InstrumentWindow *)v;
	if(iw != NULL)
	{
		MyWin *my_win = iw->my_window;
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			for(loop = 0;loop < iw->widget_cnt;loop++)
			{
				double start_x = atof(iw->start_x_in[loop]->value());
				double start_y = atof(iw->start_y_in[loop]->value());
				double start_z = atof(iw->start_z_in[loop]->value());
				double end_x = atof(iw->end_x_in[loop]->value());
				double end_y = atof(iw->end_y_in[loop]->value());
				double end_z = atof(iw->end_z_in[loop]->value());
				int frames = atoi(iw->frames[loop]->value());
				int command = INSTRUMENT_COMMAND_SET;
				if(strcmp(iw->command[loop]->label(), "Set") == 0)
				{
					command = INSTRUMENT_COMMAND_SET;
				}
				else if(strcmp(iw->command[loop]->label(), "Once") == 0)
				{
					command = INSTRUMENT_COMMAND_ONCE;
				}
				else if(strcmp(iw->command[loop]->label(), "Repeat") == 0)
				{
					command = INSTRUMENT_COMMAND_REPEAT;
				}
				else if(strcmp(iw->command[loop]->label(), "Cycle") == 0)
				{
					command = INSTRUMENT_COMMAND_CYCLE;
				}
				int type = 0;

				osg::Node *nd = (osg::Node *)iw->start_x_in[loop]->user_data();
				std:string str = nd->getName();
				char *use = (char *)str.c_str();
				if((strncmp(use, "World Center", strlen("World Center")) == 0)
				|| (strncmp(use, "World Translate", strlen("World Translate")) == 0)
				|| (strncmp(use, "Center ", strlen("Center ")) == 0)
				|| (strncmp(use, "Translate ", strlen("Translate ")) == 0))
				{
					type = MATRIX_STATE_TYPE_TRANSLATE;
				}
				if((strncmp(use, "World Rotate", strlen("World Rotate")) == 0)
				|| (strncmp(use, "Local Rotate", strlen("Local Rotate")) == 0)
				|| (strncmp(use, "Outer Rotate ", strlen("Outer Rotate ")) == 0)
				|| (strncmp(use, "Rotate ", strlen("Rotate ")) == 0))
				{
					type = MATRIX_STATE_TYPE_ROTATE;
				}
				if((strncmp(use, "World Scale", strlen("World Scale")) == 0)
				|| (strncmp(use, "Scale ", strlen("Scale ")) == 0))
				{
					type = MATRIX_STATE_TYPE_SCALE;
				}
				strncpy(cam->matrix_state[loop]->name, use, 256);
				cam->matrix_state[loop]->type = type;
				cam->matrix_state[loop]->start_x = start_x;
				cam->matrix_state[loop]->start_y = start_y;
				cam->matrix_state[loop]->start_z = start_z;
				cam->matrix_state[loop]->current_x = start_x;
				cam->matrix_state[loop]->current_y = start_y;
				cam->matrix_state[loop]->current_z = start_z;
				cam->matrix_state[loop]->end_x = end_x;
				cam->matrix_state[loop]->end_y = end_y;
				cam->matrix_state[loop]->end_z = end_z;
				cam->matrix_state[loop]->command = command;
				cam->matrix_state[loop]->current_frame = 0;
				cam->matrix_state[loop]->frames = frames;
				cam->matrix_state[loop]->node = nd;
			}
		}
	}
}

void	instrument_command_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	if(strcmp(b->label(), "Set") == 0)
	{
		b->label("Once");
	}
	else if(strcmp(b->label(), "Once") == 0)
	{
		b->label("Repeat");
	}
	else if(strcmp(b->label(), "Repeat") == 0)
	{
		b->label("Cycle");
	}
	else if(strcmp(b->label(), "Cycle") == 0)
	{
		b->label("Set");
	}
}

void	InstrumentWindow::PopulateFromCamera()
{
int		loop;
char	buf[256];

	Camera *cam = my_camera;
	for(loop = 0;loop < cam->matrix_state_cnt;loop++)
	{
		sprintf(buf, "%g", cam->matrix_state[loop]->start_x);
		start_x_in[loop]->value(buf);
		sprintf(buf, "%g", cam->matrix_state[loop]->start_y);
		start_y_in[loop]->value(buf);
		sprintf(buf, "%g", cam->matrix_state[loop]->start_z);
		start_z_in[loop]->value(buf);

		sprintf(buf, "%g", cam->matrix_state[loop]->end_x);
		end_x_in[loop]->value(buf);
		sprintf(buf, "%g", cam->matrix_state[loop]->end_y);
		end_y_in[loop]->value(buf);
		sprintf(buf, "%g", cam->matrix_state[loop]->end_z);
		end_z_in[loop]->value(buf);

		if(cam->matrix_state[loop]->command == INSTRUMENT_COMMAND_SET)
		{
			command[loop]->label("Set");
		}
		else if(cam->matrix_state[loop]->command == INSTRUMENT_COMMAND_ONCE)
		{
			command[loop]->label("Once");
		}
		else if(cam->matrix_state[loop]->command == INSTRUMENT_COMMAND_REPEAT)
		{
			command[loop]->label("Repeat");
		}
		else if(cam->matrix_state[loop]->command == INSTRUMENT_COMMAND_CYCLE)
		{
			command[loop]->label("Cycle");
		}
		sprintf(buf, "%d", cam->matrix_state[loop]->frames);
		frames[loop]->value(buf);
	}
}

InstrumentWindow::InstrumentWindow(MyWin *in_win, Camera *in_cam, int ww, int hh) : Fl_Window(ww, hh, "Instruments")
{
int	loop;

	my_window = in_win;
	my_camera = in_cam;
	if(my_camera != NULL)
	{
		Camera *cam = my_camera;
		if(cam->type == CAMERA_TYPE_OSG)
		{
			color(FL_BLACK);
			node_cnt = 0;
			for(loop = 0;loop < 128;loop++)
			{
				node[loop] = NULL;
				start_x_in[loop] = NULL;
				start_y_in[loop] = NULL;
				start_z_in[loop] = NULL;
				end_x_in[loop] = NULL;
				end_y_in[loop] = NULL;
				end_z_in[loop] = NULL;

				cam->matrix_state[loop] = NULL;
			}
			Populate();

			go_button = new Fl_Button(10, 10, 60, 22, "Go");
			go_button->box(FL_FLAT_BOX);
			go_button->labelcolor(FL_YELLOW);
			go_button->labelsize(14);
			go_button->color(FL_BLACK);
			go_button->callback(instrument_cb, this);

			int x_pos = 230;
			int y_pos = 20;
			int cnt = 0;

			Fl_Box *label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Start X");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(FL_BLACK);
			label_box->labelcolor(FL_WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Start Y");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(FL_BLACK);
			label_box->labelcolor(FL_WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Start Z");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(FL_BLACK);
			label_box->labelcolor(FL_WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 72;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Command");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(FL_BLACK);
			label_box->labelcolor(FL_WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "Frames");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(FL_BLACK);
			label_box->labelcolor(FL_WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 72;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "End X");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(FL_BLACK);
			label_box->labelcolor(FL_WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "End Y");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(FL_BLACK);
			label_box->labelcolor(FL_WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			x_pos += 62;
			label_box = new Fl_Box(x_pos, y_pos, 60, 20, "End Z");
			label_box->box(FL_FLAT_BOX);
			label_box->labelsize(9);
			label_box->color(FL_BLACK);
			label_box->labelcolor(FL_WHITE);
			label_box->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

			y_pos = 40;
			for(loop = 0;loop < node_cnt;loop++)
			{
				std:string str = node[loop]->getName();
				char *use = strdup((char *)str.c_str());
				if((strncmp(use, "World Center", strlen("World Center")) == 0)
				|| (strncmp(use, "World Translate", strlen("World Translate")) == 0)
				|| (strncmp(use, "Center ", strlen("Center ")) == 0)
				|| (strncmp(use, "Translate ", strlen("Translate ")) == 0)
				|| (strncmp(use, "World Rotate", strlen("World Rotate")) == 0)
				|| (strncmp(use, "Local Rotate", strlen("Local Rotate")) == 0)
				|| (strncmp(use, "Outer Rotate ", strlen("Outer Rotate ")) == 0)
				|| (strncmp(use, "Rotate ", strlen("Rotate ")) == 0)
				|| (strncmp(use, "World Scale", strlen("World Scale")) == 0)
				|| (strncmp(use, "Scale ", strlen("Scale ")) == 0))
				{
					Fl_Box *node_box = new Fl_Box(10, y_pos, 200, 20, use);
					node_box->box(FL_FLAT_BOX);
					node_box->color(FL_BLACK);
					node_box->labelcolor(FL_WHITE);
					node_box->labelsize(11);
					node_box->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);

					int x_pos = 230;
					start_x_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					start_x_in[cnt]->user_data(node[loop]);
					x_pos += 62;
					start_y_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					start_y_in[cnt]->user_data(node[loop]);
					x_pos += 62;
					start_z_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					start_z_in[cnt]->user_data(node[loop]);
					x_pos += 72;

					command[cnt] = new Fl_Button(x_pos, y_pos, 60, 18, "Set");
					command[cnt]->box(FL_FLAT_BOX);
					command[cnt]->labelcolor(FL_YELLOW);
					command[cnt]->labelsize(9);
					command[cnt]->color(FL_BLACK);
					command[cnt]->callback(instrument_command_cb, this);
					x_pos += 62;
					frames[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					x_pos += 72;

					end_x_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					end_x_in[cnt]->user_data(node[loop]);
					x_pos += 62;
					end_y_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					end_y_in[cnt]->user_data(node[loop]);
					x_pos += 62;
					end_z_in[cnt] = new MyFloatInput(x_pos, y_pos, 60, 18, "");
					end_z_in[cnt]->user_data(node[loop]);
					if((strncmp(use, "World Scale", strlen("World Scale")) == 0)
					|| (strncmp(use, "Scale ", strlen("Scale ")) == 0))
					{
						start_x_in[cnt]->value("1.0");
						start_y_in[cnt]->value("1.0");
						start_z_in[cnt]->value("1.0");
						end_x_in[cnt]->value("1.0");
						end_y_in[cnt]->value("1.0");
						end_z_in[cnt]->value("1.0");
					}
					if(strncmp(use, "World Scale", strlen("World Scale")) == 0)
					{
						y_pos += 31;
					}
					else
					{
						y_pos += 21;
					}
					cam->matrix_state[cnt] = new MatrixState();
					cam->matrix_state_cnt = cnt;
					cnt++;
				}
			}
			widget_cnt = cnt;
			resize(x(), y(), 800, y_pos + 20);
		}
	}
	end();
}

InstrumentWindow::~InstrumentWindow()
{
}

void	InstrumentWindow::Populate()
{
int	walk_tree(osg::Group *start, int limit, int total, osg::Node **list);
int	loop;

	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(cam->type == CAMERA_TYPE_OSG)
		{
			osg::Group *root = (osg::Group *)cam->osg_viewer->getSceneData();
			int	total = walk_tree(root, 128, 0, node);
			for(loop = 0;loop < total;loop++)
			{
				std:string str = node[loop]->getName();
				printf("%d: [%s]\n", loop, str.c_str());
			}
			node_cnt = total;
		}
	}
}

MiscCopy::MiscCopy(Camera *in_source, int in_type, Mat local, int immediate_display, char *in_str, int in_xx, int in_yy, int in_ww, int in_hh)
{
int	loop;

	mat = local.clone();
	xx = in_xx;
	yy = in_yy;
	ww = in_ww;
	hh = in_hh;
	source = in_source;
	for(loop = 0;loop < 128;loop++)
	{
		destination[loop] = NULL;
		dest_x[loop] = -1;
		dest_y[loop] = -1;
		dest_display[loop] = 0;
	}
	destination_cnt = 0;
	type = in_type;
	display = immediate_display;
	aux_str = NULL;
	if(in_str != NULL)
	{
		aux_str = strdup(in_str);
	}
	quick_text = NULL;
	if(in_type == MISC_COPY_TEXT)
	{
		int ux = xx + in_source->image_sx;
		int uy = yy + in_source->image_sy;
		quick_text = new QuickText(in_source, aux_str, ux, uy, ww, hh);
		in_source->my_window->add(quick_text);
	}
}

MiscCopy::~MiscCopy()
{
	if(quick_text != NULL)
	{
		quick_text->hide();
		delete quick_text;
	}
	if(aux_str != NULL)
	{
		free(aux_str);
	}
}

int	MyWin::AddMiscCopy(Camera *in_source, int in_type, Mat local, int immediate_display, char *str, int xx, int yy, int ww, int hh, int rr, int gg, int bb, int aa)
{
	int r = 0;
	misc_copy = (MiscCopy **)realloc(misc_copy, sizeof(MiscCopy *) * (misc_copy_cnt + 1));
	if(misc_copy != NULL)
	{
		misc_copy[misc_copy_cnt] = new MiscCopy(in_source, in_type, local, immediate_display, str, xx, yy, ww, hh);
		if((rr > -1) && (gg > -1) && (bb > -1) && (aa > -1))
		{
			misc_copy[misc_copy_cnt]->red = rr;
			misc_copy[misc_copy_cnt]->green = gg;
			misc_copy[misc_copy_cnt]->blue = bb;
			misc_copy[misc_copy_cnt]->alpha = aa;
		}
		r = misc_copy_cnt;
	}
	misc_copy_cnt++;
	return(r);
}

void	MyWin::MiscPaste(int in_x, int in_y)
{
int	loop;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < misc_copy_cnt;loop++)
		{
			if(misc_copy[loop] != NULL)
			{
				misc_copy[loop]->display = 1;
				if(misc_copy[loop]->destination_cnt < 128)
				{
					int d_cnt = misc_copy[loop]->destination_cnt;
					if((in_x > -1) && (in_y > -1))
					{
						misc_copy[loop]->dest_x[d_cnt] = in_x;
						misc_copy[loop]->dest_y[d_cnt] = in_y;
					}
					else
					{
						misc_copy[loop]->dest_x[d_cnt] = misc_copy[loop]->xx;
						misc_copy[loop]->dest_y[d_cnt] = misc_copy[loop]->yy;
					}
					misc_copy[loop]->destination[d_cnt] = cam;
					misc_copy[loop]->dest_display[d_cnt] = 1;
					misc_copy[loop]->destination_cnt++;
				}
			}
		}
	}
}

void	rubber_band_popup_cb(Fl_Widget *w, void *v)
{
int	loop;

	int retain_selection = 0;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		int ux = 0;
		int uy = 0;
		if(win->popup != NULL)
		{
			ux = win->popup->x();
			uy = win->popup->y();
			win->popup->hide();
		}
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			int xx = win->rubber_band_x;
			int yy = win->rubber_band_y;
			int ww = win->rubber_band_w;
			int hh = win->rubber_band_h;
			win->rubber_band_x = -1; 
			win->rubber_band_y = -1;
			win->rubber_band_w = -1;
			win->rubber_band_h = -1;
			Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
			char *str = (char *)browser->text(browser->value());
			if(str != NULL)
			{
				if(strcmp(str, "Dynamic Copy") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->CropFrame(cam->mat, &local, use_x, use_y, ww, hh);
					win->AddMiscCopy(cam, MISC_COPY_DYNAMIC, local, 0, NULL, use_x, use_y, ww, hh);
					cam->priority = 1;
				}
				else if(strcmp(str, "Static Copy") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->CropFrame(cam->mat, &local, use_x, use_y, ww, hh);
					win->AddMiscCopy(cam, MISC_COPY_STATIC, local, 0, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Copy to Clipboard") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->CropFrame(cam->mat, &local, use_x, use_y, ww, hh);

					Fl_Copy_Surface *copy_surf = new Fl_Copy_Surface(ww, hh);
					Fl_Surface_Device::push_current(copy_surf);
					fl_color(FL_WHITE);
					fl_rectf(0, 0, ww, hh);

					Mat local_mat;
					cvtColor(local, local_mat, COLOR_RGBA2RGB);
					fl_draw_image(local_mat.ptr(), 0, 0, ww, hh, 3);
					Fl_Surface_Device::pop_current();
					delete copy_surf;
				}
				else if(strcmp(str, "Source Camera") == 0)
				{
					char text[8192];
					char alias[8192];
					sprintf(text, "sourced://%s", cam->path);
					sprintf(alias, "Copy of %s", cam->path);
					int nw = cam->requested_x;
					int nh = cam->requested_y;
					int cam_n = win->SetupCamera(text, alias, nw, nh, 32, "Sans", 0, 0, 0, 0, 255, 255, 255, 255, 0);
					if(cam_n > -1)
					{
						win->Display(cam_n);
						Camera *result = win->DisplayedCamera();
						result->requested_x = xx - cam->image_sx;
						result->requested_y = yy - cam->image_sy;
						result->requested_w = ww;
						result->requested_h = hh;
						while(win->displayed_source >= (win->start_thumbgroup + DISPLAYED_THUMB_CNT))
						{
							win->start_thumbgroup++;
						}
						win->UpdateThumbButtons();
					}
				}
				else if(strcmp(str, "Cut Out") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_MASK, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Fill") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;

					int rr = 128;
					int gg = 128;
					int bb = 128;
					int aa = 255;
					ColorDialog *cd = new ColorDialog(win, 420, 125);
					cd->show();
					while(cd->visible())
					{
						rr = cd->red->value();
						gg = cd->green->value();
						bb = cd->blue->value();
						aa = cd->alpha->value();
						Fl::check();
					}
					win->AddMiscCopy(cam, MISC_COPY_FILL, local, 1, NULL, use_x, use_y, ww, hh, rr, gg, bb, aa);
				}
				else if(strcmp(str, "Crop") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_CROP, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Paste") == 0)
				{
					win->MiscPaste();
				}
				else if(strcmp(str, "Paste from Clipboard") == 0)
				{
					Fl::paste(*win, 1, Fl::clipboard_image);
				}
				else if(strcmp(str, "Clear Copy Buffer") == 0)
				{
					for(loop = 0;loop < win->misc_copy_cnt;loop++)
					{
						if(win->misc_copy[loop]->source != NULL)
						{
							win->misc_copy[loop]->source->priority = 0;
						}
						delete win->misc_copy[loop];
						win->misc_copy[loop] = NULL;
					}
					free(win->misc_copy);
					win->misc_copy = NULL;
					win->misc_copy_cnt = 0;
				}
				else if(strcmp(str, "Rubberband Mode") == 0)
				{
					win->rubberband_mode = 1;
				}
				else if(strcmp(str, "Scroll Mode") == 0)
				{
					win->rubberband_mode = 0;
				}
				else if(strcmp(str, "Move") == 0)
				{
					win->editing_misc_mode = EDITING_MISC_MOVE;
				}
				else if(strcmp(str, "Save") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->CropFrame(cam->mat, &local, use_x, use_y, ww, hh);
					cvtColor(local, local, COLOR_RGBA2BGRA);

					Fl_Native_File_Chooser nfc;
					nfc.title("Image File");
					nfc.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);
					int nn = nfc.show();
					if((nn != -1) && (nn != 1))
					{
						char *fn = (char *)nfc.filename();
						cv::imwrite(fn, local);
					}
				}
				else if(strcmp(str, "Load") == 0)
				{
					int use_x = ux - cam->image_sx;
					int use_y = uy - cam->image_sy;
					Fl_Native_File_Chooser nfc;
					nfc.title("Select an image file");
					nfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
					int nn = nfc.show();
					if((nn != -1) && (nn != 1))
					{
						char *fn = (char *)nfc.filename();
						if(fn != NULL)
						{
							if(strlen(fn) > 0)
							{
								Mat local_mat = imread(fn, IMREAD_UNCHANGED);
								if(!local_mat.empty())
								{
									if(local_mat.channels() == 3)
									{
										cvtColor(local_mat, local_mat, COLOR_BGR2RGBA);
									}
									else
									{
										cvtColor(local_mat, local_mat, COLOR_BGRA2RGBA);
									}
									int rr = win->AddMiscCopy(cam, MISC_COPY_STATIC, local_mat, 0, NULL, use_x, use_y, local_mat.cols, local_mat.rows);
									if(rr > -1)
									{
										win->MiscPaste();
									}
								}
							}
						}
					}
				}
				else if(strcmp(str, "Remove") == 0)
				{
					if(win->editing_misc_outer > -1)
					{
						if(win->misc_copy[win->editing_misc_outer] != NULL)
						{
							if(win->editing_misc_inner == -1)
							{
								free(win->misc_copy[win->editing_misc_outer]);
								win->misc_copy[win->editing_misc_outer] = NULL;
							}
							else if(win->editing_misc_inner > -1)
							{
								win->misc_copy[win->editing_misc_outer]->destination[win->editing_misc_inner] = NULL;
								win->misc_copy[win->editing_misc_outer]->dest_x[win->editing_misc_inner] = -1;
								win->misc_copy[win->editing_misc_outer]->dest_y[win->editing_misc_inner] = -1;
								win->misc_copy[win->editing_misc_outer]->dest_display[win->editing_misc_inner] = 0;
							}
						}
					}
				}
				else if(strcmp(str, "Remove All") == 0)
				{
					win->MiscRemoveAll();
				}
				else if(strcmp(str, "Rectangle") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_RECTANGLE, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Magnify") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_MAGNIFY, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Border") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_BORDER, local, 1, NULL, use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Text") == 0)
				{
					Mat local;
					int use_x = xx - cam->image_sx;
					int use_y = yy - cam->image_sy;
					win->AddMiscCopy(cam, MISC_COPY_TEXT, local, 1, "Sample Text", use_x, use_y, ww, hh);
				}
				else if(strcmp(str, "Resize") == 0)
				{
					win->editing_misc_mode = EDITING_MISC_RESIZE;
				}
				else if(strcmp(str, "Select All") == 0)
				{
					win->rubber_band_x = cam->image_sx;
					win->rubber_band_y = cam->image_sy;
					win->rubber_band_w = cam->width;
					win->rubber_band_h = cam->height;
					retain_selection = 1;
				}
				else if(strcmp(str, "Edit Text") == 0)
				{
					if(win->editing_misc_outer > -1)
					{
						if(win->misc_copy[win->editing_misc_outer] != NULL)
						{
							MiscCopy *misc = win->misc_copy[win->editing_misc_outer];
							TextEditWindow *text_edit_window = new TextEditWindow(win, cam, misc);
							text_edit_window->show();
						}
					}
				}
			}
		}
	}
	if(retain_selection == 0)
	{
		win->rubber_band_x = -1;
		win->rubber_band_y = -1;
		win->rubber_band_w = -1;
		win->rubber_band_h = -1;
	}
}

int	MyWin::HandleMenuPopup(int xx, int yy)
{
	int flag = 0;
	if(ImageWindowHit(last_push_x, last_push_y) == -1)
	{
		if(rubberband_mode == 1)
		{
			if((rubber_band_x > -1)
			|| (rubber_band_y > -1)
			|| (rubber_band_w > -1)
			|| (rubber_band_h > -1))
			{
				if(Fl::event_button() == FL_LEFT_MOUSE)
				{
					rubber_band_x = -1; 
					rubber_band_y = -1;
					rubber_band_w = -1;
					rubber_band_h = -1;
				}
				else if(Fl::event_button() == FL_RIGHT_MOUSE)
				{
					Camera *cam = DisplayedCamera();
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					if((xx > cam->image_sx) && (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width) && (yy < cam->image_sy + cam->height))
					{
						if(popup != NULL)
						{
							Fl::delete_widget(popup);
						}
						popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 100, 60);
						popup->browser->callback(rubber_band_popup_cb, this);
						popup->browser->clear();
						popup->browser->add("Dynamic Copy");
						popup->browser->add("Static Copy");
						popup->browser->add("Copy to Clipboard");
						popup->browser->add("Source Camera");
						popup->browser->add("Select All");
						popup->browser->add("Cut Out");
						popup->browser->add("Fill");
						popup->browser->add("Crop");
						popup->browser->add("Text");
						popup->browser->add("Rectangle");
						popup->browser->add("Magnify");
						popup->browser->add("Border");
						popup->browser->add("Save");
						popup->browser->add("Scroll Mode");
						popup->set_non_modal();
						popup->Fit();
						popup->show();
						flag = 1;
					}
				}
			}
			else
			{
				if(Fl::event_button() == FL_RIGHT_MOUSE)
				{
					Camera *cam = DisplayedCamera();
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					if((xx > cam->image_sx) && (yy > cam->image_sy)
					&& (xx < cam->image_sx + cam->width) && (yy < cam->image_sy + cam->height))
					{
						editing_misc_outer = -1;
						editing_misc_inner = -1;
						int	hit = InMiscPasted(last_push_x, last_push_y, editing_misc_outer, editing_misc_inner);
						if(popup != NULL)
						{
							Fl::delete_widget(popup);
						}
						popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 120, 40);
						popup->browser->callback(rubber_band_popup_cb, this);
						popup->browser->clear();
						if(misc_copy_cnt > 0)
						{
							if(hit == 0)
							{
								popup->browser->add("Paste");
								popup->browser->add("Clear Copy Buffer");
							}
							else
							{
								if(editing_misc_outer > -1)
								{
									if(misc_copy[editing_misc_outer]->type == MISC_COPY_TEXT)
									{
										popup->browser->add("Edit Text");
									}
								}
								popup->browser->add("Move");
								popup->browser->add("Remove");
								popup->browser->add("Remove All");
								popup->browser->add("Resize");
							}
						}
						if(Fl::clipboard_contains(Fl::clipboard_image)) 
						{
							popup->browser->add("Paste from Clipboard");
						}
						popup->browser->add("Load");
						popup->browser->add("Select All");
						popup->browser->add("Scroll Mode");
						popup->set_non_modal();
						popup->Fit();
						popup->show();
						flag = 1;
					}
				}
			}
		}
		else
		{
			if(Fl::event_button() == FL_RIGHT_MOUSE)
			{
				Camera *cam = DisplayedCamera();
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if((xx > cam->image_sx) && (yy > cam->image_sy)
				&& (xx < cam->image_sx + cam->width) && (yy < cam->image_sy + cam->height))
				{
					if(popup != NULL)
					{
						Fl::delete_widget(popup);
					}
					popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 100, 20);
					popup->browser->callback(rubber_band_popup_cb, this);
					popup->browser->clear();
					if(Fl::clipboard_contains(Fl::clipboard_image)) 
					{
						popup->browser->add("Paste from Clipboard");
					}
					popup->browser->add("Load");
					popup->browser->add("Rubberband Mode");
					popup->set_non_modal();
					popup->Fit();
					popup->show();
					flag = 1;
				}
			}
		}
	}
	return(flag);
}

int	MyWin::ShapeHandleEvent(int event)
{
int	loop;

	int flag = 0;
	int xx = Fl::event_x();
	int yy = Fl::event_y();
	for(loop = 0;loop < shape_cnt;loop++)
	{
		if(shape[loop] != NULL)
		{
			if(Fl::event_inside(shape[loop]))
			{
				flag = 1;
			}
		}
	}
	return(flag);
}

int	MyWin::handle(int event)
{
int		loop;
static int	last_resize_drag_x = -1;
static int	last_resize_drag_y = -1;
static int 	stat_me = 0;

	int flag = 0;
	Camera *cam = camera[displayed_source];
	if((cam != NULL) && (actively_loading == 0))
	{
		int shape_got_it = ShapeHandleEvent(event);
		if(shape_got_it == 0)
		{
			if(void_handle_events != NULL)
			{
				int (*handle_events)(Fl_Window *, int);
				handle_events = (int (*)(Fl_Window *, int))void_handle_events;
				flag = handle_events(this, event);
			}
			if(flag == 0)
			{
				switch(event)
				{
					case(FL_FOCUS):
					case(FL_UNFOCUS):
					{
						flag = 1;
					}
					break;
					case(FL_PASTE):
					{
						if(strcmp(Fl::event_clipboard_type(), Fl::clipboard_image) == 0) 
						{
							if(clipboard_changed == 1)
							{
								Fl_RGB_Image *im = (Fl_RGB_Image*)Fl::event_clipboard();
								if(im != NULL)
								{
									Mat local;
									unsigned char *ptr = (unsigned char *)im->data()[0];
									int use_x = Fl::event_x() - cam->image_sx;
									int use_y = Fl::event_y() - cam->image_sy;
									int ww = im->w();
									int hh = im->h();
									if((ww > 0) && (hh > 0) && (ptr != NULL))
									{
										Mat use;
										if(im->d() == 3)
										{
											Mat local(hh, ww, CV_8UC3, (void *)ptr);
											cvtColor(local, local, COLOR_RGB2RGBA);
											use = local.clone();
										}
										else if(im->d() == 4)
										{
											Mat local(hh, ww, CV_8UC4, (void *)ptr);
											use = local.clone();
										}
										int rr = AddMiscCopy(cam, MISC_COPY_STATIC, use, 0, NULL, use_x, use_y, ww, hh);
										if(rr > -1)
										{
											MiscPaste();
										}
									}
									delete im;
									clipboard_changed = 0;
									flag = 1;
								}
							}
							else
							{
								int use_x = Fl::event_x() - cam->image_sx;
								int use_y = Fl::event_y() - cam->image_sy;
								MiscPaste(use_x, use_y);
							}
						}
					}
					break;
					case(FL_KEYBOARD):
					{
						int key = Fl::event_key();
						flag = HandleKeyboard(event, cam);
					}
					break;
					case(FL_PUSH):
					{
						last_push_x = Fl::event_x();
						last_push_y = Fl::event_y();
						if(split == 1)
						{
							flag = HandlePushForSplit();
						}
						else
						{
							flag = HandleMenuPopup(last_push_x, last_push_y);
							int newly_selected = 0;
							if(im_drawing_mode == 1)
							{
								newly_selected = HandlePushToSelectImmediate(cam);
							}
							if((immediate_drawing_window->visible()) && (newly_selected == 0))
							{
								flag = HandlePushToEditImmediate(cam);
							}
							else if(newly_selected == 1)
							{
								newly_selected = 0;
								ImmediateNewlySelectedHighlight();
							}
							else if((mark_interest == 1) && (!button_group->visible()))
							{
								flag = DoMarkInterest();
							}
							else if(cam->type == CAMERA_TYPE_AV)
							{
								if(progress_scrubber != NULL)
								{
									flag = progress_scrubber->Handle(event);
								}
							}
							else if((resizing_detail == 1) || (zoom_boxing == 1))
							{
								drag_start_x = Fl::event_x();
								drag_start_y = Fl::event_y();
								flag = 1;
							}
							else if(cam->zoom > 1.0)
							{
								start_offset_x = Fl::event_x();
								start_offset_y = Fl::event_y();
							}
							else if(restore_corner == 1)
							{
								cam->display_width = cam->width;
								cam->display_height = cam->height;
							}
							else if(selecting_colors == 1)
							{
								flag = PushToSelectColors(cam);
							}
							else if((ptz_window != NULL) && (ptz_mode == 1) && (move_corner == 0) && (resize_corner == 0) && (restore_corner == 0))
							{
								flag = HandlePushForPTZ(cam);
							}
						}
					}
					break;
					case(FL_RELEASE):
					{
						if(im_drawing_mode == 1)
						{
							if(Fl::event_button() == FL_LEFT_MOUSE)
							{
								flag = MyWin::HandleReleaseForImmediate(cam);
							}
						}
						else if(selecting_colors != 1)
						{
							if(cam->type == CAMERA_TYPE_AV)
							{
								if(progress_scrubber != NULL)
								{
									flag = progress_scrubber->Handle(event);
								}
							}
							else if(ptz_mode == 0)
							{
								flag = HandleRelease(cam);
							}
							else if(rubberband_mode == 0)
							{
								flag = HandleReleaseForPTZ(cam);
							}
							last_resize_drag_x = -1;
							last_resize_drag_y = -1;
							editing_misc_mode = -1;
						}
						else
						{
							flag = 1;
						}
					}
					break;
					case(FL_MOVE):
					{
						flag = HandleMove(cam);
					}
					break;
					case(FL_DRAG):
					{
						if((crop_scaling == 1)
						&& (cam->orig_width > output_width)
						&& (cam->orig_height > output_height)
						&& (rubberband_mode == 0)
						&& (im_drawing_mode == 0))
						{
							int diff_x = last_push_x - Fl::event_x();
							int diff_y = last_push_y - Fl::event_y();
							cam->crop_start_x += diff_x;
							if(cam->crop_start_x < 0) cam->crop_start_x = 0;
							cam->crop_start_y += diff_y;
							if(cam->crop_start_y < 0) cam->crop_start_y = 0;
							last_push_x = Fl::event_x();
							last_push_y = Fl::event_y();
						}
						else if((crop_scaling == 1)
						&& (cam->orig_width < output_width)
						&& (cam->orig_height < output_height)
						&& (rubberband_mode == 0)
						&& (im_drawing_mode == 0))
						{
							if(cam->use_crop_start == 0)
							{
								cam->crop_start_x = cam->last_start_x;
								cam->crop_start_y = cam->last_start_y;
							}
							int diff_x = last_push_x - Fl::event_x();
							int diff_y = last_push_y - Fl::event_y();
							cam->crop_start_x -= diff_x;
							if(cam->crop_start_x < 0) cam->crop_start_x = 0;
							cam->crop_start_y -= diff_y;
							if(cam->crop_start_y < 0) cam->crop_start_y = 0;
							last_push_x = Fl::event_x();
							last_push_y = Fl::event_y();
							cam->use_crop_start = 1;
						}
						else
						{
							if(rubberband_mode == 0)
							{
								cam->crop_start_x = 0;
								cam->crop_start_y = 0;
								cam->use_crop_start = 0;
							}
							if(cam->type == CAMERA_TYPE_AV)
							{
								if(progress_scrubber != NULL)
								{
									flag = progress_scrubber->Handle(event);
								}
							}
							else if(im_drawing_mode == 1)
							{
								flag = HandleImmediateDrag(cam);
							}
							else if((resizing_detail == 0) && (zoom_boxing == 0))
							{
								if(ptz_joystick == 1)
								{
									flag = HandlePTZDrag();
								}
								else
								{
									flag = HandleDrag(cam);
								}
							}
						}
					}
					break;
					case(FL_MOUSEWHEEL):
					{
						if(split == 0)
						{
							if(cam->type == CAMERA_TYPE_AV)
							{
								if(progress_scrubber != NULL)
								{
									flag = progress_scrubber->Handle(event);
								}
							}
							else if(cam->type == CAMERA_TYPE_EDGE_DETECT)
							{
								int direction = Fl::event_dy();
								if(direction > 0)
								{
									cam->edge_blend += 0.01;
									if(cam->edge_blend > 1.0)
									{
										cam->edge_blend = 1.0;
									}
								}
								else
								{
									cam->edge_blend -= 0.01;
									if(cam->edge_blend < 0.0)
									{
										cam->edge_blend = 0.0;
									}
								}
							}
							else if(use_mousewheel == 1)
							{
								if((ptz_middle_mouse > 0) && (ptz_mode == 1))
								{
									flag = HandleMousewheelPTZ(cam);
								}
								else if(crop_scaling == 1)
								{
									int direction = Fl::event_dy();
									if(direction > 0)
									{
										cam->capture_scaling += 0.1;
										if(cam->capture_scaling > 4.0)
										{
											cam->capture_scaling = 4.0;
										}
									}
									else
									{
										cam->capture_scaling -= 0.1;
										if(cam->capture_scaling < 0.1)
										{
											cam->capture_scaling = 0.1;
										}
									}
									flag = 1;
								}
								else if(resize_capture == 1)
								{
									flag = HandleMousewheelResizeCapture(cam);
								}
								else
								{
									flag = HandleMousewheel(cam);
								}
							}
						}
					}
					break;
				}
			}
		}
	}
	else
	{
		if(event == FL_MOVE)
		{
			int xx = Fl::event_x();
			int yy = Fl::event_y();
			ShowButtonPanel(xx);
			ShowPTZ(NULL, xx, yy);
			ShowAudio(xx, yy);
		}
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

void	MyWin::ShowButtonPanel(int xx)
{
	int edge = 200;
	if((mark_interest == 1) && (!button_group->visible()))
	{
		edge = 60;
	}
	if(xx > w() - edge)
	{
		if(buttons_shown == 0)
		{
			ShowButtons();
			button_group->resize(w() - button_group->w(), button_group->y(), button_group->w(), button_group->h());
			button_group->show();
			buttons_shown = 1;
		}
	}
	else
	{
		if(buttons_shown == 1)
		{
			button_group->hide();
			buttons_shown = 0;
		}
	}
}

void	review_win_play_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	ReviewWin *win = (ReviewWin *)v;
	if(win->playing == 0)
	{
		b->label("@||");
		win->encode->deactivate();
		win->playing = 1;
		win->start_time = time(0);
		Fl::repeat_timeout(win->delay, review_win_cb, win);
	}
	else
	{
		b->label("@>");
		win->playing = 0;
		win->encode->activate();
		win->frames_shown = 0;
	}
}

void	review_win_play_trimmed_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	ReviewWin *win = (ReviewWin *)v;
	if(win->playing == 0)
	{
		b->label("@||");
		win->encode->deactivate();
		win->playing = 1;
		win->playing_trimmed = 1;
		win->start_time = time(0);
		Fl::repeat_timeout(win->delay, review_win_cb, win);
	}
	else
	{
		b->label("@->");
		win->playing = 0;
		win->playing_trimmed = 0;
		win->encode->activate();
		win->frames_shown = 0;
	}
}

void	review_win_encode_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	ReviewWin *win = (ReviewWin *)v;
	if(win->playing == 0)
	{
		if(win->my_win != NULL)
		{
			if((win->my_win->encoding == 0) && (win->encoding == 0))
			{
				win->encoding = 1;
				win->my_win->Encode();
				win->encoding = 0;
			}
		}
	}
}

void	MyWin::RemoveSource(int src)
{
int	loop;

	if(source_cnt > 1)
	{
		if((src > -1) && (src < source_cnt))
		{
			if(camera[src] != NULL)
			{
				Display(0);
				current_source = 0;
				delete camera[src];
				camera[src] = NULL;
				for(loop = src;loop < 127;loop++)
				{
					camera[loop] = camera[loop + 1];
				}
				source_cnt--;
				UpdateThumbButtons();
			}
		}
	}
}

void	scrub_cb(void *w, void *v)
{
	MyScrubber *scrub = (MyScrubber *)w;
	ReviewWin *win = (ReviewWin *)v;
	int nn = scrub->Value();
	win->ScrubTo(nn);
}

void	speed_cb(Fl_Widget *w, void *v)
{
	Fl_Value_Slider *slider = (Fl_Value_Slider *)w;
	ReviewWin *win = (ReviewWin *)v;
	double val = slider->value();
	win->speed = val;
}

void	review_win_start_trim_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	ReviewWin *win = (ReviewWin *)v;

	int ok = win->scrub->CheckTrim(-1, win->current_frame);
	if(ok == 1)
	{
		win->scrub->AddTrim(win->current_frame, win->current_frame);
		win->end_trim_button->activate();
		win->start_trim_button->deactivate();
		win->encode->deactivate();
	}
	win->clear_trim_button->show();
	win->redraw();
}

void	review_win_end_trim_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	ReviewWin *win = (ReviewWin *)v;

	int ok = win->scrub->CheckTrim(-1, win->current_frame);
	if(ok == 1)
	{
		win->scrub->SetEndTrim(win->current_frame);
		win->end_trim_button->deactivate();
		win->start_trim_button->activate();
		win->encode->activate();
	}
	win->play_trim->show();
	win->clear_trim_button->show();
	win->redraw();
}

void	review_win_clear_trim_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	ReviewWin *win = (ReviewWin *)v;

	win->scrub->ClearTrims();

	win->end_trim_button->deactivate();
	win->start_trim_button->activate();
	win->clear_trim_button->hide();
	win->play_trim->hide();
	win->redraw();
}

void	review_win_advance_one_cb(Fl_Widget *w, void *v)
{
	ReviewWin *win = (ReviewWin *)v;
	if(win->current_frame < (win->frame_cnt - 1))
	{
		win->single_frame = 1;
		win->playing = 1;
		win->current_frame++;
		win->redraw();
	}
}

void	review_win_retreat_one_cb(Fl_Widget *w, void *v)
{
	ReviewWin *win = (ReviewWin *)v;
	if(win->current_frame > 0)
	{
		win->single_frame = 1;
		win->playing = 1;
		win->current_frame--;
		win->redraw();
	}
}

void	review_win_snap_one_cb(Fl_Widget *w, void *v)
{
char		filename[256];
struct tm	*tm;

	ReviewWin *win = (ReviewWin *)v;
	if(win->current_frame > 0)
	{
		win->single_frame = 1;
		win->playing = 1;
		win->redraw();
		
		time_t t_num = time(0);
		tm = localtime((const time_t *)&t_num);
		if(tm != NULL)
		{
		 	sprintf(filename, "photo_%04d_%02d_%02d_%02d_%02d_%02d.png", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
			Mat src = Mat(win->h(), win->w(), CV_8UC3, win->frame);
			cvtColor(src, src, COLOR_RGB2BGR);
			imwrite(filename, src);
		}
	}
}

void	add_text_cb(Fl_Widget *w, void *v)
{
	ReviewWin *win = (ReviewWin *)v;
	if(win->add_text == 0)
	{
		win->add_text = 1;
		win->add_text_button->color(FL_WHITE);
		win->add_text_button->labelcolor(FL_BLACK);
	}
	else
	{
		win->add_text = 0;
		win->add_text_button->color(FL_BLACK);
		win->add_text_button->labelcolor(FL_WHITE);
	}
}

void	moving_crop_cb(Fl_Widget *w, void *v)
{
	ReviewWin *win = (ReviewWin *)v;
	if(win->crop_activated == 0)
	{
		win->InitCrop();
		win->crop_activated = 1;
	}
	else
	{
		win->crop_activated = 0;
	}
	win->redraw();
}

void	ReviewWin::InitCrop()
{
int	loop;

	if(crop_x != NULL)
	{
		free(crop_x);
	}
	crop_x = (int *)malloc(frame_cnt * sizeof(int));
	if(crop_y != NULL)
	{
		free(crop_y);
	}
	crop_y = (int *)malloc(frame_cnt * sizeof(int));
	for(loop = 0;loop < frame_cnt;loop++)
	{
		crop_x[loop] = (w() / 2) - 320;
		crop_y[loop] = (h() / 2) - 240;
	}
}

void	close_review_window(Fl_Widget *w, void *v)
{
	ReviewWin *rw = (ReviewWin *)w;
	if(rw != NULL)
	{
		if(rw->my_win->encoding == 0)
		{
			Fl::remove_timeout(review_win_cb);
			rw->hide();
			Fl::delete_widget(rw);
		}
	}
}

void	MyWin::DumpDirectRecording(char *in_filename, char *out_filename)
{
	Camera *cam = camera[displayed_source];
	dump_type = "Extracting Video";
	dumped_frames = 0;
	dumped_limit = -1;
	if(access(last_used_filename, 0) == 0)
	{
		VideoCapture local_cap(in_filename);
		if(local_cap.isOpened())
		{
			int fd = -1;
			int ww = 0;
			int hh = 0;
			int done = 0;
			int bad_cnt = 0;
			while(done == 0)
			{
				Mat frame;
				local_cap >> frame;
				if(!frame.empty())
				{
					if(fd == -1)
					{
						ww = frame.cols;
						hh = frame.rows;
						fd = open(out_filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
						write(fd, &ww, sizeof(int));
						write(fd, &hh, sizeof(int));
						int depth = 3;
						write(fd, &depth, sizeof(int));
						int ifps = (int)cam->fps;
						write(fd, &ifps, sizeof(int));
					}
					if(fd != -1)
					{
						long int ts = local_timestamp();
						write_frame(fd, frame.ptr(), ww * hh * 3, ts);
					}
					bad_cnt = 0;
					dumped_frames++;
				}
				else
				{
					bad_cnt++;
					if(bad_cnt > 10)
					{
						done = 1;
					}
				}
				redraw();
				Fl::check();
			}
			if(fd != -1)
			{
				close(fd);
			}
			local_cap.release();
		}
	}
	dump_type = NULL;
	dumped_frames = 0;
}

void	mux_preview_refresh_cb(void *v)
{
	MuxPreviewWindow *mpw = (MuxPreviewWindow *)v;
	mpw->redraw();
	Fl::repeat_timeout(0.03, mux_preview_refresh_cb, mpw);
}

void	delete_mux_preview_window(Fl_Widget *w, void *v)
{
	MuxPreviewWindow *mpw = (MuxPreviewWindow *)v;
	Fl::remove_timeout(mux_preview_refresh_cb, mpw);
	mpw->hide();
	Fl::delete_widget(mpw);
}

void	load_mux_video_cb(Fl_Widget *w, void *v)
{
	Fl_Menu_Button *mb = (Fl_Menu_Button *)w;
	MuxPreviewWindow *mpw = (MuxPreviewWindow *)v;
	char *val = (char *)mb->text();
	if(val != NULL)
	{
		if(strcmp(val, "Cancel") != 0)
		{
			mpw->ResetMedia(val);
		}
	}
}

MuxPreviewWindow::MuxPreviewWindow(MyWin *in_win, int ww, int hh, char *title) : Fl_Double_Window(ww, hh, title)
{
int	loop;

	my_window = in_win;
	reset_button_cb(NULL, in_win);
	for(loop = 0;loop < 128;loop++)
	{
		if(my_window->my_muxer[loop] != NULL)
		{
			my_window->my_muxer[loop]->FinishMux();
			delete my_window->my_muxer[loop];
			my_window->my_muxer[loop] = NULL;
		}
	}
	my_window->muxer_cnt = 0;
	color(FL_BLACK);
	box(FL_NO_BOX);
	vlc_window = NULL;
	if(in_win->last_muxed_list[0] != NULL)
	{
		vlc_window = new VLC_Window(in_win->last_muxed_list[0], ww, hh);
		Fl::add_timeout(0.1, vlc_window_start_cb, vlc_window);
		Fl::add_timeout(0.1, mux_preview_refresh_cb, this);
	}
	progress_scrubber = new ProgressScrubber(in_win, this, 30, hh - 60, ww - 60, 40);
	progress_scrubber->box(FL_NO_BOX);

   	Fl_Menu_Button *popup_menu = new Fl_Menu_Button(0, 0, ww, hh - 60, "Muxed");
   	popup_menu->type(Fl_Menu_Button::POPUP3);
	popup_menu->color(FL_BLACK);
	popup_menu->textcolor(FL_WHITE);
	popup_menu->textsize(9);
	popup_menu->labelsize(10);
	popup_menu->box(FL_FLAT_BOX);
	for(loop = 0;loop < 64;loop++)
	{
   		if(my_window->last_muxed_list[loop] != NULL)
		{
			popup_menu->add(my_window->last_muxed_list[loop], "", load_mux_video_cb, this);
		}
	}
   	popup_menu->add("Cancel", "", NULL, this);

	end();
	callback(delete_mux_preview_window, this);
}

MuxPreviewWindow::~MuxPreviewWindow()
{
	if(vlc_window != NULL)
	{
		vlc_window->Pause();
		vlc_window->Stop();
		delete vlc_window;
		vlc_window = NULL;
	}
	if(my_window != NULL)
	{
		if(my_window->review_muxed == this)
		{
			my_window->review_muxed = NULL;
		}
	}
}

void	MuxPreviewWindow::ResetMedia(char *path)
{
	Fl::remove_timeout(mux_preview_refresh_cb, this);
	if(vlc_window != NULL)
	{
		vlc_window->Pause();
		vlc_window->Stop();
		delete vlc_window;
		vlc_window = NULL;
	}
	vlc_window = new VLC_Window(path, w(), h());
	Fl::add_timeout(0.1, vlc_window_start_cb, vlc_window);
	Fl::add_timeout(0.1, mux_preview_refresh_cb, this);
}

void	MuxPreviewWindow::draw()
{
char	buf[256];

	fl_color(FL_BLACK);
	fl_rectf(0, 0, w(), h());
	if(vlc_window != NULL)
	{
		int width = vlc_window->mat.cols;
		int height = vlc_window->mat.rows;
		int depth = vlc_window->mat.channels();
		unsigned char *ptr = (unsigned char *)vlc_window->mat.ptr();
		if((width > 0) && (height > 0) && (ptr != NULL))
		{
			Mat mat = vlc_window->mat.clone();
			cvtColor(mat, mat, COLOR_BGR2RGB);
			fl_draw_image(mat.ptr(), 0, 0, width, height, depth);
			sprintf(buf, "%08d", vlc_window->current_frame);
			fl_font(FL_HELVETICA, 9);
			fl_color(FL_YELLOW);
			fl_draw(buf, 20, 20);
			if(progress_scrubber != NULL)
			{
				double position = vlc_window->Position();
				progress_scrubber->Position(position);
			}
		}
	}
	Fl_Double_Window::draw();
}

int	MuxPreviewWindow::handle(int event)
{
	int flag = 0;
	if(event == FL_KEYBOARD)
	{
		int key = Fl::event_key();
		if(key == ' ')
		{
			if(vlc_window->paused == 0)
			{
				vlc_window->Pause();
			}
			else
			{
				vlc_window->Resume();
			}
			flag = 1;
		}
	}
	if((event == FL_PUSH)
	|| (event == FL_RELEASE)
	|| (event == FL_MOUSEWHEEL))
	{
		if(progress_scrubber != NULL)
		{
			flag = progress_scrubber->Handle(event);
		}
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

void	title_box_remove_cb(Fl_Widget *w, void *v)
{
	TitleBox *tb = (TitleBox *)v;
	if(tb != NULL)
	{
		tb->end_frame = tb->review_window->current_frame;
		tb->hide();
		if(tb->start_frame == tb->end_frame)
		{
			tb->review_window->RemoveTitle(tb);
		}
		tb->review_window->add_text = 0;
	}
}

TitleBox::TitleBox(ReviewWin *in_win, int xx, int yy, int in_start_frame) : Fl_Window(xx, yy, 300, 100)
{
	draw_mode = 0;
	held = 0;
	init_x = 0;
	init_y = 0;
	my_color = FL_WHITE;
	font_num = FL_HELVETICA;
	review_window = in_win;
	font_size = 12;
	start_frame = in_start_frame;
	box(FL_FLAT_BOX);
	color(FL_BLACK);

	text_in = new Fl_Multiline_Input(0, 0, w() - 10, 100);
	text_in->textcolor(FL_WHITE);
	text_in->color(FL_BLACK);
	text_in->box(FL_FRAME_BOX);

	remove_button = new Fl_Button(w() - 10, 0, 10, 10, "X");
	remove_button->color(FL_BLACK);
	remove_button->labelcolor(FL_YELLOW);
	remove_button->box(FL_FRAME_BOX);
	remove_button->callback(title_box_remove_cb, this);

	end();
}

TitleBox::~TitleBox()
{
}

int	TitleBox::handle(int event)
{
	int flag = 0;
	switch(event)
	{
		case(FL_PUSH):
		{
			if(init_x < (w() - 10))
			{
				held = 1;
				init_x = Fl::event_x();
				init_y = Fl::event_y();
				flag = 1;
			}
		}
		break;
		case(FL_RELEASE):
		{
			held = 0;
			flag = 1;
		}
		break;
		case(FL_DRAG):
		{
			int diff_x = init_x - Fl::event_x();
			int diff_y = init_y - Fl::event_y();
			resize(x() - diff_x, y() - diff_y, w(), h());
			flag = 1;
		}
		break;
		case(FL_MOUSEWHEEL):
		{
			if(held == 0)
			{
				int direction = Fl::event_dy();
				font_size += direction;
				if(font_size < 4) font_size = 4;
				if(font_size > 128) font_size = 128;
				text_in->textsize(font_size);
				redraw();
			}
			else
			{
				int direction = Fl::event_dy();
				font_num += direction;
				if(font_num < 0) font_num = 15;
				if(font_num > 15) font_num = 0;
				text_in->textfont(font_num);
				redraw();
			}
			flag = 1;
		}
		break;
		case(FL_FOCUS):
		case(FL_UNFOCUS):
		case(FL_KEYBOARD):
		{
			flag = text_in->handle(event);
			review_window->redraw();
			redraw();
		}
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

void	TitleBox::draw()
{
	int nx = 0;
	int ny = 0;
	fl_font(font_num, font_size);
	fl_measure(text_in->value(), nx, ny);
	if(nx < 100) nx = 100;
	if(ny < 30) ny = 30;
	resize(x(), y(), nx + 10, ny + 10);
	text_in->resize(0, 0, nx, ny + 10);
	remove_button->resize(w() - 10, 0, 10, 10);
	if(draw_mode == 0)
	{
		Fl_Window::draw();
	}
	else
	{
		fl_color(FL_WHITE);
		fl_draw(text_in->value(), x(), y(), w(), h(), FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_WRAP);
	}
}

ReviewWin::ReviewWin(MyWin *in_my_win, int ww, int hh, int in_fps, char *lbl, char *in_filename) : Fl_Double_Window(ww, hh, lbl)
{
int	loop;

	color(FL_BLACK);
	box(FL_FLAT_BOX);

	my_win = in_my_win;
	fd = -1;
	sz = 0;
	playing = 0;
	playing_trimmed = 0;
	encoding = 0;
	scrubbing = 0;
	frame_cnt = 0;
	current_frame = 0;
	single_frame = 0;
	alt_frame = NULL;
	crop_activated = 0;
	crop_x = NULL;
	crop_y = NULL;
	speed = 1.0;
	fps = 0.0;
	add_text = 0;
	title_box_cnt = 0;
	strcpy(filename, in_filename);
	for(loop = 0;loop < 1024;loop++)
	{
		title_box[loop] = NULL;
	}
	title_box_cnt = 0;
	if(fps > 0)
	{
		delay = (double)(1.0 / (double)in_fps);
	}
	else
	{
		delay = 0.03;
	}
	frame_advance = 1.0;
	start_time = 0;
	frames_shown = 0;
	sz = w() * h() * 3;
	frame = (char *)malloc(sz);
	if(my_win->direct_recording == 1)
	{
		if(strlen(my_win->last_used_filename) > 0)
		{
			my_win->DumpDirectRecording(my_win->last_used_filename, filename);
		}
	}
	fd = open(filename, O_RDONLY);
	if(fd > -1)
	{
		long int length = filelength(fd);
		length -= (sizeof(int) * 4);
		frame_cnt = length / sz;
	}
	controls = new Fl_Window(0, h() - 30, ww, 26);
	controls->color(FL_BLACK);

		int nxx = 8;
		play = new Fl_Button(nxx, 2, 14, 14, "@>");
		play->labelcolor(FL_WHITE);
		play->box(FL_NO_BOX);
		play->tooltip("Play");
		play->callback(review_win_play_cb, this);
		nxx += 18;

		play_trim = new Fl_Button(nxx, 2, 14, 14, "@->");
		play_trim->labelcolor(FL_WHITE);
		play_trim->box(FL_NO_BOX);
		play_trim->tooltip("Play with trims");
		play_trim->callback(review_win_play_trimmed_cb, this);
		play_trim->hide();
		nxx += 18;

		retreat_one = new Fl_Repeat_Button(nxx, 2, 14, 14, "-");
		retreat_one->labelcolor(FL_WHITE);
		retreat_one->box(FL_NO_BOX);
		retreat_one->tooltip("Retreat one frame");
		retreat_one->callback(review_win_retreat_one_cb, this);
		nxx += 18;

		advance_one = new Fl_Repeat_Button(nxx, 2, 14, 14, "+");
		advance_one->labelcolor(FL_WHITE);
		advance_one->box(FL_NO_BOX);
		advance_one->tooltip("Advance one frame");
		advance_one->callback(review_win_advance_one_cb, this);
		nxx += 28;

		encode = new Fl_Button(nxx, 4, 14, 14, "@-4square");
		encode->labelcolor(FL_RED);
		encode->box(FL_NO_BOX);
		encode->tooltip("Encode with trims");
		encode->callback(review_win_encode_cb, this);
		nxx += 28;
	
		start_trim_button = new Fl_Button(nxx, 4, 14, 14, ">|");
		start_trim_button->labelcolor(FL_WHITE);
		start_trim_button->box(FL_NO_BOX);
		start_trim_button->tooltip("Start of trim");
		start_trim_button->callback(review_win_start_trim_cb, this);
		nxx += 28;
	
		end_trim_button = new Fl_Button(nxx, 4, 14, 14, "|<");
		end_trim_button->labelcolor(FL_WHITE);
		end_trim_button->box(FL_NO_BOX);
		end_trim_button->tooltip("End of trim");
		end_trim_button->callback(review_win_end_trim_cb, this);
		end_trim_button->deactivate();
		nxx += 28;

		clear_trim_button = new Fl_Button(nxx, 4, 14, 14, "@undo");
		clear_trim_button->labelcolor(FL_WHITE);
		clear_trim_button->box(FL_NO_BOX);
		clear_trim_button->tooltip("Reset all trims");
		clear_trim_button->callback(review_win_clear_trim_cb, this);
		clear_trim_button->hide();
		nxx += 48;

		snap_one_button = new Fl_Button(nxx, 4, 14, 14, "@-7circle");
		snap_one_button->labelcolor(FL_WHITE);
		snap_one_button->box(FL_NO_BOX);
		snap_one_button->tooltip("Save as image");
		snap_one_button->callback(review_win_snap_one_cb, this);
		nxx += 28;

		moving_crop_button = new Fl_Button(nxx, 4, 14, 14, "");
		moving_crop_button->labelcolor(FL_WHITE);
		moving_crop_button->box(FL_FRAME_BOX);
		moving_crop_button->tooltip("Moving Crop");
		moving_crop_button->callback(moving_crop_cb, this);
		nxx += 28;
	
		add_text_button = new Fl_Button(nxx, 4, 17, 17, "T");
		add_text_button->labelcolor(FL_WHITE);
		add_text_button->color(FL_BLACK);
		add_text_button->box(FL_FRAME_BOX);
		add_text_button->tooltip("Titles");
		add_text_button->callback(add_text_cb, this);
		nxx += 28;
	
		speed_slider = new Fl_Value_Slider(w() - 180, 3, 160, 12);
		speed_slider->type(FL_HOR_NICE_SLIDER);
		speed_slider->color(FL_BLACK);
		speed_slider->textcolor(FL_WHITE);
		speed_slider->box(FL_FLAT_BOX);
		speed_slider->range(0.01, 10.0);
		speed_slider->value(1.0);
		speed_slider->step(0.01);
		speed_slider->tooltip("Playback and encoding speed");
		speed_slider->callback(speed_cb, this);

		frame_box = new Fl_Box(w() - (240 + 180), 2, 240, 13, "");
		frame_box->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT);
		frame_box->labelcolor(FL_WHITE);
		frame_box->labelsize(9);
		frame_box->box(FL_NO_BOX);
	controls->end();

	scrub = new MyScrubber(5, h() - 52, w() - 10, 16);
	scrub->color(FL_BLACK);
	scrub->box(FL_FRAME_BOX);
	scrub->Range(frame_cnt);
	scrub->Callback(scrub_cb, this);

	controls->show();
	callback(close_review_window, this);
	set_modal();

	my_win->review_button->hide();
	my_win->review_muxed_button->hide();
	my_win->button_group->hide();
	my_win->buttons_shown = 0;
}

ReviewWin::~ReviewWin()
{
int	loop;

	if(fd != -1)
	{
		close(fd);
		fd = -1;
	}
	if(frame != NULL)
	{
		free(frame);
		frame = NULL;
	}
	if(main != NULL)
	{
		if(main->review == this)
		{
			main->review = NULL;
		}
	}
	for(loop = 0;loop < 1024;loop++)
	{
		if(title_box[loop] != NULL)
		{
			Fl::delete_widget(title_box[loop]);
			title_box[loop] = NULL;
		}
	}
	my_win->review_button->show();
}

int	ReviewWin::AdvanceToTrim(int fdx)
{
int	loop;

	int min_distance = 100000000;
	int save_frame = -1;
	for(loop = 0;loop < scrub->trim_cnt;loop++)
	{
		int distance = scrub->start_trim[loop] - current_frame;
		if(distance > 0)
		{
			if(distance < min_distance)
			{
				min_distance = distance;
				save_frame = scrub->start_trim[loop];
			}
		}
	}
	if(save_frame > -1)
	{
		current_frame = save_frame;
		off_t nn = (off_t)((off_t)current_frame * (off_t)(sz + sizeof(long int))) + (off_t)(sizeof(int) * 4);
		lseek(fdx, nn, SEEK_SET);
	}
	return(save_frame);
}

int	read_single_frame_file(int *flag)
{
	Camera *cam = (Camera *)flag;
	if(cam->single_frame_fd != -1)
	{
		while(cam->pipe_done == 0)
		{
			int fd = cam->single_frame_fd;
			int ready = 0;
			int cols = 0;
			int rows = 0;
			int depth = 0;
			lseek(fd, SEEK_SET, 0);
			read(fd, &ready, sizeof(int));
			if(ready == 1)
			{
				read(fd, &cols, sizeof(int));
				read(fd, &rows, sizeof(int));
				read(fd, &depth, sizeof(int));
				if((cols > 0) && (rows > 0) && (depth > 0))
				{
					int nn = cols * rows * depth;
					if(depth == 4)
					{
						cv::Mat local_mat(rows, cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
						if(read(fd, local_mat.ptr(), nn) == nn)
						{
							cam->mat = local_mat.clone();
						}
					}
					else if(depth == 3)
					{
						cv::Mat local_mat(rows, cols, CV_8UC3, cv::Scalar(0, 0, 0));
						if(read(fd, local_mat.ptr(), nn) == nn)
						{
							cvtColor(local_mat, local_mat, COLOR_RGB2RGBA);
							cam->mat = local_mat.clone();
						}
					}
				}
				lseek(fd, SEEK_SET, 0);
				ready = 0;
				write(fd, &ready, sizeof(int));
			}
			else
			{
				usleep(10000);
			}
		}
	}
	return(0);
}

int	read_pipe(int *flag)
{
char	buf[1024];

	Camera *cam = (Camera *)flag;
	while(cam->list_length < 1)
	{
		sleep(1);
	}
	while(cam->pipe_done == 0)
	{
		if(cam->list_ready_for_more == 1)
		{
			if(fgets(buf, 1024, cam->pipe_fp))
			{
				strip_lf(buf);
				cam->ScrollTextList(buf);
			}
			else
			{
				cam->pipe_done = -1;
			}
			cam->list_ready_for_more = 0;
		}
		else
		{
			usleep(1000);
		}
	}
	if(cam->pipe_done == 1)
	{
		kill(cam->pipe_pid, SIGTERM);
	}
	close(cam->pipe_in);
	fclose(cam->pipe_fp);
	return(0);
}

void	Camera::ScrollTextList(char *str)
{
int	loop;
static int first = 0;

	if(list_position > list_length)
	{
		list_position = list_length;
		for(loop = 0;loop < list_position;loop++)
		{
			strcpy(text_list[loop], text_list[loop + 1]);
		}
	}
	strcpy(text_list[list_position], str);
	if(list_position <= list_length)
	{
		list_position++;
	}
}

char	*parse_triplet(char *cp, int *red, int *green, int *blue)
{
	*red = atoi(cp);
	while((*cp != '\0') && (*cp != ','))
	{
		cp++;
	}
	if(*cp == ',')
	{
		cp++;
		*green = atoi(cp);
		while((*cp != '\0') && (*cp != ','))
		{
			cp++;
		}
		if(*cp == ',')
		{
			cp++;
			*blue = atoi(cp);
		}
	}
	return(cp);
}

char	*parse_quadlet(char *cp, int *sx, int *sy, int *ex, int *ey)
{
	*sx = atoi(cp);
	while((*cp != '\0') && (*cp != ','))
	{
		cp++;
	}
	if(*cp == ',')
	{
		cp++;
		*sy = atoi(cp);
		while((*cp != '\0') && (*cp != ','))
		{
			cp++;
		}
		if(*cp == ',')
		{
			cp++;
			*ex = atoi(cp);
			while((*cp != '\0') && (*cp != ','))
			{
				cp++;
			}
			if(*cp == ',')
			{
				cp++;
				*ey = atoi(cp);
			}
		}
	}
	return(cp);
}

char	*parse_doublet(char *cp, int *red, int *green)
{
	*red = atoi(cp);
	while((*cp != '\0') && (*cp != ','))
	{
		cp++;
	}
	if(*cp == ',')
	{
		cp++;
		*green = atoi(cp);
	}
	return(cp);
}

void	draw_text(const char *str, int length, int sx, int sy)
{
char buf[2];
char local[4096];

	int xx = sx;
	int yy = sy;
	strncpy(local, str, 4096);
	char *cp = local;
	int done = 0;
	int extent_y = 0;
	while(done == 0)
	{
		buf[0] = *cp;
		buf[1] = '\0';
		if(*cp == '\0')
		{
			done = 1;
		}
		else if(*cp == '\\')
		{
			char *remember = cp;
			int met = 0;
			cp++;
			if(*cp == 'c')
			{
				cp++;
				if(*cp == '[')
				{
					cp++;
					int red = -1;
					int green = -1;
					int blue = -1;
					cp = parse_triplet(cp, &red, &green, &blue);
					while((*cp != '\0') && (*cp != ']'))
					{
						cp++;
					}
					if(*cp == ']')
					{
						if((red > -1) && (green > -1) && (blue > -1))
						{
							fl_color(fl_rgb_color(red, green, blue));
						}
						met = 1;
					}
				}
				else if((*cp >= '0') && (*cp <= '9'))
				{
					int color = atoi(cp);
					if((color > -1) && (color < 256))
					{
						while((*cp != '\0') && (*cp >= '0') && (*cp <= '9'))
						{
							cp++;
						}
						fl_color(color);
						met = 1;
						cp--;
					}
				}
			}
			else if(*cp == 'p')
			{
				cp++;
				if(*cp == '[')
				{
					cp++;
					int x_pos = -1;
					int y_pos = -1;
					cp = parse_doublet(cp, &x_pos, &y_pos);
					while((*cp != '\0') && (*cp != ']'))
					{
						cp++;
					}
					if(*cp == ']')
					{
						if((x_pos > -1) && (y_pos > -1))
						{
							xx = x_pos;
							yy = y_pos;
						}
						met = 1;
					}
				}
			}
			else if(*cp == 's')
			{
				cp++;
				if((*cp >= '0') && (*cp <= '9'))
				{
					int sz = atoi(cp);
					if((sz > -1) && (sz < 256))
					{
						while((*cp != '\0') && (*cp >= '0') && (*cp <= '9'))
						{
							cp++;
						}
						fl_font(fl_font(), sz);
						met = 1;
						cp--;
					}
				}
			}
			else if(*cp == 'f')
			{
				cp++;
				if((*cp >= '0') && (*cp <= '9'))
				{
					int face = atoi(cp);
					int limit = 256;
					if(global_window != NULL)
					{
						limit = global_window->number_of_fonts;
					}
					if((face > -1) && (face < limit))
					{
						while((*cp != '\0') && (*cp >= '0') && (*cp <= '9'))
						{
							cp++;
						}
						fl_font(face, fl_size());
						met = 1;
						cp--;
					}
				}
			}
			else if(*cp == 'i')
			{
				cp++;
				if(*cp == '[')
				{
					cp++;
					char filename[4096];
					strncpy(filename, cp, 4096);
					char *cp2 = filename;
					while((*cp2 != '\0') && (*cp2 != ']'))
					{
						cp2++;
						cp++;
					}
					if(*cp2 == ']')
					{
						*cp2 = '\0';
						Fl_Shared_Image *a = Fl_Shared_Image::get(filename);
						if(a != NULL)
						{
							buf[0] = 'g';
							int lx = 0;
							int ly = 0;
							fl_measure(buf, lx, ly);
							a->draw(xx, yy - ly, a->w(), a->h(), 0, 0);
							xx += a->w();
							if(a->h() > extent_y) extent_y = a->h();
							met = 1;
						}
					}
				}
			}
			else if((*cp == 'n') || (*cp == 'r'))
			{
				buf[0] = 'g';
				int lx = 0;
				int ly = 0;
				fl_measure(buf, lx, ly);
				if(ly > extent_y) extent_y = ly;
				yy += extent_y;
				xx = sx;
				met = 1;
			}
			else if(*cp == 't')
			{
				int ok = 0;
				buf[0] = 'M';
				int lx = 0;
				int ly = 0;
				fl_measure(buf, lx, ly);
				if(lx > 0)
				{
					for(int loop = 0;((ok == 0) && (loop < 4096));loop += (lx * 4))
					{
						if(loop > xx)
						{
							ok = loop;
							xx = loop;
						}
					}
				}
				met = 1;
			}
			if(met == 0)
			{
				int lx = 0;
				int ly = 0;
				fl_measure(buf, lx, ly);
				fl_draw(buf, 1, xx, yy);
				xx += lx;
				cp = remember;
			}
		}
		else if((*cp == 10) || (*cp == 13))
		{
			buf[0] = 'g';
			int lx = 0;
			int ly = 0;
			fl_measure(buf, lx, ly);
			if(ly > extent_y) extent_y = ly;
			yy += extent_y;
		}
		else
		{
			int lx = 0;
			int ly = 0;
			fl_measure(buf, lx, ly);
			fl_draw(buf, 1, xx, yy);
			if(ly > extent_y) extent_y = ly;
			xx += lx;
		}
		cp++;
	}
}

void	fix_alpha(unsigned char *image, int ww, int hh)
{
int	x, y;

	unsigned char *p = image;
	for(x = 0;x < ww;x++)
	{
		for(y = 0;y < hh;y++)
		{
			unsigned char r = *p;
			unsigned char g = *(p + 1);
			unsigned char b = *(p + 2);
			unsigned char a = *(p + 3);
			int avg = (int)((int)r + (int)g + (int)b) / 3;
			if((r == 0) && (g == 0) && (b == 0))
			{
				*(p + 3) = 0;
			}
			p += 4;
		}
	}
}

void	Camera::RenderTextToMat(char *lit, Mat *mat)
{
char	buf[1024];
int		loop;

	cairo_surface_t *surface = cairo_image_surface_create_for_data(mat->ptr(), CAIRO_FORMAT_ARGB32, mat->cols, mat->rows, mat->step);
	if(surface != NULL)
	{
		cairo_t *context = cairo_create(surface);
		my_cairo_set_source_rgba(context, red, green, blue, alpha);
		cairo_rectangle(context, 0, 0, mat->cols, mat->rows);
		cairo_fill(context);
		if(piping_text == 1)
		{
			list_length = (height - font_sz) / font_sz;
			int y_pos = 0;
			for(loop = 0;loop < list_position;loop++)
			{
				my_cairo_draw_text(context, 0, y_pos + font_sz, text_list[loop], font_name, 0, font_sz, -1, text_red, text_green, text_blue, text_alpha, 0, 0, 0, 0);
				y_pos += font_sz;
			}
			list_ready_for_more = 1;
		}
		else
		{
			my_cairo_draw_text(context, 0, font_sz, lit, font_name, 0, font_sz, -1, text_red, text_green, text_blue, text_alpha, 0, 0, 0, 0);
		}
		cairo_destroy(context);
		cairo_surface_destroy(surface);
	}
}

void	ReviewWin::RenderTitles()
{
int	loop;
int	inner;

	if(title_box_cnt > 0)
	{
		int local_fd = open("encode_video.bin", O_RDONLY);
		if(local_fd > -1)
		{
			uchar *data_p = (uchar *)malloc(w() * h() * 3);
			if(data_p != NULL)
			{
				Fl_Offscreen off = fl_create_offscreen(w(), h());
				fl_begin_offscreen(off);
				for(loop = 0;loop < title_box_cnt;loop++)
				{
					if(title_box[loop] != NULL)
					{
						title_box[loop]->hide();
						title_box[loop]->draw_mode = 1;
						int start = title_box[loop]->start_frame;
						int end = title_box[loop]->end_frame;
						for(inner = start;inner < end;inner++)
						{
							long int ts = 0;
							off_t nn = (off_t)((off_t)inner * (off_t)(sz + sizeof(long int))) + (off_t)(sizeof(int) * 4);
							lseek(local_fd, nn, SEEK_SET);
							if(read_frame(local_fd, frame, sz, &ts) == sz)
							{
								fl_draw_image((unsigned char *)frame, 0, 0, w(), h(), 3);
								char *str = (char *)title_box[loop]->text_in->value();
								int xx = title_box[loop]->x();
								int yy = title_box[loop]->y();
								int ww = title_box[loop]->w();
								int hh = title_box[loop]->h();
								int tb_color = title_box[loop]->my_color;
								int fs = title_box[loop]->font_size;
								int fn = title_box[loop]->font_num;
								fl_color(tb_color);
								fl_font(fn, fs);
								fl_draw(str, xx, yy, ww, hh, FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_WRAP);
								uchar *p = fl_read_image(data_p, 0, 0, w(), h(), 0);
								if(p != NULL)
								{
									lseek(local_fd, nn, SEEK_SET);
									write_frame(local_fd, data_p, sz, ts);
								}
							}
						}
					}
				}
				fl_end_offscreen();
				free(data_p);
			}
			close(local_fd);
		}
	}
}

int	ReviewWin::AdjustToTrim(int check_only)
{
int	loop;

	int min_distance = 100000000;
	int save_frame = -1;
	int flag = 0;
	if(check_only == 0)
	{
		for(loop = 0;((loop < scrub->trim_cnt) && (flag == 0));loop++)
		{
			if((current_frame >= scrub->start_trim[loop]) && (current_frame <= scrub->end_trim[loop]))
			{
				flag = 1;
			}
			if(flag == 0)
			{
				int distance = scrub->start_trim[loop] - current_frame;
				if(distance > 0)
				{
					if(distance < min_distance)
					{
						min_distance = distance;
						save_frame = scrub->start_trim[loop];
					}
				}
			}
		}
		if(flag == 0)
		{
			if(save_frame > -1)
			{
				current_frame = save_frame;
				flag = 1;
			}
		}
		if(flag == 0)
		{
			current_frame = 0;
			playing = 0;
			playing_trimmed = 0;
			play_trim->label("@->");
			encode->activate();
			frames_shown = 0;
		}
	}
	else
	{
		for(loop = 0;((loop < scrub->trim_cnt) && (flag == 0));loop++)
		{
			if((current_frame >= scrub->start_trim[loop]) && (current_frame <= scrub->end_trim[loop]))
			{
				flag = 1;
			}
		}
	}
	return(flag);
}

int	ReviewWin::handle(int event)
{
int	loop;

	int flag = 0;
	switch(event)
	{
		case(FL_FOCUS):
		case(FL_UNFOCUS):
		{
			flag = 1;
		}
		break;
		case(FL_KEYBOARD):
		{
			int key = Fl::event_key();
			if((key == '.') || (key == FL_Up))
			{
				if(current_frame < (frame_cnt - 1))
				{
					single_frame = 1;
					playing = 1;
					current_frame++;
					redraw();
				}
				flag = 1;
			}
			if((key == ',') || (key == FL_Down))
			{
				if(current_frame > 0)
				{
					single_frame = 1;
					playing = 1;
					current_frame--;
					redraw();
				}
				flag = 1;
			}
			if(key == ' ')
			{
				if(playing == 1)
				{
					playing = 0;
				}
				else
				{
					playing = 1;
				}
				flag = 1;
			}
		}
		break;
		case(FL_PUSH):
		{
			if(crop_activated == 1)
			{
				if((current_frame > -1) && (current_frame < frame_cnt))
				{
					int xx = Fl::event_x();
					int yy = Fl::event_y();
					if(yy < (h() - 52))
					{
						xx -= 360;
						yy -= 240;
						if(xx < 0) xx = 0;
						if(yy < 0) yy = 0;
						if((xx + 360) > w()) xx = w() - 640;
						if((yy + 240) > h()) yy = h() - 480;
						for(loop = current_frame;loop < frame_cnt;loop++)
						{
							crop_x[loop] = xx;
							crop_y[loop] = yy;
						}
						flag = 1;
						redraw();
					}
				}
			}
			else if(add_text == 1)
			{
				int xx = Fl::event_x();
				int yy = Fl::event_y();
				if(yy < (h() - 52))
				{
					for(loop = 0;loop < title_box_cnt;loop++)
					{
						if(title_box[loop] != NULL)
						{
							flag = title_box[loop]->handle(event);
						}
					}
					if(flag == 0)
					{
						if(title_box_cnt < 1023)
						{
							TitleBox *title = new TitleBox(this, xx, yy, current_frame);
							add(title);
							title->show();
							int done = 0;
							for(loop = 0;((loop < title_box_cnt) && (done == 0));loop++)
							{
								if(title_box[loop] == NULL)
								{
									title_box[loop] = title;
									done = 1;
								}
							}
							if(done == 0)
							{
								title_box[title_box_cnt] = title;
								title_box_cnt++;
							}
							add_text = 2;
							add_text_button->color(FL_BLACK);
							add_text_button->labelcolor(FL_WHITE);
						}
						flag = 1;
					}
				}
			}
		}
		break;
		case(FL_MOUSEWHEEL):
		{
			if(add_text == 0)
			{
				int amount = 1;
				char *text = (char *)Fl::event_text();
				if(text != NULL)
				{
					char key = *text;
					if(key == 'S')
					{
						amount = (int)fps;
					}
					else if(key == 'M')
					{
						amount = (int)(fps * 60);
					}
				}
				int direction = Fl::event_dy();
				if(direction > 0)
				{
					if(current_frame < (frame_cnt - amount))
					{
						single_frame = 1;
						playing = 1;
						current_frame += amount;
						redraw();
					}
					flag = 1;
				}
				else if(direction < 0)
				{
					if(current_frame >= amount)
					{
						single_frame = 1;
						playing = 1;
						current_frame -= amount;
						redraw();
					}
					flag = 1;
				}
			}
		}
		break;
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

void	ReviewWin::draw()
{
static char buf[256];
int	loop;

	Camera *cam = main->camera[main->displayed_source];
	Fl_Double_Window::draw();
	if((fd != -1) && ((playing > 0) || (scrubbing == 1)))
	{
		if(single_frame == 0)
		{
			if(speed >= 1.0)
			{
				frame_advance = (int)speed;
			}
			else
			{
				frame_advance = 1.0;
			}
		}
		long int ts = 0;
		off_t nn = (off_t)((off_t)current_frame * (off_t)(sz + sizeof(long int))) + (off_t)(sizeof(int) * 4);
		lseek(fd, nn, SEEK_SET);
		if(read_frame(fd, frame, sz, &ts) == sz)
		{
			int go_ahead = 1;
			if(playing_trimmed == 1)
			{
				go_ahead = AdjustToTrim(0);
			}
			if(go_ahead == 1)
			{
				fl_draw_image((unsigned char *)frame, 0, 0, w(), h(), 3);
			}
			if(single_frame == 0)
			{
				if(playing == 1)
				{
					current_frame += (int)frame_advance;
				}
			}
			else
			{
				playing = 0;
				single_frame = 0;
			}
			if((playing > 0) && (scrubbing == 0))
			{
				frames_shown++;
			}
		}
		else
		{
			lseek(fd, sizeof(int) * 4, SEEK_SET);
			playing = 0;
			play->label("@>");
			current_frame = 0;
			frames_shown = 0;
		}
		if(scrubbing == 1)
		{
			scrubbing = 0;
		}
	}
	else
	{
		if(alt_frame != NULL)
		{
			fl_draw_image((unsigned char *)alt_frame, 0, 0, w(), h(), 3);
		}
		else
		{
			fl_draw_image((unsigned char *)frame, 0, 0, w(), h(), 3);
		}
		frames_shown = 0;
	}
	time_t current_time = time(0);
	int time_diff = current_time - start_time;
	fps = cam->fps;
	if(time_diff > 0)
	{
		double d_fps = (double)frames_shown / (double)time_diff;
		if(speed == 1.0)
		{
			if(d_fps < cam->fps)
			{
				if(delay > 0.00001)
				{
					delay -= 0.00001;
				}
			}
			else if(d_fps > cam->fps)
			{
				delay += 0.00001;
			}
		}
	}
	if(crop_activated == 1)
	{
		if((crop_x[current_frame] > -1) && (crop_y[current_frame] > -1))
		{
			fl_color(FL_YELLOW);
			fl_rect(crop_x[current_frame], crop_y[current_frame], 640, 480);
		}
	}
	if(add_text == 0)
	{
		for(loop = 0;loop < title_box_cnt;loop++)
		{
			if(title_box[loop] != NULL)
			{
				if((current_frame >= title_box[loop]->start_frame)
				&& (current_frame <= title_box[loop]->end_frame))
				{
					title_box[loop]->draw_mode = 1;
					title_box[loop]->hide();
					title_box[loop]->draw();
				}
				else
				{
					title_box[loop]->draw_mode = 0;
					title_box[loop]->hide();
				}
			}
		}
	}
	sprintf(buf, "(%06d of %06d) %0.2f FPS", current_frame, frame_cnt, fps);
	frame_box->label(buf);
	scrub->current = current_frame;
	scrub->redraw();
}

void	ReviewWin::RemoveTitle(TitleBox *tb)
{
int	loop;

	int done = 0;
	for(loop = 0;((loop < title_box_cnt) && (done == 0));loop++)
	{
		if(title_box[loop] == tb)
		{
			Fl::delete_widget(title_box[loop]);
			title_box[loop] = NULL;
			done = 1;
		}
	}
}

void	ReviewWin::ScrubTo(int nn)
{
	if(fd > -1)
	{
		if(nn != current_frame)
		{
			long int ts = 0;
			int nnn = nn * sz;
			current_frame = nn;
			if(read_frame(fd, frame, sz, &ts) == sz)
			{
				if(playing == 0)
				{
					scrubbing = 1;
				}
				redraw();
			}
			frames_shown = 0;
		}
	}
}

void	MyWin::SetUseOutputPath(int index, char *buf)
{
	if((index > -1) && (index < output_path_cnt))
	{
		if(output_active[index] == 1)
		{
			char use_buf[4096];
			strcpy(use_buf, "");
			streaming = interpret_output_path(NULL, output_path[index], use_buf);
			if(strlen(use_buf) > 1)
			{
				if(streaming == 0)
				{
					strcpy(buf, use_buf);
				}
				else
				{
					strcpy(stream_url, use_buf);
				}
			}
		}
	}
}

int	Camera::Record(int stream)
{
int	loop;
char	buf[4096];
struct tm *tm;
Mat	use_mat;
static Mat local_mat;

	int record_error = 0;
	if((record == 1) || (last == 1))
	{
		if(capture_interval > 0.0)
		{
			if(newly_captured == 1)
			{
				char filename[256];
				time_t t_num = time(0);
				tm = localtime((const time_t *)&t_num);
				long int lts = local_timestamp();
				sprintf(filename, "frame_%04d_%02d_%02d_%02d_%02d_%02d_%ld.png", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, lts);
				Mat out;
				cvtColor(mat, out, COLOR_RGB2BGR);
				imwrite(filename, out);
				newly_captured = 0;
			}
		}
		else
		{
			int ww = 0;
			int hh = 0;
			int flags = O_WRONLY | O_CREAT | O_TRUNC;
			if(ever_opened == 1)
			{
				flags = O_WRONLY | O_CREAT | O_APPEND;
			}
			if(my_window->muxing == 1)
			{
				if(my_window->single_stream == 0)
				{
					int use = id;
					if(my_window->my_muxer[use] == NULL)
					{
						my_window->SetCodec();
						int	num_mics = my_window->CountActiveMics();
						int use_audio = my_window->audio;

						double ifps = (current_fps * my_window->speed_factor);
						if(ifps < 24) ifps = 24;
						else if(ifps > 30) ifps = 30;
						if(num_mics <= 0)
						{
							use_audio = 2;
						}
						if(my_window->streaming == 1)
						{
							ifps = 30;
						}
						time_t t_num = time(0);
						tm = localtime((const time_t *)&t_num);
						sprintf(buf, "muxed_video_%02d_%04d_%02d_%02d_%02d_%02d_%02d.%s", id, tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, my_window->use_extension);
						my_window->video_count++;
						my_window->my_muxer[use] = new Muxer(my_window, NULL, 0);

						if(my_window->streaming == 1)
						{
							int init_mux_err = my_window->my_muxer[use]->InitMux(
								use_audio,
								(AVCodecID)AV_CODEC_ID_H264,
								(AVCodecID)AV_CODEC_ID_AAC,
								NULL,
								NULL,
								buf,
								my_window->stream_url,
								my_window->desktop_monitor,
								my_window->pulse_mixer,
								-1,
								my_window->output_width,
								my_window->output_height,
								ifps,
								(double)my_window->streaming_audio_quality,
								-1,
								NULL,
								NULL);
							if(init_mux_err != 0)
							{
								delete my_window->my_muxer[use];
								my_window->my_muxer[use] = NULL;
								my_window->muxer_cnt = 0;
								record_error = 1;
								record = 0;
							}
							else
							{
								my_window->AddLastMuxed(buf);
								my_window->muxer_cnt++;
							}
						}
						else
						{
							int init_mux_err = my_window->my_muxer[use]->InitMux(
								use_audio,
								my_window->use_video_codec,
								my_window->use_audio_codec,
								NULL,
								NULL,
								buf,
								NULL,
								my_window->desktop_monitor,
								my_window->pulse_mixer,
								-1,
								my_window->output_width,
								my_window->output_height,
								ifps,
								44100.0,
								-1,
								NULL,
								NULL);
							if(init_mux_err != 0)
							{
								delete my_window->my_muxer[use];
								my_window->my_muxer[use] = NULL;
								record_error = 1;
								record = 0;
							}
							else
							{
								my_window->AddLastMuxed(buf);
								my_window->muxer_cnt++;
							}
						}
					}
					else
					{
						if(my_window->my_muxer[use]->paused == 1)
						{
							my_window->my_muxer[use]->Resume();
						}
					}
					if(last == 1)
					{
						if(my_window->my_muxer[use] != NULL)
						{
							my_window->my_muxer[use]->FinishMux();
							delete my_window->my_muxer[use];
							my_window->my_muxer[use] = NULL;
						}
					}
				}
				else
				{
					my_window->muxer_cnt = 0;
					for(loop = 0;loop < my_window->output_path_cnt;loop++)
					{
						if(my_window->output_active[loop] == 1)
						{
							if(my_window->my_muxer[loop] == NULL)
							{
								my_window->SetCodec();
								int	num_mics = my_window->CountActiveMics();
								int use_audio = my_window->audio;

								double ifps = (current_fps * my_window->speed_factor);
								if(ifps < 24) ifps = 24;
								else if(ifps > 30) ifps = 30;
								if(num_mics <= 0)
								{
									use_audio = 2;
								}
								if(my_window->streaming == 1)
								{
									ifps = 30;
								}
								time_t t_num = time(0);
								tm = localtime((const time_t *)&t_num);
								if(my_window->single_stream == 0)
								{
									sprintf(buf, "muxed_video_%02d_%04d_%02d_%02d_%02d_%02d_%02d.%s", id, tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, my_window->use_extension);
								}
								else
								{
									my_window->SetUseOutputPath(loop, buf);
								}
								my_window->video_count++;
								my_window->my_muxer[loop] = new Muxer(my_window, NULL, 0);

								if(my_window->streaming == 1)
								{
									int init_mux_err = my_window->my_muxer[loop]->InitMux(
										use_audio,
										(AVCodecID)AV_CODEC_ID_H264,
										(AVCodecID)AV_CODEC_ID_AAC,
										NULL,
										NULL,
										buf,
										my_window->stream_url,
										my_window->desktop_monitor,
										my_window->pulse_mixer,
										-1,
										my_window->output_width,
										my_window->output_height,
										ifps,
										(double)my_window->streaming_audio_quality,
										-1,
										NULL,
										NULL);
									if(init_mux_err != 0)
									{
										delete my_window->my_muxer[loop];
										my_window->my_muxer[loop] = NULL;
										my_window->muxer_cnt = 0;
										record_error = 1;
										record = 0;
									}
									else
									{
										my_window->AddLastMuxed(buf);
										my_window->muxer_cnt++;
									}
								}
								else
								{
									int init_mux_err = my_window->my_muxer[loop]->InitMux(
										use_audio,
										my_window->use_video_codec,
										my_window->use_audio_codec,
										NULL,
										NULL,
										buf,
										NULL,
										my_window->desktop_monitor,
										my_window->pulse_mixer,
										-1,
										my_window->output_width,
										my_window->output_height,
										ifps,
										44100.0,
										-1,
										NULL,
										NULL);
									if(init_mux_err != 0)
									{
										delete my_window->my_muxer[loop];
										my_window->my_muxer[loop] = NULL;
										record_error = 1;
										record = 0;
									}
									else
									{
										my_window->AddLastMuxed(buf);
										my_window->muxer_cnt++;
									}
								}
							}
							else
							{
								my_window->muxer_cnt++;
								if(my_window->my_muxer[loop]->paused == 1)
								{
									my_window->my_muxer[loop]->Resume();
								}
							}
							if(last == 1)
							{
								if(my_window->my_muxer[loop] != NULL)
								{
									my_window->my_muxer[loop]->FinishMux();
									delete my_window->my_muxer[loop];
									my_window->my_muxer[loop] = NULL;
								}
							}
						}
					}
				}
			}
			else if(my_window->direct_recording == 0)
			{
				int depth = 4;
				unsigned char *ptr = NULL;
				if(stream == 0)
				{
					Mat out;
					cvtColor(my_window->detail->mat, out, COLOR_RGBA2BGRA);
					ptr = (unsigned char *)out.ptr();
					ww = my_window->detail->w();
					hh = my_window->detail->h();
					depth = out.channels();
				}
				else
				{
					if((my_window->output_width == mat.cols) && (my_window->output_height == mat.rows))
					{
						Mat out;
						cvtColor(mat, out, COLOR_RGBA2BGRA);
						ptr = (unsigned char *)out.ptr();
						ww = width;
						hh = height;
						depth = out.channels();
					}
					else
					{
						Mat out;
						cv::resize(mat, local_mat, cv::Size(my_window->output_width, my_window->output_height));
						cvtColor(local_mat, out, COLOR_RGBA2BGRA);
						ptr = (unsigned char *)out.ptr();
						ww = my_window->output_width;
						hh = my_window->output_height;
						depth = out.channels();
					}
				}
				int opened = 0;
				if(stream == 0)
				{
					start_ts = local_ts;
					if(fd[0] == -1)
					{
						paused_accumulation_ts = 0;
						paused_start_ts = 0;
						resuming = 0;

						if(my_window->single_stream == 0)
						{
							sprintf(buf, "detail_%02d.bin", id);
						}
						else
						{
							sprintf(buf, "single_stream.bin");
						}
						fd[0] = open(buf, flags, 0644);
						int depth = 3;
						if(ever_opened == 0)
						{
							write(fd[0], &ww, sizeof(int));
							write(fd[0], &hh, sizeof(int));
							write(fd[0], &depth, sizeof(int));
							int ifps = (int)fps;
							write(fd[0], &ifps, sizeof(int));
							ever_opened = 1;
						}
						opened = 1;
						int sz = ww * hh * depth;
						if(save_fifo != NULL)
						{
							delete save_fifo;
							save_fifo = NULL;
						}
						save_fifo = new SaveFIFO(my_window, fd[0], sz, ww, hh, start_ts);
						if(my_window->single_stream == 1)
						{
							my_window->SetAllCamerasToStream(this);
						}
					}
				}
				else if(my_window->stream_only == 0)
				{
					start_ts = local_ts;
					if(fd[1] == -1)
					{
						paused_accumulation_ts = 0;
						paused_start_ts = 0;
						resuming = 0;

						if(my_window->single_stream == 0)
						{
							sprintf(buf, "main_%02d.bin", id);
						}
						else
						{
							sprintf(buf, "single_stream.bin");
						}
						fd[1] = open(buf, flags, 0644);
						int depth = 4;
						if(ever_opened == 0)
						{
							write(fd[1], &ww, sizeof(int));
							write(fd[1], &hh, sizeof(int));
							write(fd[1], &depth, sizeof(int));
							int ifps = (int)fps;
							write(fd[1], &ifps, sizeof(int));
							ever_opened = 1;
						}
						opened = 1;
						int sz = ww * hh * depth;
						if(save_fifo != NULL)
						{
							delete save_fifo;
							save_fifo = NULL;
						}
						save_fifo = new SaveFIFO(my_window, fd[1], sz, ww, hh, start_ts);
						if(my_window->single_stream == 1)
						{
							my_window->SetAllCamerasToStream(this);
						}
					}
				}
				int sz = ww * hh * depth;
				if(fd[stream] > -1)
				{
					if(save_fifo != NULL)
					{
						if(last == 0)
						{
							if(resuming == 1)
							{
								resuming = 0;
								paused_accumulation_ts += ((local_timestamp() - paused_start_ts));
							}
						}
						save_fifo->Save(ptr, local_ts, paused_accumulation_ts);
						if(my_window->muxing == 0)
						{
							my_window->recorded_frames++;
						}
					}
				}
				if(last == 1)
				{
					paused_start_ts = local_timestamp();
					resuming = 1;
				}
				total_frames[stream]++;
			}
			else if(my_window->direct_recording == 1)
			{
				int opened = 0;
				if(my_window->direct_recorder == NULL)
				{
					if(stream == 0)
					{
						time_t t_num = time(0);
						tm = localtime((const time_t *)&t_num);
						sprintf(buf, "detail_%02d_%04d_%02d_%02d_%02d_%02d_%02d.%s", id, tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, my_window->mux_format);
						ww = my_window->detail->w();
						hh = my_window->detail->h();
						my_window->direct_recorder = new VideoWriter(buf, cv::VideoWriter::fourcc('M','J','P','G'), fps, Size(ww, hh));
						strcpy(my_window->last_used_filename, buf);
						opened = 1;
					}
					else
					{
						time_t t_num = time(0);
						tm = localtime((const time_t *)&t_num);
						sprintf(buf, "main_%02d_%04d_%02d_%02d_%02d_%02d_%02d.%s", id, tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, my_window->mux_format);
						ww = width;
						hh = height;
						my_window->direct_recorder = new VideoWriter(buf, cv::VideoWriter::fourcc('M','J','P','G'), fps, Size(ww, hh));
						strcpy(my_window->last_used_filename, buf);
						opened = 1;
					}
				}
				else
				{
					Mat blank_mat;
					if(stream == 0)
					{
						my_window->direct_recorder->write(my_window->detail->mat);
						blank_mat = my_window->detail->mat;
					}
					else
					{
						my_window->direct_recorder->write(my_window->in_mat);
						blank_mat = my_window->in_mat;
					}
					total_frames[stream]++;
					if(last == 1)
					{
						my_window->direct_recorder->release();
						delete my_window->direct_recorder;
						my_window->direct_recorder = NULL;
					}
				}
			}
			last = 0;
		}
	}
	return(record_error);
}

void	MyWin::Encode()
{
char	buf[4096];
char	old_audio_name[4096];
char	old_video_name[4096];

	if(encoding == 0)
	{
		Camera *cam = DisplayedCamera();
		if(cam != NULL)
		{
			int sz = cam->width * cam->height * 3;
			if(cam->save_fifo != NULL)
			{
				delete cam->save_fifo;
				cam->save_fifo = NULL;
			}
			if(cam->fd[stream] > -1)
			{
				close(cam->fd[stream]);
			}
			cam->fd[stream] = -1;
			if(pulse_mixer != NULL)
			{
				pulse_mixer->Stop();
			}
			strcmp(old_video_name, "");
			strcmp(old_audio_name, "");
			if((muxing == 1) && (stream_only == 1))
			{
				if(last_muxed_list[0] != NULL)
				{
					rename("video.bin", "encode_video.bin");
					strcpy(old_video_name, "video.bin");
				}
			}
			else
			{
				if(stream == 0)
				{
					if(single_stream == 0)
					{
						sprintf(buf, "detail_%02d.bin", displayed_source);
					}
					else
					{
						sprintf(buf, "single_stream.bin");
					}
					if(access(buf, 0) == 0)
					{
						rename(buf, "encode_video.bin");
						strcpy(old_video_name, buf);
					}
				}
				else
				{
					if(single_stream == 0)
					{
						sprintf(buf, "main_%02d.bin", displayed_source);
					}
					else
					{
						sprintf(buf, "single_stream.bin");
					}
					if(access(buf, 0) == 0)
					{
						rename(buf, "encode_video.bin");
						strcpy(old_video_name, buf);
					}
				}
			}
			if(pulse_mixer != NULL)
			{
				sprintf(buf, "audio.bin");
				if(access(buf, 0) == 0)
				{
					rename(buf, "encode_audio.bin");
					strcpy(old_audio_name, buf);
				}
			}
			ReallyEncode(cam->frame_cnt[stream]);
			if(strlen(old_video_name) > 0)
			{
				rename("encode_video.bin", old_video_name);
			}
			if(strlen(old_audio_name) > 0)
			{
				rename("encode_audio.bin", old_audio_name);
			}
		}
	}
}

void	read_video_header(int fdx, int *uw, int *uh, int *depth, int *ufps)
{
	read(fdx, uw, sizeof(int));
	read(fdx, uh, sizeof(int));
	read(fdx, depth, sizeof(int));
	read(fdx, ufps, sizeof(int));
}

void	write_video_header(int fdx, int uw, int uh, int depth, int ufps)
{
	write(fdx, &uw, sizeof(int));
	write(fdx, &uh, sizeof(int));
	write(fdx, &depth, sizeof(int));
	write(fdx, &ufps, sizeof(int));
}

long int	ReviewWin::EditToTrim(int *used_frames)
{
int	loop, outer, inner;
long int	start_tc[1024];
long int	end_tc[1024];

	my_win->dump_type = "Extracting";
	my_win->dumped_frames = 0;
	my_win->dumped_limit = 0;
	my_win->redraw();
	Fl::check();

	int retained_frames = 0;
	long int last_used_ts = 0;
	scrub->SortTrim();
	int total_trim = scrub->CountTrim();
	if((scrub->trim_cnt > 0) && (scrub->trim_cnt < 1024))
	{
		for(loop = 0;loop < 1024;loop++)
		{
			start_tc[loop] = 0;
			end_tc[loop] = 0;
		}
		int fdi = open("encode_video.bin", O_RDONLY);
		if(fdi > -1)
		{
			long int length = filelength(fdi);
			length -= (sizeof(int) * 4);
			int dumped_frame_cnt = length / sz;
		
			my_win->dump_type = "Extracting";
			my_win->dumped_frames = 0;
			my_win->dumped_limit = total_trim;
			my_win->redraw();
			Fl::check();
			int fdo = open("video_output.bin", O_WRONLY | O_CREAT | O_TRUNC, 0666);
			if(fdo > -1)
			{
				int uw;
				int uh;
				int depth;
				int ufps;
				long int length = filelength(fdi);
				read_video_header(fdi, &uw, &uh, &depth, &ufps);
				write_video_header(fdo, uw, uh, depth, ufps);
				int in_frame = 0;
				int sz = uw * uh * depth;
				void *ptr = malloc(sz);
				void *last_frame = malloc(sz);
				if((ptr != NULL) && (last_frame != NULL))
				{
					memset(last_frame, 0, sz);
					int flag = 0;
					int done = 0;
					off_t seek_it = -1;
					long int accum_ts = 0;
					long int start_gap = 0;
					long int end_gap = 0;
					int *new_crop_x = NULL;
					int *new_crop_y = NULL;
					if(crop_activated == 1)
					{
						new_crop_x = (int *)malloc(frame_cnt * sizeof(int));
						new_crop_y = (int *)malloc(frame_cnt * sizeof(int));
					}
					for(outer = 0;outer < scrub->trim_cnt;outer++)
					{
						long int ts = 0;
						double transition_cnt = 0.0;
						if(my_win->transition > 0)
						{
							transition_cnt = 1.0;
						}
						for(inner = scrub->start_trim[outer];inner < scrub->end_trim[outer];inner++)
						{
							my_win->redraw();
							Fl::check();

							off_t nn = (off_t)((off_t)inner * (off_t)(sz + sizeof(long int))) + (off_t)(sizeof(int) * 4);
							seek_it = lseek(fdi, nn, SEEK_SET);
							nn = read_frame(fdi, ptr, sz, &ts);
							if(nn == sz)
							{
								if((new_crop_x != NULL) && (new_crop_y != NULL)
								&& (crop_x != NULL) && (crop_y != NULL))
								{
									new_crop_x[in_frame] = crop_x[inner];
									new_crop_y[in_frame] = crop_y[inner];
								}
								retained_frames++;
								if(inner == scrub->start_trim[outer])
								{
									start_tc[outer] = ts;
									end_gap = ts;
									accum_ts += (end_gap - start_gap);
								}
								long int use_ts = ts - accum_ts;

								if(transition_cnt > 0.0)
								{
									Mat image1(Size(w(), h()), CV_8UC3, ptr);
									Mat image2(Size(w(), h()), CV_8UC3, last_frame);

									addWeighted(image2, transition_cnt, image1, 1.0 - transition_cnt, 0.0, image1);
									transition_cnt -= 0.1;
								}
								write_frame(fdo, ptr, sz, use_ts);
								last_used_ts = use_ts;
								in_frame++;

								my_win->dumped_frames = in_frame;
								my_win->dump_type = "Extracting Video";
								my_win->dumped_limit = total_trim;
							}
						}
						memcpy(last_frame, ptr, sz);
						end_tc[outer] = ts;
						start_gap = ts;
					}
					if(my_win->transition > 0)
					{
						memset(last_frame, 0, sz);
						double transition_cnt = 1.0;
						for(loop = 0;loop < 100;loop++)
						{
							if(transition_cnt > 0.0)
							{
								Mat image1(Size(w(), h()), CV_8UC3, ptr);
								Mat image2(Size(w(), h()), CV_8UC3, last_frame);

								addWeighted(image1, transition_cnt, image2, 1.0 - transition_cnt, 0.0, image1);
								transition_cnt -= 0.01;
							}
							write_frame(fdo, ptr, sz, last_used_ts);
						}
					}
					if((new_crop_x != NULL) && (new_crop_y != NULL)
					&& (crop_x != NULL) && (crop_y != NULL))
					{
						free(crop_x);
						free(crop_y);
						crop_x = new_crop_x;
						crop_y = new_crop_y;
					}
					free(ptr);
					free(last_frame);
				}
				close(fdo);
			}
			close(fdi);
			if(access("encode_audio.bin", 0) == 0)
			{
				my_win->dumped_limit = -1;
				my_win->dump_type = "Extracting Audio";
				my_win->dumped_frames = 0;
				my_win->redraw();
				Fl::check();
				int fdi = open("encode_audio.bin", O_RDONLY);
				if(fdi > -1)
				{
					long int length = filelength(fdi);
					length -= sizeof(int);
					int dumped_frame_cnt = length / sizeof(short int);

					int fdo = open("audio_output.bin", O_WRONLY | O_CREAT | O_TRUNC, 0666);
					if(fdo > -1)
					{
						int hz;
						int channels;
						read(fdi, &channels, sizeof(int));
						read(fdi, &hz, sizeof(int));
						if(hz <= 0)
						{
							hz = 44100;
						}
						write(fdo, &channels, sizeof(int));
						write(fdo, &hz, sizeof(int));
						int done = 0;
						double calc_time = 0.0;
						short int sample;
						int sample_cnt = 0;

						while(done == 0)
						{
							int nn = read(fdi, &sample, sizeof(short int));
							if(nn == sizeof(short int))
							{
								calc_time += ((1.0 / (double)hz) * 1000.0);
								int flag = 0;
								for(loop = 0;((loop < scrub->trim_cnt) && (flag == 0));loop++)
								{
									if((calc_time >= start_tc[loop]) && (calc_time <= end_tc[loop]))
									{
										flag = 1;
									}
								}
								if(flag == 1)
								{
									write(fdo, &sample, sizeof(short int));
									my_win->dumped_frames++;
									my_win->dumped_limit = dumped_frame_cnt;
									if((sample_cnt % 10000) == 0)
									{
										my_win->redraw();
										Fl::check();
									}
								}
								sample_cnt++;
							}
							else
							{
								done = 1;
							}
						}
						close(fdo);
					}
					close(fdi);
				}
			}
		}
	}
	my_win->dumped_frames = 0;
	my_win->dumped_limit = -1;
	my_win->dump_type = NULL;
	my_win->redraw();
	Fl::check();
	*used_frames = retained_frames;
	return(last_used_ts);
}

void	MyWin::ReallyEncode(int number_of_frames)
{
struct tm *tm;
int	loop;
char	buf[4096];

	Camera *cam = camera[displayed_source];
	if(cam != NULL)
	{
		int *local_crop_x = NULL;
		int *local_crop_y = NULL;
		int check_trim = 0;
		long int last_used_ts = 0;
		int retained_frames = 0;
		if(review != NULL)
		{
			review->RenderTitles();
			if(review->scrub->trim_cnt > 0)
			{
				check_trim = 1;
				review->show();
				last_used_ts = review->EditToTrim(&retained_frames);
				number_of_frames = retained_frames;
			}
			speed_factor = review->speed;
			if(review->crop_activated == 1)
			{
				local_crop_x = review->crop_x;
				local_crop_y = review->crop_y;
			}
		}
		int uw = cam->width;
		int uh = cam->height;
		int depth = 3;
		int ufps = cam->fps;

		char tmp[256];
		int fdx = -1;
		char *video_in = NULL;
		char *audio_in = NULL;
		if(check_trim == 0)
		{
			fdx = open("encode_video.bin", O_RDONLY);
			video_in = "encode_video.bin";
			
			// This can be -2, for recording the desktop
			if(pulse_mixer != NULL)
			{
				audio_in = "encode_audio.bin";
			}
		}
		else
		{
			fdx = open("video_output.bin", O_RDONLY);
			video_in = "video_output.bin";

			// This can be -2, for recording the desktop
			if(pulse_mixer != NULL)
			{
				audio_in = "audio_output.bin";
			}
		}
		if(fdx > -1)
		{
			SetCodec();
			double ifps = cam->current_fps;
			int total_seconds = cam->running_time / 1000;
			if(total_seconds < 1) total_seconds = 1;

			time_t t_num = time(0);
			tm = localtime((const time_t *)&t_num);
			sprintf(buf, "muxed_video_%04d_%02d_%02d_%02d_%02d_%02d.%s", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, use_extension);
			video_count++;
			if(my_muxer[0] != NULL)
			{
				delete my_muxer[0];
				my_muxer[0] = NULL;
			}
			long int length = filelength(fdx);
			read(fdx, &uw, sizeof(int));
			read(fdx, &uh, sizeof(int));
			read(fdx, &depth, sizeof(int));
			read(fdx, &ufps, sizeof(int));
			ifps = (double)ufps;

			int sz = uw * uh * depth;
			length -= (sizeof(int) * 4);
			if(number_of_frames > 0)
			{
				encoding_frame_cnt = number_of_frames;
			}
			else
			{
				encoding_frame_cnt = (int)(length / (sz + sizeof(int)));
			}
			double calc_fps = encoding_frame_cnt / total_seconds;

			close(fdx);
			int audio_secs = 0;
			int video_secs = encoding_frame_cnt / ifps;
			if(audio_in != NULL)
			{
				int fda = open(audio_in, O_RDONLY);
				if(fda > -1)
				{
					int hz = 1;
					int channels = 1;
					read(fda, &channels, sizeof(int));
					read(fda, &hz, sizeof(int));
					long int length = filelength(fda);
					audio_secs = (((length - sizeof(int)) / 2) / hz);
					close(fda);
				}
			}
			else
			{
				ifps *= speed_factor;
				if(ifps < minimum_fps)
				{
					ifps = minimum_fps;
				}
			}
			encoding = 1;
			Muxer *use_muxer = new Muxer(this, review, 1);
			SetUseOutputPath(0, buf);

			// COW - Forced to 30 FPS, otherwise cannot sync
			ifps = 30;

			use_muxer->InitMux(audio, use_video_codec, use_audio_codec, video_in, audio_in, buf, NULL, desktop_monitor, NULL, -1, uw, uh, ifps, 8000.0, number_of_frames, local_crop_x, local_crop_y);
			AddLastMuxed(buf);
			delete use_muxer;
			encoding = 0;
		}
	}
}

void	access_frame(unsigned char *frame, int x, int y, int ww, int hh, int dd, unsigned char *red, unsigned char *green, unsigned char *blue)
{
	int nn = (y * ww * dd) + (x * dd);
	if(frame != NULL)
	{
		unsigned char *ptr = frame + nn;
		if(dd == 3)
		{
			*red = *ptr;
			*green = *ptr + 1;
			*blue = *ptr + 2;
		}
		else
		{
			*red = *ptr;
		}
	}
}

int	MyWin::FindMovement(int threshold_sz, int *cx, int *cy, int *second_cx, int *second_cy, int region_x1, int region_y1, int region_x2, int region_y2)
{
Mat cow_gray;
Mat show_mat;
int loop;
int outer, inner;
int cnt_array[10][10];

	int r = -1;
	Camera *cam = CurrentCamera();
	if(cam != NULL)
	{
		if(region_x1 == -1) region_x1 = 0;
		if(region_y1 == -1) region_y1 = 0;
		if(region_x2 == -1) region_x2 = w();
		if(region_y2 == -1) region_y2 = h();
		for(outer = 0;outer < 10;outer++)
		{
			for(inner = 0;inner < 10;inner++)
			{
				cnt_array[outer][inner] = 0;
			}
		}
		int image_sx = (w() / 2) - (cam->mat.cols / 2);
		int image_sy = (h() / 2) - (cam->mat.rows / 2);
		cvtColor(cam->mat, cow_gray, COLOR_RGBA2GRAY);
		blur(cow_gray, cow_gray, Size(7, 7));
		if(cam->once == 1)
		{
			absdiff(cam->old_mat, cow_gray, show_mat);
			threshold(show_mat, show_mat, 25, 255, THRESH_BINARY);
			dilate(show_mat, show_mat, 0, Point(-1, -1), 2, 1, 1);
			if(motion_debug == 1)
			{
				cam->motion_mat = show_mat.clone();
			}
			vector<vector<Point> > contours;
			findContours(show_mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

			vector<vector<Point> > contours_poly(contours.size());
			vector<Rect> boundRect(contours.size());
			for(int i = 0; i < contours.size(); i++)
			{	
				approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
				boundRect[i] = boundingRect(Mat(contours_poly[i]));
			}
			for(loop = 0;loop < contours.size();loop++)
			{
				Point top_left = boundRect[loop].tl();
				Point bottom_right = boundRect[loop].br();
				int xx1 = top_left.x;
				int yy1 = top_left.y;
				int xx2 = bottom_right.x;
				int yy2 = bottom_right.y;
				int sz_x = xx2 - xx1;
				int sz_y = yy2 - yy1;
				if((xx1 >= region_x1)
				&& (yy1 >= region_y1)
				&& (xx2 <= region_x2)
				&& (yy2 <= region_y2))
				{
					int mid_x = xx1 + ((xx2 - xx1) / 2);
					int mid_y = yy1 + ((yy2 - yy1) / 2);
					int cnx = (10.0 / (double)cam->width) * (double)mid_x;
					int cny = (10.0 / (double)cam->height) * (double)mid_y;
					int area_flag = MatchArea(0, cnx, cny);

					if((area_flag == 1) || (interest_cnt == 0))
					{
						if((sz_x * sz_y) > threshold_sz)
						{
							if(visible_debug == 1)
							{
								fl_color(FL_CYAN);
								fl_rect(cam->image_sx + xx1, cam->image_sy + yy1, sz_x, sz_y);
							}
							int nx = (10.0 / (double)cam->width) * (double)xx1;
							int ny = (10.0 / (double)cam->height) * (double)yy1;
							cnt_array[nx][ny] += sz_x * sz_y;
						}
						else if((sz_x * sz_y) > 0)
						{
							if(visible_debug == 1)
							{
								fl_color(FL_RED);
								fl_rect(cam->image_sx + xx1, cam->image_sy + yy1, sz_x, sz_y);
								int px = xx1 * (cam->width / 10);
								int py = yy1 * (cam->height / 10);
								fl_color(FL_GRAY);
								fl_rect(px, py, cam->width / 10, cam->height / 10);
							}
						}
					}
				}
			}
		}
		int old_x = -1;
		int old_y = -1;
		int highest_x = -1;
		int highest_y = -1;
		int highest = 0;
		for(outer = 0;outer < 10;outer++)
		{
			for(inner = 0;inner < 10;inner++)
			{
				if(cnt_array[outer][inner] > highest)
				{
					old_x = highest_x;
					old_y = highest_y;
					highest = cnt_array[outer][inner];
					highest_x = outer * (cam->width / 10);
					highest_y = inner * (cam->height / 10);
					int reverse_x = 0;
					int reverse_y = 0;
					int box_x = highest_x;
					int box_y = highest_y;
					if(highest_x > w() / 2)
					{
						highest_x += (cam->width / 10);
						reverse_x = 1;
					}
					if(highest_y > h() / 2)
					{
						highest_y += (cam->height / 10);
						reverse_y = 1;
					}
					if(visible_debug == 1)
					{
						int off_x = (w() / 2) - (cam->width / 2);
						int off_y = (h() / 2) - (cam->height / 2);
						fl_color(FL_WHITE);
						fl_rect(box_x + off_x, box_y + off_y, cam->width / 10, cam->height / 10);
					}
					r = 1;
				}
			}
		}
		*cx = highest_x;
		*cy = highest_y;
		*second_cx = old_x;
		*second_cy = old_y;
		cam->once = 1;
		cam->old_mat = cow_gray;
	}
	return(r);
}


void	MyWin::DrawDetailFrame(Fl_Color colr)
{
struct tm *tm;

	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if((cam->follow_motion == 0) && (cam->follow_objects == 0))
		{
			cam->cx = force_center_x;
			cam->cy = force_center_y;
			int diff_x = abs(cam->ccx - cam->cx);
			int diff_y = abs(cam->ccy - cam->cy);
			if((diff_x > 0) || (diff_y > 0))
			{
				diff_x /= cam->accel;
				diff_y /= cam->accel;
				cam->accel--;
				if(cam->accel < 10) cam->accel = 10;
				if((cam->cx > cam->ccx) && (cam->ccx < (w() - (detail_width / 2)))) cam->ccx += diff_x;
				if((cam->cx < cam->ccx) && ((cam->ccx - (detail_width / 2)) > 0)) cam->ccx -= diff_x;
				if((cam->cy > cam->ccy) && (cam->ccy < (h() - (detail_height / 2)))) cam->ccy += diff_y;
				if((cam->cy < cam->ccy) && ((cam->ccy - (detail_height / 2)) > 0)) cam->ccy -= diff_y;
			}
		}
		int use_cx = cam->ccx - (detail_width / 2);
		int use_cy = cam->ccy - (detail_height / 2);
		if(use_cx < 0) use_cx = 0;
		if(use_cy < 0) use_cy = 0;
		if((use_cx + detail_width) > cam->width) use_cx = cam->width - detail_width;
		if((use_cy + detail_height) > cam->height) use_cy = cam->height - detail_height;
		fl_color(colr);
		fl_rect(use_cx, use_cy, detail_width, detail_height);
		if((use_cx == cam->last_cx) && (use_cy == cam->last_cy))
		{
			cam->accel = 100;
		}
		cam->last_cx = use_cx;
		cam->last_cy = use_cy;
		if(timestamp == 1)
		{
			char buf[4096];
			interpret_output_path(this, timestamp_format, buf);
			if(strlen(buf) > 0)
			{
				int rr = timestamp_rr;
				int gg = timestamp_gg;
				int bb = timestamp_bb;

				int back_rr = timestamp_background_rr;
				int back_gg = timestamp_background_gg;
				int back_bb = timestamp_background_bb;
				int back_aa = timestamp_background_aa;
				cv::putText(cam->mat, buf, cv::Point(use_cx + 10, use_cy + 25), cv::FONT_HERSHEY_DUPLEX, 0.4, CV_RGB(bb, gg, rr), 1, cv::LINE_AA);
			}
		}
		CropFrame(in_mat, &detail->mat, use_cx, use_cy, detail_width, detail_height);
	}
	detail->redraw();
	detail->show();
}

static int xioctl(int fh, int request, void *arg)
{
int r;

	do
	{
		r = ioctl(fh, request, arg);
	}
	while((r == -1) && (errno == EINTR));
	return r;
}

void	Camera::V4L_Motion(int direction)
{
struct v4l2_control ctrl;

	int fd = open(path, O_WRONLY);
	if(fd > -1)
	{
		if((direction & V4L_RIGHT) == V4L_RIGHT)
		{
			ctrl.id = V4L2_CID_PAN_SPEED;
			ctrl.value = 1;
			xioctl(fd, VIDIOC_S_CTRL, &ctrl);
		}
		if((direction & V4L_LEFT) == V4L_LEFT)
		{
			ctrl.id = V4L2_CID_PAN_SPEED;
			ctrl.value = -1;
			xioctl(fd, VIDIOC_S_CTRL, &ctrl);
		}
		if((direction & V4L_UP) == V4L_UP)
		{
			ctrl.id = V4L2_CID_TILT_SPEED;
			ctrl.value = 1;
			xioctl(fd, VIDIOC_S_CTRL, &ctrl);
		}
		if((direction & V4L_DOWN) == V4L_DOWN)
		{
			ctrl.id = V4L2_CID_TILT_SPEED;
			ctrl.value = -1;
			xioctl(fd, VIDIOC_S_CTRL, &ctrl);
		}
		if((direction & V4L_ZOOM_IN) == V4L_ZOOM_IN)
		{
			ctrl.id = V4L2_CID_ZOOM_CONTINUOUS;
			ctrl.value = 1;
			xioctl(fd, VIDIOC_S_CTRL, &ctrl);
		}
		if((direction & V4L_ZOOM_OUT) == V4L_ZOOM_OUT)
		{
			ctrl.id = V4L2_CID_ZOOM_CONTINUOUS;
			ctrl.value = -1;
			xioctl(fd, VIDIOC_S_CTRL, &ctrl);
		}
		if(direction == V4L_STOP)
		{
			ctrl.id = V4L2_CID_PAN_SPEED;
			ctrl.value = 0;
			xioctl(fd, VIDIOC_S_CTRL, &ctrl);
			ctrl.id = V4L2_CID_TILT_SPEED;
			ctrl.value = 0;
			xioctl(fd, VIDIOC_S_CTRL, &ctrl);
			ctrl.id = V4L2_CID_ZOOM_CONTINUOUS;
			ctrl.value = 0;
			xioctl(fd, VIDIOC_S_CTRL, &ctrl);
		}
		close(fd);
	}
	else
	{
		fprintf(stderr, "Error: Camera at [%s] failed to open for V4L commands.\n", path);
	}
}

int	Camera::V4L_Test()
{
	int rr = 0;
	int nn = cap->get(CAP_PROP_FOCUS);
	if(nn > -1)
	{
		rr = 1;
	}
	return(rr);
}

int	Camera::V4L_Test2()
{
struct v4l2_capability video_cap;

	int rr = 0;
	int fd = -1;
	if((fd = open(path, O_RDONLY)) != -1)
	{
		if(ioctl(fd, VIDIOC_QUERYCAP, &video_cap) != -1)
		{
			rr = 1;
		}
		close(fd);
	}
	return(rr);
}

void	Camera::V4L_Command(int command)
{

//			 brightness 0x00980900 (int)	: min=1 max=9 step=1 default=5 value=5
//			   contrast 0x00980901 (int)	: min=0 max=4 step=1 default=2 value=2
//			 saturation 0x00980902 (int)	: min=0 max=10 step=1 default=5 value=5
// white_balance_temperature_auto 0x0098090c (bool)   : default=1 value=1
//	   power_line_frequency 0x00980918 (menu)   : min=0 max=2 default=0 value=0
//				0: Disabled
//				1: 50 Hz
//				2: 60 Hz
//	  white_balance_temperature 0x0098091a (int)	: min=2800 max=10000 step=1 default=2800 value=4828 flags=inactive
//			  sharpness 0x0098091b (int)	: min=0 max=3 step=1 default=2 value=2
//	 backlight_compensation 0x0098091c (int)	: min=0 max=2 step=1 default=0 value=0
//		   pan_absolute 0x009a0908 (int)	: min=-471420 max=471420 step=1620 default=0 value=236520
//		  tilt_absolute 0x009a0909 (int)	: min=-103680 max=311040 step=1620 default=0 value=-103680
//		 focus_absolute 0x009a090a (int)	: min=0 max=300 step=1 default=1 value=33 flags=inactive
//			 focus_auto 0x009a090c (bool)   : default=1 value=1
//		  zoom_absolute 0x009a090d (int)	: min=0 max=909 step=1 default=0 value=909
//		zoom_continuous 0x009a090f (int)	: min=0 max=1 step=1 default=1 value=0
//			  pan_speed 0x009a0920 (int)	: min=-1 max=1 step=1 default=1 value=0
//			 tilt_speed 0x009a0921 (int)	: min=-1 max=1 step=1 default=1 value=0

	if(command == V4L_RIGHT)
	{
		V4L_Motion(V4L_RIGHT);
	}
	else if(command == V4L_LEFT)
	{
		V4L_Motion(V4L_LEFT);
	}
	else if(command == V4L_DOWN)
	{
		V4L_Motion(V4L_DOWN);
	}
	else if(command == V4L_UP)
	{
		V4L_Motion(V4L_UP);
	}
	else if(command == V4L_ZOOM_OUT)
	{
		int nn = cap->get(CAP_PROP_ZOOM);
		cap->set(CAP_PROP_ZOOM, nn - 1);
	}
	else if(command == V4L_ZOOM_IN)
	{
		int nn = cap->get(CAP_PROP_ZOOM);
		cap->set(CAP_PROP_ZOOM, nn + 1);
	}
	else if(command == V4L_FOCUS_FAR)
	{
		cap->set(CAP_PROP_AUTOFOCUS, 0);
		int nn = cap->get(CAP_PROP_FOCUS);
		cap->set(CAP_PROP_FOCUS, nn + 1);
	}
	else if(command == V4L_FOCUS_NEAR)
	{
		cap->set(CAP_PROP_AUTOFOCUS, 0);
		int nn = cap->get(CAP_PROP_FOCUS);
		cap->set(CAP_PROP_FOCUS, nn - 1);
	}
	else if(command == V4L_AUTOFOCUS)
	{
		int nn = cap->get(CAP_PROP_AUTOFOCUS);
		if(nn == 0)
		{
			cap->set(CAP_PROP_AUTOFOCUS, 1);
		}
		else
		{
			cap->set(CAP_PROP_AUTOFOCUS, 0);
		}
	}
	else if(command == V4L_STOP)
	{
		V4L_Motion(V4L_STOP);
	}
}


void	MyWin::CropFrame(Mat in, Mat *out, int xx, int yy, int ww, int hh)
{
	int extent_w = xx + ww;
	int extent_h = yy + hh;
	if((extent_w < in.cols) && (extent_h < in.rows))
	{
		cv::Rect roi;
		roi.x = xx;
		roi.y = yy;
		roi.width = ww;
		roi.height = hh;
		*out = in(roi).clone();
	}
}

void	Camera::ZoomBoxDisplay()
{
	cv::Rect roi;
	roi.x = zoom_box_x - image_sx;
	roi.y = zoom_box_y - image_sy;
	roi.width = zoom_box_w;
	roi.height = zoom_box_h;
	Mat crop = mat(roi);
	double amt1 = (double)mat.cols / (double)zoom_box_w;
	double amt2 = (double)mat.rows / (double)zoom_box_h;
	double amt = amt1;
	if(amt2 < amt1) amt = amt2;
	cv::resize(crop, crop, Size(), amt, amt, INTER_AREA);
	mat = crop.clone();
}

void	Camera::VideoEffects()
{
	if(!mat.empty())
	{
		if(saturation != 1.0)
		{
			mat = change_saturation(mat, saturation);
		}
		if(hue != 1.0)
		{
			mat = change_hue(mat, hue);
		}
		if(intensity != 1.0)
		{
			mat = change_intensity(mat, intensity);
		}
		if(contrast != 0.5)
		{
			contrast_mat(mat, contrast);
		}
		if((red_intensity != 1.0)
		|| (green_intensity != 1.0)
		|| (blue_intensity != 1.0)
		|| (alpha_intensity != 1.0))
		{
			ColorIntensity(mat, red_intensity, green_intensity, blue_intensity, alpha_intensity);
		}
		if(brightness != 0.5)
		{
			brightness_mat(mat, brightness);
		}
		if((flip_vertical == 1) && (flip_horizontal == 0))
		{
			flip(mat, mat, 0);
		}
		else if((flip_vertical == 0) && (flip_horizontal == 1))
		{
			flip(mat, mat, 1);
		}
		else if((flip_vertical == 1) && (flip_horizontal == 1))
		{
			flip(mat, mat, -1);
		}
		if(zoom_box_display == 1)
		{
			ZoomBoxDisplay();
		}
		if(zoom > 1.0)
		{
			Mat dst;
			
			int orig_w = mat.cols;
			int orig_h = mat.rows;
			int sw = (int)(zoom * (double)mat.cols);
			int sh = (int)(zoom * (double)mat.rows);
			Size sz(sw, sh);
			cv::resize(mat, dst, sz, 0, 0, INTER_AREA);
			int n_width = dst.cols;
			int n_height = dst.rows;

			int sx = ((n_width / 2) - (orig_w / 2)) + my_window->offset_x + my_window->save_offset_x;
			if(sx < 0) sx = 0;
			if(sx > sw - orig_w) sx = sw - orig_w;
			int sy = ((n_height / 2) - (orig_h / 2)) + my_window->offset_y + my_window->save_offset_y;
			if(sy < 0) sy = 0;
			if(sy > sh - orig_h) sy = sh - orig_h;

			Rect crop_region(sx, sy, orig_w, orig_h);
			Mat mat3 = dst(crop_region);
			mat = mat3.clone();
		}
	}
	if(my_window->single_stream == 1)
	{
		if(my_window->last_cam != NULL)
		{
			if((my_window->last_cam->mat.cols == mat.cols)
			&& (my_window->last_cam->mat.rows == mat.rows))
			{
				double interval = 0.1;
				if(my_window->transition == TRANSITION_BLEND)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					addWeighted(mat, my_window->transition_cnt, new_mat, 1.0 - my_window->transition_cnt, 0.0, mat);
				}
				else if(my_window->transition == TRANSITION_FADE_TO_BLACK)
				{
					Mat new_mat;
					cv::Mat local_mat(mat.rows, mat.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					new_mat = my_window->last_cam->mat.clone();
					double use = my_window->transition_cnt;
					addWeighted(new_mat, 1.0 - use, local_mat, use, 0.0, mat);
					interval = 0.025;
				}
				else if(my_window->transition == TRANSITION_FADE_FROM_BLACK)
				{
					Mat new_mat;
					cv::Mat local_mat(mat.rows, mat.cols, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					new_mat = my_window->last_cam->mat.clone();
					double use = my_window->transition_cnt;
					addWeighted(local_mat, 1.0 - use, mat, use, 0.0, mat);
					interval = 0.025;
				}
				else if(my_window->transition == TRANSITION_L2R_WIPE)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					int the_rest = new_mat.cols - (int)((double)new_mat.cols * my_window->transition_cnt);
					int start_x = new_mat.cols - the_rest;
					Rect region(start_x, 0, the_rest, new_mat.rows);
					Mat cropped = new_mat(region);
					int sx = start_x;
					int sy = 0;
					int ex = mat.cols;
					int ey = mat.rows;
					if(sx < mat.cols)
					{
						cropped.copyTo(mat.rowRange(sy, ey).colRange(sx, ex));
					}
					interval = 0.2;
				}
				else if(my_window->transition == TRANSITION_R2L_WIPE)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					int the_rest = new_mat.cols - (int)((double)new_mat.cols * my_window->transition_cnt);
					int start_x = new_mat.cols - the_rest;
					Rect region(0, 0, the_rest, new_mat.rows);
					Mat cropped = new_mat(region);
					int sx = 0;
					int sy = 0;
					int ex = the_rest;
					int ey = mat.rows;
					if(ex > 0)
					{
						cropped.copyTo(mat.rowRange(sy, ey).colRange(sx, ex));
					}
					interval = 0.2;
				}
				else if(my_window->transition == TRANSITION_T2B_WIPE)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					int the_rest = new_mat.rows - (int)((double)new_mat.rows * my_window->transition_cnt);
					int start_y = new_mat.rows - the_rest;
					Rect region(0, start_y, new_mat.cols, the_rest);
					Mat cropped = new_mat(region);
					int sx = 0;
					int sy = start_y;
					int ex = mat.cols;
					int ey = mat.rows;
					if(sy < mat.rows)
					{
						cropped.copyTo(mat.rowRange(sy, ey).colRange(sx, ex));
					}
					interval = 0.2;
				}
				else if(my_window->transition == TRANSITION_B2T_WIPE)
				{
					Mat new_mat;
					new_mat = my_window->last_cam->mat.clone();
					int the_rest = new_mat.rows - (int)((double)new_mat.rows * my_window->transition_cnt);
					int start_y = new_mat.rows - the_rest;
					Rect region(0, 0, new_mat.cols, the_rest);
					Mat cropped = new_mat(region);
					int sx = 0;
					int sy = 0;
					int ex = mat.cols;
					int ey = the_rest;
					if(ey > 0)
					{
						cropped.copyTo(mat.rowRange(sy, ey).colRange(sx, ex));
					}
					interval = 0.2;
				}
				my_window->transition_cnt += interval;
				if(my_window->transition_cnt > 1.0)
				{
					if(my_window->transition == TRANSITION_FADE_TO_BLACK)
					{
						my_window->transition = TRANSITION_FADE_FROM_BLACK;
					}
					else
					{
						my_window->last_cam = NULL;
					}
					my_window->transition_cnt = 0.0;
				}
			}
		}
	}
}

void	Camera::TimestampFrame()
{
int	interpret_output_path(MyWin *win, char *in, char *out);

	if(cairo_context != NULL)
	{
		char buf[4096];
		interpret_output_path(my_window, my_window->timestamp_format, buf);
		if(strlen(buf) > 0)
		{
			int rr = my_window->timestamp_rr;
			int gg = my_window->timestamp_gg;
			int bb = my_window->timestamp_bb;
			int aa = my_window->timestamp_aa;
			int back_r = my_window->timestamp_background_rr;
			int back_g = my_window->timestamp_background_gg;
			int back_b = my_window->timestamp_background_bb;
			int back_a = my_window->timestamp_background_aa;
			int sz = my_window->timestamp_font_sz;
			int xx = my_window->timestamp_position_x;
			int yy = my_window->timestamp_position_y;

			if(back_a > 0)
			{
				cairo_font_slant_t slant = CAIRO_FONT_SLANT_NORMAL;
				cairo_font_weight_t bold = CAIRO_FONT_WEIGHT_NORMAL;
				cairo_select_font_face(cairo_context, "Sans", slant, bold);
				cairo_set_font_size(cairo_context, sz);

				cairo_text_extents_t extents;
				cairo_text_extents(cairo_context, buf, &extents);
				int sz_x = extents.x_advance;
				int sz_y = extents.height;

				my_cairo_set_source_rgba(cairo_context, back_r, back_g, back_b, back_a);
				cairo_rectangle(cairo_context, xx, yy - sz_y, sz_x, sz_y + (sz_y / 4));
				cairo_fill(cairo_context);
			}
			my_cairo_draw_text(cairo_context, xx, yy, buf, "Sans", 0, sz, -1, rr, gg, bb, aa, 0, 0, 0, 255);
		}
	}
}

void	Camera::SnapshotFrame()
{
	char buf[4096];
	interpret_output_path(my_window, snapshot_filename_format, buf);
	if(strlen(buf) > 0)
	{
		Mat out;
		cvtColor(mat, out, COLOR_RGB2BGR);
		if(snapshot_scale > 0.0)
		{
			cv::resize(out, out, cv::Size(), snapshot_scale, snapshot_scale);
			imwrite(buf, out);
		}
	}
}

void	MyWin::MarkInterestGrid()
{
int	loop;

	int ww = camera[current_source]->width / 10;
	int hh = camera[current_source]->height / 10;
	int orig_x = image_origin_x;
	int orig_y = image_origin_y;
	fl_color(FL_GRAY);
	for(loop = 0;loop < camera[current_source]->width;loop += ww)
	{
		fl_line(loop + orig_x, orig_y, loop + orig_x, orig_y + camera[current_source]->height);
	}
	for(loop = 0;loop < camera[current_source]->height;loop += hh)
	{
		fl_line(orig_x, loop + orig_y, orig_x + camera[current_source]->width, loop + orig_y);
	}
}

void	MyWin::SplitScreen()
{
int	loop;

	int nxx = 0;
	int nyy = 0;
	int sz_w = w();
	int sz_h = h();
	if(source_cnt == 1)
	{
		sz_w = w();
		sz_h = h();
	}
	else if(source_cnt < 5)
	{
		sz_w = w() / 2;
		sz_h = h() / 2;
	}
	else if(source_cnt < 10)
	{
		sz_w = w() / 3;
		sz_h = h() / 3;
	}
	if((camera[current_source]->width < sz_w) || (camera[current_source]->height < sz_h))
	{
		sz_w = camera[current_source]->width;
		sz_h = camera[current_source]->height;
	}
	for(loop = 0;loop < source_cnt;loop++)
	{
		if(camera[loop] != NULL)
		{
			int go = 0;
			Mat local_mat;
			if((camera[loop]->power == 1) 
			&& (camera[loop]->type != CAMERA_TYPE_DESKTOP) 
			&& (camera[loop]->type != CAMERA_TYPE_WINDOW)
			&& (camera[loop]->type != CAMERA_TYPE_PSEUDO)
			&& (camera[loop]->type != CAMERA_TYPE_PLUGIN))
			{
				if(camera[loop]->type == CAMERA_TYPE_IMAGE)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_BLANK)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_HTML)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_SOURCED)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_EDGE_DETECT)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_CHROMAKEY)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_ALTERNATING)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_ALL)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_OSG)
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else if(camera[loop]->type == CAMERA_TYPE_AV)
				{
					if(camera[loop]->av_window != NULL)
					{
						local_mat = camera[loop]->av_window->mat.clone();
						cvtColor(local_mat, local_mat, COLOR_BGR2RGB);
						go = 1;
					}
				}
				else if((camera[loop]->type == CAMERA_TYPE_TEXT) || (camera[loop]->type == CAMERA_TYPE_PIPED))
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
				else
				{
					camera[loop]->mat.copyTo(local_mat);
					go = 1;
				}
			}
			else if((camera[loop]->power == 1) && (camera[loop]->type == CAMERA_TYPE_DESKTOP))
			{
				GrabDesktop();
				local_mat = desktop_mat.clone();
				go = 1;
			}
			else if((camera[loop]->power == 1) && (camera[loop]->type == CAMERA_TYPE_WINDOW))
			{
				camera[loop]->GrabWindow();
				local_mat = camera[loop]->mat.clone();
				go = 1;
			}
			else if((camera[loop]->power == 1) && (camera[loop]->type == CAMERA_TYPE_PSEUDO))
			{
				local_mat = camera[loop]->mat.clone();
				go = 1;
			}
			else if((camera[loop]->power == 1) && (camera[loop]->type == CAMERA_TYPE_PLUGIN))
			{
				local_mat = camera[loop]->mat.clone();
				go = 1;
			}
			if(go == 1)
			{
				Mat new_mat;
				cv::resize(local_mat, new_mat, cv::Size(sz_w, sz_h));
				if((camera[loop]->flip_vertical == 1) && (camera[loop]->flip_horizontal == 0))
				{
					flip(new_mat, new_mat, 0);
				}
				else if((camera[loop]->flip_vertical == 0) && (camera[loop]->flip_horizontal == 1))
				{
					flip(new_mat, new_mat, 1);
				}
				else if((camera[loop]->flip_vertical == 1) && (camera[loop]->flip_horizontal == 1))
				{
					flip(new_mat, new_mat, -1);
				}
				int test_nxx = nxx + new_mat.cols;
				if(test_nxx > w())
				{
					nxx = 0;
					nyy += new_mat.rows;
				}
				fl_draw_image((unsigned char *)new_mat.ptr(), nxx, nyy, new_mat.cols, new_mat.rows, new_mat.channels());
				fl_color(FL_YELLOW);
				int bx = nxx + (new_mat.cols - 25);
				int by = nyy + 5;
				fl_rect(bx, by, 20, 20);
				fl_line(bx, by, bx + 20, by + 20);
				fl_line(bx, by + 20, bx + 20, by);
				fl_rect(nxx + 8, nyy + 8, 14, 14, FL_YELLOW);
				if(camera[loop]->record == 1)
				{
					fl_rectf(nxx + 10, nyy + 10, 10, 10, FL_RED);
				}
				split_bx[loop] = bx;
				split_by[loop] = by;
				split_rx[loop] = nxx + 8;
				split_ry[loop] = nyy + 8;
				nxx += new_mat.cols;
				if(nxx >= w())
				{
					nxx = 0;
					nyy += new_mat.rows;
				}
			}
			else
			{
				fprintf(stderr, "Error: %d FAILED TO STREAM\n", loop);
			}
		}
		else
		{
			fprintf(stderr, "Error: %d FAILED TO GRAB\n", loop);
		}
	}
}

void	MyWin::ShowLog()
{
extern char		*global_log[128];
extern int		global_log_cnt;
int			loop;

	if(global_log_cnt > 0)
	{
		int hh = 60 + (global_log_cnt * 22);
		if(hh > 400) hh = 400;
		Fl_Window *win = new Fl_Window(600, hh, "Mux Error Log");
		win->box(FL_FRAME_BOX);
		win->color(FL_BLACK);
		win->border(0);
			Fl_Box *title_box = new Fl_Box(0, 0, 600, 25, "Mux Error Log");
			title_box->color(DARK_RED);
			title_box->box(FL_FRAME_BOX);
			title_box->labelsize(13);
			title_box->labelcolor(FL_YELLOW);
			Fl_Scroll *scroll = new Fl_Scroll(2, 30, 596, hh - 34);
			scroll->box(FL_FLAT_BOX);
			scroll->color(FL_BLACK);
			scroll->scrollbar_size(4);
			scroll->scrollbar.hide();
				for(loop = 0;loop < global_log_cnt;loop++)
				{
					int xx = 0;
					int yy = 0;
					Fl_Output *box = new Fl_Output(0, 30 + (loop * 22), 750, 22);
					box->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
					box->box(FL_FLAT_BOX);
					box->color(FL_BLACK);
					box->textcolor(FL_WHITE);
					box->textsize(12);
					box->value(global_log[loop]);
				}
			scroll->end();
		win->end();
		win->show();
		global_log_cnt = 0;
	}
}

void	MyWin::TagRecognized(Camera *cam, char *label, double confidence)
{
	if(tag_fp != NULL)
	{
		int total_seconds = cam->running_time / 1000;
		int minutes = total_seconds / 60;
		int seconds = total_seconds % 60;
		fprintf(tag_fp, "%03d:%02d\t(%.3f)\t[%s]\n", minutes, seconds, confidence, label);
	}
}

void	MyWin::Detect()
{
int			loop;

	Camera *cam = CurrentCamera();
	if(cam != NULL)
	{
		int dw = cam->width;
		int dh = cam->height;
		if(detail != NULL)
		{
			dw = detail->w();
			dh = detail->h();
		}
		int ddw = dw / 2;
		int ddh = dh / 2;
		if(encoding == 0)
		{
			if(direct_recording == 0)
			{
				if((muxing == 0) || (stream_only == 0))
				{
					encode_button->show();
				}
			}
		}
		int detected = 0;
		if((cam->motion_detect == 1) || (cam->follow_motion == 1) || (cam->follow_objects == 1) || (cam->object_detect == 1))
		{
			int tcx = -1;
			int tcy = -1;
			int second_cx = -1;
			int second_cy = -1;
			int rr = -1;
			if(cam->motion_detect == 1)
			{
				int use_cx = cam->ccx - ddw;
				int use_cy = cam->ccy - ddh;
				rr = FindMovement(cam->motion_threshold, &tcx, &tcy, &second_cx, &second_cy, use_cx, use_cy, use_cx + dw, use_cy + dh);
			}
			else if(cam->follow_motion == 1)
			{
				int use_cx = cam->ccx - ddw;
				int use_cy = cam->ccy - ddh;
				rr = FindMovement(cam->motion_threshold, &tcx, &tcy, &second_cx, &second_cy, -1, -1, -1, -1);
			}
			else if((cam->follow_objects == 1) || (cam->object_detect == 1))
			{
				if((cam->true_total_frames[stream] % cam->recognize_interval) == 0)
				{
					int tagged = 0;
					rr = cam->DetectObjects(&tcx, &tcy, &second_cx, &second_cy);
					if(rr > -1)
					{
						if(current_source == displayed_source)
						{
							fl_color(FL_RED);
							for(loop = 0;loop < cam->detected_object_cnt;loop++)
							{
								int xx = cam->detected_object[loop].x;
								int yy = cam->detected_object[loop].y;
								int ww = cam->detected_object[loop].w;
								int hh = cam->detected_object[loop].h;

								double adj_x1 = ((double)cam->display_width / (double)cam->mat.cols);
								double adj_y1 = ((double)cam->display_height / (double)cam->mat.rows);
								int adj_xx = (int)(double)xx * adj_x1;
								int adj_yy = (int)(double)yy * adj_y1;
								int adj_ww = (int)(double)ww * adj_x1;
								int adj_hh = (int)(double)hh * adj_y1;
								double confidence = cam->detected_object[loop].confidence;

								if(cam->detected_object[loop].idx > -1)
								{
									int nn = cam->detected_object[loop].idx;
									char *label = recognize_class_name[nn];
									fl_rect(cam->image_sx + adj_xx, cam->image_sy + adj_yy, adj_ww, adj_hh);
									char buf[256];
									sprintf(buf, "%s (%f)", label, cam->detected_object[loop].confidence);
									fl_draw(buf, cam->image_sx + adj_xx, cam->image_sy + adj_yy);
									if(tag_recognized == 1)
									{
										TagRecognized(cam, label, confidence);
										tagged++;
									}
								}
							}
						}
					}
					if(tagged == 0)
					{
						if(tag_recognized == 1)
						{
							TagRecognized(cam, "Nothing Found", 0.0);
						}
					}
				}
				else if(current_source == displayed_source)
				{
					fl_color(FL_YELLOW);
					for(loop = 0;loop < cam->detected_object_cnt;loop++)
					{
						int xx = cam->detected_object[loop].x;
						int yy = cam->detected_object[loop].y;
						int ww = cam->detected_object[loop].w;
						int hh = cam->detected_object[loop].h;

						double adj_x1 = ((double)cam->display_width / (double)cam->mat.cols);
						double adj_y1 = ((double)cam->display_height / (double)cam->mat.rows);
						int adj_xx = (int)(double)xx * adj_x1;
						int adj_yy = (int)(double)yy * adj_y1;
						int adj_ww = (int)(double)ww * adj_x1;
						int adj_hh = (int)(double)hh * adj_y1;

						fl_rect(cam->image_sx + adj_xx, cam->image_sy + adj_yy, adj_ww, adj_hh);
						if(cam->detected_object[loop].idx > -1)
						{
							int nn = cam->detected_object[loop].idx;
							char *label = recognize_class_name[nn];
							char buf[256];
							sprintf(buf, "%s (%f)", label, cam->detected_object[loop].confidence);
							fl_draw(buf, cam->image_sx + adj_xx, cam->image_sy + adj_yy);
							if(visible_debug == 1)
							{
								rectangle(cam->mat, Point(xx, yy), Point(xx + ww, yy + hh), Scalar(255, 255, 255), 1);
								putText(cam->mat, buf, cv::Point(xx, yy - 4), cv::FONT_HERSHEY_DUPLEX, 0.5, CV_RGB(255, 255, 255), 1, cv::LINE_AA);
							}
						}
					}
				}
			}
			if(rr > -1)
			{
				if((cam->follow_motion == 1) || (cam->follow_objects == 1))
				{
					if((tcx > -1) && (tcy > -1))
					{
						if((second_cx > -1) && (second_cy > -1))
						{
							int dx = second_cx - tcx;
							int dy = second_cy - tcy;
							int adx = abs(dx);
							int ady = abs(dy);
							if((adx < detail_width) && (ady < detail_height))
							{
								if(dx < 0)
								{
									tcx = second_cx;
								}
								if(dy < 0)
								{
									tcy = second_cy;
								}
							}
						}
						cam->cx = tcx;
						cam->cy = tcy;
					}
				}
				else if(ptz_follow == 1)
				{
					if((tcx > -1) && (tcy > -1)
					&& (second_cx > -1) && (second_cy > -1))
					{
						int image_center_x = cam->mat.cols / 2;
						int image_center_y = cam->mat.rows / 2;
						int image_sx = (w() / 2) - image_center_x;
						int image_sy = (h() / 2) - image_center_y;
						int nx = image_sx + (tcx + ((second_cx - tcx) / 2));
						int ny = image_sy + (tcy + ((second_cy - tcy) / 2));
						int diff_x = abs(nx - (w() / 2));
						int diff_y = abs(ny - (h() / 2));
						if((diff_x > (cam->mat.cols / 3)) || (diff_y > (cam->mat.rows / 3)))
						{
							PTZ_MoveTo(0, 0, nx, ny);
						}
					}
				}
				detected = 1;
				if(single_stream == 1)
				{
					int other = 0;
					for(loop = 0;((loop < source_cnt) && (other == 0));loop++)
					{
						if(camera[loop] != NULL)
						{
							Camera *another = camera[loop];
							if(another != cam)
							{
								if((another->recording == 1) || (another->record == 1))
								{
									other = 1;
								}
							}
						}
					}
					if(other == 0)
					{
						cam->record = 1;
					}
				}
				else
				{
					cam->record = 1;
				}
			}
			int diff_x = abs(cam->ccx - cam->cx);
			int diff_y = abs(cam->ccy - cam->cy);
			if((diff_x > 140) || (diff_y > 100))
			{
				fl_color(FL_GREEN);
				fl_line(cam->cx, cam->cy, cam->ccx, cam->ccy);
				fl_color(FL_YELLOW);
				fl_rectf(cam->cx, cam->cy, 10, 10);

				diff_x /= cam->accel;
				diff_y /= cam->accel;
				cam->accel--;
				if(cam->accel < 10) cam->accel = 10;
				if((cam->cx > cam->ccx) && (cam->ccx < (w() - ddw))) cam->ccx += diff_x;
				if((cam->cx < cam->ccx) && ((cam->ccx - ddw) > 0)) cam->ccx -= diff_x;
				if((cam->cy > cam->ccy) && (cam->ccy < (h() - ddh))) cam->ccy += diff_y;
				if((cam->cy < cam->ccy) && ((cam->ccy - ddh) > 0)) cam->ccy -= diff_y;
			}
			if(detected == 1)
			{
				if(hide_status == 0)
				{
					fl_color(FL_RED);
					fl_rectf(12, 12, 18, 18);
				}
				detect_time = time(0);
			}
			if(hide_status == 0)
			{
				fl_color(FL_YELLOW);
				fl_rect(10, 10, 22, 22);
			}
		}
		if(cam->record == 1)
		{
			if(pulse_mixer != NULL)
			{
				pulse_mixer->Resume();
			}
			cam->last = 0;
			int err = cam->Record(stream);
			if(err == 0)
			{
				cam->recording = 1;
				if(hide_status == 0)
				{
					if(detected == 0)
					{
						fl_color(FL_YELLOW);
					}
					else
					{
						fl_color(FL_RED);
					}
					fl_rectf(12, 12, 18, 18);
				}
				time_t current_time = time(0);
				if((cam->motion_detect == 1) || (cam->object_detect == 1)
				|| (cam->follow_motion == 1) || (cam->follow_objects == 1))
				{
					int diff_time = (int)(current_time - detect_time);
					if(diff_time > 12)
					{
						cam->record = 0;
						if(ptz_follow == 1)
						{
							ViscaCommand(PTZ_ABSOLUTE_POSITION, 4, 1, 1, ptz_follow_home_pan, ptz_follow_home_tilt);
						}
					}
				}
			}
			else
			{
				cam->record = 0;
				cam->recording = 0;
				cam->stopped = 1;
				fprintf(stderr, "Error: Camera cannot record.\n");
				RecordingFullStop();
				ShowLog();
			}
		}
		else
		{
			if(CountRecordingCameras() == 0)
			{
				if(pulse_mixer != NULL)
				{
					pulse_mixer->Stop();
				}
				if((cam->motion_detect == 1) || (cam->object_detect == 1)
				|| (cam->follow_motion == 1) || (cam->follow_objects == 1))
				{
					for(loop = 0;loop < 128;loop++)
					{
						if(my_muxer[loop] != NULL)
						{
							if(my_muxer[loop]->paused != 1)
							{
								my_muxer[loop]->Pause();
							}
						}
					}
				}
			}
			if(cam->recording != 0)
			{
				cam->recording = 0;
			}
		}
	}
}

int	MyWin::CountRecordingCameras()
{
int	loop;

	int cnt = 0;
	for(loop = 0;loop < source_cnt;loop++)
	{
		Camera *cam = camera[loop];
		if(cam != NULL)
		{
			if(cam->record == 1)
			{
				cnt++;
			}
		}
	}
	return(cnt);
}

void	Camera::BlurDetectedRegions()
{
int	loop;
static int last_x = -1;
static int last_y = -1;
static int last_w = -1;
static int last_h = -1;
static int last = 0;

	for(loop = 0;loop < detected_object_cnt;loop++)
	{
		int xx = detected_object[loop].x;
		int yy = detected_object[loop].y;
		int ww = detected_object[loop].w;
		int hh = detected_object[loop].h;
		last = 300;
	}
	if(last > 0)
	{
		blur_it(this, 73, last_x, last_y, last_w, last_h);
		last--;
	}
}

void	MyWin::MarkInterest()
{
int	loop;

	int off_x = image_origin_x;
	int off_y = image_origin_y;
	if((nominal_interest_x > -1) && (nominal_interest_y > -1))
	{
		int xx = nominal_interest_x * (camera[current_source]->width / 10);
		int yy = nominal_interest_y * (camera[current_source]->height / 10);
		fl_color(FL_YELLOW);
		fl_rectf(off_x + xx, off_y + yy, camera[current_source]->width / 10, camera[current_source]->height / 10);
	}
	for(loop = 0;loop < interest_cnt;loop++)
	{
		int nx = interest_x[loop];
		int ny = interest_y[loop];
		int xx = nx * (camera[current_source]->width / 10);
		int yy = ny * (camera[current_source]->height / 10);
		fl_color(FL_WHITE);
		fl_rectf(off_x + xx, off_y + yy, camera[current_source]->width / 10, camera[current_source]->height / 10);
	}
}

void	MyWin::CurrentFPS()
{
char	buf[4096];
double	calc_fps;
static long int last_time_here = 0;

	Camera *cam = CurrentCamera();
	if(cam != NULL)
	{
		time_t now = precise_time();
		double frac = (double)(now - cam->last_time) / 1000000.0;
		calc_fps = 0.0;
		if(frac > 0.0)
		{
			calc_fps = 1.0 / frac;
		}
		cam->last_time = precise_time();

		cam->elapsed = time(0) - cam->since_time;
		cam->since_frames[stream]++;

		if(cam->elapsed != cam->old_elapsed)
		{
			cam->current_fps = (double)cam->since_frames[stream];
			cam->old_elapsed = cam->elapsed;
			cam->since_frames[stream] = 0;
		}
		all_frames = 0;
		int minutes = 0;
		int seconds = 0;
		long int now_here = local_timestamp();
		long int use_here = now_here - last_time_here;
		last_time_here = now_here;
		if(cam->record == 1)
		{
			if(cam->starting_time == 0)
			{
				cam->starting_time = local_timestamp();
			}
			else
			{
				cam->running_time += (local_timestamp() - cam->starting_time);
				cam->starting_time = local_timestamp();
			}
		}
		else
		{
			cam->starting_time = 0;
		}
		if(cam->current_fps > 0)
		{
			int use_fps = cam->current_fps;
			if(muxing == 1)
			{
				if(use_fps < 24) use_fps = 24;
				if(use_fps > 30) use_fps = 30;
			}
			else
			{
				if(use_fps < 1) use_fps = 1;
			}
			int total_seconds = cam->running_time / 1000;
			minutes = total_seconds / 60;
			seconds = total_seconds % 60;
		}
		if(cam == DisplayedCamera())
		{
			if(hide_status == 0)
			{
				sprintf(buf, "%06d %03d:%02d [%06.02f : %06.02f] %6.2f (%d x %d) [%ld]", recorded_frames, minutes, seconds, cam->current_fps, calc_fps, cam->fps, cam->width, cam->height, use_here);
				fl_font(FL_HELVETICA, 14 * gui_scale_factor);
				if(recording == 1)
				{
					fl_color(FL_YELLOW);
				}
				else
				{
					fl_color(FL_WHITE);
					fl_rect(10, 10, 22, 22);
				}
				fl_draw(buf, 42 * gui_scale_factor, 26 * gui_scale_factor);
			}
		}
	}
}

void	MyWin::CalcInitialFPS()
{
char	buf[256];

	Camera *cam = camera[current_source];
	cam->frame_cnt[stream]++;
	if(start_time == 0)
	{
		start_time = time(0);
	}
	time_t current_time = time(0);
	time_t elapsed = current_time - start_time;
	if(elapsed < 1) elapsed = 1;
	double nn_fps = (double)cam->frame_cnt[stream] / (double)elapsed;
	nn_fps *= 0.85;
	if(nn_fps < 4.0) nn_fps = 4.0;
	if(cam->old_fps == (int)nn_fps)
	{
		cam->fps_cnt++;
	}
	cam->old_fps = (int)nn_fps;
	if((elapsed >= 100) || (cam->fps_cnt > 100))
	{
		cam->fps = nn_fps;
		cam->frame_cnt[stream] = 0;
	}
	sprintf(buf, "Testing: %d (%2.2f FPS)", (int)elapsed, nn_fps);
	fl_color(FL_BLACK);
	fl_rectf((w() / 2) - 55, (h() / 2) - 24, 170, 22);
	fl_color(FL_YELLOW);
	fl_font(FL_HELVETICA, 14);
	fl_draw(buf, (w() / 2) - 50, (h() / 2) - 10);
}

void	MyWin::ResizeDetail()
{
	fl_color(FL_WHITE);
	int nx = Fl::event_x();
	int ny = Fl::event_y();

	int nx1 = drag_start_x;
	int nx2 = nx;
	if(drag_start_x > nx)
	{
		nx1 = nx;
		nx2 = drag_start_x;
	}
	int ny1 = drag_start_y;
	int ny2 = ny;
	if(drag_start_y > ny)
	{
		ny1 = ny;
		ny2 = drag_start_y;
	}
	fl_rect(nx1, ny1, nx2 - nx1, ny2 - ny1);
}

void	MyWin::DrawThumbnails()
{
int	loop;

	int tg_cnt = 0;
	int displayed_cnt = 0;
	for(loop = source_cnt;loop < 128;loop++)
	{
		ThumbGroup *tb = thumbnail[loop];
		if(tb != NULL)
		{
			tb->hide();
		}
	}
	int viewable = 0;
	if(video_thumbnail_group->visible())
	{
		for(loop = 0;loop < 128;loop++)
		{
			ThumbGroup *tb = thumbnail[loop];
			if((camera[loop] != NULL) && (tb != NULL))
			{
				Camera *cam = camera[loop];
				if(cam->power == 1)
				{
					viewable++;
				}
			}
		}
	}
	int extent_y = 0;
	if(video_thumbnail_group->visible())
	{
		for(loop = 0;loop < 128;loop++)
		{
			ThumbGroup *tb = thumbnail[loop];
			if((camera[loop] != NULL) && (tb != NULL))
			{
				Camera *cam = camera[loop];
				if(cam->power == 1)
				{
					VideoCapture *cap = cam->cap;
					if(cap != NULL)
					{
						int nw = 153 * gui_scale_factor;
						int nh = 86 * gui_scale_factor;
						tb->thumb_button->index = loop;
						if(cam->type == CAMERA_TYPE_CAMERA)
						{
							if(cap->isOpened())
							{
								if(redraw_cnt == 0)
								{
									Mat new_mat;
									if(!cam->mat.empty())
									{
										if((cam->mat.rows > 0) && (cam->mat.cols > 0))
										{
											cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
											tb->thumb_button->mat = new_mat;
											if(trigger_window != NULL)
											{
												ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
												trigger_thumb->mat = new_mat;
											}
										}
									}
								}
							}
						}
						else if((cam->type == CAMERA_TYPE_TEXT) || (cam->type == CAMERA_TYPE_PIPED))
						{
							if(redraw_cnt == 0)
							{
								if(!cam->mat.empty())
								{
									if((cam->mat.rows > 0) && (cam->mat.cols > 0))
									{
										Mat new_mat;
										cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
										tb->thumb_button->mat = new_mat;
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_DESKTOP)
						{
							if(redraw_cnt == 0)
							{
								if((desktop_mat.cols > 0) && (desktop_mat.rows > 0))
								{
									Mat new_mat;
									if((cam->grab_portion_x > -1)
									&& (cam->grab_portion_y > -1)
									&& (cam->grab_portion_w > -1)
									&& (cam->grab_portion_h > -1))
									{
										GrabDesktop(1);
										Mat local_mat = desktop_mat(Rect(cam->grab_portion_x, cam->grab_portion_y, cam->grab_portion_w, cam->grab_portion_h));
										Mat use_mat = local_mat;
										if(!use_mat.empty())
										{
											cv::resize(use_mat, new_mat, cv::Size(nw, nh));
										}
									}
									else
									{
										if(!desktop_mat.empty())
										{
											cv::resize(desktop_mat, new_mat, cv::Size(nw, nh));
										}
									}
									tb->thumb_button->mat = new_mat;
									if(trigger_window != NULL)
									{
										ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
										trigger_thumb->mat = new_mat;
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_WINDOW)
						{
							if(redraw_cnt == 0)
							{
								if(!cam->mat.empty())
								{
									Mat new_mat;
									cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
									tb->thumb_button->mat = new_mat;
									if(trigger_window != NULL)
									{
										ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
										trigger_thumb->mat = new_mat;
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_PSEUDO)
						{
							if(redraw_cnt == 0)
							{
								if(!cam->mat.empty())
								{
									Mat new_mat;
									cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
									tb->thumb_button->mat = new_mat;
									if(trigger_window != NULL)
									{
										ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
										trigger_thumb->mat = new_mat;
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_PLUGIN)
						{
							if(redraw_cnt == 0)
							{
								if(!cam->mat.empty())
								{
									Mat new_mat;
									cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
									tb->thumb_button->mat = new_mat;
									if(trigger_window != NULL)
									{
										ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
										trigger_thumb->mat = new_mat;
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_IMAGE)
						{
							if(redraw_cnt == 0)
							{
								Mat new_mat;
								if(!cam->mat.empty())
								{
									if((cam->mat.rows > 0) && (cam->mat.cols > 0))
									{
										cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
										tb->thumb_button->mat = new_mat;
										if(trigger_window != NULL)
										{
											ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
											trigger_thumb->mat = new_mat;
										}
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_SOURCED)
						{
							if(redraw_cnt == 0)
							{
								Mat new_mat;
								if(!cam->mat.empty())
								{
									if((cam->mat.rows > 0) && (cam->mat.cols > 0))
									{
										cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
										tb->thumb_button->mat = new_mat;
										if(trigger_window != NULL)
										{
											ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
											trigger_thumb->mat = new_mat;
										}
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_OSG)
						{
							if(redraw_cnt == 0)
							{
								Mat new_mat;
								if(!cam->mat.empty())
								{
									if((cam->mat.rows > 0) && (cam->mat.cols > 0))
									{
										cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
										tb->thumb_button->mat = new_mat;
										if(trigger_window != NULL)
										{
											ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
											trigger_thumb->mat = new_mat;
										}
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_EDGE_DETECT)
						{
							if(redraw_cnt == 0)
							{
								Mat new_mat;
								if(!cam->mat.empty())
								{
									if((cam->mat.rows > 0) && (cam->mat.cols > 0))
									{
										cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
										tb->thumb_button->mat = new_mat;
										if(trigger_window != NULL)
										{
											ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
											trigger_thumb->mat = new_mat;
										}
									}
								}
							}
						}
						else if(cam->type == CAMERA_TYPE_CHROMAKEY)
						{
							if(redraw_cnt == 0)
							{
								if(!cam->mat.empty())
								{
									Mat new_mat;
									if((cam->mat.rows > 0) && (cam->mat.cols > 0))
									{
										cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
										tb->thumb_button->mat = new_mat;
										if(trigger_window != NULL)
										{
											ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
											trigger_thumb->mat = new_mat;
										}
									}
								}
							}
						}
						else
						{
							if(redraw_cnt == 0)
							{
								if(!cam->mat.empty())
								{
									Mat new_mat;
									if((cam->mat.rows > 0) && (cam->mat.cols > 0))
									{
										cv::resize(cam->mat, new_mat, cv::Size(nw, nh));
										tb->thumb_button->mat = new_mat;
										if(trigger_window != NULL)
										{
											ThumbButton *trigger_thumb = trigger_window->thumbnail[loop];
											trigger_thumb->mat = new_mat;
										}
									}
								}
							}
						}
					}
					if((cam->type == CAMERA_TYPE_IMAGE) || (cam->type == CAMERA_TYPE_TEXT) || (cam->type == CAMERA_TYPE_PIPED))
					{
						tb->set_color->show();
						if((cam->type == CAMERA_TYPE_TEXT) || (cam->type == CAMERA_TYPE_PIPED))
						{
							tb->set_text_color->show();
						}
					}
					if((tg_cnt >= start_thumbgroup) && (tg_cnt < (start_thumbgroup + DISPLAYED_THUMB_CNT)))
					{
						tb->redraw();
						tb->resize(20, 80 + ((120 * displayed_cnt) * gui_scale_factor), tb->w(), tb->h());
						tb->show();
						fl_color(FL_YELLOW);
						if(loop == displayed_source)
						{
							fl_rect(tb->x() - 3, tb->y() - 3, tb->w() + 6, tb->h() + 6);
						}
						fl_font(FL_HELVETICA, (12 * gui_scale_factor));
						if(strlen(cam->alias) > 0)
						{
							fl_draw(cam->alias, tb->x(), tb->y() + tb->h() + (15 * gui_scale_factor));
						}
						else
						{
							fl_draw(cam->path, tb->x(), tb->y() + tb->h() + (15 * gui_scale_factor));
						}
						displayed_cnt++;
						extent_y = tb->y() + tb->h() + (15 * gui_scale_factor);
					}
					tg_cnt++;
				}
				else
				{
					tb->redraw();
					tb->resize(20, 80 + ((120 * displayed_cnt) * gui_scale_factor), tb->w(), tb->h());
					tb->show();
					fl_color(FL_BLACK);
					fl_rectf(tb->x() - 3, tb->y() - 3, tb->w() + 6, tb->h() + 6);
					fl_color(FL_GRAY);
					if(loop == displayed_source)
					{
						fl_rect(tb->x() - 3, tb->y() - 3, tb->w() + 6, tb->h() + 6);
						fl_font(FL_HELVETICA, (12 * gui_scale_factor));
					}
					if(strlen(cam->alias) > 0)
					{
						fl_draw(cam->alias, tb->x(), tb->y() + tb->h() + (15 * gui_scale_factor));
					}
					else
					{
						fl_draw(cam->path, tb->x(), tb->y() + tb->h() + (15 * gui_scale_factor));
					}
					extent_y = tb->y() + tb->h() + (15 * gui_scale_factor);
					displayed_cnt++;
				}
			}
		}
	}
	if(viewable > DISPLAYED_THUMB_CNT)
	{
		fl_color(FL_YELLOW);
		fl_rect(0, extent_y + 15, 260, 10);
	}
}

void	MyWin::TriggerCamera(Camera *cam)
{
int	loop;

	if(cam != NULL)
	{
		if(cam->trigger_cnt > 0)
		{
			int flag = 0;
			for(loop = 0;loop < cam->trigger_cnt;loop++)
			{
				int trig = cam->trigger[loop];
				if(trig > -1)
				{
					if(camera[trig] != NULL)
					{
						if(camera[trig] != cam)
						{
							if(camera[trig]->record == 1)
							{
								cam->record = 1;
								flag = 1;
							}
						}
					}
				}
			}
			if(flag == 0)
			{
				cam->record = 0;
			}
		}
	}
}

void	MyWin::DrawPIP()
{
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if((im_drawing_mode == 0) || (recording == 0))
		{
			if(camera[cam->pip_idx] != NULL)
			{
				Mat local_mat;
				camera[cam->pip_idx]->Capture();
				local_mat = camera[cam->pip_idx]->mat;
				if(!local_mat.empty())
				{
					Mat new_mat;
					int nw = local_mat.cols / 2;
					int nh = local_mat.rows / 2;
					cv::resize(local_mat, new_mat, cv::Size(nw, nh));
					fl_draw_image((unsigned char *)new_mat.ptr(), w() - (nw + 50), h() - (nh + 50), new_mat.cols, new_mat.rows, new_mat.channels());
					if(cam->keep_pip == 0)
					{
						fl_color(FL_WHITE);
					}
					else
					{
						fl_color(FL_YELLOW);
					}
					fl_rect(w() - (nw + 50), h() - (nh + 50), new_mat.cols, new_mat.rows);
				}
			}
		}
	}
}

void	MyWin::DrawEmbeddedPIP()
{
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if(camera[cam->pip_idx] != NULL)
		{
			Mat local_mat;
			camera[cam->pip_idx]->Capture();
			local_mat = camera[cam->pip_idx]->mat;
			if(!local_mat.empty())
			{
				Mat new_mat;
				Mat dst = cam->mat;
				int nw = (int)((double)local_mat.cols * pip_size);
				int nh = (int)((double)local_mat.rows * pip_size);
				cv::resize(local_mat, new_mat, cv::Size(nw, nh));

				int px = (int)((double)dst.cols * pip_x_position);
				int py = (int)((double)dst.rows * pip_y_position);

				int dx = dst.cols - (px + nw);
				if(dx < 0) px += dx;
				int dy = dst.rows - (py + nh);
				if(dy < 0) py += dy;

				new_mat.copyTo(dst.rowRange(py, py + nh).colRange(px, px + nw));
				if((pip_red > -1) && (pip_green > -1) && (pip_blue > -1))
				{
					rectangle(dst, Point(px, py), Point(px + nw, py + nh), Scalar(pip_blue, pip_green, pip_red), 1);
				}
			}
		}
	}
}

void	MyWin::DrawEncodingMessage()
{
char	buf[256];

	int ww = (w() / 2);
	sprintf(buf, "Encoding: %d of %d", encoding, encoding_frame_cnt);
	int xx = 0;
	int yy = 0;
	fl_measure(buf, xx, yy);
	int nx = ww - (xx / 2);
	fl_color(FL_BLACK);
	fl_rectf(nx, 12, 250, 22);
	fl_font(FL_HELVETICA, 14);
	fl_color(FL_YELLOW);
	fl_draw(buf, nx, 12, 250, 22, FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
}

void	update_extracting_message(int type)
{
	if(global_window != NULL)
	{
		global_window->extracting += type;
		if((global_window->extracting % 100) == 0)
		{
			global_window->redraw();
			Fl::check();
		}
	}
}

void	MyWin::DrawExtractingMessage()
{
char	buf[256];

	if(extracting > 0)
	{
		sprintf(buf, "Extracting Video: %d", abs(extracting));
	}
	else
	{
		sprintf(buf, "Extracting Audio: %d", abs(extracting));
	}
	fl_color(FL_BLACK);
	fl_rectf(360, 8, 250, 22);
	fl_font(FL_HELVETICA, 14);
	fl_color(FL_YELLOW);
	fl_draw(buf, 380, 22);
}

void	MyWin::DrawDumpingMessage()
{
char	buf[256];

	if(dumped_limit > -1)
	{
		sprintf(buf, "%s: %ld OF %ld", dump_type, dumped_frames, dumped_limit);
	}
	else if(dumped_frames > -1)
	{
		sprintf(buf, "%s: %ld", dump_type, dumped_frames);
	}
	else
	{
		sprintf(buf, "%s", dump_type);
	}
	fl_color(FL_BLACK);
	fl_rectf(360, 8, 250, 22);
	fl_font(FL_HELVETICA, 14);
	fl_color(FL_YELLOW);
	fl_draw(buf, 380, 22);
}

void	MyWin::AllCameraMotion()
{
Mat	local_mat;
int	loop;

	for(loop = 0;loop < source_cnt;loop++)
	{
		if(camera[loop] != NULL)
		{
			VideoCapture *cap = camera[loop]->cap;
			if(cap->isOpened())
			{
				*cap >> local_mat;
				if(!local_mat.empty())
				{
					Detect();
				}
			}
		}
	}
}

void	MyWin::SelectRecordingCamera()
{
int	outer;

	int cnt = 0;
	int use_cam = -1;
	for(outer = 0;outer < source_cnt;outer++)
	{
		if(camera[outer] != NULL)
		{
			Camera *cam = camera[outer];
			if(cam->record == 1)
			{
				cnt++;
				use_cam = outer;
			}
		}
	}
	if(cnt == 1)
	{
		Display(use_cam);
	}
}

void	MyWin::SetAllCamerasToStream(Camera *in_cam)
{
int	outer;

	int cnt = 0;
	int use_cam = -1;
	for(outer = 0;outer < source_cnt;outer++)
	{
		if(camera[outer] != NULL)
		{
			Camera *cam = camera[outer];
			cam->save_fifo = in_cam->save_fifo;
			cam->fd[0] = in_cam->fd[0];
			cam->fd[1] = in_cam->fd[1];
		}
	}
}

void	MyWin::SetAllCamerasToStop()
{
int	outer;

	int cnt = 0;
	int use_cam = -1;
	for(outer = 0;outer < source_cnt;outer++)
	{
		if(camera[outer] != NULL)
		{
			Camera *cam = camera[outer];
			cam->stopped = 1;
		}
	}
}

void	MyWin::SetAllCamerasToGo()
{
int	outer;

	int cnt = 0;
	int use_cam = -1;
	for(outer = 0;outer < source_cnt;outer++)
	{
		if(camera[outer] != NULL)
		{
			Camera *cam = camera[outer];
			cam->stopped = 0;
		}
	}
}

void	Camera::ColorIntensity(Mat frame, double red, double green, double blue, double alpha)
{
vector<Mat>	layer;
int		i, j, n;

	unsigned char *ptr = frame.ptr();
	int channels = frame.channels();
	if(ptr != NULL)
	{
		for(j = 0; j < frame.rows; j++)
		{
			for(i = 0; i < frame.cols; i++)
			{
				for(n = 0;n < channels;n++)
				{
					int val = (int)*ptr;
					if(n == 0)
					{
						val = (int)((double)val * red);
					}
					else if(n == 1)
					{
						val = (int)((double)val * green);
					}
					else if(n == 2)
					{
						val = (int)((double)val * blue);
					}
					else if(n == 3)
					{
						val = (int)((double)val * alpha);
					}
					if(val < 0) val = 0;
					if(val > 255) val = 255;
					*ptr = (unsigned char)val;
					ptr++;
				}
			}
		}
	}
}

void drawTransparency(Mat frame, Mat transp, int xPos, int yPos)
{
Mat mask;
vector<Mat> layers;

	Mat use;
	split(transp, layers); // seperate channels
	Mat rgb[3] = { layers[0], layers[1], layers[2] };
	mask = layers[3]; // png's alpha channel used as mask
	merge(rgb, 3, use);  // put together the RGB channels, now transp is not transparent
	int sx = xPos;
	if(sx < 0)
	{
		sx = 0;
	}
	int sy = yPos;
	if(sy < 0)
	{
		sy = 0;
	}
	int ex = xPos + transp.cols;
	if(ex >= frame.cols)
	{
		ex = (frame.cols - 1);
	}
	int ey = yPos + transp.rows;
	if(ey >= frame.rows)
	{
		ey = (frame.rows - 1);
	}
	int tw = (ex - sx);
	int th = (ey - sy);
	if((tw > 0) && (th > 0)
	&& (tw == use.cols) && (th == use.rows))
	{
		cvtColor(use, use, COLOR_RGB2RGBA);
		use.copyTo(frame.rowRange(sy, ey).colRange(sx, ex), mask);
	}
}

void	MyWin::FrameForMuxer(Camera *cam, Mat in_mat)
{
static Mat	local_mat[128];
int			loop;

	pthread_mutex_lock(&mux_mutex);
	int use = cam->id;
	if((output_width != in_mat.cols) || (output_height != in_mat.rows))
	{
		cv::resize(in_mat, local_mat[use], cv::Size(output_width, output_height));
		cvtColor(local_mat[use], local_mat[use], COLOR_RGB2YUV_I420);
	}
	else
	{
		cvtColor(in_mat, local_mat[use], COLOR_RGB2YUV_I420);
	}
	if(single_stream == 0)
	{
		int use = cam->id;
		if(my_muxer[use] != NULL)
		{
			if(my_muxer[use]->fresh_image == 0)
			{
				my_muxer[use]->frame_ptr = local_mat[use].ptr();
				my_muxer[use]->fresh_image++;
			}
		}
	}
	else
	{
		for(loop = 0;loop < 128;loop++)
		{
			if(my_muxer[loop] != NULL)
			{
				if(my_muxer[loop]->fresh_image == 0)
				{
					my_muxer[loop]->frame_ptr = local_mat[use].ptr();
					my_muxer[loop]->fresh_image = 1;
				}
			}
		}
	}
	pthread_mutex_unlock(&mux_mutex);
}

void	Camera::ShowImmediateList()
{
int	loop;
int	outer;

	for(outer = 0;outer < 8;outer++)
	{
		if(layer_state[outer] == 1)
		{
			int moving_element = 0;
			int someone_is_dragging = 0;
			DrawImageWindowsBefore(outer, 0, mat, moving_element, someone_is_dragging);
			if(immediate_list != NULL)
			{
				for(loop = 0;loop < immediate_cnt;loop++)
				{
					if(immediate_list[loop] != NULL)
					{
						if(immediate_list[loop]->layer == outer)
						{
							immediate_list[loop]->show();
							immediate_list[loop]->redraw();
							immediate_list[loop]->draw();
						}
					}
				}
			}
		}
	}
}

void	Camera::HideImmediateList()
{
int	loop;

	if(immediate_list != NULL)
	{
		for(loop = 0;loop < immediate_cnt;loop++)
		{
			if(immediate_list[loop] != NULL)
			{
				immediate_list[loop]->hide();
			}
		}
	}
}

int	Camera::CheckRecurseChildren(Camera *in, Camera *find)
{
int	loop;

	int rr = 0;
	for(loop = 0;((loop < 128) && (rr == 0));loop++)
	{
		if(in->image_window[loop] != NULL)
		{
			Camera *camera = in->image_window[loop]->camera;
			if(camera != NULL)
			{
				if(camera == find)
				{
					rr = 1;
				}
				else
				{
					rr = camera->CheckRecurseChildren(camera, find);
				}
			}
		}
	}
	return(rr);
}

int	Camera::CheckRecursion(Camera *dest)
{
int	loop;

	int rr = 0;
	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			Camera *camera = image_window[loop]->camera;
			if(camera != NULL)
			{
				if(camera == dest)
				{
					rr = 1;
				}
			}
		}
	}
	return(rr);
}

void	Camera::DrawImageWindowsBefore(int current_layer, int check_only, Mat& in_mat, int& moving_element, int& someone_is_dragging)
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->buttonize == 0)
			{
				if(check_only == 0)
				{
					if((image_window[loop]->layer == current_layer)
					|| (current_layer == -1))
					{
						image_window[loop]->Draw(this);
						in_mat = mat;
					}
				}
				if(image_window[loop]->transform == MODE_MOVING)
				{
					moving_element = 1;
				}
				if(image_window[loop]->dragging == 1)
				{
					someone_is_dragging = 1;
				}
			}
		}
	}
}

void	Camera::DrawImageWindowsAfter()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->buttonize == 1)
			{
				image_window[loop]->Draw(this);
			}
			else if(image_window[loop]->dragging == 1)
			{
				fl_color(FL_WHITE);
				int xx = image_window[loop]->x();
				int yy = image_window[loop]->y();
				int ww = image_window[loop]->w();
				int hh = image_window[loop]->h();
				fl_rect(xx, yy, ww, hh);
			}
		}
	}
}

void	Camera::DrawEmbeddedPIP()
{
	if((pip_idx > -1) && (pip_idx != my_window->displayed_source))
	{
		Camera *local_cam = my_window->camera[pip_idx];
		if(local_cam != NULL)
		{
			if(local_cam->power == 1)
			{
				VideoCapture *cap = local_cam->cap;
				if(cap != NULL)
				{
					my_window->DrawEmbeddedPIP();
				}
			}
		}
	}
}

void	Camera::DrawImageWindowGrid(int grid_size)
{
int	loop;

	int cam_x = image_sx;
	int cam_y = image_sy;
	int cam_w = width;
	int cam_h = height;
	fl_color(FL_GRAY);
	for(loop = cam_x;loop < cam_x + cam_w;loop += grid_size)
	{
		fl_line(loop, cam_y, loop, cam_y + cam_h);
	}
	for(loop = cam_y;loop < cam_y + cam_h;loop += grid_size)
	{
		fl_line(cam_x, loop, cam_x + cam_w, loop);
	}
}

void	Camera::DisplayAVWindow()
{
	if(av_window != NULL)
	{
		double position = av_window->Position();
		int ww = mat.cols;
		int pp = (int)((double)ww * position);
		int nx = image_sx;
		int ny = (image_sy + mat.rows);
		int val = (image_sx + pp);
		if(my_window->progress_scrubber != NULL)
		{
			my_window->progress_scrubber->resize(nx, ny, ww, 40);
			my_window->progress_scrubber->Position(position);
			my_window->progress_scrubber->show();
			my_window->progress_scrubber->draw();
		}
	}
}

void	MyWin::DrawPIPsAfter()
{
	if(embed_pip == 0)
	{
		Camera *cam = DisplayedCamera();
		if(cam != NULL)
		{
			if(multipip > 0)
			{
				cam->DrawPIP();
			}
			else
			{
				if((cam->pip_idx > -1) && (cam->pip_idx != displayed_source))
				{
					Camera *local_cam = camera[cam->pip_idx];
					if(local_cam != NULL)
					{
						if(local_cam->power == 1)
						{
							VideoCapture *cap = local_cam->cap;
							if(cap != NULL)
							{
								DrawPIP();
							}
						}
					}
				}
			}
		}
	}
}

void	MyWin::DisplayOutput(Camera *cam, Mat in_mat, Camera *alt_cam)
{
	if(display_video == 1)
	{
		double gsf = gui_scale_factor;
		int local_display_width = cam->display_width * image_display_scale;
		int local_display_height = cam->display_height * image_display_scale;
		if(alt_cam == NULL)
		{
			if(((cam->motion_detect == 1) || (cam->follow_motion == 1)) && (motion_debug == 1))
			{
				if((cam->motion_mat.rows == cam->mat.rows)
				&& (cam->motion_mat.cols == cam->mat.cols))
				{
					Mat dst, cow_gray;
					cvtColor(cam->mat, cow_gray, COLOR_RGB2GRAY);
					addWeighted(cow_gray, 0.5, cam->motion_mat, 0.5, 0.0, dst);
					fl_draw_image((unsigned char *)dst.ptr(), cam->image_sx * gsf, cam->image_sy * gsf, cam->motion_mat.cols, cam->motion_mat.rows, cam->motion_mat.channels());
					image_origin_x = cam->image_sx;
					image_origin_y = cam->image_sy;
				}
			}
			else
			{
				if((local_display_width != in_mat.cols) || (local_display_height != in_mat.rows))
				{
					Mat really_local_mat;
					int interpolation = cv::INTER_AREA;
					if(image_display_scale > 1.0)
					{
						interpolation = cv::INTER_CUBIC;
					}
					cv::resize(in_mat, really_local_mat, cv::Size(local_display_width, local_display_height), 0, 0, interpolation);
					int use_x = (Fl::w() / 2) - (really_local_mat.cols / 2);
					int use_y = (Fl::h() / 2) - (really_local_mat.rows / 2);
					fl_draw_image((unsigned char *)really_local_mat.ptr(), use_x * gsf, use_y * gsf, really_local_mat.cols, really_local_mat.rows, really_local_mat.channels());
					image_origin_x = use_x;
					image_origin_y = use_y;
				}
				else
				{
					cam->image_sx = (w() / 2) - (cam->mat.cols / 2);
					cam->image_sy = (h() / 2) - (cam->mat.rows / 2);
					fl_draw_image((unsigned char *)in_mat.ptr(), cam->image_sx, cam->image_sy, cam->mat.cols, cam->mat.rows, cam->mat.channels());
					image_origin_x = cam->image_sx;
					image_origin_y = cam->image_sy;
				}
			}
		}
		else
		{
			Mat use_mat = alt_cam->mat;
			Mat really_local_mat;
			int interpolation = cv::INTER_AREA;
			if(image_display_scale > 1.0)
			{
				interpolation = cv::INTER_CUBIC;
			}
			cv::resize(use_mat, really_local_mat, cv::Size(local_display_width, local_display_height), 0, 0, interpolation);
			int use_x = (Fl::w() / 2) - (really_local_mat.cols / 2);
			int use_y = (Fl::h() / 2) - (really_local_mat.rows / 2);
			fl_draw_image((unsigned char *)really_local_mat.ptr(), use_x * gsf, use_y * gsf, really_local_mat.cols, really_local_mat.rows, really_local_mat.channels());
			image_origin_x = use_x;
			image_origin_y = use_y;
		}
	}
}

void	MyWin::DrawPTZZoomer(int use_image_sx, int use_image_sy)
{
int	loop;

	if((use_image_sx > -1) && (use_image_sy > -1))
	{
		int xx = use_image_sx + 10;
		int yy = (use_image_sy + in_mat.rows) - 40;
		for(loop = 0;loop < abs(ptz_zoomer_speed);loop++)
		{
			if(ptz_zoomer > 0)
			{
				fl_color(FL_WHITE);
				fl_line(xx, yy - (loop * 2), xx + 10, yy - (loop * 2));
			}
			else
			{
				fl_color(FL_YELLOW);
				fl_line(xx, yy + (loop * 2), xx + 10, yy + (loop * 2));
			}
		}
	}
}

void	MyWin::DrawEmbeddedApps()
{
int	loop;

	for(loop = 0;loop < 10;loop++)
	{
		EmbedAppWindow *eaw = embedded_app[loop];
		if(eaw != NULL)
		{
			if(eaw->viz == 0)
			{
				fl_color(DARK_GRAY);
				fl_rectf(eaw->my_x, h() - 25, eaw->my_w, 25);
				fl_color(FL_WHITE);
				fl_draw(eaw->title, eaw->my_x, h() - 25, eaw->my_w, 25, FL_ALIGN_CENTER);
			}
		}
	}
}

void	Camera::DrawFilterDialogs()
{
int	loop;

	int yy = Fl::event_y();
	if(yy > (my_window->h() - 220))
	{
		int cnt = 0;
		Camera *show_em = my_window->DisplayedCamera();
		for(loop = 0;loop < filter_cnt;loop++)
		{
			if(filter_name[loop] != NULL)
			{
				if(filter_dialog[loop] != NULL)
				{
					if(show_em == this)
					{
						filter_dialog[loop]->resize(345 + (cnt * 102), my_window->h() - 220, filter_dialog[loop]->w(), filter_dialog[loop]->h());
						filter_dialog[loop]->show();
					}
					else
					{
						filter_dialog[loop]->hide();
					}
				}
				cnt++;
			}
		}
	}
	else
	{
		for(loop = 0;loop < filter_cnt;loop++)
		{
			if(filter_dialog[loop] != NULL)
			{
				filter_dialog[loop]->hide();
			}
		}
	}
}

void	MyWin::draw()
{
Mat		CropSection(Mat source, Mat& cropped, int xx, int yy, int ww, int hh);
struct tm	*tm;
int		loop;
char		buf[256];
int		inner;
int		outer;

	fl_color(FL_BLACK);
	fl_rectf(0, 0, w(), h());
	fl_color(FL_YELLOW);
	fl_font(FL_HELVETICA, 11);
	int use_image_sx = -1;
	int use_image_sy = -1;
	GrabAllCameras();
	if(display_recording_camera == 1)
	{
		SelectRecordingCamera();
	}
	Camera *alt_cam = NULL;
	for(outer = 0;outer < source_cnt;outer++)
	{
		if(camera[outer] != NULL)
		{
			Camera *cam = camera[outer];
			if(cam->power == 1)
			{
				VideoCapture *cap = cam->cap;
				if(cap != NULL)
				{
					if(cap->isOpened())
					{
						TriggerCamera(cam);
					}
					else if(cam->type == CAMERA_TYPE_IMAGE)
					{
						TriggerCamera(cam);
					}
				}
				current_source = outer;
				all_frames++;
				if((redraw_cnt == 0) 
				|| (outer == displayed_source) 
				|| (split == 1) 
				|| (cam->priority == 1) 
				|| (cam->snapshot == 1) 
				|| (cam->record == 1))
				{
					cam->Capture();
					cam->focus_frame_ready = 1;
					if(alt_displayed_source > -1)
					{
						alt_cam = camera[alt_displayed_source];
						if(alt_cam->power == 1)
						{
							alt_cam->Capture();	
						}
					}
				}
				if(outer == displayed_source)
				{
					if(embed_pip == 1)
					{
						if(multipip > 0)
						{
							cam->DrawPIP();
						}
						else
						{
							cam->DrawEmbeddedPIP();
						}
					}
				}
				in_mat = cam->mat;
				if(!in_mat.empty())
				{
					cam->true_total_frames[stream]++;
					cam->local_ts = local_timestamp();
					int moving_element = 0;
					int someone_is_dragging = 0;
					if(cam->record == 1)
					{
						cam->DrawImageWindowsBefore(-1, 1, in_mat, moving_element, someone_is_dragging);
						if((muxer_cnt > 0) || (single_stream == 0))
						{
							FrameForMuxer(cam, in_mat);
						}
					}
					if(direct_recording == 2)
					{
						cvtColor(in_mat, yuv, COLOR_RGB2YCrCb);
					}
					if(transmitting == 1)
					{
						if(outer == displayed_source)
						{
							cam->PrepImageForNet(in_mat);
						}
					}
					int took_snapshot = 0;
					if(cam->snapshot == 1)
					{
						if(outer == displayed_source)
						{
							cam->SnapshotFrame();
							fl_color(FL_YELLOW);
							took_snapshot = 1;
							cam->snapshot = 0;
						}
					}
					if(outer == displayed_source)
					{
						if(split == 0)
						{
							if(cam->zoom_box_display == 0)
							{
								use_image_sx = cam->image_sx;
								use_image_sy = cam->image_sy;
							}
							DisplayOutput(cam, in_mat, alt_cam);
							if(move_corner == 1)
							{
								fl_color(FL_YELLOW);
								fl_rectf(cam->image_sx + 2, cam->image_sy + 2, 25, 25);
							}
							if(resize_corner == 1)
							{
								fl_color(FL_BLUE);
								fl_rectf(cam->image_sx + cam->display_width - 27, cam->image_sy + cam->display_height - 27, 25, 25);
							}
							if(restore_corner == 1)
							{
								fl_color(FL_GREEN);
								fl_rectf(cam->image_sx + 2, cam->image_sy + cam->display_height - 27, 25, 25);
							}
							if((buttonized_visible == 1) || (someone_is_dragging == 1))
							{
								cam->DrawImageWindowsAfter();
							}
							if(grid_size > 1)
							{
								if(moving_element == 1)
								{
									cam->DrawImageWindowGrid(grid_size);
								}
							}
						}
					}
					if(took_snapshot == 1)
					{
						if((cam->display_width < w()) || (cam->display_height < h()))
						{
							fl_rect(cam->image_sx - 5, cam->image_sy - 5, cam->display_width + 10, cam->display_height + 10);
						}
						else
						{
							fl_rectf(0, 0, w(), h());
						}
					}
					if(mark_interest == 1)
					{
						if(split == 0)
						{
							MarkInterestGrid();
						}
					}
					else if(cam->fps > 0.0)
					{
						if((resizing_detail == 0) && (zoom_boxing == 0))
						{
							if((cam->follow_motion == 1) 
							|| (cam->follow_objects == 1) 	
							|| (cam->motion_detect == 1) 
							|| (cam->object_detect == 1)
							|| (cam->record == 1))
							{
								if(visible_debug == 0)
								{
									Detect();
								}
							}
							if(cam->record == 1)
							{
								if(buttonized_visible == 0)
								{
									if(pulse_mixer != NULL)
									{
										if(split == 0)
										{
											DrawAudioGraph(cam);
										}
									}
								}
							}
							if(stream == 0)
							{
								if(detail != NULL)
								{
									if(outer == displayed_source)
									{
										if(split == 0)
										{
											if(cam->record == 1)
											{
												DrawDetailFrame(FL_YELLOW);
											}
											else if((cam->follow_motion == 1) || (cam->follow_objects == 1))
											{
												DrawDetailFrame(FL_BLUE);
											}
											else if((cam->motion_detect == 1) || (cam->object_detect == 1))
											{
												DrawDetailFrame(FL_RED);
											}
											else
											{
												DrawDetailFrame(FL_WHITE);
											}
										}
									}
								}
							}
							if(cam == DisplayedCamera())
							{
								if(split == 0)
								{
									CurrentFPS();
								}
							}
						}
					}
					else
					{
						CalcInitialFPS();
					}
				}
				else
				{
					if((redraw_cnt == 0) || (outer == displayed_source))
					{
						printf("ERROR: No frame\n");
					}
				}
			}
			if(split == 0)
			{
				cam->DrawFilterDialogs();
				cam->HighlightShapes();
			}
		}
		else
		{
			printf("ERROR: current stream is NULL\n");
		}
	}
	if(split == 0)
	{
		if((magic_x > -1) && (magic_y > -1))
		{
			int sx = (w() / 2) - (1280 / 2) + magic_x;
			int sy = (h() / 2) - (720 / 2) + magic_y;
			fl_color(FL_YELLOW);
			fl_rect(sx, sy, 100, 100);
		}
		if(mark_interest == 1)
		{
			MarkInterest();
		}
		if(((resizing_detail == 1) || (zoom_boxing == 1)) && (drag_start_x > -1) && (drag_start_y > -1))
		{
			ResizeDetail();
		}
		if(ptz_zoomer != 0)
		{
			DrawPTZZoomer(use_image_sx, use_image_sy);
		}
		if(ptz_joystick == 1)
		{
			fl_color(FL_GRAY);
			int cx = w() / 2;
			int cy = h() / 2;
			for(loop = 1;loop <= 100;loop += 10)
			{
				fl_rect(cx - loop, cy - loop, (loop * 2), (loop * 2));
			}
			fl_color(FL_YELLOW);
			fl_rect(cx + (ptz_joystick_x - 10), cy + (ptz_joystick_y - 10), 20, 20);
		}
		if(center_message_timer > 0)
		{
			fl_color(FL_YELLOW);
			fl_font(FL_HELVETICA, 36);
			int use_x = 0;
			int use_y = 0;
			fl_measure(center_message, use_x, use_y);
			fl_draw(center_message, (w() / 2) - (use_x / 2), (h() / 2) - (use_y / 2));
			center_message_timer--;
		}
		if(source_cnt > 0)
		{
			if(video_thumbnail_group->visible())
			{
				DrawThumbnails();
			}
			DrawPIPsAfter();
		}
	}
	else
	{
		fl_rectf(x(), y(), w(), h(), FL_BLACK);
		SplitScreen();
	}
	if((dumped_frames > 0) || (dump_type != NULL))
	{
		DrawDumpingMessage();
	}
	if(encoding > 0)
	{
		DrawEncodingMessage();
	}
	if(extracting != 0)
	{
		DrawExtractingMessage();
	}
	else
	{
		Camera *cam = DisplayedCamera();
		if(cam != NULL)
		{
			if(cam->total_frames[stream] > 0)
			{
				if(direct_recording == 0)
				{
					if((muxing == 0) || (stream_only == 0))
					{
						encode_button->show();
					}
				}
			}
			if(cam->type == CAMERA_TYPE_AV)
			{
				cam->DisplayAVWindow();
			}
			else
			{
				progress_scrubber->hide();
			}
		}
		else
		{
			progress_scrubber->hide();
		}
	}
	Fl_Double_Window::draw();
	if(transitions_window != NULL)
	{
		if(transitions_window->visible())
		{
			transitions_window->Update();
		}
	}
	DrawEmbeddedApps();
	if(dragging_thumb != NULL)
	{
		ThumbButton *tb = dragging_thumb;
		fl_draw_image(tb->mat.ptr(), Fl::event_x(), Fl::event_y(), tb->mat.cols, tb->mat.rows, tb->mat.channels());
		dragging_thumb_x = Fl::event_x();
		dragging_thumb_y = Fl::event_y();
	}
	if(split == 0)
	{
		if((rubber_band_x > -1)
		&& (rubber_band_y > -1)
		&& (rubber_band_w > -1)
		&& (rubber_band_h > -1))
		{
			fl_color(FL_WHITE);
			fl_rect(rubber_band_x, rubber_band_y, rubber_band_w, rubber_band_h);
		}
	}
	redraw_cnt++;
	if(redraw_cnt > 60)
	{
		redraw_cnt = 0;
	}
	refreshed = 1;
}


void	adjust_mouse_image(XFixesCursorImage *img, unsigned char *out)
{
unsigned char r, g, b, a;
unsigned short row, col, pos;

	unsigned char *cp = out;
	pos = 0;
	for(row = 0;row < img->height;row++)
	{
		for(col = 0;col < img->width;col++)
		{
			a = (unsigned char)((img->pixels[pos] >> 24) & 0xff);  
			r = (unsigned char)((img->pixels[pos] >> 16) & 0xff);  
			g = (unsigned char)((img->pixels[pos] >>  8) & 0xff);
			b = (unsigned char)((img->pixels[pos] >>  0) & 0xff);
		
			*cp++ = r;
			*cp++ = g;
			*cp++ = b;
			*cp++ = a;

			pos++;
		}
	}
}

void	GetMouseImage(Mat& use)
{
	XFixesCursorImage *cur = XFixesGetCursorImage(fl_display);
	cv::Mat local_mat(cur->height, cur->width, CV_8UC4, (unsigned char *)cur->pixels);
	adjust_mouse_image(cur, local_mat.ptr());
	use = local_mat;
	XFree(cur);
}

void	AddMouse(Mat& dest, int mouse_x, int mouse_y)
{
void	drawTransparency(Mat frame, Mat transp, int xPos, int yPos);

	Mat mouse_mat;
	GetMouseImage(mouse_mat);
	drawTransparency(dest, mouse_mat, mouse_x, mouse_y);
}

static void map_busy_key(char *final)
{
int i;
unsigned char keymap[32];
unsigned char my_keymap[0xffff];
unsigned int state = 0;
int cap_lock = 0;
int num_lock = 0;

	strcpy(final, "");
	static unsigned int masktable[8] = {
		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
	};
	for(i = 0;i < 0xffff;i++)
	{
		my_keymap[i] = 0;
	}
	XkbGetIndicatorState (fl_display, XkbUseCoreKbd, &state);
	if((state & 1) == 1) cap_lock = 1;
	if((state & 2) == 2) num_lock = 1;

	XQueryKeymap(fl_display, (char *)keymap);
	int shifted = 0;
	int controlled = 0;
	int alted = 0;
	unsigned char cc = 0;
	for(i = 0; i < 256; i++) 
	{
		if(keymap[i >> 3] & masktable[i & 7]) 
		{
			KeySym ks = XkbKeycodeToKeysym(fl_display, (KeyCode)i, 0, 0);
			my_keymap[ks] = 1;
			char *cp = XKeysymToString(ks);
			if(cp != NULL)
			{
				if(strlen(cp) == 1)
				{
					cc = *cp;
				}
				else
				{
					if(((my_keymap[0xffe1] != 1) && (my_keymap[0xffe2] != 1))
					&& ((my_keymap[0xffe3] != 1) && (my_keymap[0xffe4] != 1))
					&& ((my_keymap[0xffe9] != 1) && (my_keymap[0xffea] != 1)))
					{
						strcpy(final, cp);
					}
					if(ks == 0x60) cc = '`';
					if(ks == 0x2d) cc = '-';
					if(ks == 0x3d) cc = '=';
					if(ks == 0x5b) cc = '[';
					if(ks == 0x5d) cc = ']';
					if(ks == 0x5c) cc = '\\';
					if(ks == 0x3b) cc = ';';
					if(ks == 0x27) cc = '\'';
					if(ks == 0x2c) cc = ',';
					if(ks == 0x2e) cc = '.';
					if(ks == 0x2f) cc = '/';
				}
			}
		}
	}
	// Timeouts provided for CAPS_LOCK and NUM_LOCK
	// so they won't toggle just because the user
	// lingers on the key.
	char *shift_str = "";
	char *ctrl_str = "";
	char *alt_str = "";
	if((my_keymap[0xffe1] == 1) || (my_keymap[0xffe2] == 1) || (cap_lock > 0))
	{
		shift_str = "SHIFT-";
		if((cc >= 'a') && (cc <= 'z'))
		{
			cc -= 32;
		}
		if((my_keymap[0xffe1] == 1) || (my_keymap[0xffe2] == 1))
		{
			if(cc == '`') cc = '~';
			else if(cc == '1') cc = '!';
			else if(cc == '2') cc = '@';
			else if(cc == '3') cc = '#';
			else if(cc == '4') cc = '$';
			else if(cc == '5') cc = '%';
			else if(cc == '6') cc = '^';
			else if(cc == '7') cc = '&';
			else if(cc == '8') cc = '*';
			else if(cc == '9') cc = '(';
			else if(cc == '0') cc = ')';
			else if(cc == '-') cc = '_';
			else if(cc == '=') cc = '+';
			else if(cc == '[') cc = '{';
			else if(cc == ']') cc = '}';
			else if(cc == '\\') cc = '|';
			else if(cc == ';') cc = ':';
			else if(cc == '\'') cc = '"';
			else if(cc == ',') cc = '<';
			else if(cc == '.') cc = '>';
			else if(cc == '/') cc = '?';
		}
	}
	if(num_lock > 0)
	{
		if(my_keymap[0xff95] == 1) cc = '7';
		if(my_keymap[0xff97] == 1) cc = '8';
		if(my_keymap[0xff9a] == 1) cc = '9';
		if(my_keymap[0xff96] == 1) cc = '4';
		if(my_keymap[0xff9d] == 1) cc = '5';
		if(my_keymap[0xff98] == 1) cc = '6';
		if(my_keymap[0xff9c] == 1) cc = '1';
		if(my_keymap[0xff99] == 1) cc = '2';
		if(my_keymap[0xff9b] == 1) cc = '3';
		if(my_keymap[0xff9e] == 1) cc = '0';
		if(my_keymap[0xff9f] == 1) cc = '.';
	}
	if((my_keymap[0xffe3] == 1) || (my_keymap[0xffe4] == 1))
	{
		ctrl_str = "CTRL-";
	}
	if((my_keymap[0xffe9] == 1) || (my_keymap[0xffea] == 1))
	{
		alt_str = "ALT-";
	}
	if(cc > 0)
	{
		sprintf(final, "%s%s%s%c", shift_str, ctrl_str, alt_str, cc);
	}
}

void	MyWin::FrameImage(Camera *cam, Mat& in_mat, Mat& out_mat, double force_aspect_x, double force_aspect_y)
{
Mat		CropSection(Mat source, Mat& cropped, int xx, int yy, int ww, int hh);

	if((force_aspect_x != 1.0) || (force_aspect_y != 1.0))
	{
		int ww = in_mat.cols * force_aspect_x;
		int hh = in_mat.rows * force_aspect_y;
		cv::resize(in_mat, in_mat, cv::Size(ww, hh));
	}
	if((in_mat.cols != output_width) || (in_mat.rows != output_height))
	{
		if(crop_scaling == 0)
		{
			double ratio = (double)in_mat.cols / (double)in_mat.rows;
			double output_ratio = (double)output_width / (double)output_height;
			if(ratio != output_ratio)
			{
				double use_ratio_x = (double)output_width / (double)in_mat.cols;
				double use_ratio_y = (double)output_height / (double)in_mat.rows;
				double use_ratio = use_ratio_y;
				if(use_ratio_x < use_ratio_y)
				{
					use_ratio = use_ratio_x;
				}
				int nn_rows = (int)((double)in_mat.rows * use_ratio);
				int nn_cols = (int)((double)in_mat.cols * use_ratio);
				cv::resize(in_mat, out_mat, cv::Size(nn_cols, nn_rows));
				if(in_mat.channels() == 4)
				{
					cv::Mat local_mat(output_height, output_width, CV_8UC4, cv::Scalar(0, 0, 0, 0));
					int start_x = (output_width / 2) - (out_mat.cols / 2);
					int start_y = (output_height / 2) - (out_mat.rows / 2);
					out_mat.copyTo(local_mat.rowRange(start_y, start_y + out_mat.rows).colRange(start_x, start_x + out_mat.cols));
					out_mat = local_mat.clone();
					cam->last_start_x = start_x;
					cam->last_start_y = start_y;
				}
				else
				{
					cv::Mat local_mat(output_height, output_width, CV_8UC3, cv::Scalar(0, 100, 80));
					int start_x = (output_width / 2) - (out_mat.cols / 2);
					int start_y = (output_height / 2) - (out_mat.rows / 2);
					out_mat.copyTo(local_mat.rowRange(start_y, start_y + out_mat.rows).colRange(start_x, start_x + out_mat.cols));
					out_mat = local_mat.clone();
					cam->last_start_x = start_x;
					cam->last_start_y = start_y;
				}
			}
		}
		else if(crop_scaling == 1)
		{
			if((in_mat.cols > output_width) && (in_mat.rows > output_height))
			{
				if(cam->crop_start_x + output_width >= in_mat.cols)
				{
					cam->crop_start_x = (in_mat.cols - output_width) - 1;
				}
				if(cam->crop_start_y + output_height >= in_mat.rows)
				{
					cam->crop_start_y = (in_mat.rows - output_height) - 1;
				}
				if(cam->crop_start_x < 0) cam->crop_start_x = 0;
				if(cam->crop_start_y < 0) cam->crop_start_y = 0;
				CropSection(in_mat, out_mat, cam->crop_start_x, cam->crop_start_y, output_width, output_height);
				cam->last_start_x = cam->crop_start_x;
				cam->last_start_y = cam->crop_start_y;
			}
			else if((in_mat.cols < output_width) && (in_mat.rows < output_height))
			{
				cv::Mat local_mat(output_height, output_width, CV_8UC4, cv::Scalar(0, 0, 0, 0));
				int start_x = (output_width / 2) - (out_mat.cols / 2);
				int start_y = (output_height / 2) - (out_mat.rows / 2);
				if(cam->use_crop_start == 1)
				{
					start_x = cam->crop_start_x;
					if(start_x + out_mat.cols >= local_mat.cols)
					{
						int diff = (start_x + out_mat.cols) - local_mat.cols;
						start_x -= (diff + 1);
					}
					start_y = cam->crop_start_y;
					if(start_y + out_mat.rows >= local_mat.rows)
					{
						int diff = (start_y + out_mat.rows) - local_mat.rows;
						start_y -= (diff + 1);
					}
				}
				out_mat.copyTo(local_mat.rowRange(start_y, start_y + out_mat.rows).colRange(start_x, start_x + out_mat.cols));
				out_mat = local_mat.clone();
				cam->last_start_x = start_x;
				cam->last_start_y = start_y;
			}
			else
			{
				cv::resize(in_mat, out_mat, cv::Size(output_width, output_height));
				cam->last_start_x = 0;
				cam->last_start_y = 0;
			}
		}
		else
		{
			cv::resize(in_mat, out_mat, cv::Size(output_width, output_height));
			cam->last_start_x = 0;
			cam->last_start_y = 0;
		}
	}
}

void	MyWin::GrabDesktop(int retain_size)
{
unsigned char	*grab_raw_image(Fl_Window *win, int xx, int yy, int ww, int hh, int *sz, int *in_depth);
void			XMouse(int& xx, int& yy, int& buttons);
Mat				CropSection(Mat source, Mat& cropped, int xx, int yy, int ww, int hh);
static int		radius = 10;
static char		buf[256];
static int 		text_countdown = 0;

	int depth = 0;
	int sz = 0;
	if(desktop_x == -1) desktop_x = 0;
	if(desktop_y == -1) desktop_y = 0;
	if(desktop_w == -1) desktop_w = Fl::w();
	if(desktop_h == -1) desktop_h = Fl::h();
	time_t start = time(0);
	unsigned char *b = NULL;
	Mat use;
	int alt_capture = 0;
	int width = 0;
	int height = 0;
	if(void_capture_capture != NULL)
	{
		b = local_capture_cap(&width, &height);
		alt_capture = 1;
		retain_size = 0;
	}
	else
	{
		b = grab_raw_image(NULL, desktop_x, desktop_y, desktop_w, desktop_h, &sz, &depth);
	}
	if(b != NULL)
	{
		int mx = 0;
		int my = 0;
		int buttons = 0;
		XMouse(mx, my, buttons);
		char keystring[256];
		strcpy(keystring, "");
		map_busy_key(keystring);
	
		double s = Fl::screen_scale(0);
		if(alt_capture == 0)
		{
			height = (int)(desktop_h * s);
			width = (int)(desktop_w * s);
		}
		Mat src(height, width, CV_8UC4, (void *)b);
		if((render_mouse == 1) && (alt_capture == 0))
		{
			if(tutorial_mode == 1)
			{
				int do_it = 0;
				Scalar line_color(150, 240, 255);
				if((buttons & BUTTON_1_MASK) == BUTTON_1_MASK)
				{
					do_it = 1;
					line_color = Scalar(150, 240, 255);
					sprintf(buf, "Mouse 1");
					text_countdown = 30;
				}
				if((buttons & BUTTON_2_MASK) == BUTTON_2_MASK)
				{
					do_it = 1;
					sprintf(buf, "Mouse 2");
					line_color = Scalar(255, 240, 150);
					text_countdown = 30;
				}
				if((buttons & BUTTON_3_MASK) == BUTTON_3_MASK)
				{
					do_it = 1;
					sprintf(buf, "Mouse 3");
					line_color = Scalar(0, 100, 255);
					text_countdown = 30;
				}
				if(strlen(keystring) > 0)
				{
					strcpy(buf, keystring);
					do_it = 2;
					text_countdown = 30;
				}
				if((do_it > 0) || (text_countdown > 0))
				{
					if(do_it == 1)
					{
						int thickness = 2;
						Point center(mx, my);
						circle(src, center, radius, line_color, thickness);
						radius += 4;
						if(radius > 50)
						{
							radius = 10;
						}
					}
					if(strlen(buf) > 0)
					{
						if(text_countdown > 0)
						{
							int baseLine;
							Size labelSize = getTextSize(buf, FONT_HERSHEY_SIMPLEX, 0.5, 1, &baseLine);
							int tw = labelSize.width;
							putText(src, 
								buf, 
								cv::Point((desktop_w / 2) - tw, desktop_h - 30), 
								cv::FONT_HERSHEY_DUPLEX, 
								2.0, 
								CV_RGB(255, 255, 255), 
								1, 
								cv::LINE_AA);
							text_countdown--;
						}
						else
						{
							strcpy(buf, "");
						}
					}
				}
				else
				{
					radius = 10;
				}
			}
			AddMouse(src, mx, my);
		}
		if(retain_size == 1)
		{
			cv::resize(src, src, cv::Size(desktop_w, desktop_h));
		}
		else
		{
			cv::resize(src, src, cv::Size(output_width, output_height));
		}
		cvtColor(src, src, COLOR_BGRA2RGBA);
		desktop_mat = src;
	}
	else
	{
		fprintf(stderr, "ERROR: Bad Frame\n");
	}
}

void	MyWin::DrawAudioGraph(Camera *cam)
{
int	inner;

	if(muxing == 0)
	{
		if(pulse_mixer != NULL)
		{
			if(pulse_mixer->buffer != NULL)
			{
				int start_x = (w() / 2) - 512;
				int start_y = h() - 60;
				int bar_cnt = 0;
				fl_color(FL_WHITE);
				for(inner = 0;inner < pulse_mixer->size;inner++)
				{
					short int nn = pulse_mixer->preserve[inner];
					if(pulse_mixer->mute == 1)
					{
						nn = 0;
					}
					double bar_height = (30.0 / 32768.0) * (double)nn;
					if(bar_height != 0)
					{
						double red_height = (30.0 / 32768.0) * (double)nn;
						fl_color(FL_RED);
						fl_line(start_x + bar_cnt, start_y, start_x + bar_cnt, start_y + (int)red_height);

						double yellow_height = (25.0 / 32768.0) * (double)nn;
						fl_color(FL_YELLOW);
						fl_line(start_x + bar_cnt, start_y, start_x + bar_cnt, start_y + (int)yellow_height);

						double white_height = (20.0 / 32768.0) * (double)nn;
						fl_color(FL_WHITE);
						fl_line(start_x + bar_cnt, start_y, start_x + bar_cnt, start_y + (int)white_height);
					}
					else
					{
						fl_line(start_x + bar_cnt, start_y, start_x + bar_cnt, start_y + 1);
					}
					bar_cnt++;
				}
				if(pulse_mixer->mute == 1)
				{
					fl_color(FL_YELLOW);
					fl_font(FL_HELVETICA, 36);
					fl_draw("MUTING", start_x + (bar_cnt / 2) - 50, start_y - 50);
				}
			}
		}
	}
	else
	{
		if(my_muxer[0] != NULL)
		{
			if(my_muxer[0]->recordedSamples != NULL)
			{
				int bar_cnt = 0;
				int start_x = (w() / 2) - (my_muxer[0]->number_of_audio_samples / 2);
				int start_y = h() - 60;
				fl_color(FL_WHITE);
				for(inner = 0;inner < my_muxer[0]->number_of_audio_samples;inner++)
				{
					short int nn = my_muxer[0]->recordedSamples[inner];
					if(my_muxer[0]->mute == 1)
					{
						nn = 0;
					}
					double bar_height = (30.0 / 32768.0) * (double)nn;
					if(bar_height != 0)
					{
						double red_height = (30.0 / 32768.0) * (double)nn;
						fl_color(FL_RED);
						fl_line(start_x + bar_cnt, start_y, start_x + bar_cnt, start_y + (int)red_height);

						double yellow_height = (25.0 / 32768.0) * (double)nn;
						fl_color(FL_YELLOW);
						fl_line(start_x + bar_cnt, start_y, start_x + bar_cnt, start_y + (int)yellow_height);

						double white_height = (20.0 / 32768.0) * (double)nn;
						fl_color(FL_WHITE);
						fl_line(start_x + bar_cnt, start_y, start_x + bar_cnt, start_y + (int)white_height);
					}
					bar_cnt++;
				}
				if(my_muxer[0]->mute == 1)
				{
					fl_color(FL_YELLOW);
					fl_font(FL_HELVETICA, 36);
					fl_draw("MUTING", start_x + (bar_cnt / 2) - 50, start_y - 50);
				}
			}
		}
	}
}

unsigned char	*grab_window_image(Camera *cam, Window win, int *ww, int *hh, int *dd)
{
XWindowAttributes attributes;
XColor colors;

	unsigned char *final_ptr = NULL;

	XGetWindowAttributes(fl_display, win, &attributes);
	int width = attributes.width;
	int height = attributes.height;
	int depth = attributes.depth / 8;

	XImage *image = NULL;
	XShmSegmentInfo	shminfo;
	if(cam == NULL)
	{
		image = CreateSharedImage(&shminfo, width, height);
	}
	if(cam != NULL)
	{
		if(cam->shared_image == NULL)
		{
			cam->shared_image = CreateSharedImage(&cam->shminfo, width, height);
		}
		image = cam->shared_image;
	}
	if(image != NULL)
	{
		XShmGetImage(fl_display, win, image, 0, 0, AllPlanes);
		unsigned char *use_data = (unsigned char *)image->data;

		int cv_flag = CV_8UC4;
		Mat frame(cv::Size(width, height), cv_flag, use_data);

		// COW NOTE - SET TO DEPTH OF 3, REMOVING ALPHA
		depth = 3;
		int color_flag = COLOR_BGRA2RGB;
		cvtColor(frame, frame, color_flag);
		unsigned char *r_data = (unsigned char *)frame.ptr();

		int outlen = width * height * depth;
		final_ptr = (unsigned char *)malloc(outlen);
		if(final_ptr != NULL)
		{
			*ww = width;
			*hh = height;
			*dd = depth;
			memcpy(final_ptr, r_data, outlen);
		}
		if(cam == NULL)
		{
			DestroySharedImage(image, &shminfo);
		}
	}
	return(final_ptr);
}

void	Camera::GrabWindowImage(Window win, Mat *use_mat)
{
XWindowAttributes attributes;
XColor colors;

	attributes.width = 0;
	attributes.height = 0;
	Status status = XGetWindowAttributes(fl_display, win, &attributes);
	int width = attributes.width;
	int height = attributes.height;
	int depth = attributes.depth / 8;

	if((width > 0) && (height > 0) && (status != 0))
	{
		XImage *image = NULL;
		if(shared_image == NULL)
		{
			shared_image = CreateSharedImage(&shminfo, width, height);
		}
		image = shared_image;
		if(image != NULL)
		{
			XCompositeRedirectWindow(fl_display, win, CompositeRedirectAutomatic);
			Pixmap pixmap = XCompositeNameWindowPixmap(fl_display, win);
			XShmGetImage(fl_display, pixmap, image, 0, 0, AllPlanes);

			depth = 4;
			unsigned char *use_data = (unsigned char *)image->data;
			int cv_flag = CV_8UC4;
			Mat frame(cv::Size(width, height), cv_flag, use_data);

			// COW - CLEAR THE ALPHA CHANNEL
			cvtColor(frame, frame, COLOR_BGRA2BGR);
			cvtColor(frame, frame, COLOR_BGR2RGBA);
			frame.copyTo(*use_mat);

			XFlush(fl_display);

			XFreePixmap(fl_display, pixmap);
			XCompositeUnredirectWindow(fl_display, win, CompositeRedirectAutomatic);
		}
		else
		{
			Mat frame(requested_h, requested_w, CV_8UC4, cv::Scalar(0, 100, 200, 0));
			frame.copyTo(*use_mat);
		}
	}
	else
	{
		Mat frame(requested_h, requested_w, CV_8UC4, cv::Scalar(0, 100, 200, 0));
		frame.copyTo(*use_mat);
	}
}

void	Camera::GrabWindow()
{
	if(grab_window_id != 0)
	{
		GrabWindowImage(grab_window_id, &mat);
	}
}

void	Camera::GrabThisWindow()
{
	Window x_id = fl_xid(my_window);
	GrabWindowImage(x_id, &mat);
}

void	XMouse(int& xx, int& yy, int& mask)
{
Window		window_returned;
int		root_x, root_y;
int		win_x, win_y;
unsigned	int mask_return;

	int result = XQueryPointer(
		fl_display, 
		RootWindow(fl_display, fl_screen), 
		&window_returned, 
		&window_returned, 
		&root_x, 
		&root_y, 
		&win_x, 
		&win_y, 
		&mask_return);
	xx = root_x;
	yy = root_y;
	mask = mask_return;
}

unsigned char *grab_raw_image(Fl_Window *win, int xx, int yy, int ww, int hh, int *sz, int *in_depth)
{
static XShmSegmentInfo	 shminfo;
static XImage *image = NULL;
static int old_w = -1;
static int old_h = -1;

	int outlen = 0;
	unsigned char *r_data = NULL;
	int n_ww, n_hh;
	int start_x = 0;
	int start_y = 0;
	int start_w = Fl::w();
	int start_h = Fl::h();
	if(xx > -1)
	{
		start_x = xx;
	}
	if(yy > -1)
	{
		start_y = yy;
	}
	if(ww > -1)
	{
		start_w = ww;
	}
	if(hh > -1)
	{
		start_h = hh;
	}
	Window xwin = RootWindow(fl_display, fl_screen);
	if(win != NULL)
	{
		if(xx == -1) start_x = 0;
		if(yy == -1) start_y = 0;
		if(ww == -1) start_w = win->w();
		if(hh == -1) start_h = win->h();
		xwin = fl_xid(win);
	}
	double s = Fl::screen_scale(0);
	int Xs = Fl_Scalable_Graphics_Driver::floor(start_x, s);
	int Ys = Fl_Scalable_Graphics_Driver::floor(start_y, s);
	int ws = Fl_Scalable_Graphics_Driver::floor(start_x + start_w, s) - Xs;
	int hs = Fl_Scalable_Graphics_Driver::floor(start_y + start_h, s) - Ys;
	start_x = Xs;
	start_y = Ys;
	start_w = ws;
	start_h = hs;
	int true_w = Fl_Scalable_Graphics_Driver::floor(Fl::w(), s);
	int true_h = Fl_Scalable_Graphics_Driver::floor(Fl::h(), s);

	XSetWindowAttributes setwinattr;
	setwinattr.backing_store = Always;
	XChangeWindowAttributes(fl_display, xwin, CWBackingStore, &setwinattr);

	int use_x = 0;
	int use_y = 0;
	int my_depth = 4;

	if((image != NULL) && ((old_w != start_w) || (old_h != start_h)))
	{
		DestroySharedImage(image, &shminfo);
		image = NULL;
	}
	if(image == NULL)
	{
		image = CreateSharedImage(&shminfo, start_w, start_h);
		old_w = start_w;
		old_h = start_h;
	}
	if(image != NULL)
	{
		XWindowAttributes win_info;
		XGetWindowAttributes(fl_display, xwin, &win_info);
		Pixmap pixmap = None;
		if(((start_x + start_w) > true_w)
		|| ((start_y + start_h) > true_h)
		|| (start_x < 0)
		|| (start_y < 0))
		{
			XSetSubwindowMode(fl_display, DefaultGC(fl_display, fl_screen), IncludeInferiors);
			pixmap = XCreatePixmap(fl_display, xwin, start_w, start_h, win_info.depth);
			XCopyArea(fl_display, xwin, pixmap, DefaultGC(fl_display, fl_screen), use_x, use_y, start_w, start_h, 0, 0);
		}
		int nn = 0;
		unsigned char *use_data = NULL;
		if(pixmap == None)
		{
			nn = (int)XShmGetImage(fl_display, xwin, image, start_x, start_y, AllPlanes);
		}
		else
		{
			nn = (int)XShmGetImage(fl_display, pixmap, image, start_x, start_y, AllPlanes);
			XFreePixmap(fl_display, pixmap);
		}
		r_data = (unsigned char *)image->data;
		outlen = image->width * image->height * 4;
	}
	*sz = outlen;
	*in_depth = my_depth;
	return(r_data);
}

void	MyWin::RecordAll()
{
	if(refreshed == 1)
	{
		int depth = 0;
		int sz = 0;
		unsigned char *b = grab_raw_image((Fl_Double_Window *)this, -1, -1, -1, -1, &sz, &depth);
		if(b != NULL)
		{
			if(all_fd > -1)
			{
				double s = Fl::screen_scale(0);
				int nw = w() * s;
				int nh = h() * s;
				Mat src = Mat(nh, nw, CV_8UC4, b);
				cv::resize(src, src, cv::Size(original_w, original_h));
				write_frame(all_fd, src.ptr(), original_w * original_h * 4, 0);
				record_all_cnt++;
			}
		}
		else
		{
			fprintf(stderr, "ERROR: Bad Frame\n");
		}
		refreshed = 0;
	}
}

void	my_slider_reset_cb(Fl_Widget *w, void *v)
{
	if(v != NULL)
	{
		MySlider *slider = (MySlider *)v;
		slider->value(slider->initial_value);
		slider->do_callback();
		slider->redraw();
	}
}

void	v4l_autofocus_cb(Fl_Widget *w, void *v)
{
	ThumbGroup *tg = (ThumbGroup *)v;
	MyWin *main_win = tg->my_win;
	if(main_win != NULL)
	{
		Camera *cam = main_win->camera[tg->index];
		cam->V4L_Command(V4L_AUTOFOCUS);
	}
}

ThumbGroup::ThumbGroup(MyWin *win, int idx, int xx, int yy, int ww, int hh) : Fl_Double_Window(xx, yy, ww, hh)
{
	my_win = win;
	double gsf = win->gui_scale_factor;
	index = idx;
	Camera *cam = NULL;
	if(idx > -1)
	{
		cam = win->camera[index];
	}
	align(FL_ALIGN_BOTTOM | FL_ALIGN_CENTER);
	labelcolor(FL_YELLOW);
	labelsize(16 * gsf);

	thumb_button = new ThumbButton(my_win, idx, 0, 0, 153 * gsf, 86 * gsf);
	thumb_button->box(FL_FRAME);
	thumb_button->callback(thumbnail_cb, win);

	remove = new Fl_Button(2, 2, 16 * gsf, 16 * gsf, "X");
	remove->box(FL_FRAME_BOX);
	remove->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
	remove->color(FL_BLACK);
	remove->labelcolor(FL_WHITE);
	remove->labelsize(8 * gsf);
	remove->callback(thumb_remove_button_cb, win);

	place = new Fl_Button(18 * gsf, 2, 16 * gsf, 16 * gsf);
	place->box(FL_FRAME);
	place->color(FL_BLACK);
	place->align(FL_ALIGN_RIGHT);
	place->labelcolor(FL_WHITE);
	place->labelsize(8 * gsf);
	place->callback(thumb_place_button_cb, win);

	int cy = 0;
	record = new Fl_Button(155 * gsf, cy, 16 * gsf, 16 * gsf, "Recording");
	record->box(FL_FRAME);
	record->color(FL_BLACK);
	record->align(FL_ALIGN_RIGHT);
	record->labelcolor(FL_WHITE);
	record->labelsize(8 * gsf);
	record->callback(thumb_record_button_cb, win);
	cy += 18 * gsf;

	detect_motion = new Fl_Button(155 * gsf, 18 * gsf, 16 * gsf, 16 * gsf, "Detecting Motion");
	detect_motion->box(FL_FRAME);
	detect_motion->color(FL_BLACK);
	detect_motion->align(FL_ALIGN_RIGHT);
	detect_motion->labelcolor(FL_WHITE);
	detect_motion->labelsize(8 * gsf);
	detect_motion->callback(thumb_motion_button_cb, win);
	detect_motion->hide();
	
	detect_object = new Fl_Button(155 * gsf, 36 * gsf, 16 * gsf, 16 * gsf, "Detecting Objects");
	detect_object->box(FL_FRAME);
	detect_object->color(FL_BLACK);
	detect_object->align(FL_ALIGN_RIGHT);
	detect_object->labelcolor(FL_WHITE);
	detect_object->labelsize(8 * gsf);
	detect_object->callback(thumb_object_button_cb, win);
	detect_object->hide();

	instrument = new Fl_Button(155 * gsf, 18 * gsf, 16 * gsf, 16 * gsf, "Instrument");
	instrument->box(FL_FRAME);
	instrument->color(FL_BLACK);
	instrument->align(FL_ALIGN_RIGHT);
	instrument->labelcolor(FL_WHITE);
	instrument->labelsize(8 * gsf);
	instrument->callback(thumb_instrument_button_cb, win);
	instrument->hide();
	
	set_color = new Fl_Button(155 * gsf, 18 * gsf, 16 * gsf, 16 * gsf, "Background");
	set_color->box(FL_FRAME_BOX);
	set_color->color(FL_WHITE);
	set_color->align(FL_ALIGN_RIGHT);
	set_color->labelcolor(FL_WHITE);
	set_color->labelsize(8 * gsf);
	set_color->callback(thumb_background_button_cb, win);
	set_color->hide();
	
	set_text_color = new Fl_Button(155 * gsf, 36 * gsf, 16 * gsf, 16 * gsf, "Text");
	set_text_color->box(FL_FRAME_BOX);
	set_text_color->color(FL_WHITE);
	set_text_color->align(FL_ALIGN_RIGHT);
	set_text_color->labelcolor(FL_WHITE);
	set_text_color->labelsize(8 * gsf);
	set_text_color->callback(thumb_text_color_button_cb, win);
	set_text_color->hide();

	pause_av = new Fl_Button(155 * gsf, 18 * gsf, 16 * gsf, 16 * gsf, "Pause");
	pause_av->box(FL_FRAME_BOX);
	pause_av->color(FL_WHITE);
	pause_av->align(FL_ALIGN_RIGHT);
	pause_av->labelcolor(FL_WHITE);
	pause_av->labelsize(8 * gsf);
	pause_av->callback(thumb_pause_av_button_cb, win);
	pause_av->hide();

	mute_av = new Fl_Button(155 * gsf, 36 * gsf, 16 * gsf, 16 * gsf, "Mute");
	mute_av->box(FL_FRAME_BOX);
	mute_av->color(FL_WHITE);
	mute_av->align(FL_ALIGN_RIGHT);
	mute_av->labelcolor(FL_WHITE);
	mute_av->labelsize(8 * gsf);
	mute_av->callback(thumb_mute_av_button_cb, win);
	mute_av->hide();

	V4L_Window = new Fl_Window(155 * gsf, 54 * gsf, 100 * gsf, 64 * gsf);
		cy = 0;
		int cx = 0;
		up_left = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		up_left->box(FL_FRAME_BOX);
		up_left->color(FL_BLACK);
		cx += 11 * gsf;
		up = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		up->box(FL_FRAME_BOX);
		up->color(FL_BLACK);
		cx += 11 * gsf;
		up_right = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		up_right->box(FL_FRAME_BOX);
		up_right->color(FL_BLACK);
		cx = 0;
		cy += 11 * gsf;
		left = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		left->box(FL_FRAME_BOX);
		left->color(FL_BLACK);
		cx += 22 * gsf;
		right = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		right->box(FL_FRAME_BOX);
		right->color(FL_BLACK);
		cx = 0;
		cy += 11 * gsf;
		down_left = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		down_left->box(FL_FRAME_BOX);
		down_left->color(FL_BLACK);
		cx += 11 * gsf;
		down = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		down->box(FL_FRAME_BOX);
		down->color(FL_BLACK);
		cx += 11 * gsf;
		down_right = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		down_right->box(FL_FRAME_BOX);
		down_right->color(FL_BLACK);

		cy = 10 * gsf;
		cx = 40 * gsf;
		zoom_in = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "Zoom");
		zoom_in->box(FL_FRAME_BOX);
		zoom_in->color(FL_BLACK);
		zoom_in->align(FL_ALIGN_TOP | FL_ALIGN_CENTER);
		zoom_in->labelcolor(FL_WHITE);
		zoom_in->labelsize(5 * gsf);
		cy += 12 * gsf;
		zoom_out = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		zoom_out->box(FL_FRAME_BOX);
		zoom_out->color(FL_BLACK);

		cy = 10 * gsf;
		cx = 58 * gsf;
		focus_far = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "Focus");
		focus_far->box(FL_FRAME_BOX);
		focus_far->color(FL_BLACK);
		focus_far->align(FL_ALIGN_TOP | FL_ALIGN_CENTER);
		focus_far->labelcolor(FL_WHITE);
		focus_far->labelsize(5 * gsf);
		cy += 12 * gsf;
		focus_near = new V4L_Button(this, cx, cy, 11 * gsf, 11 * gsf, "");
		focus_near->box(FL_FRAME_BOX);
		focus_near->color(FL_BLACK);

		cy = 10 * gsf;
		cx = 76 * gsf;
		autofocus = new Fl_Toggle_Button(cx, cy, 11 * gsf, 11 * gsf, "AF");
		autofocus->box(FL_FRAME_BOX);
		autofocus->color(FL_BLACK);
		autofocus->down_color(FL_YELLOW);
		autofocus->align(FL_ALIGN_TOP | FL_ALIGN_CENTER);
		autofocus->labelcolor(FL_WHITE);
		autofocus->labelsize(5 * gsf);
		autofocus->callback(v4l_autofocus_cb, this);
	V4L_Window->end();
	V4L_Window->color(FL_BLACK);
	V4L_Window->hide();

	UpdateButtons(cam);

	color(FL_BLACK);
	border(0);
	box(FL_FLAT_BOX);

	end();
	hide();
}

int	ThumbGroup::handle(int event)
{
	int flag = 0;
	if((event == FL_FOCUS)
	|| (event == FL_UNFOCUS))
	{
		flag = 1;
	}
	else if(event == FL_PUSH)
	{
		if(Fl::event_button() == 3)
		{
			if(my_win != NULL)
			{
				my_win->AltDisplay(index);
			}
			flag = 1;
		}
	}
	if(flag == 0)
	{
		flag = Fl_Double_Window::handle(event);
	}
	return(flag);
}

void	ThumbGroup::draw()
{
	Fl_Double_Window::draw();
}

void	ThumbGroup::UpdateButtons(Camera *cam)
{
	if(cam != NULL)
	{
		detect_object->hide();
		detect_motion->hide();
		instrument->hide();
		set_color->hide();
		set_text_color->hide();
		pause_av->hide();
		mute_av->hide();
		V4L_Window->hide();

		if((cam->type != CAMERA_TYPE_IMAGE)
		&& (cam->type != CAMERA_TYPE_BLANK)
		&& (cam->type != CAMERA_TYPE_TEXT)
		&& (cam->type != CAMERA_TYPE_PIPED)
		&& (cam->type != CAMERA_TYPE_OSG))
		{
			if(cam->my_window != NULL)
			{
				if(cam->my_window->init_detect == 1)
				{
					detect_object->show();
				}
			}
			detect_motion->show();
		}
		if(cam->type == CAMERA_TYPE_OSG)
		{
			instrument->show();
		}
		if((cam->type == CAMERA_TYPE_IMAGE)
		|| (cam->type == CAMERA_TYPE_BLANK))
		{
			set_color->show();
		}
		if((cam->type == CAMERA_TYPE_TEXT) 
		|| (cam->type == CAMERA_TYPE_PIPED))
		{
			set_color->show();
			set_text_color->show();
		}
		if(cam->type == CAMERA_TYPE_AV) 
		{
			pause_av->show();
			mute_av->show();
		}
		if(cam->type == CAMERA_TYPE_CAMERA)
		{
			if(cam->V4L_Test() == 1)
			{
				if(cam->V4L_Test2() == 1)
				{
					V4L_Window->show();
				}
			}
		}
	}
}

void	MyWin::UpdateThumbButtons()
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		ThumbGroup *tb = thumbnail[loop];
		if(tb != NULL)
		{
			if(camera[loop] != NULL)
			{
				Camera *cam = camera[loop];
				tb->UpdateButtons(cam);
			}
		}
	}
}

ThumbButton::ThumbButton(MyWin *in_win, int in_idx, int xx, int yy, int ww, int hh, char *lbl) : Fl_Button(xx, yy, ww, hh, lbl)
{
	my_window = in_win;
	index = in_idx;
	dragging = 0;
	push_x = 0;
	push_y = 0;
}

ThumbButton::~ThumbButton()
{
	index = -1;
}

int	ThumbButton::handle(int event)
{
int	loop;
int	inner;

	int flag = 0;
	Camera *cam = my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(event == FL_ENTER)
		{
			if(my_window->dragging_thumb == NULL)
			{
				if(cam->keep_pip == 0)
				{
					for(loop = 0;loop < 128;loop++)
					{
						if(this == my_window->thumbnail[loop]->thumb_button)
						{
							cam->pip_idx = loop;
						}
					}
					flag = 1;
				}
			}
		}
		else if(event == FL_LEAVE)
		{
			if(cam->keep_pip == 0)
			{
				cam->pip_idx = -1;
				flag = 1;
			}
		}
		else if(event == FL_PUSH)
		{
			push_x = Fl::event_x();
			push_y = Fl::event_y();
			if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
			{
				if(my_window->multipip > 0)
				{
					Camera *camera = NULL;
					for(loop = 0;loop < 128;loop++)
					{
						if(this == my_window->thumbnail[loop]->thumb_button)
						{
							camera = my_window->camera[loop];
						}
					}
					if(cam != NULL)
					{
						cam->AddPIPByCamera(camera, 0);
					}
				}
				else
				{
					if(cam->keep_pip == 0)
					{
						cam->keep_pip = 1;
					}
					else
					{
						cam->pip_idx = -1;
						cam->keep_pip = 0;
					}
				}
				flag = 1;
			}
		}
		else if(event == FL_DRAG)
		{
			int dx = abs(push_x - Fl::event_x());
			int dy = abs(push_y - Fl::event_y());
			if((dx > 5) || (dy > 5))
			{
				my_window->dragging_thumb = this;
				dragging = 1;
				if(cam->keep_pip == 0)
				{
					cam->pip_idx = -1;
				}
				redraw();
				flag = 1;
			}
		}
		else if(event == FL_RELEASE)
		{
			if(dragging == 1)
			{
				if(my_window->dragging_thumb != NULL)
				{
					int dtx = my_window->dragging_thumb_x;
					int dty = my_window->dragging_thumb_y;
					if((dtx > cam->image_sx) && (dtx < cam->image_sx + cam->mat.cols)
					&& (dty > cam->image_sy) && (dty < cam->image_sy + cam->mat.rows))
					{
						thumb_place_button_cb(this, my_window);
					}
					my_window->dragging_thumb = NULL;
				}
				dragging = 0;
				flag = 1;
			}
		}
		else if(event == FL_KEYBOARD)
		{
			int key = Fl::event_key();
			if(key == ' ')
			{
				flag = -1;
			}
		}
	}
	if(flag == 0)
	{
		flag = Fl_Button::handle(event);
	}
	if(flag == -1)
	{
		flag = 0;
	}
	return(flag);
}

void	ThumbButton::draw()
{
int	loop;

	if(my_window->video_thumbnail_group->visible())
	{
		if(index > -1)
		{
			if(!mat.empty())
			{
				Camera *cam = my_window->DisplayedCamera();
				fl_color(255, 240, 100);
				char buf[32];
				sprintf(buf, "%d", index);
				fl_draw(buf, 5, y() + 20);

				MyWin *win = (MyWin *)top_window();
				double gsf = win->gui_scale_factor;
				int b_sz = 16 * gsf;
				Camera *my_cam = win->camera[index];
				if(my_cam != NULL)
				{
					if(my_cam->power == 1)
					{
						use_mat = mat.clone();
						fl_draw_image((unsigned char *)use_mat.ptr(), x(), y(), w(), h(), use_mat.channels());
					}
					else
					{
						fl_color(FL_BLACK);
						fl_rectf(x(), y(), w(), h());
					}
					if(win->trigger_select_mode == 0)
					{
						ThumbGroup *grp = (ThumbGroup *)window();
						if(my_cam->record == 1)
						{
							int xx = grp->record->x();
							int yy = grp->record->y();
							fl_color(FL_RED);
							fl_rectf(xx, yy, b_sz, b_sz);
						}
						if((grp->detect_motion != NULL)
						&& (grp->detect_object != NULL))
						{
							if((my_cam->motion_detect == 1)
							|| (my_cam->follow_motion == 1))
							{
								int xx = grp->detect_motion->x();
								int yy = grp->detect_motion->y();
								fl_color(FL_RED);
								fl_rectf(xx, yy, b_sz, b_sz);
							}
							if((my_cam->object_detect == 1)
							|| (my_cam->follow_objects == 1))
							{
								int xx = grp->detect_object->x();
								int yy = grp->detect_object->y();
								fl_color(FL_RED);
								fl_rectf(xx, yy, b_sz, b_sz);
							}
						}
					}
					if(cam != NULL)
					{
						for(loop = 0;loop < cam->trigger_cnt;loop++)
						{
							if(cam->trigger[loop] == index)
							{
								fl_color(FL_CYAN);
								fl_rect(x(), y(), w(), h());
							}
						}
					}
				}
			}
		}
	}
}


void	update_standalone_cb(void *v)
{
	StandaloneDisplay *sd = (StandaloneDisplay *)v;
	sd->redraw();
	Fl::repeat_timeout(0.01, update_standalone_cb, v);
}

StandaloneDisplay::StandaloneDisplay(Camera *in_cam, int ww, int hh, char *lbl) : Fl_Double_Window(ww, hh, lbl)
{
	cam = in_cam;
	resizable(this);
	ratio_w = (double)ww / (double)hh;
	ratio_h = (double)hh / (double)ww;
	Fl::add_timeout(0.1, update_standalone_cb, this);
}

StandaloneDisplay::~StandaloneDisplay()
{
}

void	StandaloneDisplay::draw()
{
	Fl_Double_Window::draw();
	if(cam != NULL)
	{
		Mat use_mat = cam->mat.clone();
		int ww = (int)((double)h() * ratio_w);
		int hh = (int)((double)w() * ratio_h);
		if(w() > h())
		{
			cv::resize(use_mat, use_mat, cv::Size(ww, h()));
		}
		else
		{
			cv::resize(use_mat, use_mat, cv::Size(w(), hh));
		}
		fl_draw_image((unsigned char *)use_mat.ptr(), 0, 0, use_mat.cols, use_mat.rows, use_mat.channels());
	}
}

MyScrubber::MyScrubber(int xx, int yy, int ww, int hh) : Fl_Window(xx - 2, yy - 2, ww + 4, hh + 4)
{
	box(FL_FRAME_BOX);
	range = 0;
	current = 0;
	trim_cnt = 0;
	mode = 0;
	selected_trim = -1;
	hot_trim = -1;
	current_trim = -1;
	start_trim = NULL;
	end_trim = NULL;
	end();
	my_callback = NULL;
	my_callback_value = NULL;
}

MyScrubber::~MyScrubber()
{
	ClearTrims();
}

void	MyScrubber::Callback(void (*cb)(void *, void *), void *p)
{
	my_callback = cb;
	my_callback_value = p;
}

void	MyScrubber::draw()
{
int	loop;
char	buf[256];

	Fl_Window::draw();
	if(range > 0)
	{
		fl_color(FL_WHITE);
		fl_rectf(4, 4, Scale(current) - 4, h() - 8);
		sprintf(buf, "%d", current);
		fl_font(FL_HELVETICA, 9);
		if(Scale(current) < w() - 50)
		{
			fl_draw(buf, Scale(current) + 6, 14);
		}
		else
		{
			fl_color(FL_BLACK);
			fl_draw(buf, Scale(current) - 50, 14);
		}
		if(trim_cnt > 0)
		{
			for(loop = 0;loop < trim_cnt;loop++)
			{
				if(loop == hot_trim)
				{
					fl_color(DARK_RED);
				}
				else
				{
					fl_color(DARK_BLUE);
				}
				int sx1 = start_trim[loop];
				if(sx1 > -1)
				{
					fl_rectf(Scale(sx1) - 3, 10, 6, 10);
					sprintf(buf, "%d", sx1);
					if(sx1 > current)
					{
						fl_color(FL_WHITE);
					}
					else
					{
						fl_color(FL_BLACK);
					}
					fl_font(FL_HELVETICA, 9);
					fl_draw(buf, Scale(sx1) + 6, 14);
				}
				if(loop == hot_trim)
				{
					fl_color(DARK_RED);
				}
				else
				{
					fl_color(DARK_BLUE);
				}
				int sx2 = end_trim[loop];
				if((sx2 > -1) && (sx2 != sx1))
				{
					fl_rectf(Scale(sx2) - 3, 10, 6, 10);
					int diff = abs(sx2 - sx1);
					fl_rectf(Scale(sx1) + 3, 17, Scale(diff) - 3, 3);
					sprintf(buf, "%d", sx2);
					if(sx2 > current)
					{
						fl_color(FL_WHITE);
					}
					else
					{
						fl_color(FL_BLACK);
					}
					fl_font(FL_HELVETICA, 9);
					fl_draw(buf, Scale(sx2) - 32, 14);
				}
			}
		}
	}
}

int	MyScrubber::handle(int event)
{
int	loop;

	int flag = 0;
	switch(event)
	{
		case(FL_PUSH):
		{
			int nx = Descale(Fl::event_x());
			int ny = Fl::event_y();
			if(ny < 10)
			{
				Value(nx);
				mode = 0;
			}
			else if(trim_cnt > 0)
			{
				int flag = -1;
				selected_trim = -1;
				for(loop = 0;((loop < trim_cnt) && (flag == -1));loop++)
				{
					if((nx >= start_trim[loop] - 5) && (nx <= start_trim[loop] + 5))
					{
						flag = loop;
						mode = 1;
					}
					else if((nx >= end_trim[loop] - 5) && (nx <= end_trim[loop] + 5))
					{
						flag = loop;
						mode = 2;
					}
				}
				if(flag > -1)
				{
					selected_trim = flag;
				}
				if(selected_trim == -1)
				{
					Value(nx);
					mode = 0;
				}
			}
			redraw();
			flag = 1;
		}
		break;
		case(FL_DRAG):
		{
			int nx = Fl::event_x();
			int ny = Fl::event_y();
			if((nx > 0) && (nx < w()))
			{
				nx = Descale(nx);
				if(mode == 0)
				{
					Value(nx);
				}
				else if((mode == 1) || (mode == 2))
				{
					if(selected_trim > -1)
					{
						int ok = CheckTrim(selected_trim, nx);
						if(ok == 1)
						{
							if(mode == 1)
							{
								if(nx < end_trim[selected_trim] - 6)
								{
									start_trim[selected_trim] = nx;
								}
							}
							else if(mode == 2)
							{
								if(nx > start_trim[selected_trim] + 6)
								{
									end_trim[selected_trim] = nx;
								}
							}
						}
					}
				}
			}
			redraw();
			flag = 1;
		}
		break;
		case(FL_MOVE):
		{
			int nx = Fl::event_x();
			int ny = Fl::event_y();
			if((nx > 0) && (nx < w()))
			{
				nx = Descale(nx);
				hot_trim = -1;
				for(loop = 0;loop < trim_cnt;loop++)
				{
					if((nx >= start_trim[loop] - 5) && (nx <= start_trim[loop] + 5))
					{
						hot_trim = loop;
					}
					else if((nx >= end_trim[loop] - 5) && (nx <= end_trim[loop] + 5))
					{
						hot_trim = loop;
					}
				}
				redraw();
			}
			flag = 1;
		}
		break;
	}
	if(flag == 0)
	{
		flag = Fl_Window::handle(event);
	}
	return(flag);
}

int	MyScrubber::Scale(int nn)
{
	int r = 0;
	if(range > 0)
	{
		r = (int)((double)nn * ((double)(w() - 4) / (double)range));
	}
	return(r);
}

int	MyScrubber::Descale(int nn)
{
	int r = (int)((double)nn * ((double)range / (double)(w() - 4)));
	return(r);
}

int	MyScrubber::CheckTrim(int selected, int pos)
{
int	loop;

	int okay = 1;
	for(loop = 0;loop < trim_cnt;loop++)
	{
		if(loop != selected)
		{
			if((pos >= (start_trim[loop] - 6)) && (pos <= (end_trim[loop]) + 6))
			{
				okay = 0;
			}
		}
	}
	return(okay);
}

int	MyScrubber::CountTrim()
{
int	loop;

	int total = 0;
	for(loop = 0;loop < trim_cnt;loop++)
	{
		total += (end_trim[loop] - start_trim[loop]);
	}
	return(total);
}

void	MyScrubber::SortTrim()
{
int	inner, outer;

	for(outer = 0;outer < trim_cnt;outer++)
	{
		for(inner = 0;inner < trim_cnt;inner++)
		{
			if(start_trim[outer] < start_trim[inner])
			{
				if(inner != outer)
				{
					int tmp  = start_trim[outer];
					start_trim[outer] = start_trim[inner];
					start_trim[inner] = tmp;

					tmp  = end_trim[outer];
					end_trim[outer] = end_trim[inner];
					end_trim[inner] = tmp;
				}
			}
		}
	}
}

int	MyScrubber::Value()
{
	return(current);
}

void	MyScrubber::Value(int v)
{
	current = v;
	if(my_callback != NULL)
	{
		(*my_callback)(this, my_callback_value);
	}
}

int	MyScrubber::Range()
{
	return(range);
}

void	MyScrubber::Range(int v)
{
	range = v;
}

void	MyScrubber::AddTrim(int start, int end)
{
	int *tmp1 = (int *)realloc(start_trim, sizeof(int) * (trim_cnt + 1));
	if(tmp1 != NULL)
	{
		int *tmp2 = (int *)realloc(end_trim, sizeof(int) * (trim_cnt + 1));
		if(tmp2 != NULL)
		{
			start_trim = tmp1;
			start_trim[trim_cnt] = start;
			end_trim = tmp2;
			end_trim[trim_cnt] = end;
			current_trim = trim_cnt;
			trim_cnt++;
		}
	}
}

void	MyScrubber::SetStartTrim(int nn)
{
	if(current_trim > -1)
	{
		start_trim[current_trim] = nn;
	}
}

void	MyScrubber::SetEndTrim(int nn)
{
	if(current_trim > -1)
	{
		if(start_trim[current_trim] < nn)
		{
			end_trim[current_trim] = nn;
		}
		else
		{
			int tmp = start_trim[current_trim];
			start_trim[current_trim] = nn;
			end_trim[current_trim] = tmp;
		}
	}
}


void	MyScrubber::ClearTrims()
{
	if(start_trim != NULL)
	{
		free(start_trim);
		start_trim = NULL;
	}
	if(end_trim != NULL)
	{
		free(end_trim);
		end_trim = NULL;
	}
	trim_cnt = 0;
}

void	MyScrubber::RemoveTrim(int idx)
{
int	loop;

	if(trim_cnt > 1)
	{
		if((idx > -1) && (idx < trim_cnt))
		{
			int *tmp1 = (int *)malloc((trim_cnt - 1) * sizeof(int));
			if(tmp1 != NULL)
			{
				int *tmp2 = (int *)malloc((trim_cnt - 1) * sizeof(int));
				if(tmp2 != NULL)
				{
					int cnt = 0;
					for(loop = 0;loop < trim_cnt;loop++)
					{
						if(loop != idx)
						{
							tmp1[cnt] = start_trim[loop];
							tmp2[cnt] = end_trim[loop];
							cnt++;
						}
					}
					free(start_trim);
					free(end_trim);
					start_trim = tmp1;
					end_trim = tmp2;
					trim_cnt--;
				}
			}
		}
	}
	else
	{
		free(start_trim);
		free(end_trim);
		trim_cnt = 0;
	}
}

ProgressScrubber::ProgressScrubber(MyWin *in_win, MuxPreviewWindow *mux, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	my_window = in_win;
	mux_preview = mux;
	position = 0.0;
	playing = 0;
	play_x1 = 0;
	play_y1 = 0;
	play_x2 = 0;
	play_y2 = 0;
	end();
}

ProgressScrubber::~ProgressScrubber()
{
}

void	ProgressScrubber::draw()
{
char	text[64];

	fl_color(FL_BLACK);
	if(box() != FL_NO_BOX)
	{
		fl_rectf(x(), y(), w(), h());
	}
	fl_rectf(x(), y(), w(), 10);
	fl_color(FL_WHITE);
	fl_rect(x(), y(), w(), 10);
	int pp = (int)((double)w() * position);
	fl_rectf(x() + pp, y(), 4, 10);
	int nx = x() + ((w() / 2) - 5);
	int ny = y() + h() - 21;
	fl_rect(nx, ny, 20, 20);
	playing = 1;
	if(mux_preview == NULL)
	{
		Camera *cam = my_window->DisplayedCamera();
		if(cam != NULL)
		{
			if(cam->type == CAMERA_TYPE_AV)
			{
				if(cam->av_window->paused == 1)
				{
					playing = 0;
				}
			}
		}
	}
	else
	{
		if(mux_preview->vlc_window->paused == 1)
		{
			playing = 0;
		}
	}
	if(playing == 1)
	{
		strcpy(text, "@#||");
	}
	else
	{
		strcpy(text, "@#>");
	}
	fl_draw(text, nx + 1, ny, 20, 20, FL_ALIGN_CENTER | FL_ALIGN_INSIDE, NULL, 1);
	play_x1 = nx - x();
	play_y1 = ny - y();
	play_x2 = play_x1 + 20;
	play_y2 = play_y1 + 20;
}

int	ProgressScrubber::Handle(int event)
{
	int flag = 0;
	if(event == FL_PUSH)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		xx -= x();
		yy -= y();
		if((xx > 0) && (yy > 0)
		&& (xx < w()) && (yy < h()))
		{
			if(mux_preview == NULL)
			{
				Camera *cam = my_window->DisplayedCamera();
				if(cam != NULL)
				{
					if(cam->type == CAMERA_TYPE_AV)
					{
						if(yy < (h() - 30))
						{
							double val = (1.0 / w()) * (double)xx;
							cam->av_window->Position(val);
							flag = 1;
						}
						else if((xx > play_x1) && (yy > play_y1)
						&& (xx < play_x2) && (yy < play_y2))
						{
							if(cam->av_window->paused == 0)
							{
								playing = 0;
								cam->av_window->Pause();
							}
							else
							{
								playing = 1;
								cam->av_window->Resume();
							}
						}
					}
				}
			}
			else
			{
				if(yy < (h() - 30))
				{
					double val = (1.0 / w()) * (double)xx;
					mux_preview->vlc_window->Position(val);
					flag = 1;
				}
				else if((xx > play_x1) && (yy > play_y1)
				&& (xx < play_x2) && (yy < play_y2))
				{
					if(mux_preview->vlc_window->paused == 0)
					{
						playing = 0;
						mux_preview->vlc_window->Pause();
					}
					else
					{
						playing = 1;
						mux_preview->vlc_window->Resume();
					}
				}
			}
		}
	}
	return(flag);
}

void	ProgressScrubber::Position(double in_pos)
{
	position = in_pos;
}

void	MyWin::AddEmbeddedWindow(EmbedAppWindow *embed)
{
int	loop;

	int done = -1;
	embedded_app_cnt = 0;
	for(loop = 0;loop < 10;loop++)
	{
		if(embedded_app[loop] == NULL)
		{
			done = loop;
		}
		else
		{
			embedded_app_cnt++;
		}
	}
	if(done != -1)
	{
		add(embed);
		embedded_app[done] = embed;
		embedded_app_cnt++;
	}
}

void	MyWin::CalcEmbeddedWindowPosition(int use_w, int use_h, int& x_pos, int& y_pos)
{
int	loop;

	y_pos = (h() - use_h);
	int accum = 0;
	for(loop = 0;loop < 10;loop++)
	{
		if(embedded_app[loop] != NULL)
		{
			accum += embedded_app[loop]->my_w;
		}
	}
	x_pos = 200 + accum;
}

void	embed_app_cb(Fl_Widget *w, void *v)
{
int	loop;

	EmbedAppSettings *win = (EmbedAppSettings *)v;
	if(win->my_window->embedded_app_cnt < 10)
	{
		char *path = (char *)win->path->value();
		if(path != NULL)
		{
			if(strlen(path) > 0)
			{
				int use_w = 450;
				int use_h = 270;
				char *str_w = (char *)win->use_w->value();
				if(str_w != NULL)
				{
					if(strlen(str_w) > 0)
					{
						use_w = atoi(str_w);
						if(use_w < 50)
						{
							use_w = 50;
						}
					}
				}
				char *str_h = (char *)win->use_h->value();
				if(str_h != NULL)
				{
					if(strlen(str_h) > 0)
					{
						use_h = atoi(str_h);
						if(use_h < 50)
						{
							use_h = 50;
						}
					}
				}
				int x_pos = 0;
				int y_pos = 0;
				win->my_window->CalcEmbeddedWindowPosition(use_w, use_h, x_pos, y_pos);
				EmbedAppWindow *embed = new EmbedAppWindow(x_pos, y_pos, use_w, use_h);
				win->my_window->AddEmbeddedWindow(embed);
				embed->set_non_modal();
				embed->show();
				char *arg[10];
				for(loop = 0;loop < 10;loop++)
				{
					arg[loop] = NULL;
					char *str = (char *)win->arg[loop]->value();
					if(str != NULL)
					{
						if(strlen(str) > 0)
						{
							arg[loop] = str;
						}
					}
				}
				embed->EmbedApp(path, arg);
			}
		}
	}
	win->hide();
}

void	hide_window_cb(Fl_Widget *w, void *v)
{
	Fl_Window *win = (Fl_Window *)v;
	win->hide();
}

EmbedAppSettings::EmbedAppSettings(MyWin *in_win) : Fl_Window(450, 300, 300, 350)
{
int	loop;
char	buf[256];

	color(FL_BLACK);
	border(0);
	box(FL_FRAME_BOX);

	double gsf = in_win->gui_scale_factor;
	resize(x() * gsf, y() * gsf, w() * gsf, h() * gsf);

	my_window = in_win;
	int y_pos = 20 * gsf;
	path = new Fl_Input(75 * gsf, y_pos, 200 * gsf, 20 * gsf, "Path");
	path->textsize(11 * gsf);
	path->textcolor(FL_BLACK);
	path->color(LIGHT_GRAY);
	path->labelcolor(LIGHT_GRAY);
	path->labelsize(11 * gsf);
	path->box(FL_FLAT_BOX);
	y_pos += (22 * gsf);

	use_w = new Fl_Input(75 * gsf, y_pos, 50 * gsf, 20 * gsf, "Width");
	use_w->textsize(11 * gsf);
	use_w->textcolor(FL_BLACK);
	use_w->color(LIGHT_GRAY);
	use_w->labelcolor(LIGHT_GRAY);
	use_w->labelsize(11 * gsf);
	use_w->box(FL_FLAT_BOX);

	use_h = new Fl_Input(175 * gsf, y_pos, 50 * gsf, 20 * gsf, "Height");
	use_h->textsize(11 * gsf);
	use_h->textcolor(FL_BLACK);
	use_h->color(LIGHT_GRAY);
	use_h->labelcolor(LIGHT_GRAY);
	use_h->labelsize(11 * gsf);
	use_h->box(FL_FLAT_BOX);
	y_pos += (32 * gsf);

	for(loop = 0;loop < 10;loop++)
	{
		sprintf(buf, "Argument %d", loop);
		arg[loop] = new Fl_Input(100 * gsf, y_pos, 175 * gsf, 20 * gsf, strdup(buf));
		arg[loop]->color(FL_WHITE);
		arg[loop]->textsize(11 * gsf);
		arg[loop]->textcolor(FL_BLACK);
		arg[loop]->color(LIGHT_GRAY);
		arg[loop]->labelcolor(LIGHT_GRAY);
		arg[loop]->labelsize(11 * gsf);
		arg[loop]->box(FL_FLAT_BOX);
		y_pos += (22 * gsf);
	}
	y_pos += (22 * gsf);
	accept = new Fl_Button(50 * gsf, y_pos, 80, 20, "Accept");
	accept->box(FL_NO_BOX);
	accept->color(FL_WHITE);
	accept->labelcolor(FL_YELLOW);
	accept->labelsize(12 * gsf);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->callback(embed_app_cb, this);

	cancel = new Fl_Button(170 * gsf, y_pos, 80, 20, "Cancel");
	cancel->box(FL_NO_BOX);
	cancel->color(FL_WHITE);
	cancel->labelcolor(FL_YELLOW);
	cancel->labelsize(12 * gsf);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->callback(hide_window_cb, this);

	end();
	hide();
}

EmbedAppSettings::~EmbedAppSettings()
{
}

MySlider::MySlider(int xx, int yy, int ww, int hh, char *lbl) : Fl_Slider(xx, yy, ww, hh, lbl)
{
	initial_value = 0.0;
	type(FL_HOR_NICE_SLIDER);
	align(FL_ALIGN_LEFT);
	color(FL_BLACK);
	labelcolor(FL_YELLOW);
	box(FL_FLAT_BOX);
	reset = new Fl_Button(xx + w() + 4, yy + 2, hh - 4, hh - 4, "@#-2undo");
	reset->color(FL_BLACK);
	reset->box(FL_THIN_UP_BOX);
	reset->labelcolor(FL_WHITE);
	reset->callback(my_slider_reset_cb, this);
}

MySlider::~MySlider()
{
}

void	MySlider::draw()
{
char	buf[256];

	fl_push_clip(x(), y(), w(), h());
	fl_color(FL_BLACK);
	fl_rectf(x() + 1, y() + 1, w() - 2, h() - 2);
	fl_color(FL_WHITE);
	fl_rect(x(), y(), w(), h());
	double min = minimum();
	double max = maximum();
	double rng = abs(max - min);
	double val = value();
	int pos = (int)((((double)w() / rng) * val) - ((w() / rng) * min));
	fl_rect(x() + pos - 2, y() + 4, 4, h() - 8);
	fl_font(FL_HELVETICA, 9);
	sprintf(buf, "%.2f", val);
	int use_x = 0;
	int use_y = 0;
	fl_measure(buf, use_x, use_y);
	if(pos > (w() / 2))
	{
		fl_draw(buf, x() + pos - (use_x + 5), y() + (use_y + 2));
	}
	else
	{
		fl_draw(buf, x() + pos + 5, y() + (use_y + 2));
	}
	fl_pop_clip();
}

void	contrast_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				cam->contrast = nn;
			}
		}
	}
}

void	brightness_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				cam->brightness = nn;
			}
		}
	}
}

void	saturation_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->saturation = rr;
			}
		}
	}
}

void	hue_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->hue = rr;
			}
		}
	}
}

void	intensity_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->intensity = rr;
			}
		}
	}
}

void	red_intensity_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->red_intensity = rr;
			}
		}
	}
}

void	green_intensity_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->green_intensity = rr;
			}
		}
	}
}

void	blue_intensity_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->blue_intensity = rr;
			}
		}
	}
}

void	alpha_intensity_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->alpha_intensity = rr;
			}
		}
	}
}

void	aspect_x_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->forced_aspect_x = rr;
			}
		}
	}
}

void	aspect_y_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->forced_aspect_y = rr;
			}
		}
	}
}

void	fps_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		MySlider *slide = (MySlider *)w;
		if(slide != NULL)
		{
			double nn = slide->value();
			double rr = nn;
			win->forced_fps = (int)rr;
		}
	}
}

void	motion_threshold_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->motion_threshold = (int)rr;
			}
		}
	}
}

void	threshold_slider_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->recognition_threshold = (int)rr;
			}
		}
	}
}

void	recognition_interval_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				double rr = nn;
				cam->recognize_interval = (int)rr;
			}
		}
	}
}

void	encode_fps_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		MySlider *slide = (MySlider *)w;
		if(slide != NULL)
		{
			double nn = slide->value();
			win->speed_factor = nn;
		}
	}
}

void	minimum_fps_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		MySlider *slide = (MySlider *)w;
		if(slide != NULL)
		{
			double nn = slide->value();
			win->minimum_fps = nn;
		}
	}
}

void	capture_interval_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		Camera *cam = win->DisplayedCamera();
		if(cam != NULL)
		{
			MySlider *slide = (MySlider *)w;
			if(slide != NULL)
			{
				double nn = slide->value();
				cam->capture_interval = nn;
			}
		}
	}
}


void	settings_close_cb(Fl_Widget *w, void *v)
{
	if(v != NULL)
	{
		SettingWindow *sw = (SettingWindow *)v;
		MyWin *win = sw->main_win;
		int fd = open("video_settings.bin", O_WRONLY | O_CREAT, 0666);
		if(fd > -1)
		{
			write(fd, &win->output_width, sizeof(int));
			write(fd, &win->output_height, sizeof(int));
			write(fd, &win->forced_fps, sizeof(int));
			write(fd, &win->speed_factor, sizeof(double));
			write(fd, &win->minimum_fps, sizeof(double));
			write(fd, &win->direct_recording, sizeof(int));
			write(fd, &win->stream_only, sizeof(int));
			write(fd, &win->audio, sizeof(int));
			write(fd, &win->muxing, sizeof(int));
			write(fd, &win->embed_pip, sizeof(int));
			write(fd, &win->tag_recognized, sizeof(int));
			write(fd, &win->record_all, sizeof(int));
			write(fd, &win->frame_scaling, sizeof(int));
			write(fd, &win->crop_scaling, sizeof(int));
			write(fd, &win->single_stream, sizeof(int));
			write(fd, &win->timestamp, sizeof(int));
			write(fd, &win->timestamp_format, 4096);
			write(fd, &win->timestamp_rr, sizeof(int));
			write(fd, &win->timestamp_gg, sizeof(int));
			write(fd, &win->timestamp_bb, sizeof(int));
			write(fd, &win->timestamp_aa, sizeof(int));
			write(fd, &win->timestamp_background_rr, sizeof(int));
			write(fd, &win->timestamp_background_gg, sizeof(int));
			write(fd, &win->timestamp_background_bb, sizeof(int));
			write(fd, &win->timestamp_background_aa, sizeof(int));
			write(fd, &win->timestamp_font_sz, sizeof(int));
			write(fd, &win->timestamp_position_x, sizeof(int));
			write(fd, &win->timestamp_position_y, sizeof(int));
			close(fd);
		}
		sw->hide();
	}
}

void	load_system_video_settings_from_file(MyWin *win)
{
	if(win != NULL)
	{
		if(access("video_settings.bin", 0) == 0)
		{
			int fd = open("video_settings.bin", O_RDONLY);
			if(fd > -1)
			{
				read(fd, &win->output_width, sizeof(int));
				read(fd, &win->output_height, sizeof(int));
				read(fd, &win->forced_fps, sizeof(int));
				read(fd, &win->speed_factor, sizeof(double));
				read(fd, &win->minimum_fps, sizeof(double));
				read(fd, &win->direct_recording, sizeof(int));
				read(fd, &win->stream_only, sizeof(int));
				read(fd, &win->audio, sizeof(int));
				read(fd, &win->muxing, sizeof(int));
				read(fd, &win->embed_pip, sizeof(int));
				read(fd, &win->tag_recognized, sizeof(int));
				read(fd, &win->record_all, sizeof(int));
				read(fd, &win->frame_scaling, sizeof(int));
				read(fd, &win->crop_scaling, sizeof(int));
				read(fd, &win->single_stream, sizeof(int));
				read(fd, &win->timestamp, sizeof(int));
				read(fd, &win->timestamp_format, 4096);
				read(fd, &win->timestamp_rr, sizeof(int));
				read(fd, &win->timestamp_gg, sizeof(int));
				read(fd, &win->timestamp_bb, sizeof(int));
				read(fd, &win->timestamp_aa, sizeof(int));
				read(fd, &win->timestamp_background_rr, sizeof(int));
				read(fd, &win->timestamp_background_gg, sizeof(int));
				read(fd, &win->timestamp_background_bb, sizeof(int));
				read(fd, &win->timestamp_background_aa, sizeof(int));
				read(fd, &win->timestamp_font_sz, sizeof(int));
				read(fd, &win->timestamp_position_x, sizeof(int));
				read(fd, &win->timestamp_position_y, sizeof(int));
				close(fd);
			}
		}
	}
}

void	realtime_encoding_cb(Fl_Widget *w, void *v)
{
int	loop;

	Fl_Light_Button *b = (Fl_Light_Button *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->muxing = b->value();
		for(loop = 0;loop < win->source_cnt;loop++)
		{
			if(win->camera[loop] != NULL)
			{
				Camera *cam = win->camera[loop];
				cam->starting_time = 0;
			}
		}
		if(win->muxing == 0)
		{
			win->direct_recording = 0;
			win->stream_only = 0;
		}
		else
		{
			win->audio = 1;
		}
	}
}

void	record_all_cb(Fl_Widget *w, void *v)
{
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		if(b->value() == 1)
		{
			if(win->record_all == 0)
			{
				win->record_all_start = time(0);
				win->all_fd = open("global.bin", O_CREAT | O_WRONLY | O_TRUNC, 0777);
				int uw = win->original_w;
				int uh = win->original_h;
				int depth = 4;
				int ufps = 25;
				write(win->all_fd, &uw, sizeof(int));
				write(win->all_fd, &uh, sizeof(int));
				write(win->all_fd, &depth, sizeof(int));
				write(win->all_fd, &ufps, sizeof(int));
				win->record_all = 1;
			}
		}
		else
		{
			if(win->record_all == 1)
			{
				win->record_all = 0;
				if(win->all_fd > -1)
				{
					win->SetCodec();
					close(win->all_fd);
					double fps = 25.0;
					int total_time = (int)(time(0) - win->record_all_start);
					if(total_time > 0)
					{
						fps = (double)win->record_all_cnt / (double)total_time;
					}
					char out_filename[4096];
					sprintf(out_filename, "global.%s", win->use_extension);
					Muxer *use_muxer = new Muxer(win, NULL, 1);
					use_muxer->InitMux(win->audio, win->use_video_codec, win->use_audio_codec, "global.bin", NULL, out_filename, NULL, win->desktop_monitor, win->pulse_mixer, -1, win->original_w, win->original_h, fps, 8000.0, -1, NULL, NULL);
					win->AddLastMuxed(out_filename);
					delete use_muxer;
				}
			}
		}
	}
}

void	embed_pip_cb(Fl_Widget *w, void *v)
{
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->embed_pip = b->value();
	}
}

void	frame_scaling_cb(Fl_Widget *w, void *v)
{
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->frame_scaling = b->value();
	}
}

void	crop_scaling_cb(Fl_Widget *w, void *v)
{
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->crop_scaling = b->value();
	}
}

void	create_tag_file_cb(Fl_Widget *w, void *v)
{
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		win->tag_recognized = b->value();
	}
}

void	single_stream_cb(Fl_Widget *w, void *v)
{
	Fl_Light_Button *b = (Fl_Light_Button *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		if(win->recording == 0)
		{
			if(b->value() == 1)
			{
				win->single_stream = 0;
			}
			else
			{
				win->single_stream = 1;
			}
		}
		else
		{
			if(win->single_stream == 1)
			{
				b->value(0);
			}
			else
			{
				b->value(1);
			}
			b->redraw();
		}
	}
}

void	out_function(char *ptr)
{
	if(global_log_window != NULL)
	{
		Fl_Browser *browser = (Fl_Browser *)global_log_window->child(0);
		if(!global_log_window->visible())
		{
			browser->clear();
		}
		browser->add(ptr);
		int num = browser->size();
		browser->bottomline(num);
		global_log_window->show();
		global_log_window->redraw();
		if((num % 100) == 0)
		{
			Fl::check();
		}
	}
}

void	gather_codecs_cb(Fl_Widget *w, void *v)
{
void	enumerate_codecs();
void	enumerate_test(void (*output_cb)(char *), int test_w, int test_h, int test_fps, int test_hz);
int		loop;

	Fl_Button *b = (Fl_Button *)w;
	MyWin *win = (MyWin *)v;
	if(win != NULL)
	{
		for(loop = 0;loop < global_my_format_cnt;loop++)
		{
			MyFormat *mf = global_my_format[loop];
			delete mf;
			global_my_format[loop] = NULL;
		}
		global_my_format_cnt = 0;
		if(global_my_format_cnt == 0)
		{
			enumerate_codecs();
			enumerate_test(out_function, win->output_width, win->output_height, win->minimum_fps, win->streaming_audio_quality);
		}
		out_function("@bDONE");
	}
}

void	timestamp_default_cb(Fl_Widget *w, void *v)
{
	SettingWindow *sw = (SettingWindow *)v;
	MyWin *win = sw->main_win;
	int val = sw->timestamp_default->value();
	win->timestamp = val;
}

void	timestamp_format_cb(Fl_Widget *w, void *v)
{
	SettingWindow *sw = (SettingWindow *)v;
	MyWin *win = sw->main_win;
	Camera *cam = win->DisplayedCamera();
	char *str = (char *)sw->timestamp_format->value();
	if(str != NULL)
	{
		strncpy(win->timestamp_format, str, 4096);
	}
}

void	timestamp_color_cb(Fl_Widget *w, void *v)
{
	SettingWindow *sw = (SettingWindow *)v;
	MyWin *win = sw->main_win;
	Camera *cam = win->DisplayedCamera();
	int rr = 255;
	int gg = 240;
	int bb = 128;
	int aa = 255;
	ColorDialog *cd = new ColorDialog(win, 420, 125, "Timestamp Text", &rr, &gg, &bb, &aa);
	cd->show();
	cd->set_modal();
	while(cd->visible())
	{
		rr = cd->red->value();
		gg = cd->green->value();
		bb = cd->blue->value();
		aa = cd->alpha->value();
		Fl::check();
	}
	win->timestamp_rr = rr;
	win->timestamp_gg = gg;
	win->timestamp_bb = bb;
	win->timestamp_aa = aa;
	sw->timestamp_color_button->color(fl_rgb_color(rr, gg, bb));
	sw->redraw();
}

void	timestamp_background_color_cb(Fl_Widget *w, void *v)
{
	SettingWindow *sw = (SettingWindow *)v;
	MyWin *win = sw->main_win;
	Camera *cam = win->DisplayedCamera();
	int rr = 0;
	int gg = 0;
	int bb = 0;
	int aa = 0;
	ColorDialog *cd = new ColorDialog(win, 420, 125, "Timestamp Background", &rr, &gg, &bb, &aa);
	cd->show();
	cd->set_modal();
	while(cd->visible())
	{
		rr = cd->red->value();
		gg = cd->green->value();
		bb = cd->blue->value();
		aa = cd->alpha->value();
		Fl::check();
	}
	win->timestamp_background_rr = rr;
	win->timestamp_background_gg = gg;
	win->timestamp_background_bb = bb;
	win->timestamp_background_aa = aa;
	sw->timestamp_background_color_button->color(fl_rgb_color(rr, gg, bb));
	sw->redraw();
}

void	timestamp_font_size_cb(Fl_Widget *w, void *v)
{
	SettingWindow *sw = (SettingWindow *)v;
	MyWin *win = sw->main_win;
	char *str = (char *)sw->timestamp_font_size->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->timestamp_font_sz = nn;
		}
	}
}

void	timestamp_position_cb(Fl_Widget *w, void *v)
{
	SettingWindow *sw = (SettingWindow *)v;
	MyWin *win = sw->main_win;
	char *str = (char *)sw->timestamp_position_x->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->timestamp_position_x = nn;
		}
	}
	str = (char *)sw->timestamp_position_y->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->timestamp_position_y = nn;
		}
	}
}

void	video_settings_resolution_cb(Fl_Widget *w, void *v)
{
	SettingWindow *sw = (SettingWindow *)v;
	MyWin *win = sw->main_win;
	Camera *cam = win->DisplayedCamera();
	char *str = (char *)sw->output_w->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->output_width = nn;
		}
	}
	str = (char *)sw->output_h->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			win->output_height = nn;
		}
	}
	str = (char *)sw->display_w->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			cam->display_width = nn;
		}
	}
	str = (char *)sw->display_h->value();
	if(str != NULL)
	{
		int nn = atoi(str);
		if(nn > 0)
		{
			cam->display_height = nn;
		}
	}
}

SettingWindow::SettingWindow(MyWin *in_win) : Fl_Window(360, 200, 800, 735)
{
char	buf[256];

	main_win = in_win;
	double gsf = in_win->gui_scale_factor;
	Camera *cam = main_win->DisplayedCamera();

	if(main_win->disregard_settings == 0)
	{
		load_system_video_settings_from_file(main_win);
	}
	last_x = 0;
	last_y = 0;
	resize(x() * gsf, y() * gsf, w() * gsf, h() * gsf);
	border(0);
	box(FL_FRAME_BOX);
	color(FL_BLACK);

	int yp = 20 * gsf;
	output_w = new Fl_Int_Input(200 * gsf, yp, 60, 20, "Output Size");
	output_w->box(FL_FRAME_BOX);
	output_w->color(FL_BLACK);
	output_w->labelcolor(FL_YELLOW);
	output_w->textcolor(FL_WHITE);
	output_w->labelsize(12 * gsf);
	output_w->textsize(11 * gsf);
	output_w->cursor_color(FL_WHITE);
	sprintf(buf, "%d", main_win->output_width);
	output_w->value(buf);
	output_w->callback(video_settings_resolution_cb, this);

	output_h = new Fl_Int_Input(262 * gsf, yp, 60, 20, "");
	output_h->box(FL_FRAME_BOX);
	output_h->color(FL_BLACK);
	output_h->labelcolor(FL_YELLOW);
	output_h->textcolor(FL_WHITE);
	output_h->labelsize(12 * gsf);
	output_h->textsize(11 * gsf);
	output_h->cursor_color(FL_WHITE);
	sprintf(buf, "%d", main_win->output_height);
	output_h->value(buf);
	output_h->callback(video_settings_resolution_cb, this);
	yp += (25 * gsf);

	display_w = new Fl_Int_Input(200 * gsf, yp, 60, 20, "Display Size");
	display_w->box(FL_FRAME_BOX);
	display_w->color(FL_BLACK);
	display_w->labelcolor(FL_YELLOW);
	display_w->textcolor(FL_WHITE);
	display_w->labelsize(12 * gsf);
	display_w->textsize(11 * gsf);
	display_w->cursor_color(FL_WHITE);
	display_w->labelcolor(FL_WHITE);
	if(cam != NULL)
	{
		sprintf(buf, "%d", (int)cam->display_width);
		display_w->value(buf);
	}
	display_w->callback(video_settings_resolution_cb, this);

	display_h = new Fl_Int_Input(262 * gsf, yp, 60, 20, "");
	display_h->box(FL_FRAME_BOX);
	display_h->color(FL_BLACK);
	display_h->labelcolor(FL_YELLOW);
	display_h->textcolor(FL_WHITE);
	display_h->labelsize(12 * gsf);
	display_h->textsize(11 * gsf);
	display_h->cursor_color(FL_WHITE);
	display_h->labelcolor(FL_WHITE);
	if(cam != NULL)
	{
		sprintf(buf, "%d", (int)cam->display_height);
		display_h->value(buf);
	}
	display_h->callback(video_settings_resolution_cb, this);
	yp += (25 * gsf);
	timestamp_default = new Fl_Toggle_Button(200 * gsf, yp + 2, 16 * gsf, 16 * gsf, "Timestamp");
	timestamp_default->box(FL_FRAME_BOX);
	timestamp_default->color(FL_BLACK);
	timestamp_default->down_color(FL_WHITE);
	timestamp_default->align(FL_ALIGN_LEFT);
	timestamp_default->labelcolor(FL_YELLOW);
	timestamp_default->labelsize(12 * gsf);
	timestamp_default->value(main_win->timestamp);
	timestamp_default->callback(timestamp_default_cb, this);

	timestamp_format = new Fl_Input(218 * gsf, yp, 462 * gsf, 20, "Format");
	timestamp_format->box(FL_FRAME_BOX);
	timestamp_format->color(FL_BLACK);
	timestamp_format->textcolor(FL_WHITE);
	timestamp_format->labelsize(12 * gsf);
	timestamp_format->textsize(11 * gsf);
	timestamp_format->cursor_color(FL_WHITE);
	timestamp_format->labelcolor(FL_YELLOW);
	timestamp_format->align(FL_ALIGN_TOP | FL_ALIGN_CENTER);
	timestamp_format->value(main_win->timestamp_format);
	timestamp_format->callback(timestamp_format_cb, this);

	timestamp_color_button = new Fl_Button(681 * gsf, yp, 20 * gsf, 20 * gsf, "F");
	timestamp_color_button->box(FL_FRAME_BOX);
	int rr = main_win->timestamp_rr;
	int gg = main_win->timestamp_gg;
	int bb = main_win->timestamp_bb;
	timestamp_color_button->color(fl_rgb_color(rr, gg, bb));
	timestamp_color_button->labelcolor(FL_YELLOW);
	timestamp_color_button->labelsize(9);
	timestamp_color_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	timestamp_color_button->callback(timestamp_color_cb, this);

	timestamp_background_color_button = new Fl_Button(702 * gsf, yp, 20 * gsf, 20 * gsf, "B");
	timestamp_background_color_button->box(FL_FRAME_BOX);
	rr = main_win->timestamp_background_rr;
	gg = main_win->timestamp_background_gg;
	bb = main_win->timestamp_background_bb;
	timestamp_background_color_button->color(fl_rgb_color(rr, gg, bb));
	timestamp_background_color_button->labelcolor(FL_YELLOW);
	timestamp_background_color_button->labelsize(9);
	timestamp_background_color_button->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	timestamp_background_color_button->callback(timestamp_background_color_cb, this);
	yp += (40 * gsf);

	Fl_Box *tf_box = new Fl_Box(200 * gsf, yp, 500 * gsf, 20,
		"%Y = current year\t"
		"%M = current month\t"
		"%D = current day\n"
		"%h = hour\t"
		"%m = minute\t"
		"%s = second\n"
		"%u = microsecond\t"
		"%U = millisecond\n"
		"%S = current time in seconds\t"
		"%d = duration\n"
		"%frame = recorded frames\t"
		"%source = path to video source");

	tf_box->box(FL_FLAT_BOX);
	tf_box->color(FL_BLACK);
	tf_box->labelcolor(FL_WHITE);
	tf_box->labelsize(9 * gsf);
	tf_box->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	yp += (40 * gsf);

	timestamp_font_size = new Fl_Int_Input(200 * gsf, yp, 60, 20, "Timestamp Font Size");
	timestamp_font_size->box(FL_FRAME_BOX);
	timestamp_font_size->color(FL_BLACK);
	timestamp_font_size->textcolor(FL_WHITE);
	timestamp_font_size->labelsize(12 * gsf);
	timestamp_font_size->textsize(11 * gsf);
	timestamp_font_size->cursor_color(FL_WHITE);
	sprintf(buf, "%d", (int)main_win->timestamp_font_sz);
	timestamp_font_size->value(buf);
	timestamp_font_size->labelcolor(FL_YELLOW);
	timestamp_font_size->callback(timestamp_font_size_cb, this);

	timestamp_position_x = new Fl_Int_Input(400 * gsf, yp, 60, 20, "Timestamp Position");
	timestamp_position_x->box(FL_FRAME_BOX);
	timestamp_position_x->color(FL_BLACK);
	timestamp_position_x->textcolor(FL_WHITE);
	timestamp_position_x->labelsize(12 * gsf);
	timestamp_position_x->textsize(11 * gsf);
	timestamp_position_x->cursor_color(FL_WHITE);
	sprintf(buf, "%d", (int)main_win->timestamp_position_x);
	timestamp_position_x->value(buf);
	timestamp_position_x->labelcolor(FL_YELLOW);
	timestamp_position_x->callback(timestamp_position_cb, this);

	timestamp_position_y = new Fl_Int_Input(470 * gsf, yp, 60, 20, "");
	timestamp_position_y->box(FL_FRAME_BOX);
	timestamp_position_y->color(FL_BLACK);
	timestamp_position_y->textcolor(FL_WHITE);
	timestamp_position_y->labelsize(12 * gsf);
	timestamp_position_y->textsize(11 * gsf);
	timestamp_position_y->cursor_color(FL_WHITE);
	sprintf(buf, "%d", (int)main_win->timestamp_position_y);
	timestamp_position_y->value(buf);
	timestamp_position_y->labelcolor(FL_YELLOW);
	timestamp_position_y->callback(timestamp_position_cb, this);
	yp += (25 * gsf);

	contrast_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Contrast");
	contrast_slider->range(0.0, 1.0);
	contrast_slider->value(0.5);
	contrast_slider->initial_value = 0.5;
	contrast_slider->labelsize(12 * gsf);
	contrast_slider->labelcolor(FL_WHITE);
	contrast_slider->callback(contrast_slider_cb, main_win);
	yp += (25 * gsf);
	brightness_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Brightness");
	brightness_slider->range(0.0, 1.0);
	brightness_slider->value(0.5);
	brightness_slider->initial_value = 0.5;
	brightness_slider->labelsize(12 * gsf);
	brightness_slider->labelcolor(FL_WHITE);
	brightness_slider->callback(brightness_slider_cb, main_win);
	yp += (25 * gsf);
	saturation_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Saturation");
	saturation_slider->range(0.0, 2.0);
	saturation_slider->value(1.0);
	saturation_slider->initial_value = 1.0;
	saturation_slider->labelsize(12 * gsf);
	saturation_slider->labelcolor(FL_WHITE);
	saturation_slider->callback(saturation_slider_cb, main_win);
	yp += (25 * gsf);
	hue_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Hue");
	hue_slider->range(0.0, 2.0);
	hue_slider->value(1.0);
	hue_slider->initial_value = 1.0;
	hue_slider->labelsize(12 * gsf);
	hue_slider->labelcolor(FL_WHITE);
	hue_slider->callback(hue_slider_cb, main_win);
	yp += (25 * gsf);
	intensity_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Value");
	intensity_slider->range(0.0, 2.0);
	intensity_slider->value(1.0);
	intensity_slider->initial_value = 1.0;
	intensity_slider->labelsize(12 * gsf);
	intensity_slider->labelcolor(FL_WHITE);
	intensity_slider->callback(intensity_slider_cb, main_win);
	yp += (25 * gsf);
	red_intensity_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Red Value");
	red_intensity_slider->range(0.0, 2.0);
	red_intensity_slider->value(1.0);
	red_intensity_slider->initial_value = 1.0;
	red_intensity_slider->labelsize(12 * gsf);
	red_intensity_slider->labelcolor(FL_WHITE);
	red_intensity_slider->callback(red_intensity_slider_cb, main_win);
	yp += (25 * gsf);
	green_intensity_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Green Value");
	green_intensity_slider->range(0.0, 2.0);
	green_intensity_slider->value(1.0);
	green_intensity_slider->initial_value = 1.0;
	green_intensity_slider->labelsize(12 * gsf);
	green_intensity_slider->labelcolor(FL_WHITE);
	green_intensity_slider->callback(green_intensity_slider_cb, main_win);
	yp += (25 * gsf);
	blue_intensity_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Blue Value");
	blue_intensity_slider->range(0.0, 2.0);
	blue_intensity_slider->value(1.0);
	blue_intensity_slider->initial_value = 1.0;
	blue_intensity_slider->labelsize(12 * gsf);
	blue_intensity_slider->labelcolor(FL_WHITE);
	blue_intensity_slider->callback(blue_intensity_slider_cb, main_win);
	yp += (25 * gsf);
	alpha_intensity_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Alpha Value");
	alpha_intensity_slider->range(0.0, 2.0);
	alpha_intensity_slider->value(1.0);
	alpha_intensity_slider->initial_value = 1.0;
	alpha_intensity_slider->labelsize(12 * gsf);
	alpha_intensity_slider->labelcolor(FL_WHITE);
	alpha_intensity_slider->callback(alpha_intensity_slider_cb, main_win);
	yp += (25 * gsf);
	aspect_x_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Aspect Width");
	aspect_x_slider->range(0.0, 2.0);
	aspect_x_slider->value(1.0);
	aspect_x_slider->initial_value = 1.0;
	aspect_x_slider->labelsize(12 * gsf);
	aspect_x_slider->labelcolor(FL_WHITE);
	aspect_x_slider->callback(aspect_x_slider_cb, main_win);
	yp += (25 * gsf);
	aspect_y_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Aspect Height");
	aspect_y_slider->range(0.0, 2.0);
	aspect_y_slider->value(1.0);
	aspect_y_slider->initial_value = 1.0;
	aspect_y_slider->labelsize(12 * gsf);
	aspect_y_slider->labelcolor(FL_WHITE);
	aspect_y_slider->callback(aspect_y_slider_cb, main_win);

	yp += (25 * gsf);
	fps_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "FPS");
	fps_slider->range(0.0, 100.0);
	fps_slider->value(0.0);
	fps_slider->initial_value = 0.0;
	fps_slider->labelsize(12 * gsf);
	fps_slider->callback(fps_slider_cb, main_win);

	yp += (25 * gsf);
	motion_threshold_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Motion Threshold");
	motion_threshold_slider->range(10.0, 10000.0);
	motion_threshold_slider->value(100.0);
	motion_threshold_slider->initial_value = 100.0;
	motion_threshold_slider->labelsize(12 * gsf);
	motion_threshold_slider->labelcolor(FL_WHITE);
	motion_threshold_slider->callback(motion_threshold_slider_cb, main_win);

	yp += (25 * gsf);
	recognition_threshold_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Object Recog. Threshold");
	recognition_threshold_slider->range(0.0, 1.0);
	recognition_threshold_slider->value(0.5);
	recognition_threshold_slider->initial_value = 0.5;
	recognition_threshold_slider->labelsize(12 * gsf);
	recognition_threshold_slider->labelcolor(FL_WHITE);
	recognition_threshold_slider->callback(threshold_slider_cb, main_win);

	yp += (25 * gsf);
	recognition_interval_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Object Recog. Interval");
	recognition_interval_slider->range(1, 100);
	recognition_interval_slider->value(10);
	recognition_interval_slider->step(1);
	recognition_interval_slider->initial_value = 10;
	recognition_interval_slider->labelsize(12 * gsf);
	recognition_interval_slider->labelcolor(FL_WHITE);
	recognition_interval_slider->callback(recognition_interval_cb, main_win);

	yp += (25 * gsf);
	encode_fps_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Encode FPS (factor)");
	encode_fps_slider->range(0.01, 25.0);
	encode_fps_slider->value(1.0);
	encode_fps_slider->step(0.01);
	encode_fps_slider->initial_value = 1.0;
	encode_fps_slider->labelsize(12 * gsf);
	encode_fps_slider->callback(encode_fps_cb, main_win);

	yp += (25 * gsf);
	minimum_fps_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Minimum FPS");
	minimum_fps_slider->range(0.01, 60.0);
	minimum_fps_slider->value(20.0);
	minimum_fps_slider->step(1.0);
	minimum_fps_slider->initial_value = 20.0;
	minimum_fps_slider->labelsize(12 * gsf);
	minimum_fps_slider->callback(minimum_fps_cb, main_win);

	yp += (25 * gsf);
	capture_interval_slider = new MySlider(200 * gsf, yp, 500 * gsf, 25 * gsf, "Capture Interval");
	capture_interval_slider->range(0.1, 60.0);
	capture_interval_slider->value(0.0);
	capture_interval_slider->step(0.1);
	capture_interval_slider->initial_value = 0.0;
	capture_interval_slider->labelsize(12 * gsf);
	capture_interval_slider->labelcolor(FL_WHITE);
	capture_interval_slider->callback(capture_interval_cb, main_win);

	yp += (30 * gsf);
	int row_start = yp;
	realtime_encoding_button = new Fl_Light_Button(200 * gsf, yp, 120 * gsf, 20 * gsf, "Realtime Encoding");
	realtime_encoding_button->box(FL_FRAME_BOX);
	realtime_encoding_button->color(FL_BLACK);
	realtime_encoding_button->labelcolor(FL_YELLOW);
	realtime_encoding_button->labelsize(9 * gsf);
	realtime_encoding_button->align(FL_ALIGN_CENTER);
	realtime_encoding_button->value(main_win->muxing);
	realtime_encoding_button->callback(realtime_encoding_cb, main_win);
	yp += (22 * gsf);
	embed_pip_button = new Fl_Light_Button(200 * gsf, yp, 120 * gsf, 20 * gsf, "Embed PIP");
	embed_pip_button->box(FL_FRAME_BOX);
	embed_pip_button->color(FL_BLACK);
	embed_pip_button->labelcolor(FL_YELLOW);
	embed_pip_button->labelsize(9 * gsf);
	embed_pip_button->align(FL_ALIGN_CENTER);
	embed_pip_button->value(main_win->embed_pip);
	embed_pip_button->callback(embed_pip_cb, main_win);
	yp += (22 * gsf);
	gather_codecs_button = new Fl_Button(200 * gsf, yp, 120 * gsf, 20 * gsf, "Gather Codecs");
	gather_codecs_button->box(FL_FRAME_BOX);
	gather_codecs_button->color(FL_BLACK);
	gather_codecs_button->labelcolor(FL_YELLOW);
	gather_codecs_button->labelsize(9 * gsf);
	gather_codecs_button->align(FL_ALIGN_CENTER);
	gather_codecs_button->value(main_win->embed_pip);
	gather_codecs_button->callback(gather_codecs_cb, main_win);
	yp += (22 * gsf);
	create_tag_file_button = new Fl_Light_Button(200 * gsf, yp, 120 * gsf, 20 * gsf, "Create Tag File");
	create_tag_file_button->box(FL_FRAME_BOX);
	create_tag_file_button->color(FL_BLACK);
	create_tag_file_button->labelcolor(FL_YELLOW);
	create_tag_file_button->labelsize(9 * gsf);
	create_tag_file_button->align(FL_ALIGN_CENTER);
	create_tag_file_button->value(main_win->tag_recognized);
	create_tag_file_button->callback(create_tag_file_cb, main_win);
	yp = row_start;
	record_all_button = new Fl_Light_Button(330 * gsf, yp, 120 * gsf, 20 * gsf, "Record Main Window");
	record_all_button->box(FL_FRAME_BOX);
	record_all_button->color(FL_BLACK);
	record_all_button->labelcolor(FL_YELLOW);
	record_all_button->labelsize(9 * gsf);
	record_all_button->align(FL_ALIGN_CENTER);
	record_all_button->value(main_win->record_all);
	record_all_button->callback(record_all_cb, main_win);
	yp += (22 * gsf);
	frame_scaling_button = new Fl_Light_Button(330 * gsf, yp, 120 * gsf, 20 * gsf, "Frame Scaled Output");
	frame_scaling_button->box(FL_FRAME_BOX);
	frame_scaling_button->color(FL_BLACK);
	frame_scaling_button->labelcolor(FL_YELLOW);
	frame_scaling_button->labelsize(9 * gsf);
	frame_scaling_button->align(FL_ALIGN_CENTER);
	frame_scaling_button->value(main_win->frame_scaling);
	frame_scaling_button->callback(frame_scaling_cb, main_win);
	yp += (22 * gsf);
	crop_scaling_button = new Fl_Light_Button(330 * gsf, yp, 120 * gsf, 20 * gsf, "Cropped Output");
	crop_scaling_button->box(FL_FRAME_BOX);
	crop_scaling_button->color(FL_BLACK);
	crop_scaling_button->labelcolor(FL_YELLOW);
	crop_scaling_button->labelsize(9 * gsf);
	crop_scaling_button->align(FL_ALIGN_CENTER);
	crop_scaling_button->value(main_win->crop_scaling);
	crop_scaling_button->callback(crop_scaling_cb, main_win);
	yp += (22 * gsf);
	single_stream_button = new Fl_Light_Button(330 * gsf, yp, 120 * gsf, 20 * gsf, "Multistream Output");
	single_stream_button->box(FL_FRAME_BOX);
	single_stream_button->color(FL_BLACK);
	single_stream_button->labelcolor(FL_YELLOW);
	single_stream_button->labelsize(9 * gsf);
	single_stream_button->align(FL_ALIGN_CENTER);
	single_stream_button->value(!main_win->single_stream);
	single_stream_button->callback(single_stream_cb, main_win);

	Fl_Button *close = new Fl_Button(70 * gsf, (h() * gsf) - 90, 100 * gsf, 30 * gsf, "Close");
	close->box(FL_FRAME_BOX);
	close->color(FL_BLACK);
	close->labelcolor(FL_YELLOW);
	close->labelsize(12 * gsf);
	close->callback(settings_close_cb, this);
	end();
	show();
}

SettingWindow::~SettingWindow()
{
}

void	SettingWindow::draw()
{
	fl_color(FL_BLACK);
	fl_rectf(40, 40, 160, h() - 80);
	Fl_Window::draw();
}

int	SettingWindow::handle(int event)
{
	int flag = 0;
	flag = Fl_Window::handle(event);
	if(flag == 0)
	{
		if((event == FL_FOCUS)
		|| (event == FL_UNFOCUS))
		{
			flag = 1;
		}
		else if(event == FL_KEYBOARD)
		{
			int key = Fl::event_key();
			if(key == FL_Escape)
			{
				hide();
				flag = 1;
			}
		}
		else if(event == FL_PUSH)
		{
			last_x = Fl::event_x_root();
			last_y = Fl::event_y_root();
			flag = 1;
		}
		else if(event == FL_RELEASE)
		{
			flag = 1;
		}
		else if(event == FL_DRAG)
		{
			int xx = Fl::event_x_root();
			int yy = Fl::event_y_root();
			int dx = last_x - xx;
			int dy = last_y - yy;
			resize(x() - dx, y() - dy, w(), h());
			last_x = xx;
			last_y = yy;
			flag = 1;
		}
	}
	return(flag);
}

void	SettingWindow::Update()
{
	if(main_win != NULL)
	{
		Camera *cam = main_win->DisplayedCamera();
		if(cam != NULL)
		{
			contrast_slider->value(cam->contrast);
			brightness_slider->value(cam->brightness);
			saturation_slider->value(cam->saturation);
			hue_slider->value(cam->hue);
			intensity_slider->value(cam->intensity);
			fps_slider->value(cam->fps);
			motion_threshold_slider->value(cam->motion_threshold);
			recognition_threshold_slider->value(cam->recognition_threshold);
			recognition_interval_slider->value(cam->recognize_interval);
		}
	}
}

void	snapshot_filename_format_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			strcpy(cam->snapshot_filename_format, win->filename_format->value());
		}
	}
}

void	snapshot_initial_delay_slider_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			cam->snapshot_initial_delay = (int)win->initial_delay_slider->value();
		}
	}
}

void	snapshot_repeat_delay_slider_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			int seconds = (int)win->repeat_seconds_delay_slider->value();
			int minutes = (int)win->repeat_minutes_delay_slider->value();
			cam->snapshot_repeat_delay = (minutes * 60) + seconds;
		}
	}
}

void	snapshot_scale_slider_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			double scale = win->scale_slider->value();
			cam->snapshot_scale = scale;
		}
	}
}

void	snapshot_trigger_cb(Fl_Widget *w, void *v)
{
	SnapshotSettingWindow *win = (SnapshotSettingWindow *)v;
	MyWin *my_win = win->main_win;
	if(my_win != NULL)
	{
		Camera *cam = my_win->DisplayedCamera();
		if(cam != NULL)
		{
			if(win->snapshot_trigger_on_button->value() == 1)
			{
				cam->snapshot_trigger_condition = SNAPSHOT_TRIGGER_BUTTON;
			}
			else if(win->snapshot_trigger_on_start->value() == 1)
			{
				cam->snapshot_trigger_condition = SNAPSHOT_TRIGGER_START;
			}
			else if(win->snapshot_trigger_on_record->value() == 1)
			{
				cam->snapshot_trigger_condition = SNAPSHOT_TRIGGER_RECORD;
			}
			else if(win->snapshot_continuous->value() == 1)
			{
				cam->snapshot_trigger_condition = SNAPSHOT_TRIGGER_CONTINUOUS;
			}
		}
	}
}

SnapshotSettingWindow::SnapshotSettingWindow(MyWin *in_win) : Fl_Window(360, 200, 600, 370)
{
char	buf[256];

	main_win = in_win;
	double gsf = in_win->gui_scale_factor;
	Camera *cam = main_win->DisplayedCamera();

	int yp = 22;
	if(cam != NULL)
	{
		last_x = 0;
		last_y = 0;
		resize(x() * gsf, y() * gsf, w() * gsf, h() * gsf);
		border(0);
		box(FL_FRAME_BOX);
		color(FL_BLACK);

		filename_format = new Fl_Input(100 * gsf, yp, 462 * gsf, 20, "Filename");
		filename_format->box(FL_FRAME_BOX);
		filename_format->color(FL_BLACK);
		filename_format->textcolor(FL_WHITE);
		filename_format->labelsize(11 * gsf);
		filename_format->textsize(11 * gsf);
		filename_format->cursor_color(FL_WHITE);
		filename_format->labelcolor(FL_YELLOW);
		filename_format->when(FL_WHEN_CHANGED);
		filename_format->value(cam->snapshot_filename_format);
		filename_format->callback(snapshot_filename_format_cb, this);
		yp += 32;

		Fl_Box *instruction = new Fl_Box(10, yp, 560, 100);
		instruction->box(FL_FLAT_BOX);
		instruction->color(FL_BLACK);
		instruction->labelsize(9);
		instruction->labelcolor(FL_WHITE);
		instruction->labelfont(FL_SCREEN);
		instruction->align(FL_ALIGN_TOP | FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		instruction->label(
			"Insert into the path:\n\n"
			"%home = home directory\t\t\t"
			"%cwd = current working directory\n"
			"%Y = current year\t\t\t"
			"%M = current month\t\t\t"
			"%D = current day\n"
			"%h = hour\t\t\t\t"
			"%m = minute\t\t\t\t"
			"%s = second\n"
			"%u = microsecond\t\t\t"
			"%U = millisecond\t\t\t"
			"%S = current time in seconds\n"
			"%frame = recorded frames\t\t"
			"%source = path to video source\n\n"
			"So: \"snapshot_%Y_%M_%D_%h_%m_%s.flv\" will produce \"snapshot_2024_1_22_13_6_31.flv\" on January 22nd, 2024");
		yp += 120;

		initial_delay_slider = new MySlider(100 * gsf, yp, 450 * gsf, 20 * gsf, "Initial Delay");
		initial_delay_slider->range(0.0, 60.0);
		initial_delay_slider->value(0.0);
		initial_delay_slider->step(1.0);
		initial_delay_slider->initial_value = 0.0;
		initial_delay_slider->labelsize(11 * gsf);
		initial_delay_slider->labelcolor(FL_YELLOW);
		initial_delay_slider->callback(snapshot_initial_delay_slider_cb, this);
		yp += 30;

		repeat_seconds_delay_slider = new MySlider(100 * gsf, yp, 450 * gsf, 20 * gsf, "Repeat (sec.)");
		repeat_seconds_delay_slider->range(0.0, 60.0);
		repeat_seconds_delay_slider->value(0.0);
		repeat_seconds_delay_slider->step(1.0);
		repeat_seconds_delay_slider->initial_value = 0.0;
		repeat_seconds_delay_slider->labelsize(11 * gsf);
		repeat_seconds_delay_slider->labelcolor(FL_YELLOW);
		repeat_seconds_delay_slider->callback(snapshot_repeat_delay_slider_cb, this);
		yp += 22;

		repeat_minutes_delay_slider = new MySlider(100 * gsf, yp, 450 * gsf, 20 * gsf, "Repeat (min.)");
		repeat_minutes_delay_slider->range(0.0, 60.0);
		repeat_minutes_delay_slider->value(0.0);
		repeat_minutes_delay_slider->step(1.0);
		repeat_minutes_delay_slider->initial_value = 0.0;
		repeat_minutes_delay_slider->labelsize(11 * gsf);
		repeat_minutes_delay_slider->labelcolor(FL_YELLOW);
		repeat_minutes_delay_slider->callback(snapshot_repeat_delay_slider_cb, this);
		yp += 30;

		int xp = 50;
		Fl_Group *radio = new Fl_Group(xp * gsf, yp, 500 * gsf, 20 * gsf);
		snapshot_trigger_on_button = new Fl_Light_Button(xp * gsf, yp, 120 * gsf, 20 * gsf, "Trigger on Button");
		snapshot_trigger_on_button->box(FL_FRAME_BOX);
		snapshot_trigger_on_button->color(FL_BLACK);
		snapshot_trigger_on_button->labelcolor(FL_YELLOW);
		snapshot_trigger_on_button->labelsize(9 * gsf);
		snapshot_trigger_on_button->type(FL_RADIO_BUTTON);
		snapshot_trigger_on_button->align(FL_ALIGN_CENTER);
		snapshot_trigger_on_button->value(1);
		snapshot_trigger_on_button->callback(snapshot_trigger_cb, this);
		xp += 125;

		snapshot_trigger_on_start = new Fl_Light_Button(xp * gsf, yp, 120 * gsf, 20 * gsf, "Trigger on Start");
		snapshot_trigger_on_start->box(FL_FRAME_BOX);
		snapshot_trigger_on_start->color(FL_BLACK);
		snapshot_trigger_on_start->labelcolor(FL_YELLOW);
		snapshot_trigger_on_start->labelsize(9 * gsf);
		snapshot_trigger_on_start->type(FL_RADIO_BUTTON);
		snapshot_trigger_on_start->align(FL_ALIGN_CENTER);
		snapshot_trigger_on_start->callback(snapshot_trigger_cb, this);
		xp += 125;

		snapshot_trigger_on_record = new Fl_Light_Button(xp * gsf, yp, 120 * gsf, 20 * gsf, "Trigger on Record");
		snapshot_trigger_on_record->box(FL_FRAME_BOX);
		snapshot_trigger_on_record->color(FL_BLACK);
		snapshot_trigger_on_record->labelcolor(FL_YELLOW);
		snapshot_trigger_on_record->labelsize(9 * gsf);
		snapshot_trigger_on_record->align(FL_ALIGN_CENTER);
		snapshot_trigger_on_record->type(FL_RADIO_BUTTON);
		snapshot_trigger_on_record->callback(snapshot_trigger_cb, this);
		xp += 125;

		snapshot_continuous = new Fl_Light_Button(xp * gsf, yp, 120 * gsf, 20 * gsf, "Continuous");
		snapshot_continuous->box(FL_FRAME_BOX);
		snapshot_continuous->color(FL_BLACK);
		snapshot_continuous->labelcolor(FL_YELLOW);
		snapshot_continuous->labelsize(9 * gsf);
		snapshot_continuous->align(FL_ALIGN_CENTER);
		snapshot_continuous->type(FL_RADIO_BUTTON);
		snapshot_continuous->callback(snapshot_trigger_cb, this);
		radio->end();
		yp += 30;
		if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_BUTTON)
		{
			snapshot_trigger_on_button->value(1);
		}
		else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_START)
		{
			snapshot_trigger_on_start->value(1);
		}
		else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
		{
			snapshot_trigger_on_record->value(1);
		}
		else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_CONTINUOUS)
		{
			snapshot_continuous->value(1);
		}
		scale_slider = new MySlider(100 * gsf, yp, 450 * gsf, 20 * gsf, "Scale");
		scale_slider->range(0.05, 1.0);
		scale_slider->value(cam->snapshot_scale);
		scale_slider->step(0.05);
		scale_slider->initial_value = 1.0;
		scale_slider->labelsize(11 * gsf);
		scale_slider->labelcolor(FL_YELLOW);
		scale_slider->callback(snapshot_scale_slider_cb, this);
		yp += 40;
	}
	Fl_Button *close = new Fl_Button(70 * gsf, yp, 60 * gsf, 22 * gsf, "Close");
	close->box(FL_FRAME_BOX);
	close->color(FL_BLACK);
	close->labelcolor(FL_YELLOW);
	close->labelsize(11 * gsf);
	close->callback(hide_window_cb, this);
	end();
}

SnapshotSettingWindow::~SnapshotSettingWindow()
{
}

void	SnapshotSettingWindow::draw()
{
	fl_color(FL_BLACK);
	fl_rectf(40, 40, 160, h() - 80);
	Fl_Window::draw();
}

int	SnapshotSettingWindow::handle(int event)
{
	int flag = 0;
	flag = Fl_Window::handle(event);
	if(flag == 0)
	{
		if((event == FL_FOCUS)
		|| (event == FL_UNFOCUS))
		{
			flag = 1;
		}
		else if(event == FL_KEYBOARD)
		{
			int key = Fl::event_key();
			if(key == FL_Escape)
			{
				hide();
				flag = 1;
			}
		}
		else if(event == FL_PUSH)
		{
			last_x = Fl::event_x_root();
			last_y = Fl::event_y_root();
			flag = 1;
		}
		else if(event == FL_RELEASE)
		{
			flag = 1;
		}
		else if(event == FL_DRAG)
		{
			int xx = Fl::event_x_root();
			int yy = Fl::event_y_root();
			int dx = last_x - xx;
			int dy = last_y - yy;
			resize(x() - dx, y() - dy, w(), h());
			last_x = xx;
			last_y = yy;
			flag = 1;
		}
	}
	return(flag);
}

void	SnapshotSettingWindow::Update()
{
	if(main_win != NULL)
	{
		Camera *cam = main_win->DisplayedCamera();
		if(cam != NULL)
		{
			filename_format->value(cam->snapshot_filename_format);
			initial_delay_slider->value(cam->snapshot_initial_delay);

			int nn = cam->snapshot_repeat_delay;
			int minutes = nn / 60;
			int seconds = nn - (minutes * 60);
			repeat_seconds_delay_slider->value(seconds);
			repeat_minutes_delay_slider->value(minutes);

			scale_slider->value(cam->snapshot_scale);

			if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_BUTTON)
			{
				snapshot_trigger_on_button->value(1);
			}
			else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_START)
			{
				snapshot_trigger_on_start->value(1);
			}
			else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_RECORD)
			{
				snapshot_trigger_on_record->value(1);
			}
			else if(cam->snapshot_trigger_condition == SNAPSHOT_TRIGGER_CONTINUOUS)
			{
				snapshot_continuous->value(1);
			}
		}
	}
}

void	gui_settings_cb(Fl_Widget *w, void *v)
{
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	gsw->my_window->retain_commands = gsw->retain_commands_button->value();
	gsw->my_window->retain_cameras = gsw->retain_cameras_button->value();
	gsw->my_window->retain_audio = gsw->retain_audio_button->value();
	gsw->my_window->retain_ptz = gsw->retain_ptz_button->value();
	if(gsw->retain_all_button->value())
	{
		gsw->my_window->retain_commands = 1;
		gsw->my_window->retain_cameras = 1;
		gsw->my_window->retain_audio = 1;
		gsw->my_window->retain_ptz = 1;
	}
	Fl::set_color(FL_BLACK, gsw->background_color_r, gsw->background_color_g, gsw->background_color_b);
	Fl::set_color(FL_WHITE, gsw->text_color_r, gsw->text_color_g, gsw->text_color_b);
	Fl::set_color(FL_YELLOW, gsw->highlight_color_r, gsw->highlight_color_g, gsw->highlight_color_b);
	Fl::set_color(FL_GRAY, gsw->gray_color_r, gsw->gray_color_g, gsw->gray_color_b);
	Fl::set_color(FL_RED, gsw->red_color_r, gsw->red_color_g, gsw->red_color_b);
	Fl::set_color(DARK_RED, gsw->dark_red_color_r, gsw->dark_red_color_g, gsw->dark_red_color_b);
	Fl::set_color(FL_BLUE, gsw->blue_color_r, gsw->blue_color_g, gsw->blue_color_b);
	Fl::set_color(DARK_BLUE, gsw->dark_blue_color_r, gsw->dark_blue_color_g, gsw->dark_blue_color_b);
	Fl::set_color(FL_CYAN, gsw->cyan_color_r, gsw->cyan_color_g, gsw->cyan_color_b);

	Fl_Hold_Browser *hold = (Fl_Hold_Browser *)gsw->font_browser;
	char *str = (char *)hold->text(hold->value());
	if(str != NULL)
	{
		Fl::set_font(FL_HELVETICA, str);
	}
	gsw->my_window->redraw();
	gsw->hide();
}

void	gui_setting_background_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->background_color_r;
	unsigned char green = gsw->background_color_g;
	unsigned char blue = gsw->background_color_b;
	if(fl_color_chooser("Background Color", red, green, blue, 1))
	{
		gsw->background_color_r = red;
		gsw->background_color_g = green;
		gsw->background_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_text_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->text_color_r;
	unsigned char green = gsw->text_color_g;
	unsigned char blue = gsw->text_color_b;
	if(fl_color_chooser("Text Color", red, green, blue, 1))
	{
		gsw->text_color_r = red;
		gsw->text_color_g = green;
		gsw->text_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_highlight_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->highlight_color_r;
	unsigned char green = gsw->highlight_color_g;
	unsigned char blue = gsw->highlight_color_b;
	if(fl_color_chooser("Highlight Color", red, green, blue, 1))
	{
		gsw->highlight_color_r = red;
		gsw->highlight_color_g = green;
		gsw->highlight_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_gray_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->gray_color_r;
	unsigned char green = gsw->gray_color_g;
	unsigned char blue = gsw->gray_color_b;
	if(fl_color_chooser("Gray Color", red, green, blue, 1))
	{
		gsw->gray_color_r = red;
		gsw->gray_color_g = green;
		gsw->gray_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_dark_gray_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->dark_gray_color_r;
	unsigned char green = gsw->dark_gray_color_g;
	unsigned char blue = gsw->dark_gray_color_b;
	if(fl_color_chooser("Dark Gray Color", red, green, blue, 1))
	{
		gsw->dark_gray_color_r = red;
		gsw->dark_gray_color_g = green;
		gsw->dark_gray_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_red_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->red_color_r;
	unsigned char green = gsw->red_color_g;
	unsigned char blue = gsw->red_color_b;
	if(fl_color_chooser("Red Color", red, green, blue, 1))
	{
		gsw->red_color_r = red;
		gsw->red_color_g = green;
		gsw->red_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_dark_red_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->dark_red_color_r;
	unsigned char green = gsw->dark_red_color_g;
	unsigned char blue = gsw->dark_red_color_b;
	if(fl_color_chooser("Dark Red Color", red, green, blue, 1))
	{
		gsw->dark_red_color_r = red;
		gsw->dark_red_color_g = green;
		gsw->dark_red_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_blue_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->blue_color_r;
	unsigned char green = gsw->blue_color_g;
	unsigned char blue = gsw->blue_color_b;
	if(fl_color_chooser("Blue Color", red, green, blue, 1))
	{
		gsw->blue_color_r = red;
		gsw->blue_color_g = green;
		gsw->blue_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_dark_blue_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->dark_blue_color_r;
	unsigned char green = gsw->dark_blue_color_g;
	unsigned char blue = gsw->dark_blue_color_b;
	if(fl_color_chooser("Dark Blue Color", red, green, blue, 1))
	{
		gsw->dark_blue_color_r = red;
		gsw->dark_blue_color_g = green;
		gsw->dark_blue_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	gui_setting_cyan_color_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	GUI_SettingsWindow *gsw = (GUI_SettingsWindow *)v;
	unsigned char red = gsw->cyan_color_r;
	unsigned char green = gsw->cyan_color_g;
	unsigned char blue = gsw->cyan_color_b;
	if(fl_color_chooser("Cyan Color", red, green, blue, 1))
	{
		gsw->cyan_color_r = red;
		gsw->cyan_color_g = green;
		gsw->cyan_color_b = blue;
		b->color(fl_rgb_color(red, green, blue));
		b->redraw();
	}
}

void	generic_cancel_cb(Fl_Widget *w, void *v)
{
	Fl_Window *win = (Fl_Window *)v;
	win->hide();
}

GUI_SettingsWindow::GUI_SettingsWindow(MyWin *in_win) : Fl_Window(400, 100, 330, 900)
{
int	loop;

	my_window = in_win;
	double gsf = in_win->gui_scale_factor;
	resize(x() * gsf, y() * gsf, w() * gsf, h() * gsf);
	color(FL_BLACK);
	border(0);
	box(FL_FRAME_BOX);
	clear_visible_focus();
	set_modal();

	Fl::get_color(FL_BLACK, background_color_r, background_color_g, background_color_b);
	Fl::get_color(FL_WHITE, text_color_r, text_color_g, text_color_b);
	Fl::get_color(FL_YELLOW, highlight_color_r, highlight_color_g, highlight_color_b);
	Fl::get_color(FL_GRAY, gray_color_r, gray_color_g, gray_color_b);
	Fl::get_color(DARK_GRAY, dark_gray_color_r, dark_gray_color_g, dark_gray_color_b);
	Fl::get_color(FL_RED, red_color_r, red_color_g, red_color_b);
	Fl::get_color(DARK_RED, dark_red_color_r, dark_red_color_g, dark_red_color_b);
	Fl::get_color(FL_BLUE, blue_color_r, blue_color_g, blue_color_b);
	Fl::get_color(DARK_BLUE, dark_blue_color_r, dark_blue_color_g, dark_blue_color_b);
	Fl::get_color(FL_CYAN, cyan_color_r, cyan_color_g, cyan_color_b);

	int yp = 10 * gsf;

	retain_commands_button = new Fl_Light_Button(10 * gsf, yp, 160 * gsf, 20 * gsf, "Retain Commands");
	retain_commands_button->box(FL_FRAME_BOX);
	retain_commands_button->color(FL_BLACK);
	retain_commands_button->labelcolor(FL_YELLOW);
	retain_commands_button->labelsize(9 * gsf);
	retain_commands_button->align(FL_ALIGN_CENTER);
	retain_commands_button->value(my_window->retain_commands);
	yp += (22 * gsf);
	retain_cameras_button = new Fl_Light_Button(10 * gsf, yp, 160 * gsf, 20 * gsf, "Retain Cameras");
	retain_cameras_button->box(FL_FRAME_BOX);
	retain_cameras_button->color(FL_BLACK);
	retain_cameras_button->labelcolor(FL_YELLOW);
	retain_cameras_button->labelsize(9 * gsf);
	retain_cameras_button->align(FL_ALIGN_CENTER);
	retain_cameras_button->value(my_window->retain_cameras);
	yp += (22 * gsf);
	retain_audio_button = new Fl_Light_Button(10 * gsf, yp, 160 * gsf, 20 * gsf, "Retain Audio Devices");
	retain_audio_button->box(FL_FRAME_BOX);
	retain_audio_button->color(FL_BLACK);
	retain_audio_button->labelcolor(FL_YELLOW);
	retain_audio_button->labelsize(9 * gsf);
	retain_audio_button->align(FL_ALIGN_CENTER);
	retain_audio_button->value(my_window->retain_audio);
	yp += (22 * gsf);
	retain_ptz_button = new Fl_Light_Button(10 * gsf, yp, 160 * gsf, 20 * gsf, "Retain PTZ");
	retain_ptz_button->box(FL_FRAME_BOX);
	retain_ptz_button->color(FL_BLACK);
	retain_ptz_button->labelcolor(FL_YELLOW);
	retain_ptz_button->labelsize(9 * gsf);
	retain_ptz_button->align(FL_ALIGN_CENTER);
	retain_ptz_button->value(my_window->retain_ptz);
	yp += (22 * gsf);
	retain_all_button = new Fl_Light_Button(10 * gsf, yp, 160 * gsf, 20 * gsf, "Retain All Panels");
	retain_all_button->box(FL_FRAME_BOX);
	retain_all_button->color(FL_BLACK);
	retain_all_button->labelcolor(FL_YELLOW);
	retain_all_button->labelsize(9 * gsf);
	retain_all_button->align(FL_ALIGN_CENTER);
	retain_all_button->value(0);
	yp += (26 * gsf);
	background_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Background Color");
	background_color_box->box(FL_FRAME_BOX);
	background_color_box->color(FL_BLACK);
	background_color_box->labelcolor(FL_YELLOW);
	background_color_box->labelsize(9 * gsf);
	background_color_box->align(FL_ALIGN_CENTER);
	background_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	background_color_button->box(FL_FRAME_BOX);
	background_color_button->color(fl_rgb_color(background_color_r, background_color_g, background_color_b));
	background_color_button->callback(gui_setting_background_color_cb, this);
	yp += (22 * gsf);
	text_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Text Color");
	text_color_box->box(FL_FRAME_BOX);
	text_color_box->color(FL_BLACK);
	text_color_box->labelcolor(FL_YELLOW);
	text_color_box->labelsize(9 * gsf);
	text_color_box->align(FL_ALIGN_CENTER);
	text_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	text_color_button->box(FL_FRAME_BOX);
	text_color_button->color(fl_rgb_color(text_color_r, text_color_g, text_color_b));
	text_color_button->callback(gui_setting_text_color_cb, this);
	yp += (22 * gsf);
	highlight_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Highlight Color");
	highlight_color_box->box(FL_FRAME_BOX);
	highlight_color_box->color(FL_BLACK);
	highlight_color_box->labelcolor(FL_YELLOW);
	highlight_color_box->labelsize(9 * gsf);
	highlight_color_box->align(FL_ALIGN_CENTER);
	highlight_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	highlight_color_button->box(FL_FRAME_BOX);
	highlight_color_button->color(fl_rgb_color(highlight_color_r, highlight_color_g, highlight_color_b));
	highlight_color_button->callback(gui_setting_highlight_color_cb, this);
	yp += (22 * gsf);
	gray_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Gray Color");
	gray_color_box->box(FL_FRAME_BOX);
	gray_color_box->color(FL_BLACK);
	gray_color_box->labelcolor(FL_YELLOW);
	gray_color_box->labelsize(9 * gsf);
	gray_color_box->align(FL_ALIGN_CENTER);
	gray_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	gray_color_button->box(FL_FRAME_BOX);
	gray_color_button->color(fl_rgb_color(gray_color_r, gray_color_g, gray_color_b));
	gray_color_button->callback(gui_setting_gray_color_cb, this);
	yp += (22 * gsf);
	dark_gray_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Dark Gray Color");
	dark_gray_color_box->box(FL_FRAME_BOX);
	dark_gray_color_box->color(FL_BLACK);
	dark_gray_color_box->labelcolor(FL_YELLOW);
	dark_gray_color_box->labelsize(9 * gsf);
	dark_gray_color_box->align(FL_ALIGN_CENTER);
	dark_gray_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	dark_gray_color_button->box(FL_FRAME_BOX);
	dark_gray_color_button->color(fl_rgb_color(dark_gray_color_r, dark_gray_color_g, dark_gray_color_b));
	dark_gray_color_button->callback(gui_setting_dark_gray_color_cb, this);
	yp += (22 * gsf);
	red_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Red Color");
	red_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Red Color");
	red_color_box->box(FL_FRAME_BOX);
	red_color_box->color(FL_BLACK);
	red_color_box->labelcolor(FL_YELLOW);
	red_color_box->labelsize(9 * gsf);
	red_color_box->align(FL_ALIGN_CENTER);
	red_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	red_color_button->box(FL_FRAME_BOX);
	red_color_button->color(fl_rgb_color(red_color_r, red_color_g, red_color_b));
	red_color_button->callback(gui_setting_red_color_cb, this);
	yp += (22 * gsf);
	dark_red_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Dark Red Color");
	dark_red_color_box->box(FL_FRAME_BOX);
	dark_red_color_box->color(FL_BLACK);
	dark_red_color_box->labelcolor(FL_YELLOW);
	dark_red_color_box->labelsize(9 * gsf);
	dark_red_color_box->align(FL_ALIGN_CENTER);
	dark_red_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	dark_red_color_button->box(FL_FRAME_BOX);
	dark_red_color_button->color(fl_rgb_color(dark_red_color_r, dark_red_color_g, dark_red_color_b));
	dark_red_color_button->callback(gui_setting_dark_red_color_cb, this);
	yp += (22 * gsf);
	blue_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Blue Color");
	blue_color_box->box(FL_FRAME_BOX);
	blue_color_box->color(FL_BLACK);
	blue_color_box->labelcolor(FL_YELLOW);
	blue_color_box->labelsize(9 * gsf);
	blue_color_box->align(FL_ALIGN_CENTER);
	blue_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	blue_color_button->box(FL_FRAME_BOX);
	blue_color_button->color(fl_rgb_color(blue_color_r, blue_color_g, blue_color_b));
	blue_color_button->callback(gui_setting_blue_color_cb, this);
	yp += (22 * gsf);
	dark_blue_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Dark Blue Color");
	dark_blue_color_box->box(FL_FRAME_BOX);
	dark_blue_color_box->color(FL_BLACK);
	dark_blue_color_box->labelcolor(FL_YELLOW);
	dark_blue_color_box->labelsize(9 * gsf);
	dark_blue_color_box->align(FL_ALIGN_CENTER);
	dark_blue_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	dark_blue_color_button->box(FL_FRAME_BOX);
	dark_blue_color_button->color(fl_rgb_color(dark_blue_color_r, dark_blue_color_g, dark_blue_color_b));
	dark_blue_color_button->callback(gui_setting_dark_blue_color_cb, this);
	yp += (22 * gsf);
	cyan_color_box = new Fl_Box(10 * gsf, yp, 160 * gsf, 20 * gsf, "Cyan Color");
	cyan_color_box->box(FL_FRAME_BOX);
	cyan_color_box->color(FL_BLACK);
	cyan_color_box->labelcolor(FL_YELLOW);
	cyan_color_box->labelsize(9 * gsf);
	cyan_color_box->align(FL_ALIGN_CENTER);
	cyan_color_button = new Fl_Button(180 * gsf, yp, 20 * gsf, 20 * gsf);
	cyan_color_button->box(FL_FRAME_BOX);
	cyan_color_button->color(fl_rgb_color(cyan_color_r, cyan_color_g, cyan_color_b));
	cyan_color_button->callback(gui_setting_cyan_color_cb, this);
	yp += (42 * gsf);
	font_browser = new Fl_Hold_Browser(10 * gsf, yp, 300 * gsf, 200 * gsf, "Font");
	font_browser->color(FL_BLACK);
	font_browser->box(FL_FRAME_BOX);
	font_browser->textcolor(FL_WHITE);
	font_browser->labelcolor(FL_WHITE);
	font_browser->labelsize(11 * gsf);
	font_browser->textsize(9 * gsf);
	font_browser->selection_color(FL_YELLOW);
	font_browser->scrollbar_size(4);
	font_browser->scrollbar.color(FL_BLACK);
	font_browser->align(FL_ALIGN_TOP);
	int nn = my_window->number_of_fonts;
	for(loop = 0;loop < nn;loop++)
	{
		char *str = (char *)Fl::get_font_name(loop);
		font_browser->add(str);
	}
	font_browser->select(1);
	yp += (204 * gsf);
	int bottom = yp + 32;

	yp = 10 * gsf;
	Fl_Button *accept = new Fl_Button(180 * gsf, yp, 60 * gsf, 20 * gsf, "Accept");
	accept->box(FL_FRAME_BOX);
	accept->color(FL_BLACK);
	accept->labelcolor(FL_YELLOW);
	accept->labelsize(9 * gsf);
	accept->align(FL_ALIGN_CENTER);
	accept->callback(gui_settings_cb, this);
	yp += (22 * gsf);
	Fl_Button *cancel = new Fl_Button(180 * gsf, yp, 60 * gsf, 20 * gsf, "Cancel");
	cancel->box(FL_FRAME_BOX);
	cancel->color(FL_BLACK);
	cancel->labelcolor(FL_YELLOW);
	cancel->labelsize(9 * gsf);
	cancel->align(FL_ALIGN_CENTER);
	cancel->callback(generic_cancel_cb, this);
	yp += (22 * gsf);
	end();
	resize(x(), y(), w(), bottom);
}

GUI_SettingsWindow::~GUI_SettingsWindow()
{
}

FilterButton::FilterButton(FilterPluginsWindow *in_win, int xx, int yy, int ww, int hh, char *lbl) : Fl_Box(xx, yy, ww, hh, lbl)
{
void	move_filter_button_cb(Fl_Widget *w, void *v);

	my_window = in_win;
	dragging = 0;

	box(FL_NO_BOX);
	color(FL_BLACK);
	labelcolor(FL_WHITE);
	labelsize(11);
	align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	callback(move_filter_button_cb, this);

	filter_dialog = my_window->my_window->MakeFilterDialog(lbl);
}

FilterButton::~FilterButton()
{
	if(filter_dialog != NULL)
	{
		filter_dialog->hide();
		Fl_Group *grp = filter_dialog->parent();
		if(grp != NULL)
		{
			grp->remove(filter_dialog);
			Fl::delete_widget(filter_dialog);
		}
	}
}

int	FilterButton::handle(int event)
{
int		loop;

	int flag = 0;
	if(event == FL_PUSH)
	{
		int xx = Fl::event_x();
		int yy = Fl::event_y();
		offset_x = xx - x();
		offset_y = yy - y();
		dragging = 1;
		flag = 1;
	}
	else if((event == FL_MOVE) || (event == FL_DRAG))
	{
		if(dragging == 1)
		{
			int xx = Fl::event_x();
			int yy = Fl::event_y();
			int pyy = yy - my_window->use->y();
			int py = pyy / 20;
			int col_flag = 1;
			if(x() < 100)
			{
				col_flag = 2;
				my_window->available->box(FL_FRAME);
				my_window->use->box(FL_NO_BOX);
			}
			else
			{
				my_window->available->box(FL_NO_BOX);
				my_window->use->box(FL_FRAME);
			}
			my_window->Arrange(col_flag, py);
			window()->add(this);
			resize(xx - offset_x, yy - offset_y, w(), h());
			redraw();
			window()->redraw();
		}
	}
	else if(event == FL_RELEASE)
	{
		int yy = Fl::event_y();
		int pyy = yy - my_window->use->y();
		int py = pyy / 20;
		if(x() > 100)
		{
			if(parent() == my_window)
			{
				my_window->use->insert(*this, py);
				if(my_window->filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
				{
					int cnt = my_window->available->children() + 1;
					FilterButton *filter_button = new FilterButton(my_window, my_window->available->x(), my_window->available->y() + (cnt * 20), 120, 20, (char *)label());
					my_window->available->add(filter_button);
				}
			}
		}
		else
		{
			if(my_window->filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
			{
				if(parent() == my_window)
				{
					my_window->use->remove(this);
					hide();
				}
			}
			else
			{
				if(parent() == my_window)
				{
					my_window->available->insert(*this, py);
				}
			}
		}
		my_window->Arrange();
		my_window->available->box(FL_NO_BOX);
		my_window->use->box(FL_NO_BOX);
		window()->redraw();
		dragging = 0;
		flag = 1;
	}
	if(flag == 0)
	{
		flag = Fl_Box::handle(event);
	}
	return(flag);
}

void	move_filter_button_cb(Fl_Widget *w, void *v)
{
int	loop;

	FilterPluginsWindow *fpw = (FilterPluginsWindow *)v;
	Fl_Button *b = (Fl_Button *)w;
	if(b->parent() == fpw->available)
	{
		double gsf = fpw->my_window->gui_scale_factor;
		fpw->available->remove(b);
		fpw->use->add(b);
	}
	else
	{
		fpw->available->add(b);
		fpw->use->remove(b);
	}
	fpw->redraw();
}

void	use_no_filters_cb(Fl_Widget *w, void *v)
{
	FilterPluginsWindow *fpw = (FilterPluginsWindow *)v;
	while(fpw->use->children() > 0)
	{
		Fl_Widget *b = fpw->use->child(0);
		fpw->use->remove(b);
		fpw->available->add(b);
	}
	fpw->Arrange();
	fpw->redraw();
}

FilterDialog	*MyWin::MakeFilterDialog(char *name)
{
int	loop;

	FilterDialog *dialog = NULL;
	if(strcmp(name, "Grayscale") == 0)
	{
		dialog = new GrayscaleFilterDialog(this, 0, 0, 100, 22, (char *)strdup(name));
	}
	else if(strcmp(name, "Threshold") == 0)
	{
		dialog = new ThresholdFilterDialog(this, 0, 0, 100, 90, (char *)strdup(name));
		dialog->number[0] = 128.0;
		dialog->number[1] = 255.0;
		dialog->str[0] = strdup("Binary");
		dialog->str[1] = strdup("Binary Inv.");
		dialog->str[2] = strdup("Truncate");
		dialog->str[3] = strdup("To Zero");
		dialog->str[4] = strdup("To Zero Inv.");
		dialog->limit = 5;
	}
	else if(strcmp(name, "Invert") == 0)
	{
		dialog = new InvertFilterDialog(this, 0, 0, 100, 22, (char *)strdup(name));
	}
	else if(strcmp(name, "Edge Detect") == 0)
	{
		dialog = new EdgeDetectFilterDialog(this, 0, 0, 100, 110, (char *)strdup(name));
		dialog->number[0] = 3.0;
		dialog->number[1] = 30.0;
		dialog->number[2] = 70.0;
		dialog->number[3] = 0.5;
	}
	else if(strcmp(name, "Brightness") == 0)
	{
		dialog = new BrightnessFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 0.5;
	}
	else if(strcmp(name, "Contrast") == 0)
	{
		dialog = new ContrastFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 0.5;
	}
	else if(strcmp(name, "Saturation") == 0)
	{
		dialog = new SaturationFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 1.0;
	}
	else if(strcmp(name, "Hue") == 0)
	{
		dialog = new HueFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 1.0;
	}
	else if(strcmp(name, "CLAHE") == 0)
	{
		dialog = new ClaheFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 2.0;
	}
	else if(strcmp(name, "Color Intensity") == 0)
	{
		dialog = new ColorIntensityFilterDialog(this, 0, 0, 100, 110, (char *)strdup(name));
		dialog->number[0] = 1.0;
		dialog->number[1] = 1.0;
		dialog->number[2] = 1.0;
		dialog->number[3] = 1.0;
	}
	else if(strcmp(name, "Blur") == 0)
	{
		dialog = new BlurFilterDialog(this, 0, 0, 100, 42, (char *)strdup(name));
		dialog->number[0] = 1.0;
	}
	else if(strcmp(name, "Crop") == 0)
	{
		dialog = new CropFilterDialog(this, 0, 0, 100, 110, (char *)strdup(name));
		dialog->number[0] = 0.0;
		dialog->number[1] = 1.0;
		dialog->number[2] = 0.0;
		dialog->number[3] = 1.0;
	}
	else if(strcmp(name, "Scale") == 0)
	{
		dialog = new ScaleFilterDialog(this, 0, 0, 100, 110, (char *)strdup(name));
		dialog->number[0] = 1.0;
		dialog->number[1] = 1.0;
	}
	else if(strcmp(name, "Blend") == 0)
	{
		dialog = new BlendFilterDialog(this, 0, 0, 100, 90, (char *)strdup(name));
		dialog->number[0] = 0.5;
		int cnt = 0;
		for(loop = 0;loop < source_cnt;loop++)
		{
			Camera *cam = camera[loop];
			if(cam != NULL)
			{
				dialog->str[cnt] = strdup(cam->alias);
				cnt++;
			}
		}
		dialog->limit = cnt;
	}
	else if(strcmp(name, "Bevel") == 0)
	{
		dialog = new BevelFilterDialog(this, 0, 0, 100, 130, (char *)strdup(name));
		dialog->number[0] = 30;
		dialog->number[1] = 32;
		dialog->number[2] = 1;
		dialog->number[3] = 1;
		dialog->number[4] = 1;
	}
	else if(strcmp(name, "Gradient") == 0)
	{
		dialog = new GradientFilterDialog(this, 0, 0, 100, 220, (char *)strdup(name));
		dialog->str[0] = strdup("Vertical");
		dialog->str[1] = strdup("Horizontal");
		dialog->limit = 2;
		dialog->number[0] = 0;
		dialog->number[1] = 0;
		dialog->number[2] = 0;
		dialog->number[3] = 0;
		dialog->number[4] = 255;
		dialog->number[5] = 255;
		dialog->number[6] = 255;
		dialog->number[7] = 255;
	}
	return(dialog);
}

void	filters_accept_cb(Fl_Widget *w, void *v)
{
int	loop;
int	inner;
int	inner2;
char	buf[256];

	FilterPluginsWindow *fpw = (FilterPluginsWindow *)v;
	Camera *cam = fpw->my_window->DisplayedCamera();
	if(cam != NULL)
	{
		if(fpw->filter_type == FILTER_TYPE_VIDEO)
		{
			for(loop = 0;loop < 128;loop++)
			{
				cam->filter_plugin[loop] = NULL;
				if(cam->filter_plugin_name[loop] != NULL)
				{
					free(cam->filter_plugin_name[loop]);
					cam->filter_plugin_name[loop] = NULL;
				}
			}
		}
		else if(fpw->filter_type == FILTER_TYPE_AUDIO)
		{
			for(inner2 = 0;inner2 < fpw->my_window->pulse_microphone_cnt;inner2++)
			{
				PulseMicrophone *mic = fpw->my_window->pulse_microphone[inner2];
				if(mic != NULL)
				{
					for(loop = 0;loop < 128;loop++)
					{
						mic->filter_plugin[loop] = NULL;
					}
					mic->filter_plugin_cnt = 0;
				}
			}
		}
		else if(fpw->filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
		{
			for(loop = 0;loop < 128;loop++)
			{
				if(cam->filter_name[loop] != NULL)
				{
					free(cam->filter_name[loop]);
					cam->filter_name[loop] = NULL;
				}
				if(cam->filter_dialog[loop] != NULL)
				{
					cam->filter_dialog[loop]->hide();
					cam->my_window->remove(cam->filter_dialog[loop]);
					cam->filter_dialog[loop] = NULL;
				}
			}
		}
		int cnt = 0;
		for(loop = 0;loop < fpw->use->children();loop++)
		{
			Fl_Widget *b = fpw->use->child(loop);
			if(b != NULL)
			{
				if(b->label() != NULL)
				{
					if(fpw->filter_type == FILTER_TYPE_VIDEO)
					{
						sprintf(buf, "filter_%s", b->label());
						for(inner = 0;inner < global_potential_filter_cnt;inner++)
						{
							if((global_potential_filter[inner] != NULL) && (global_potential_filter_handle[inner] != NULL))
							{
								if(strcmp(buf, global_potential_filter[inner]) == 0)
								{
									if(cnt < 128)
									{
										cam->filter_plugin[cnt] = (void *)dlsym(global_potential_filter_handle[inner], global_potential_filter[inner]);
										cam->filter_plugin_name[cnt] = strdup(buf);
										if(cam->filter_plugin[cnt] != NULL)
										{
											cnt++;
										}
									}
								}
							}
						}
					}
					else if(fpw->filter_type == FILTER_TYPE_AUDIO)
					{
						sprintf(buf, "audio_filter_%s", b->label());
						for(inner = 0;inner < global_potential_audio_filter_cnt;inner++)
						{
							if((global_potential_audio_filter[inner] != NULL) && (global_potential_filter_handle[inner] != NULL))
							{
								if(strcmp(buf, global_potential_audio_filter[inner]) == 0)
								{
									for(inner2 = 0;inner2 < fpw->my_window->pulse_microphone_cnt;inner2++)
									{
										PulseMicrophone *mic = fpw->my_window->pulse_microphone[inner2];
										if(mic != NULL)
										{
											if(mic->stop == 0)
											{
												mic->filter_plugin[mic->filter_plugin_cnt] = (void *)dlsym(global_potential_filter_handle[inner], global_potential_audio_filter[inner]);
												if(mic->filter_plugin[mic->filter_plugin_cnt] != NULL)
												{
													mic->filter_plugin_cnt++;
												}
											}
										}
									}
								}
							}
						}
					}
					else if(fpw->filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
					{
						FilterButton *filter_button = (FilterButton *)b;
						cam->filter_name[cnt] = strdup(filter_button->label());
						cam->filter_dialog[cnt] = filter_button->filter_dialog;
						cam->my_window->add(filter_button->filter_dialog);
						filter_button->filter_dialog->show();
						cnt++;
					}
				}
			}
		}
		if(fpw->filter_type == FILTER_TYPE_VIDEO)
		{
			cam->filter_plugin_cnt = cnt;
		}
		else if(fpw->filter_type == FILTER_TYPE_AUDIO)
		{
		}
		else if(fpw->filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
		{
			cam->filter_cnt = cnt;
		}
	}
	fpw->hide();
}

FilterPluginsWindow::FilterPluginsWindow(MyWin *in_win, int in_filter_type) : TransparentWindow(in_win, 400, 300, 270, 400)
{
int	loop;

	my_window = in_win;
	filter_type = in_filter_type;
	double gsf = in_win->gui_scale_factor;
	resize(x() * gsf, y() * gsf, w() * gsf, h() * gsf);

	color(FL_BLACK);
	border(0);
	box(FL_FRAME);
	clear_visible_focus();
	set_non_modal();

	Fl_Box *available_label = new Fl_Box(10 * gsf, 5 * gsf, 120 * gsf, 20 * gsf, "Available");
	available_label->box(FL_NO_BOX);
	available_label->labelcolor(FL_GRAY);
	available_label->labelsize(13 * gsf);
	available_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	
	Fl_Box *use_label = new Fl_Box(130 * gsf, 5 * gsf, 120 * gsf, 20 * gsf, "Use");
	use_label->box(FL_NO_BOX);
	use_label->labelcolor(FL_GRAY);
	use_label->labelsize(13 * gsf);
	use_label->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);

	int use_cnt = 0;
	if((filter_type == FILTER_TYPE_VIDEO)
	|| (filter_type == FILTER_TYPE_AUDIO))
	{
		use_cnt = global_potential_filter_cnt;
	}
	else
	{
		use_cnt = 9;
	}
	available = new Fl_Pack(10 * gsf, 25 * gsf, 120 * gsf, (use_cnt * 20) * gsf);
	available->box(FL_NO_BOX);
	available->color(FL_WHITE);
	available->end();

	use = new Fl_Pack(140 * gsf, 25 * gsf, 120 * gsf, (use_cnt * 20) * gsf);
	use->box(FL_NO_BOX);
	use->color(FL_WHITE);
	use->end();

	int cnt = 0;
	if(filter_type == FILTER_TYPE_VIDEO)
	{
		for(loop = 0;loop < global_potential_filter_cnt;loop++)
		{
			if((global_potential_filter[loop] != NULL) && (global_potential_filter_handle[loop] != NULL))
			{
				char *str = global_potential_filter[loop] + strlen("filter_");
				FilterButton *filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, str);
				available->add(filter_button);
				cnt++;
			}
		}
	}
	else if(filter_type == FILTER_TYPE_AUDIO)
	{
		for(loop = 0;loop < global_potential_audio_filter_cnt;loop++)
		{
			if((global_potential_audio_filter[loop] != NULL) && (global_potential_audio_filter_handle[loop] != NULL))
			{
				char *str = global_potential_audio_filter[loop] + strlen("audio_filter_");
				FilterButton *filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, str);
				available->add(filter_button);
				cnt++;
			}
		}
	}
	else if(filter_type == FILTER_TYPE_VIDEO_BUILT_IN)
	{
		FilterButton *filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Grayscale");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Threshold");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Invert");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Edge Detect");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Brightness");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Contrast");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Saturation");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Hue");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "CLAHE");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Color Intensity");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Blur");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Crop");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Scale");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Blend");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Bevel");
		available->add(filter_button);
		cnt++;
		filter_button = new FilterButton(this, available->x(), available->y() + ((cnt * 20) * gsf), 120 * gsf, 20 * gsf, "Gradient");
		available->add(filter_button);
		cnt++;
	}
	my_accept = new Fl_Button(10 * gsf, (35 + (22 * cnt)) * gsf, 120 * gsf, 20 * gsf, "Accept");
	my_accept->box(FL_NO_BOX);
	my_accept->color(FL_WHITE);
	my_accept->labelcolor(FL_YELLOW);
	my_accept->labelsize(12 * gsf);
	my_accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	my_accept->callback(filters_accept_cb, this);

	my_cancel = new Fl_Button(140 * gsf, (35 + (22 * cnt)) * gsf, 120 * gsf, 20 * gsf, "Use None");
	my_cancel->box(FL_NO_BOX);
	my_cancel->color(FL_WHITE);
	my_cancel->labelcolor(FL_YELLOW);
	my_cancel->labelsize(12 * gsf);
	my_cancel->callback(use_no_filters_cb, this);
	cnt++;
	end();
	resize(x(), y(), w(), (45 + (cnt * 22)) * gsf);
}

FilterPluginsWindow::~FilterPluginsWindow()
{
}

void	FilterPluginsWindow::draw()
{
	TransparentWindow::draw();
}

void	FilterPluginsWindow::Arrange(int flag, int py)
{
int	loop;

	int cnt = 0;
	int max1 = 0;
	int max2 = 0;
	for(loop = 0;loop < use->children();loop++)
	{
		Fl_Widget *child = use->child(loop);
		if(child != NULL)
		{
			if(flag == 1)
			{
				if(py == loop)
				{
					cnt++;
				}
			}
			child->resize(use->x(), use->y() + (cnt * 20), child->w(), child->h());
			max1 = use->y() + (cnt * 20) + child->h();
			cnt++;
		}
	}
	cnt = 0;
	for(loop = 0;loop < available->children();loop++)
	{
		Fl_Widget *child = available->child(loop);
		if(child != NULL)
		{
			if(flag == 2)
			{
				if(py == loop)
				{
					cnt++;
				}
			}
			child->resize(available->x(), available->y() + (cnt * 20), child->w(), child->h());
			max2 = use->y() + (cnt * 20) + child->h();
			cnt++;
		}
	}
	int max = 0;
	if(max2 > max1) max = max2;
	else max = max1;
	resize(x(), y(), w(), max + 40);
	my_accept->resize(my_accept->x(), h() - 20, my_accept->w(), my_accept->h());
	my_cancel->resize(my_cancel->x(), h() - 20, my_cancel->w(), my_cancel->h());
}

void	plugin_camera_cancel_cb(Fl_Widget *w, void *v)
{
	PseudoCameraWindow *pcw = (PseudoCameraWindow *)v;
	pcw->hide();
}

void	select_plugin_camera_cb(Fl_Widget *w, void *v)
{
char	buf[4092];
char	use[4092];
int	loop;

	PseudoCameraWindow *pcw = (PseudoCameraWindow *)v;
	NewSourceWindow *nsw = pcw->my_window->new_source_window;
	Fl_Button *b = (Fl_Button *)w;
	if(b->label() != NULL)
	{
		sprintf(buf, "camera_%s", b->label());
		for(loop = 0;loop < global_potential_camera_cnt;loop++)
		{
			if((global_potential_camera[loop] != NULL) && (global_potential_camera_handle[loop] != NULL))
			{
				if(strcmp(global_potential_camera[loop], buf) == 0)
				{ 
					void *handle = global_potential_camera_handle[loop];
					void *void_camera_plugin = (void *)dlsym(handle, buf);

					sprintf(use, "plugin://%ld", (long int)void_camera_plugin);
					int cam_n = pcw->my_window->SetupCamera(use, "Text", 1920, 1080, 11);
					if(cam_n > -1)
					{
						pcw->my_window->Display(cam_n);
						while(pcw->my_window->displayed_source >= (pcw->my_window->start_thumbgroup + DISPLAYED_THUMB_CNT))
						{
							pcw->my_window->start_thumbgroup++;
						}
					}
				}
			}
		}
	}
	pcw->hide();
	nsw->hide();
}

class	SelectAudioButton : public Fl_Button
{
public:
			SelectAudioButton(int xx, int yy, int ww, int hh, char *lbl, char *in_use_str) : Fl_Button(xx, yy, ww, hh, lbl) 
			{
				use_str = strdup(in_use_str);
			};
			~SelectAudioButton() 
			{
				if(use_str != NULL)
				{
					free(use_str);
				}
			};
	char	*use_str;
};

void	select_audio_cb(Fl_Widget *w, void *v)
{
int	loop;

	SelectAudioButton *b = (SelectAudioButton *)w;
	SelectAudioWindow *saw = (SelectAudioWindow *)v;
	if(saw->my_window->audio_thumbnail_cnt < 128)
	{
		double gsf = saw->my_window->gui_scale_factor;
		int started_here = 0;
		if(saw->my_window->pulse_mixer == NULL)
		{
			saw->my_window->pulse_mixer = new PulseMixer(saw->my_window, FRAMES_PER_BUFFER);
			started_here = 1;
		}
		int nyy = 10 * gsf;
		int nxx = (600 * gsf) + (saw->my_window->audio_thumbnail_cnt * 155 * gsf);
		char *str = strdup(b->use_str);
		char *use_str = strdup(b->label());
		if((str != NULL) && (use_str != NULL))
		{
			if((strcmp(str, "File") == 0)
			&& (strcmp(use_str, "Audio File") == 0))
			{
				Fl_Native_File_Chooser nfc;
				nfc.title("Select an audio file");
				nfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
				nfc.filter("*.{mp3,wav,flac}");
				int nn = nfc.show();
				if((nn != -1) && (nn != 1))
				{
					char *fn = (char *)nfc.filename();
					if(fn != NULL)
					{
						free(str);
						str = strdup(fn);
						free(use_str);
						use_str = strdup(fn);
					}
				}
			}
		}
		char *cp = use_str;
		int cnt = 0;
		char last_cp = '\0';
		while(*cp != '\0')
		{
			if(isalnum(*cp))
			{
				use_str[cnt] = *cp;
				cnt++;
				last_cp = *cp;
			}
			else
			{
				if(last_cp != ' ')
				{
					use_str[cnt] = ' ';
					cnt++;
				}
				last_cp = ' ';
			}
			cp++;
		}
		use_str[cnt] = '\0';
		PulseAudioButton *at = new PulseAudioButton(saw->my_window, str, nxx, nyy, 150 * gsf, 60 * gsf, use_str);
		if(at->microphone != NULL)
		{
			int which = saw->my_window->audio_thumbnail_cnt / 7;
			int done = -1;
			for(loop = 0;((loop < saw->my_window->audio_thumbnail_cnt) && (done == -1));loop++)
			{
				if(saw->my_window->audio_thumbnail[loop] == NULL)
				{
					done = loop;
				}
			}
			if(done == -1)
			{
				saw->my_window->audio_thumbnail[saw->my_window->audio_thumbnail_cnt] = at;
				saw->my_window->audio_thumbnail_cnt++;
			}
			else
			{
				int nxx = (600 * gsf) + (done * 155 * gsf);
				at->resize(nxx, at->y(), at->w(), at->h());
				saw->my_window->audio_thumbnail[done] = at;
			}
			if(which < 3)
			{
				Fl_Pack *pack = saw->my_window->audio_thumbnail_pack[which];
				if(pack != NULL)
				{
					pack->add(at);
				}
			}
		}
		else
		{
			at->hide();
			Fl::delete_widget(at);
		}
		if(started_here == 1)
		{
			saw->my_window->RunPulse(MODE_RECORD);
			saw->my_window->RunPulse(MODE_PLAY);
		}
	}
	saw->hide();
	Fl::delete_widget(saw);
}

SelectAudioWindow::SelectAudioWindow(MyWin *in_win) : TransparentWindow(in_win, 800, 320, 460, 180)
{
int	loop;
char *list[128];
char *description[128];
int index[128];

	my_window = in_win;
	color(FL_BLACK);
	border(0);
	clear_visible_focus();
	set_non_modal();
	int nn = pulse_list_devices(1, 128, list, description, index);
	int max = -1;
	fl_font(FL_HELVETICA, 11);
	for(loop = 0;loop < nn;loop++)
	{
		int mx = 0;
		int my = 0;
		fl_measure(list[loop], mx, my);
		if(mx > max) max = mx;
	}
	if(max < 460) max = 460;
	int y_cnt = 10;
	for(loop = 0;loop < nn;loop++)
	{
		SelectAudioButton *b = new SelectAudioButton(10, y_cnt, max + 5, 20, strdup(description[loop]), list[loop]);
		b->box(FL_FLAT_BOX);
		b->color(DARK_BLUE);
		b->labelcolor(FL_YELLOW);
		b->labelsize(11);
		b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		b->callback(select_audio_cb, this);
		y_cnt += 21;
		free(list[loop]);
		free(description[loop]);
	}
	SelectAudioButton *b = new SelectAudioButton(10, y_cnt, max + 5, 20, "Audio File", "File");
	b->box(FL_FLAT_BOX);
	b->color(fl_lighter(DARK_BLUE));
	b->labelcolor(FL_YELLOW);
	b->labelsize(11);
	b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
	b->callback(select_audio_cb, this);
	y_cnt += 21;
	end();
	resize(x(), y(), max + 25, 10 + y_cnt);
}

SelectAudioWindow::~SelectAudioWindow()
{
}

void	SelectAudioWindow::draw()
{
	TransparentWindow::draw();
}

class	CameraFormatButton : public Fl_Button
{
public:
			CameraFormatButton(int xx, int yy, int ww, int hh, char *lbl) : Fl_Button(xx, yy, ww, hh, lbl) {};
			~CameraFormatButton() {};
	char	*path;
	char	*alias;
	int		fmt;
};

void	select_camera_format_cb(Fl_Widget *w, void *v)
{
char buf[4096];
char fourcc[5];

	CameraFormatButton *b = (CameraFormatButton *)w;
	SelectCameraWindow *scw = (SelectCameraWindow *)v;
	int tmp = b->fmt;
	sprintf(fourcc, "%c%c%c%c", tmp & 0xff, (tmp >> 8) & 0xff, (tmp >> 16) & 0xff, (tmp >> 24) & 0xff);
	sprintf(buf, "%s::V4L2:%s", b->path, fourcc);
	scw->my_window->SetupCamera(buf, b->alias, scw->my_window->requested_w, scw->my_window->requested_h, 32);
	scw->hide();
	Fl::delete_widget(scw);
}

SelectCameraWindow::SelectCameraWindow(MyWin *in_win) : TransparentWindow(in_win, 800, 320, 460, 180)
{
int	loop, inner;

	my_window = in_win;
	color(FL_BLACK);
	border(0);
	clear_visible_focus();
	set_non_modal();
	int cnt = my_window->PopulateCameraCaps();
	int y_cnt = 10;
	for(loop = 0;loop < cnt;loop++)
	{
		int inner;
		char *path = my_window->camera_caps[loop]->path;
		char *alias = my_window->camera_caps[loop]->alias;

		Fl_Box *b = new Fl_Box(10, y_cnt, 300, 20, alias);
		b->box(FL_NO_BOX);
		b->color(FL_BLACK);
		b->labelcolor(FL_WHITE);
		b->labelsize(11);
		b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
		y_cnt += 21;

		for(inner = 0;inner < my_window->camera_caps[loop]->fourcc_cnt;inner++)
		{
			int tmp = my_window->camera_caps[loop]->fourcc[inner];
			char *desc = my_window->camera_caps[loop]->fourcc_description[inner];
			char buf[4092];
			sprintf(buf, "%c%c%c%c %s", tmp & 0xff, (tmp >> 8) & 0xff, (tmp >> 16) & 0xff, (tmp >> 24) & 0xff, desc);

			CameraFormatButton *b = new CameraFormatButton(150, y_cnt, 300, 20, strdup(buf));
			b->path = path;
			b->alias = alias;
			b->fmt = tmp;

			b->box(FL_FLAT_BOX);
			b->color(DARK_BLUE);
			b->labelcolor(FL_YELLOW);
			b->labelsize(11);
			b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
			b->callback(select_camera_format_cb, this);
			y_cnt += 21;
		}
	}
	end();
	resize(x(), y(), w(), 10 + y_cnt);
}

SelectCameraWindow::~SelectCameraWindow()
{
}

void	SelectCameraWindow::draw()
{
	TransparentWindow::draw();
}

PseudoCameraWindow::PseudoCameraWindow(MyWin *in_win) : TransparentWindow(in_win, 1075, 300, 140, 180)
{
int	loop;

	my_window = in_win;
	color(FL_BLACK);
	border(0);
	clear_visible_focus();
	set_non_modal();
	int cnt = 0;
	for(loop = 0;loop < global_potential_camera_cnt;loop++)
	{
		if((global_potential_camera[loop] != NULL) && (global_potential_camera_handle[loop] != NULL))
		{
			char *str = global_potential_camera[loop] + strlen("camera_");
			pseudo[cnt] = new Fl_Button(10, 10 + (22 * cnt), 120, 20, str);
			pseudo[cnt]->box(FL_FLAT_BOX);
			pseudo[cnt]->color(FL_BLACK);
			pseudo[cnt]->labelcolor(FL_WHITE);
			pseudo[cnt]->labelsize(11);
			pseudo[cnt]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
			pseudo[cnt]->callback(select_plugin_camera_cb, this);
			cnt++;
		}
	}
	pseudo[cnt] = new Fl_Button(10, 10 + (22 * cnt), 120, 20, "Cancel");
	pseudo[cnt]->box(FL_FLAT_BOX);
	pseudo[cnt]->color(FL_BLACK);
	pseudo[cnt]->labelcolor(FL_YELLOW);
	pseudo[cnt]->labelsize(11);
	pseudo[cnt]->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	pseudo[cnt]->callback(plugin_camera_cancel_cb, this);
	cnt++;
	end();
	resize(x(), y(), w(), 20 + (cnt * 22));
}

PseudoCameraWindow::~PseudoCameraWindow()
{
}

void	PseudoCameraWindow::draw()
{
	TransparentWindow::draw();
}

void	transitions_close_cb(Fl_Widget *w, void *v)
{
	if(v != NULL)
	{
		TransitionWindow *win = (TransitionWindow *)v;
		win->hide();
	}
}

void	transition_select_cb(Fl_Widget *w, void *v)
{
	Fl_Button *b = (Fl_Button *)w;
	TransitionWindow *win = (TransitionWindow *)v;
	if(b == win->none_button)
	{
		win->my_window->transition = TRANSITION_NONE;
	}
	else if(b == win->blend_button)
	{
		win->my_window->transition = TRANSITION_BLEND;
	}
	else if(b == win->to_black_button)
	{
		win->my_window->transition = TRANSITION_FADE_TO_BLACK;
	}
	else if(b == win->wipe_l2r_button)
	{
		win->my_window->transition = TRANSITION_L2R_WIPE;
	}
	else if(b == win->wipe_r2l_button)
	{
		win->my_window->transition = TRANSITION_R2L_WIPE;
	}
	else if(b == win->wipe_t2b_button)
	{
		win->my_window->transition = TRANSITION_T2B_WIPE;
	}
	else if(b == win->wipe_b2t_button)
	{
		win->my_window->transition = TRANSITION_B2T_WIPE;
	}
	win->Update();
}


TransitionWindow::TransitionWindow(MyWin *in_win) : TransparentWindow(in_win, 350, 300, 780, 180)
{
	my_window = in_win;
	double gsf = in_win->gui_scale_factor;
	resize(x() * gsf, y() * gsf, w() * gsf, h() * gsf);

	border(0);
	box(FL_NO_BOX);
	color(FL_BLACK);

	int x_pos = (10 * gsf);
	Fl_PNG_Image *none = new Fl_PNG_Image("transition_none.png");
	none_button = new Fl_Button(x_pos, 40 * gsf, 100 * gsf, 100 * gsf);
	none_button->image(none);
	none_button->type(FL_RADIO_BUTTON);
	none_button->callback(transition_select_cb, this);
	x_pos += (110 * gsf);

	Fl_PNG_Image *blend = new Fl_PNG_Image("transition_blend.png");
	blend_button = new Fl_Button(x_pos, 40 * gsf, 100 * gsf, 100 * gsf);
	blend_button->image(blend);
	blend_button->type(FL_RADIO_BUTTON);
	blend_button->callback(transition_select_cb, this);
	x_pos += (110 * gsf);

	Fl_PNG_Image *to_black = new Fl_PNG_Image("transition_2black.png");
	to_black_button = new Fl_Button(x_pos, 40 * gsf, 100 * gsf, 100 * gsf);
	to_black_button->image(to_black);
	to_black_button->type(FL_RADIO_BUTTON);
	to_black_button->callback(transition_select_cb, this);
	x_pos += (110 * gsf);

	Fl_PNG_Image *wipe_l2r = new Fl_PNG_Image("transition_wipe_l2r.png");
	wipe_l2r_button = new Fl_Button(x_pos, 40 * gsf, 100 * gsf, 100 * gsf);
	wipe_l2r_button->image(wipe_l2r);
	wipe_l2r_button->type(FL_RADIO_BUTTON);
	wipe_l2r_button->callback(transition_select_cb, this);
	x_pos += (110 * gsf);

	Fl_PNG_Image *wipe_r2l = new Fl_PNG_Image("transition_wipe_r2l.png");
	wipe_r2l_button = new Fl_Button(x_pos, 40 * gsf, 100 * gsf, 100 * gsf);
	wipe_r2l_button->image(wipe_r2l);
	wipe_r2l_button->type(FL_RADIO_BUTTON);
	wipe_r2l_button->callback(transition_select_cb, this);
	x_pos += (110 * gsf);

	Fl_PNG_Image *wipe_t2b = new Fl_PNG_Image("transition_wipe_t2b.png");
	wipe_t2b_button = new Fl_Button(x_pos, 40 * gsf, 100 * gsf, 100 * gsf);
	wipe_t2b_button->image(wipe_t2b);
	wipe_t2b_button->type(FL_RADIO_BUTTON);
	wipe_t2b_button->callback(transition_select_cb, this);
	x_pos += (110 * gsf);

	Fl_PNG_Image *wipe_b2t = new Fl_PNG_Image("transition_wipe_b2t.png");
	wipe_b2t_button = new Fl_Button(x_pos, 40 * gsf, 100 * gsf, 100 * gsf);
	wipe_b2t_button->image(wipe_b2t);
	wipe_b2t_button->type(FL_RADIO_BUTTON);
	wipe_b2t_button->callback(transition_select_cb, this);

	Fl_Button *close = new Fl_Button(x_pos + (30 * gsf), 5 * gsf, 100 * gsf, 30 * gsf, "Close");
	close->box(FL_NO_BOX);
	close->color(FL_BLACK);
	close->labelcolor(FL_YELLOW);
	close->labelsize(12 * gsf);
	close->callback(transitions_close_cb, this);

	selection = new Fl_Box(0, 0, 48 * gsf, 48 * gsf, "@#+88->");
	selection->box(FL_NO_BOX);
	selection->labelcolor(FL_YELLOW);
	selection->hide();

	hide();
	end();
	Update();
}

TransitionWindow::~TransitionWindow()
{
}

void	TransitionWindow::draw()
{
	TransparentWindow::draw();
}

void	TransitionWindow::Update()
{
	double gsf = my_window->gui_scale_factor;
	if(my_window->transition == TRANSITION_NONE)
	{
		none_button->value(1);
		selection->resize(none_button->x() + (36 * gsf), none_button->y() + (100 * gsf), 24 * gsf, 24 * gsf);
	}
	else if(my_window->transition == TRANSITION_BLEND)
	{
		blend_button->value(1);
		selection->resize(blend_button->x() + (36 * gsf), blend_button->y() + (100 * gsf), 24 * gsf, 24 * gsf);
	}
	else if(my_window->transition == TRANSITION_L2R_WIPE)
	{
		wipe_l2r_button->value(1);
		selection->resize(wipe_l2r_button->x() + (36 * gsf), wipe_l2r_button->y() + (100 * gsf), 24 * gsf, 24 * gsf);
	}
	else if(my_window->transition == TRANSITION_R2L_WIPE)
	{
		wipe_r2l_button->value(1);
		selection->resize(wipe_r2l_button->x() + (36 * gsf), wipe_r2l_button->y() + (100 * gsf), 24 * gsf, 24 * gsf);
	}
	else if(my_window->transition == TRANSITION_T2B_WIPE)
	{
		wipe_t2b_button->value(1);
		selection->resize(wipe_t2b_button->x() + (36 * gsf), wipe_t2b_button->y() + (100 * gsf), 24 * gsf, 24 * gsf);
	}
	else if(my_window->transition == TRANSITION_B2T_WIPE)
	{
		wipe_b2t_button->value(1);
		selection->resize(wipe_b2t_button->x() + (36 * gsf), wipe_b2t_button->y() + (100 * gsf), 24 * gsf, 24 * gsf);
	}
	else if(my_window->transition == TRANSITION_FADE_TO_BLACK)
	{
		to_black_button->value(1);
		selection->resize(to_black_button->x() + (36 * gsf), to_black_button->y() + (100 * gsf), 24 * gsf, 24 * gsf);
	}
	selection->show();
	redraw();
}

void	trigger_window_cb(Fl_Widget *w, void *v)
{
	MyWin *win = (MyWin *)v;
	trigger_camera_button_cb(NULL, win);
}

void	trigger_window_clear_cb(Fl_Widget *w, void *v)
{
int	loop;

	MyWin *win = (MyWin *)v;
	Camera *cam = win->DisplayedCamera();
	if(cam != NULL)
	{
		for(loop = 0;loop < 128;loop++)
		{
			cam->trigger[loop] = -1;
		}
		cam->trigger_cnt = 0;
		win->trigger_window->redraw();
	}
}

TriggerWindow::TriggerWindow(MyWin *in_win) : Fl_Window(400, 300, 800, 450)
{
int	loop;

	main_win = in_win;
	box(FL_FLAT_BOX);
	color(FL_BLACK);
	border(0);

	Fl_Button *done = new Fl_Button(w() - 70, 10, 70, 22, "Done");
	done->labelcolor(FL_YELLOW);
	done->box(FL_NO_BOX);
	done->callback(trigger_window_cb, main_win);

	Fl_Button *clear = new Fl_Button(w() - 70, 34, 70, 22, "Clear");
	clear->labelcolor(FL_YELLOW);
	clear->box(FL_NO_BOX);
	clear->callback(trigger_window_clear_cb, main_win);

	int nxx = 20;
	int nyy = 50;
	for(loop = 0;loop < 128;loop++)
	{
		if((nyy + 86) > h())
		{
			nyy = 50;
			nxx += 160;
		}
		thumbnail[loop] = new ThumbButton(in_win, loop, nxx, nyy, 153, 86);
		thumbnail[loop]->box(FL_NO_BOX);
		thumbnail[loop]->callback(thumbnail_cb, in_win);
		nyy += 90;
	}
	end();
}

TriggerWindow::~TriggerWindow()
{
}

DetailWin::DetailWin(int ww, int hh, char *lbl) : Fl_Double_Window(ww, hh, lbl)
{
}

DetailWin::~DetailWin()
{
}

void	DetailWin::draw()
{
struct tm *tm;
Mat	display_mat;

	Fl_Double_Window::draw();
	fl_draw_image((unsigned char *)mat.ptr(), 0, 0, mat.cols, mat.rows, mat.channels());
}

void	my_window_cb(void *v)
{
	MyWin *win = (MyWin *)v;
	if(win->frozen == 0)
	{
		win->redraw();
	}
	if(win->record_all == 1)
	{
		win->RecordAll();
	}
	Fl::repeat_timeout(win->forced_interval, my_window_cb, win);
}

void	MyWin::Done()
{
	Camera *cam = DisplayedCamera();
	if(cam != NULL)
	{
		if(pulse_mixer != NULL)
		{
			pulse_mixer->Stop();
		}
		cam->last = 1;
		if(muxer_cnt > 0)
		{
			cam->Record(stream);
			cam->resuming = 1;
		}
		RecordOff();
		SetAllCamerasToStop();
	}
}

void	MatchingMethod(int match_method, Mat img, Mat temp, int *xx, int *yy)
{
Mat	result;

	/// Create the result matrix
	int result_cols =  img.cols - temp.cols + 1;
	int result_rows = img.rows - temp.rows + 1;

	result.create(result_rows, result_cols, CV_32FC1);

	/// Do the Matching and Normalize
	matchTemplate(img, temp, result, match_method);
	normalize(result, result, 0, 1, NORM_MINMAX, -1, Mat());

	/// Localizing the best match with minMaxLoc
	double minVal;
	double maxVal;
	Point minLoc;
	Point maxLoc;
	Point matchLoc;

	minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, Mat());

	/// For SQDIFF and SQDIFF_NORMED, the best matches are lower values. For all the other methods, the higher the better
	if((match_method == TM_SQDIFF) || (match_method == TM_SQDIFF_NORMED))
	{
		matchLoc = minLoc;
	}
	else
	{
		matchLoc = maxLoc;
	}
	*xx = matchLoc.x;
	*yy = matchLoc.y;
}

Mat	CropSection(Mat source, Mat& cropped, int xx, int yy, int ww, int hh)
{
	if(xx < -1) xx = 0;
	if(yy < -1) yy = 0;
	if((xx + ww) >= source.cols)
	{
		ww -= ((xx + ww) - (source.cols + 1));
	}
	if((yy + hh) >= source.rows)
	{
		hh -= ((yy + hh) - (source.rows + 1));
	}
	if(((xx + ww) < source.cols) && ((yy + hh) < source.rows))
	{
		Rect myROI(xx, yy, ww, hh);
		Mat croppedRef(source, myROI);
		cropped = croppedRef.clone();
	}
	else
	{
		cropped = source.clone();
	}
	return(cropped);
}

void	Camera::CompressImageWindowList()
{
ImageWindow	*list[1024];
int			loop;

	for(loop = 0;loop < 1024;loop++)
	{
		list[loop] = NULL;
	}
	int cnt = 0;
	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			list[cnt] = image_window[loop];
			cnt++;
		}
	}
	image_window_cnt = cnt;
	for(loop = 0;loop < 128;loop++)
	{
		image_window[loop] = list[loop];
	}
}

ImageWindow::ImageWindow(int in_index, MyWin *win, Camera *cam, Camera *in_dest, int xx, int yy, int ww, int hh) : Fl_Group(xx, yy, ww, hh)
{
	end();

	index = in_index;
	my_window = win;
	camera = cam;
	dest_camera = in_dest;
	layer = 0;
	if(dest_camera != NULL)
	{
		layer = dest_camera->edit_layer;
	}
	dragging = 0;
	transform = 0;
	start_drag_x = -1;
	start_drag_y = -1;
	width = ww;
	height = hh;
	orig_w = ww;
	orig_h = hh;
	dx = xx;
	dy = yy;
	dw = ww;
	dh = hh;
	buttonize = 0;
	buttonized_x = -1;
	buttonized_y = -1;
	buttonized_w = -1;
	buttonized_h = -1;
	crop_x = 0;
	crop_y = 0;
	crop_w = 0;
	crop_h = 0;
	trim_x = 0;
	trim_y = 0;
	frame = 0;
	drag_mode = DRAG_MODE_MOVE;
	popup = NULL;
	overall_alpha = 1.0;
	mw_transparency = 0;
	mw_rotate = 0;
	angle = 0.0;
	flip_horizontal = 0;
	flip_vertical = 0;
	box(FL_NO_BOX);
	hide();
}

ImageWindow::~ImageWindow()
{
	if(popup != NULL)
	{
		popup->hide();
		Fl::delete_widget(popup);
		popup = NULL;
	}
}

int	ImageWindow::AsButton(int xx, int yy)
{
	int flag = 0;
	if((xx > buttonized_x)
	&& (yy > buttonized_y)
	&& (xx < buttonized_x + buttonized_w)
	&& (yy < buttonized_y + buttonized_h))
	{
		buttonize = 0;
		show();
		flag = 1;
	}
	return(flag);
}

void	Camera::OffsetPositionImageWindows(int off_x, int off_y)
{
int	loop;

	for(loop = 0;loop < 128;loop++)
	{
		if(image_window[loop] != NULL)
		{
			int xx = image_window[loop]->dx;
			int yy = image_window[loop]->dy;
			int ww = image_window[loop]->dw;
			int hh = image_window[loop]->dh;
			image_window[loop]->resize(xx + off_x, yy + off_y, ww, hh);
		}
	}
}

void overlayImage(Mat *src, Mat *overlay, const Point& location)
{
	for (int y = max(location.y, 0); y < src->rows; ++y)
	{
		int fY = y - location.y;
		if (fY >= overlay->rows)
			break;

		for(int x = max(location.x, 0); x < src->cols; ++x)
		{
			int fX = x - location.x;
			if (fX >= overlay->cols)
				break;

			double opacity = ((double)overlay->data[fY * overlay->step + fX * overlay->channels() + 3]) / 255;
			for(int c = 0; opacity > 0 && c < src->channels(); ++c)
			{
				unsigned char overlayPx = overlay->data[fY * overlay->step + fX * overlay->channels() + c];
				unsigned char srcPx = src->data[y * src->step + x * src->channels() + c];
				src->data[y * src->step + src->channels() * x + c] = srcPx * (1.0 - opacity) + overlayPx * opacity;
			}
		}
	}
}

void	Camera::PositionAllButtonized()
{
int	loop;

	int done = 0;
	int x_pos = 280;
	int y_pos = Fl::h() - 160;
	for(loop = 0;loop < image_window_cnt;loop++)
	{
		if(image_window[loop] != NULL)
		{
			if(image_window[loop]->buttonize == 1)
			{
				image_window[loop]->buttonized_x = x_pos;
				image_window[loop]->buttonized_y = y_pos;
				x_pos += (image_window[loop]->buttonized_w) + 10;
				if((x_pos + image_window[loop]->buttonized_w) > (Fl::w() - 180))
				{
					x_pos = 280;
					y_pos += (image_window[loop]->buttonized_h + 8);
					if(y_pos + image_window[loop]->buttonized_h > Fl::h())
					{
						image_window[loop]->buttonized_x = -1;
						image_window[loop]->buttonized_y = -1;
						image_window[loop]->buttonized_w = -1;
						image_window[loop]->buttonized_h = -1;
					}
				}
			}
		}
	}
}

void	Camera::PasteMat(Mat mat, int sx, int sy)
{
	cairo_surface_t *surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
	if((surface != NULL) && (cairo_surface != NULL))
	{
		cairo_set_source_surface(cairo_context, surface, sx, sy);
		cairo_paint(cairo_context);
		cairo_surface_destroy(surface);
	}
}

void	rotate_mat(double angle, Mat& src)
{
	// get rotation matrix for rotating the image around its center in pixel coordinates
	cv::Point2f center((src.cols - 1) / 2.0, (src.rows - 1) / 2.0);
	cv::Mat rot = cv::getRotationMatrix2D(center, angle, 1.0);

	// determine bounding rectangle, center not relevant
	cv::Rect2f bbox = cv::RotatedRect(cv::Point2f(), src.size(), angle).boundingRect2f();

	// adjust transformation matrix
	rot.at<double>(0, 2) += bbox.width / 2.0 - src.cols / 2.0;
	rot.at<double>(1, 2) += bbox.height / 2.0 - src.rows / 2.0;

	cv::Mat dst;
	cv::warpAffine(src, dst, rot, bbox.size());
	src = dst.clone();
}

void	ImageWindow::Draw(Camera *dest_camera)
{
int	loop;

	if(visible())
	{
		if(camera != NULL)
		{
			camera->Capture();
			Camera *dest = my_window->DisplayedCamera();
			if(dest_camera != NULL)
			{
				dest = dest_camera;
			}
			if(dest != camera)
			{
				if((camera->mat.rows > 0) && (camera->mat.cols > 0))
				{
					int sx = x() - dest->image_sx;
					if(sx < 0) sx = 0;
					int sy = y() - dest->image_sy;
					if(sy < 0) sy = 0;
					cv::resize(camera->mat, mat, cv::Size(w(), h()));
					if((crop_w > 0) && (crop_h > 0))
					{
						CropSection(mat, mat, crop_x, crop_y, crop_w, crop_h);
					}
					int use_w = w();
					int use_h = h();

					blend_two(dest->mat, mat, sx, sy, overall_alpha);
					if(angle != 0.0)
					{
						rotate_mat(angle, mat);
					}
					if((flip_vertical == 1) && (flip_horizontal == 0))
					{
						flip(mat, mat, 0);
					}
					else if((flip_vertical == 0) && (flip_horizontal == 1))
					{
						flip(mat, mat, 1);
					}
					else if((flip_vertical == 1) && (flip_horizontal == 1))
					{
						flip(mat, mat, -1);
					}
					if(dest->cairo_context != NULL)
					{
						cairo_surface_t *surface = cairo_image_surface_create_for_data(mat.ptr(), CAIRO_FORMAT_ARGB32, mat.cols, mat.rows, mat.step);
						if((surface != NULL) && (dest->cairo_surface != NULL))
						{
							cairo_set_source_surface(dest->cairo_context, surface, sx, sy);
							cairo_paint(dest->cairo_context);
							cairo_surface_destroy(surface);

							if(frame == 1)
							{
								cairo_set_dash(dest->cairo_context, NULL, 0, 1);
								cairo_set_line_width(dest->cairo_context, 2);
								my_cairo_set_source_rgba(dest->cairo_context, camera->text_red, camera->text_green, camera->text_blue, camera->text_alpha);
								cairo_rectangle(dest->cairo_context, sx, sy, mat.cols, mat.rows);
								cairo_stroke(dest->cairo_context);
							}
						}
						resize(sx + dest->image_sx, sy + dest->image_sy, use_w, use_h);
						if(dragging == 1)
						{
							if(transform == MODE_TRIMMING)
							{
								my_cairo_set_source_rgb(dest->cairo_context, 255, 255, 128);
								cairo_rectangle(dest->cairo_context, start_drag_x - dest->image_sx, start_drag_y - dest->image_sy, trim_x - start_drag_x, trim_y - start_drag_y);
								cairo_stroke(dest->cairo_context);
							}
						}
					}
				}
			}
		}
	}
	else if(buttonize == 1)
	{
		Camera *cam = my_window->DisplayedCamera();
		char buf[4096];
		strcpy(buf, "Source");
		if(camera != NULL)
		{
			if(strlen(camera->alias) > 0)
			{
				sprintf(buf, "%s", camera->alias);
			}
			else
			{
				sprintf(buf, "%s", camera->path);
			}
		}
		int sw = 0;
		int sh = 0;
		int out_x = 0;
		int out_y = 0;
		fl_measure(buf, sw, sh);
		buttonized_w = sw + 8;
		buttonized_h = sh + 4;
		cam->PositionAllButtonized();
		if((buttonized_w > 0) && (buttonized_h > 0))
		{
			fl_color(FL_YELLOW);
			fl_draw(buf, buttonized_x, buttonized_y + sh);
			fl_rect(buttonized_x - 4, buttonized_y, sw + 8, sh + 4);
		}
	}
}

void	ImageWindow::ZipLeft()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindLeft(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			resize(val, y(), w(), h());
		}
		else
		{
			resize(dest->image_sx, y(), w(), h());
		}
	}
}

void	ImageWindow::GrowLeft()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindLeft(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			int diff = abs(x() - val);
			resize(val, y(), w() + diff, h());
		}
		else
		{
			int diff = abs(x() - dest->image_sx);
			resize(dest->image_sx, y(), w() + diff, h());
		}
	}
}

void	ImageWindow::ZipRight()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindRight(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			resize(val - w(), y(), w(), h());
		}
		else
		{
			resize((dest->image_sx + dest->mat.cols) - w(), y(), w(), h());
		}
	}
}

void	ImageWindow::GrowRight()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindRight(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			int diff = abs((x() + w()) - val);
			resize(x(), y(), w() + diff, h());
		}
		else
		{
			int diff = abs((x() + w()) - (dest->image_sx + dest->mat.cols));
			resize(x(), y(), w() + (diff - 1), h());
		}
	}
}

void	ImageWindow::ZipUp()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindTop(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			resize(x(), val, w(), h());
		}
		else
		{
			resize(x(), dest->image_sy, w(), h());
		}
	}
}

void	ImageWindow::GrowUp()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindTop(this, layer, x(), y(), w(), h());
		if(val > -1000000)
		{
			int diff = abs(y() - val);
			resize(x(), val, w(), h() + diff);
		}
		else
		{
			int diff = abs(y() - dest->image_sy);
			resize(x(), dest->image_sy, w(), h() + diff);
		}
	}
}

void	ImageWindow::ZipDown()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindBottom(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			resize(x(), val - h(), w(), h());
		}
		else
		{
			resize(x(), (dest->image_sy + dest->mat.rows) - h(), w(), h());
		}
	}
}

void	ImageWindow::GrowDown()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int	val = dest->FindBottom(this, layer, x(), y(), w(), h());
		if(val < 1000000)
		{
			int diff = abs((y() + h()) - val);
			resize(x(), y(), w(), h() + diff);
		}
		else
		{
			int diff = abs((y() + h()) - (dest->image_sy + dest->mat.rows));
			resize(x(), y(), w(), h() + (diff - 1));
		}
	}
}

void	ImageWindow::FillFrame()
{
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		int ww = dest->mat.cols;
		int hh = dest->mat.rows;
		resize(0, 0, ww, hh);
	}
}

void	image_window_popup_cb(Fl_Widget *w, void *v)
{
	ImageWindow *iw = (ImageWindow *)v;
	if(iw != NULL)
	{
		Fl_Hold_Browser *browser = (Fl_Hold_Browser *)w;
		char *str = (char *)browser->text(browser->value());
		if(str != NULL)
		{
			if(strcmp(str, "Move") == 0)
			{
				iw->drag_mode = DRAG_MODE_MOVE;
			}
			else if(strcmp(str, "Resize") == 0)
			{
				iw->drag_mode = DRAG_MODE_RESIZE;
			}
			else if(strcmp(str, "Crop") == 0)
			{
				iw->drag_mode = DRAG_MODE_CROP;
			}
			else if(strcmp(str, "Rotate") == 0)
			{
				iw->drag_mode = DRAG_MODE_ROTATE;
			}
			else if(strcmp(str, "Restore") == 0)
			{
				iw->Restore();
			}
			else if(strcmp(str, "Delete") == 0)
			{
				iw->Delete();
			}
			else if(strcmp(str, "Hide") == 0)
			{
				iw->Buttonize();
			}
			else if(strcmp(str, "Zip Left") == 0)
			{
				iw->ZipLeft();
			}
			else if(strcmp(str, "Grow Left") == 0)
			{
				iw->GrowLeft();
			}
			else if(strcmp(str, "Zip Right") == 0)
			{
				iw->ZipRight();
			}
			else if(strcmp(str, "Grow Right") == 0)
			{
				iw->GrowRight();
			}
			else if(strcmp(str, "Zip Up") == 0)
			{
				iw->ZipUp();
			}
			else if(strcmp(str, "Grow Up") == 0)
			{
				iw->GrowUp();
			}
			else if(strcmp(str, "Zip Down") == 0)
			{
				iw->ZipDown();
			}
			else if(strcmp(str, "Grow Down") == 0)
			{
				iw->GrowDown();
			}
			else if(strcmp(str, "Toggle Frame") == 0)
			{
				if(iw->frame == 0)
				{
					iw->frame = 1;
				}
				else
				{
					iw->frame = 0;
				}
			}
			else if(strcmp(str, "MW Transparency") == 0)
			{
				iw->mw_transparency = 1;
				iw->mw_rotate = 0;
			}
			else if(strcmp(str, "MW Stacking Order") == 0)
			{
				iw->mw_transparency = 0;
				iw->mw_rotate = 0;
			}
			else if(strcmp(str, "Make Transparent") == 0)
			{
				iw->overall_alpha = 0.0;
			}
			else if(strcmp(str, "Make Opaque") == 0)
			{
				iw->overall_alpha = 1.0;
			}
			else if(strcmp(str, "MW Rotate") == 0)
			{
				iw->mw_transparency = 0;
				iw->mw_rotate = 1;
			}
			else if(strcmp(str, "Flip Horizontal") == 0)
			{
				if(iw->flip_horizontal == 0)
				{
					iw->flip_horizontal = 1;
				}
				else
				{
					iw->flip_horizontal = 0;
				}
			}
			else if(strcmp(str, "Flip Vertical") == 0)
			{
				if(iw->flip_vertical == 0)
				{
					iw->flip_vertical = 1;
				}
				else
				{
					iw->flip_vertical = 0;
				}
			}
			else if(strcmp(str, "Fill Frame") == 0)
			{
				iw->FillFrame();
			}
		}
		if(iw->popup != NULL)
		{
			iw->popup->hide();
		}
	}
}

void	ImageWindow::Restore()
{
	drag_mode = DRAG_MODE_MOVE;
	width = orig_w;
	height = orig_h;
	crop_x = 0;
	crop_y = 0;
	crop_w = 0;
	crop_h = 0;
	int xx = x();
	int yy = x();
	overall_alpha = 1.0;
	angle = 0.0;
	if(dest_camera != NULL)
	{
		xx = dest_camera->image_sx + ((dest_camera->mat.cols / 2) - (width / 2));
		yy = dest_camera->image_sy + ((dest_camera->mat.rows / 2) - (height / 2));
	}
	resize(xx, yy, width, height);
}

void	ImageWindow::Delete()
{
	my_window->use_mousewheel = 1;
	hide();
	my_window->remove(this);
	Camera *dest = my_window->DisplayedCamera();
	if(dest != NULL)
	{
		dest->image_window[index] = NULL;
		dest->CompressImageWindowList();
	}
	Fl::delete_widget(this);
	fl_cursor(FL_CURSOR_DEFAULT);
}

void	ImageWindow::Buttonize()
{
	my_window->use_mousewheel = 1;
	buttonize = 1;
	hide();
	fl_cursor(FL_CURSOR_DEFAULT);
}

int	ImageWindow::handle(int event)
{
int	loop;

	int flag = 0;
	if(my_window != NULL)
	{
		Camera *cam = my_window->DisplayedCamera();
		if(cam != NULL)
		{
			if(dest_camera == cam)
			{
				if((cam->display_width == cam->width) && (cam->display_height == cam->height))
				{
					if(cam->edit_layer == layer)
					{
						int xx = Fl::event_x();
						int yy = Fl::event_y();
						switch(event)
						{
							case(FL_PUSH):
							{
								if(Fl::event_state(FL_BUTTON3) == FL_BUTTON3)
								{
									if(popup == NULL)
									{
										popup = new PopupMenu(Fl::event_x_root(), Fl::event_y_root(), 160, 300);
										popup->browser->callback(image_window_popup_cb, this);
									}
									else
									{
										popup->resize(Fl::event_x_root(), Fl::event_y_root(), popup->w(), popup->h());
									}
									if(popup != NULL)
									{
										popup->browser->clear();
										popup->browser->add("Move");
										popup->browser->add("Resize");
										popup->browser->add("Crop");
										popup->browser->add("Rotate");
										popup->browser->add("Restore");
										popup->browser->add("Hide");
										popup->browser->add("Delete");
										popup->browser->add("");
										popup->browser->add("Zip Left");
										popup->browser->add("Grow Left");
										popup->browser->add("Zip Right");
										popup->browser->add("Grow Right");
										popup->browser->add("Zip Up");
										popup->browser->add("Grow Up");
										popup->browser->add("Zip Down");
										popup->browser->add("Grow Down");
										popup->browser->add("");
										popup->browser->add("Toggle Frame");
										popup->browser->add("MW Transparency");
										popup->browser->add("MW Stacking Order");
										popup->browser->add("MW Rotate");
										popup->browser->add("Make Transparent");
										popup->browser->add("Make Opaque");
										popup->browser->add("Flip Horizontal");
										popup->browser->add("Flip Vertical");
										popup->browser->add("Fill Frame");
										popup->set_non_modal();
										popup->Fit();
										popup->show();
									}
								}
								else
								{
									dragging = 1;
									start_drag_x = xx;
									start_drag_y = yy;
								}
								flag = 1;
							}
							break;
							case(FL_RELEASE):
							{
								fl_cursor(FL_CURSOR_DEFAULT);
								dragging = 0;
								int grid_sz = my_window->grid_size;
								if(transform == MODE_MOVING)
								{
									if(grid_sz > 1)
									{
										Camera *cam = my_window->DisplayedCamera();
										int cam_x = cam->image_sx;
										int cam_y = cam->image_sy;
										int use_x = x() - cam_x;
										int use_y = y() - cam_y;
										use_x = force_to_grid(grid_sz, use_x);
										use_y = force_to_grid(grid_sz, use_y);
										resize(use_x + cam_x, use_y + cam_y, w(), h());
									}
								}
								else if(transform == MODE_TRIMMING)
								{
									Mat cropped;
									int x1 = start_drag_x;
									int x2 = xx;
									if(start_drag_x > xx)
									{
										x1 = xx;
										x2 = start_drag_x;
									}
									int y1 = start_drag_y;
									int y2 = yy;
									if(start_drag_y > yy)
									{
										y1 = yy;
										y2 = start_drag_y;
									}
									crop_x = x1 - x();
									crop_y = y1 - y();
									crop_w = abs(x2 - x1);
									crop_h = abs(y2 - y1);
								}
								transform = 0;
								flag = 1;
							}
							break;
							case(FL_ENTER):
							{
								take_focus();
								my_window->use_mousewheel = 0;
								flag = 1;
							}
							break;
							case(FL_LEAVE):
							{
								fl_cursor(FL_CURSOR_DEFAULT);
								my_window->use_mousewheel = 1;
								flag = 1;
							}
							break;
							case(FL_DRAG):
							case(FL_MOVE):
							{
								if(dragging == 1)
								{
									if(Fl::event_state(FL_BUTTON1) == FL_BUTTON1)
									{
										if(drag_mode == DRAG_MODE_MOVE)
										{
											fl_cursor(FL_CURSOR_MOVE);
											int ddx = xx - start_drag_x;
											int ddy = yy - start_drag_y;
											int use_x = x() + ddx;
											int use_y = y() + ddy;
											int use_w = w();
											if(crop_w > 0) use_w = crop_w;
											int use_h = h();
											if(crop_h > 0) use_h = crop_h;
											if((use_x + use_w < cam->image_sx + cam->width)
											&& (use_y + use_h < cam->image_sy + cam->height))
											{
												resize(use_x, use_y, w(), h());
												dx = use_x;
												dy = use_y;

												start_drag_x = xx;
												start_drag_y = yy;
											}
											transform = MODE_MOVING;
										}
										else if(drag_mode == DRAG_MODE_RESIZE)
										{
											if((crop_w == 0) && (crop_h == 0))
											{
												if((xx > (x() + w() - 50))
												&& (yy < (y() + h() - 50)))
												{
													Rescale(cam, xx, yy, 0);
												}
												else if((xx < (x() + w() - 50))
												&& (yy > (y() + h() - 50)))
												{
													Rescale(cam, xx, yy, 0);
												}
												else
												{
													Rescale(cam, xx, yy, 1);
												}
												transform = MODE_RESIZING;
											}
										}
										else if(drag_mode == DRAG_MODE_CROP)
										{
											transform = MODE_TRIMMING;
											trim_x = xx;
											trim_y = yy;
										}
										else if(drag_mode == DRAG_MODE_ROTATE)
										{
											if(yy > start_drag_y)
											{
												angle += 1.0;
												if(angle >= 360.0)
												{
													angle = 0.0;
												}
											}
											else
											{
												angle -= 1.0;
												if(angle < 0.0)
												{
													angle = 359.0;
												}
											}
											transform = MODE_ROTATING;
										}
									}
									else if(Fl::event_state(FL_BUTTON2) == FL_BUTTON2)
									{
										if((crop_w == 0) && (crop_h == 0))
										{
											if((xx > (x() + w() - 50))
											&& (yy < (y() + h() - 50)))
											{
												Rescale(cam, xx, yy, 0);
											}
											else if((xx < (x() + w() - 50))
											&& (yy > (y() + h() - 50)))
											{
												Rescale(cam, xx, yy, 0);
											}
											else
											{
												Rescale(cam, xx, yy, 1);
											}
											transform = MODE_RESIZING;
										}
									}
								}
								else
								{
									fl_cursor(FL_CURSOR_DEFAULT);
									if((xx > (x() + 5))
									&& (yy > (y() + 5))
									&& (xx < (x() + w() - 50))
									&& (yy < (y() + h() - 50)))
									{
										fl_cursor(FL_CURSOR_CROSS);
									}
									else if((xx > (x() + w() - 50))
									&& (yy < (y() + h() - 50)))
									{
										fl_cursor(FL_CURSOR_WE);
									}
									else if((xx < (x() + w() - 50))
									&& (yy > (y() + h() - 50)))
									{
										fl_cursor(FL_CURSOR_NS);
									}
									else
									{
										fl_cursor(FL_CURSOR_MOVE);
									}
								}
								flag = 1;
							}
							break;
							case(FL_FOCUS):
							case(FL_UNFOCUS):
							{
								flag = 1;
							}
							break;
							case(FL_KEYBOARD):
							{
								int key = Fl::event_key();
								if(key == FL_Delete)
								{
									Delete();
									flag = 1;
								}
								else if(key == FL_Home)
								{
									Restore();
									flag = 1;
								}
								else if(key == FL_End)
								{
									Buttonize();
									flag = 1;
								}
								else if(key == FL_Left)
								{
									if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
									{
										GrowLeft();
									}
									else
									{
										ZipLeft();
									}
									flag = 1;
								}
								else if(key == FL_Right)
								{
									if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
									{
										GrowRight();
									}
									else
									{
										ZipRight();
									}
									flag = 1;
								}
								else if(key == FL_Up)
								{
									if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
									{
										GrowUp();
									}
									else
									{
										ZipUp();
									}
									flag = 1;
								}
								else if(key == FL_Down)
								{
									if(Fl::event_state(FL_SHIFT) == FL_SHIFT)
									{
										GrowDown();
									}
									else
									{
										ZipDown();
									}
									flag = 1;
								}
							}
							break;
							case(FL_MOUSEWHEEL):
							{
								int nn = Fl::event_dy();
								if(nn > 0)
								{
									if(mw_rotate == 1)
									{
										angle += 1.0;
										if(angle >= 360.0)
										{
											angle = 0.0;
										}
									}
									else if(mw_transparency == 1)
									{
										if(overall_alpha < 1.0)
										{
											overall_alpha += 0.01;
										}
									}
									else
									{
										if(index < 127)
										{
											Camera *dest = my_window->DisplayedCamera();
											if(dest != NULL)
											{
												dest->CompressImageWindowList();
												ImageWindow *tmp = dest->image_window[index + 1];
												if(tmp != NULL)
												{
													dest->image_window[index + 1] = this;
													dest->image_window[index] = tmp;
													tmp->index--;
													index++;
												}
											}
										}
									}
								}
								else
								{
									if(mw_rotate == 1)
									{
										angle -= 1.0;
										if(angle < 0.0)
										{
											angle = 359.0;
										}
									}
									else if(mw_transparency == 1)
									{
										if(overall_alpha > 0.0)
										{
											overall_alpha -= 0.01;
										}
									}
									else
									{
										if(index > 0)
										{
											Camera *dest = my_window->DisplayedCamera();
											if(dest != NULL)
											{
												dest->CompressImageWindowList();
												ImageWindow *tmp = dest->image_window[index - 1];
												if(tmp != NULL)
												{
													dest->image_window[index - 1] = this;
													dest->image_window[index] = tmp;
													tmp->index++;
													index--;
												}
											}
										}
									}
								}
								flag = 1;
							}
							break;
						}
					}
				}
			}
		}
	}
	if(flag == 0)
	{
		flag = Fl_Group::handle(event);
	}
	return(flag);
}

void	ImageWindow::Rescale(Camera *cam, int xx, int yy, int proportional)
{
	int do_it = 0;
	int ddx = xx - start_drag_x;
	int ddy = yy - start_drag_y;
	double factor = 1.0;
	if((xx > (x() + w() - 50))
	&& (yy < (y() + h() - 50)))
	{
		fl_cursor(FL_CURSOR_WE);
		factor = (double)(width + ddx) / (double)width;
		do_it = 1;
	}
	else if((xx < (x() + w() - 50))
	&& (yy > (y() + h() - 50)))
	{
		fl_cursor(FL_CURSOR_NS);
		factor = (double)(height + ddy) / (double)height;
		do_it = 2;
	}
	else
	{
		factor = (double)(width + ddx) / (double)width;
		fl_cursor(FL_CURSOR_MOVE);
		do_it = 1;
	}
	if(do_it != 0)
	{
		if(proportional == 1)
		{
			double use_x = (double)width * factor;
			double use_y = (double)height * factor;
			if((use_x > 50) && (use_y > 50))
			{
				if((x() + use_x < cam->image_sx + cam->width)
				&& (y() + use_y < cam->image_sy + cam->height))
				{
					resize(x(), y(), use_x, use_y);
					width = use_x;
					height = use_y;
				}
			}
			start_drag_x = xx;
			start_drag_y = yy;
			transform = MODE_RESIZING;
		}
		else
		{
			if(do_it == 1)
			{
				double use_x = (double)width * factor;
				if(use_x > 50)
				{
					if(x() + use_x < cam->image_sx + cam->width)
					{
						resize(x(), y(), use_x, h());
						width = use_x;
					}
				}
				start_drag_x = xx;
			}
			else if(do_it == 2)
			{
				double use_y = (double)height * factor;
				if(use_y > 50)
				{
					if(y() + use_y < cam->image_sy + cam->height)
					{
						resize(x(), y(), w(), use_y);
						height = use_y;
					}
				}
				start_drag_y = yy;
			}
		}
	}
}

void	fltk_plugin_accept_cb(Fl_Widget *w, void *v)
{
int	loop;

	FltkPluginWindow *fpw = (FltkPluginWindow *)v;
	fpw->hide();
	for(loop = 0;loop < global_potential_fltk_cnt;loop++)
	{
		if(fpw->plug_in[loop] != NULL)
		{
			int val = fpw->plug_in[loop]->value();
			if(val)
			{
				char *str = global_potential_fltk[loop];
				void *handle = global_potential_fltk_handle[loop];
				void *void_ptr = (void *)dlsym(handle, str);
				if(void_ptr != NULL)
				{
					void (*fltk)(Fl_Window *);
					fltk = (void (*)(Fl_Window *))void_ptr;
					fltk(fpw->my_window);
				}
			}
		}
	}
}

FltkPluginWindow::FltkPluginWindow(MyWin *in_win) : Fl_Window(200, 600, "FLTK Plugins")
{
	my_window = in_win;
	color(DARK_RED);
	Populate();
	end();
}

FltkPluginWindow::~FltkPluginWindow()
{
}

void	FltkPluginWindow::Populate()
{
int	loop;

	int y_pos = 0;
	for(loop = 0;loop < 128;loop++)
	{
		plug_in[loop] = NULL;
	}
	for(loop = 0;loop < global_potential_fltk_cnt;loop++)
	{
		char *cp = global_potential_fltk[loop] + strlen("fltk_");
		plug_in[loop] = new Fl_Light_Button(10, y_pos, 190, 20, cp);
		plug_in[loop]->box(FL_FLAT_BOX);
		plug_in[loop]->color(DARK_RED);
		plug_in[loop]->labelcolor(FL_WHITE);
		plug_in[loop]->labelsize(11);
		plug_in[loop]->align(FL_ALIGN_INSIDE | FL_ALIGN_CENTER);
		plug_in[loop]->visible_focus(0);
		y_pos += 20;
	}
	y_pos += 10;
	accept = new Fl_Button(10, y_pos, 80, 20, "Accept");
	accept->box(FL_NO_BOX);
	accept->color(FL_WHITE);
	accept->labelcolor(FL_YELLOW);
	accept->labelsize(12);
	accept->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	accept->callback(fltk_plugin_accept_cb, this);

	cancel = new Fl_Button(110, y_pos, 80, 20, "Cancel");
	cancel->box(FL_NO_BOX);
	cancel->color(FL_WHITE);
	cancel->labelcolor(FL_YELLOW);
	cancel->labelsize(12);
	cancel->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
	cancel->callback(hide_window_cb, this);

	y_pos += 30;
	resize(x(), y(), w(), y_pos);
}

void	FltkPluginWindow::Reset()
{
int	loop;

	for(loop = 0;loop < global_potential_fltk_cnt;loop++)
	{
		if(plug_in[loop] != NULL)
		{
			plug_in[loop]->value(0);
		}
	}
}

int	list_shared_exports(char *dir_name)
{
dirent	**list;
char	buf[4096];

	int numOfFiles = fl_filename_list(dir_name, &list);
	for(int i = 0; i < numOfFiles; i++)
	{
		char *library_filename = list[i]->d_name;
		char *ext = (char *)fl_filename_ext(library_filename);
		if(strcmp(ext, ".so") == 0)
		{
			sprintf(buf, "%s/%s", dir_name, library_filename);
			void *library = dlopen(buf, RTLD_LAZY);
			if(library != NULL)
			{
				int found = 0;
				struct link_map *map = nullptr;
				dlinfo(library, RTLD_DI_LINKMAP, &map);
				if(map != NULL)
				{
					Elf64_Sym *symtab = nullptr;
					char *strtab = nullptr;
					int symentries = 0;
					for(auto section = map->l_ld; section->d_tag != DT_NULL; ++section)
					{
						if(section->d_tag == DT_SYMTAB)
						{
							symtab = (Elf64_Sym *)section->d_un.d_ptr;
						}
						if(section->d_tag == DT_STRTAB)
						{
							strtab = (char*)section->d_un.d_ptr;
						}
						if(section->d_tag == DT_SYMENT)
						{
							symentries = section->d_un.d_val;
						}
					}
					int size = strtab - (char *)symtab;
					for(int k = 0; k < size / symentries; ++k)
					{
						auto sym = &symtab[k];
						// if sym is function
						if(ELF64_ST_TYPE(symtab[k].st_info) == STT_FUNC)
						{
							// str is name of each symbol
							char *str = &strtab[sym->st_name];
							if(strncmp(str, "filter_", strlen("filter_")) == 0)
							{
								if(global_potential_filter_cnt < 1024)
								{
									printf("FILTER: %s\n", str);
									global_potential_filter[global_potential_filter_cnt] = strdup(str);
									global_potential_filter_handle[global_potential_filter_cnt] = library;
									global_potential_filter_cnt++;
								}
								found = 1;
							}
							if(strncmp(str, "audio_filter_", strlen("audio_filter_")) == 0)
							{
								if(global_potential_audio_filter_cnt < 1024)
								{
									printf("AUDIO FILTER: %s\n", str);
									global_potential_audio_filter[global_potential_audio_filter_cnt] = strdup(str);
									global_potential_audio_filter_handle[global_potential_audio_filter_cnt] = library;
									global_potential_audio_filter_cnt++;
								}
								found = 1;
							}
							if(strncmp(str, "camera_", strlen("camera_")) == 0)
							{
								if(global_potential_camera_cnt < 1024)
								{
									printf("CAMERA: %s %p\n", str, library);
									global_potential_camera[global_potential_camera_cnt] = strdup(str);
									global_potential_camera_handle[global_potential_camera_cnt] = library;
									global_potential_camera_cnt++;
								}
								found = 1;
							}
							if(strncmp(str, "fltk_", strlen("fltk_")) == 0)
							{
								if(global_potential_fltk_cnt < 1024)
								{
									printf("FLTK: %s %p\n", str, library);
									global_potential_fltk[global_potential_fltk_cnt] = strdup(str);
									global_potential_fltk_handle[global_potential_fltk_cnt] = library;
									global_potential_fltk_cnt++;
								}
								found = 1;
							}
						}
					}
				}
				if(found == 0)
				{
					dlclose(library);
				}
			}
		}
	}
	return(0);
}

void handler(int signal_number, siginfo_t *aa, void *bb)
{
	exit(0);
}

void	show_help()
{
	printf("cowcam [--source=[N|URL[::BACKEND[:FOURCC]]][--width=n][--height=n][--help]\n");
	printf("examples:\n\n");
	printf("# Use the default USB cowcam\n");
	printf("cowcam\n\n");
	printf("# Specify a device\n");
	printf("cowcam --source=/dev/video0\n\n");
	printf("# Specify a device and a backend\n");
	printf("cowcam --source=/dev/video0::V4L\n\n");
	printf("# Specify a device and an alias\n");
	printf("cowcam --source=/dev/video0[alias=Sony]\n\n");
	printf("# Specify a device and a backend with fourcc code (must be 4 characters long)\n");
	printf("cowcam --source=/dev/video0::V4L:MJPG\n\n");
	printf("# Specify an audio input device\n");
	printf("cowcam --audio_source=alsa_input.usb-audio-technica____AT2020_USB-00.analog-stereo\n\n");
	printf("# Load a full setup. This will overwrite most other options.\n");
	printf("cowcam --load=your_file.setup\n\n");
	printf("# Use an IP camera at a RTSP URL with login and password\n");
	printf("cowcam --source=rtsp://your_login:your_password@url_for_your_webcam.org/live\n\n");
	printf("# Use USB camera number 4\n");
	printf("cowcam --source=4\n\n");
	printf("# Set main window width to 1920, Defaults to fullscreen.\n");
	printf("cowcam --main_width=1920\n\n");
	printf("# Set main window height to 1080, Defaults to fullscreen.\n");
	printf("cowcam --main_width=1080\n\n");
	printf("# Set preferred video width to 640\n");
	printf("cowcam --width=640\n\n");
	printf("# Set preferred video height to 480\n");
	printf("cowcam --height=480\n\n");
	printf("# Scale the interface to system wide screen scaling.\n");
	printf("cowcam --auto_scale\n\n");
	printf("# Force a scaling factor to the interface.\n");
	printf("cowcam --forced_scale=2.0\n\n");
	printf("# Set preferred output video width to 1280. Output defaults to input.\n");
	printf("cowcam --output_width=1280\n\n");
	printf("# Set preferred output video height to 720. Output defaults to input.\n");
	printf("cowcam --output_height=720\n\n");
	printf("# Set preferred display video width to 1280. Display defaults to input.\n");
	printf("cowcam --display_width=1280\n\n");
	printf("# Set preferred display video height to 720. Display defaults to input.\n");
	printf("cowcam --display_height=720\n\n");
	printf("# Set the FPS to a specific value, avoiding testing\n");
	printf("cowcam --fps=18\n\n");
	printf("# Sets the interval between frames to a rigid length. Specified in seconds.\n");
	printf("cowcam --interval=0.01\n\n");
	printf("# Split the main screen between all the video sources\n");
	printf("cowcam --split\n\n");
	printf("# Start recording with the main a tracking detail window.\n");
	printf("cowcam --detail\n\n");
	printf("# Do not buffer frames and audio for later encoding.\n# video is recorded to MJPEG in MKV.\n");
	printf("cowcam --unbuffered\n\n");
	printf("# Record audio and video to raw files (unmuxed) and mux as a separate step.\n");
	printf("cowcam --buffered\n\n");
	printf("# Flip horizontally or vertically or both\n");
	printf("cowcam --flip=horizontal --flip=vertical\n\n");
	printf("# Do not record audio.\n");
	printf("cowcam --no_audio\n\n");
	printf("# Reopen old .bin (temporary files) to encode. Record is turned off.\n");
	printf("cowcam --old\n\n");
	printf("# Do not scan for USB cameras.\n");
	printf("cowcam --no_scan\n\n");
	printf("# Do not scan for input audio devices.\n");
	printf("cowcam --no_audio_scan\n\n");
	printf("# Scan for PTZ serial ports.\n");
	printf("cowcam --scan_for_ptz\n\n");
	printf("# Record entire main window, encoding on exit. Usually used to make tutorial videos for the program itself.\n");
	printf("cowcam --record_main_window\n\n");
	printf("# Record the desktop as another camera.\n");
	printf("cowcam --record_desktop\n\n");
	printf("# Record the desktop as another camera, specifying area to record as x,y,w,h.\n");
	printf("cowcam --record_desktop=20,40,640,360\n\n");
	printf("# Record each recording camera to its own file.\n");
	printf("cowcam --multi_stream\n\n");
	printf("# Display the camera that is currently recording.\n");
	printf("cowcam --display_recording_camera\n\n");
	printf("# Blend automatically between cuts when editing with the previewer.\n");
	printf("# Also fades in and out from black at the beginning and end.\n");
	printf("cowcam --transition=blend\n\n");
	printf("# Allows for PTZ camera control using VISCA over the specified serial port. A colon following the path\n");
	printf("# followed by a 1, indicates that this interface does not reply.\n");
	printf("cowcam --ptz=/dev/ttyUSB0:1\n\n");
	printf("# Reset PTZ cameras to home position on launch.\n");
	printf("cowcam --ptz_home.\n\n");
	printf("# Initialize object detection. Without this object detection is not offered.\n");
	printf("cowcam --detect\n\n");
	printf("# Use alternate DNN/YOLO files for recognition. If anyone one of these is provided,\n");
	printf("# the other two must also be present. The default values are:\n");
	printf("# \t\"yolov3-openimages.cfg\"\n");
	printf("# \t\"yolov3-openimages.weights\"\n");
	printf("# \t\"openimages.names\"\n");
	printf("# Or, depending on the value of --yolo_model=\n");
	printf("# \t\"yolov3.cfg\"\n");
	printf("# \t\"yolov3.weights\"\n");
	printf("# \t\"coco.names\"\n");
	printf("cowcam --yolo_cfg=cfg_filename --yolo_weights=weights_filename --yolo_names=names_filename\n\n");
	printf("# Use the default YOLO filenames for COCO or OpenImages. This defaults to OpenImages.\n");
	printf("cowcam --yolo_model=coco\n\n");
	printf("# If JPEG streaming is turned on, stream the current camera's image to\n");
	printf("# a custom server running at www.example.com on port 20000. Port 20001\n");
	printf("# will be used as the PTZ control port. If port 10000 was selected\n");
	printf("# port 10001 would be the control port.\n");
	printf("cowcam --jpeg_streaming=www.example.com:20000\n\n");
	printf("# Stream to a streaming server like Twitch or YouTube Live.\n");
	printf("# The entire URL must be specifed, including the protocol specifier\n");
	printf("# i.e.: smpt:// or rtmp://, etc. and any other URL embedded arguments\n");
	printf("# like your key\n");
	printf("cowcam --streaming=rtmp://www.streaming_server.com/your_key\n\n");
	printf("# Stream to the server specified in --streaming= or save to a muxed file if no server is specified.\n");
	printf("cowcam --streaming_only\n\n");
	printf("# Streaming audio quality expressed as a factor. The default is best. Base value is 11025 hz, so.\n");
	printf("# cowcam --streaming_audio_quality=good would be 11025 hz.\n");
	printf("# cowcam --streaming_audio_quality=better would be 22050 hz.\n");
	printf("# cowcam --streaming_audio_quality=best would be 44100 hz.\n");
	printf("cowcam --streaming_audio_quality=good\n\n");
	printf("# Embed the picture in picture stream into the recorded output.\n");
	printf("cowcam --embed_pip\n\n");
	printf("# Set the position of the picture in picture.\n");
	printf("cowcam --pip_position=0.8,0.1\n\n");
	printf("# Set the rgb color of the border around the pip. Set it to -1,-1,-1 for no border.\n");
	printf("cowcam --pip_highlight=255,128,64\n\n");
	printf("# Set the size of pip as fraction of its real size. The default is 1/4th (ie: 0.25)\n");
	printf("cowcam --pip_size=0.35\n\n");
	printf("# Allows for more than one pip.\n");
	printf("cowcam --multipip=right\n\n");
	printf("# Set the grid size for placement of sources. Default is 1 for no grid.\n");
	printf("cowcam --grid_size=10\n\n");
	printf("# Set the desktop audio monitor device (a null sink in pulseaudio).\n");
	printf("cowcam --desktop_monitor=my_null_sink\n\n");
	printf("# Query the system for available codecs and offer a menu of options.\n");
	printf("cowcam --query_codecs\n\n");
	printf("# Test the codecs found by --query_codecs at current settings to determing if they are usable,\n");
	printf("# eliminating those that are not from the offered options.\n");
	printf("cowcam --test_codecs\n\n");
	printf("# Timestamp video images.\n");
	printf("cowcam --timestamp\n\n");
	printf("# Disregard video setting when starting, using defaults and command line arguments instead.\n");
	printf("cowcam --disregard_settings\n\n");
	printf("# When scaling input images to output, keep aspect ratio and border excess.\n");
	printf("cowcam --no_frame_scaling\n\n");
	printf("# Crop image to output size rather than scaling it.\n");
	printf("cowcam --crop_output\n\n");
	printf("# Scale GUI elements to keep them around sized to output resolution.\n");
	printf("cowcam --scale_gui\n\n");
	printf("# Add a plugin filter library file to be searched.\n");
	printf("cowcam --filter_plugin_file=filename.so\n\n");
	printf("# Add a plugin filter from the library specified in --filter_plugin_file=...\n");
	printf("cowcam --filter_plugin=filter_name\n\n");
	printf("# Add a screen capture plugin library file to be searched.\n");
	printf("cowcam --capture_plugin_file=filename.so\n\n");
	printf("# Force GUI elements to persist on the screen rather than appearing when the mouse approaches.\n");
	printf("cowcam --retain_commands\n");
	printf("cowcam --retain_cameras\n");
	printf("cowcam --retain_audio\n");
	printf("cowcam --retain_ptz\n\n");
	printf("# Force all GUI elements to persist on the screen rather than appearing when the mouse approaches.\n");
	printf("cowcam --lock_panels\n\n");
	printf("# Hide the status message.\n");
	printf("cowcam --hide_status\n\n");
}

int StartMain()
{
void	enumerate_codecs();
void	enumerate_test(void (*output_cb)(char *), int test_w, int test_h, int test_fps, int test_hz);
int	xx, yy;
int	loop;
int	outer;
char	*source[128];
char	*audio_source[128];
extern int	global_my_format_cnt;

	int argc = global_argc;
	start_win->Update("Parsing arguments");
	int source_cnt = 0;
	int audio_source_cnt = 0;
	int new_width = 1920;
	int new_height = 1080;
	int new_output_width = -1;
	int new_output_height = -1;
	int new_display_width = -1;
	int new_display_height = -1;
	int new_fps = 30.0;
	double new_interval = 0.01;
	int new_split = 0;
	int new_main = 1;

	int new_muxing = 1;
	int use_audio = 1;

	int use_single_stream = 1;

	int new_flip = 0;
	int use_no_scan = 0;
	int use_no_audio_scan = 0;
	int new_direct_recording = 0;
	int use_old = 0;
	int use_record_all = 0;
	int use_record_desktop = 0;
	int use_desktop_x = -1;
	int use_desktop_y = -1;
	int use_desktop_w = -1;
	int use_desktop_h = -1;
	int use_display_recording_camera = 0;
	int use_transition = 0;
	int use_ptz_home_on_launch = 0;
	char *use_yolo_cfg = NULL;
	char *use_yolo_weights = NULL;
	char *use_yolo_names = NULL;
	int use_yolo_model = USE_YOLO_MODEL_OPEN_IMAGES;
	char *use_ptz_device_path[NUMBER_OF_INTERFACES];
	char *use_ptz_lock_alias[NUMBER_OF_INTERFACES];
	char *use_ptz_alias[NUMBER_OF_INTERFACES];
	char *use_jpeg_streaming = NULL;
	int use_streaming = 0;
	char *use_stream_url = NULL;
	int use_stream_only = 0;
	int use_streaming_audio_quality = 44100;
	for(loop = 0;loop < NUMBER_OF_INTERFACES;loop++)
	{
		use_ptz_device_path[loop] = NULL;
		use_ptz_lock_alias[loop] = NULL;
		use_ptz_alias[loop] = NULL;
	}
	int use_ptz_device_path_cnt = 0;
	char new_mux_format[256];
	strcpy(new_mux_format, "mov");
	int use_embed_pip = 0;
	double use_pip_x_position = 0.74;
	double use_pip_y_position = 0.73;
	int use_pip_red = 255;
	int use_pip_green = 255;
	int use_pip_blue = 255;
	double use_pip_size = 0.25;
	double use_grid_size = 0;
	int use_multipip = 0;
	int use_multipip_side = MULTIPIP_SIDE_RIGHT;
	char *use_desktop_monitor = NULL;
	int use_detect = 0;
	int test_codecs = 0;
	int query_codecs = 0;
	int timestamp = 0;
	int frame_scaling = 1;
	int crop_output = 0;
	int scale_gui = 0;
	char *load_file = NULL;
	int auto_scale = 0;
	double screen_scaling = 1.0;
	int default_window_width = -1;
	int default_window_height = -1;
	int scan_for_ptz = 0;
	int use_retain_commands = 0;
	int use_retain_cameras = 0;
	int use_retain_audio = 0;
	int use_retain_ptz = 0;
	int use_hide_status = 0;
	int use_disregard_settings = 0;
	if(argc > 1)
	{
		char *argv[1024];
		for(loop = 1;loop < argc;loop++)
		{
			argv[loop] = global_argv[loop];
			if(argv[loop] != NULL)
			{
				if(strncmp(argv[loop], "--source=", strlen("--source=")) == 0)
				{
					if(source_cnt < 128)
					{
						source[source_cnt] = strdup(argv[loop] + strlen("--source="));
						source_cnt++;
					}
				}
				if(strncmp(argv[loop], "--audio_source=", strlen("--audio_source=")) == 0)
				{
					if(audio_source_cnt < 128)
					{
						audio_source[audio_source_cnt] = strdup(argv[loop] + strlen("--audio_source="));
						audio_source_cnt++;
					}
				}
				if(strncmp(argv[loop], "--width=", strlen("--width=")) == 0)
				{
					new_width = atoi(argv[loop] + strlen("--width="));
					new_output_width = new_width;
					new_display_width = new_width;
				}
				if(strncmp(argv[loop], "--height=", strlen("--height=")) == 0)
				{
					new_height = atoi(argv[loop] + strlen("--height="));
					new_output_height = new_height;
					new_display_height = new_height;
				}
				if(strncmp(argv[loop], "--output_width=", strlen("--output_width=")) == 0)
				{
					new_output_width = atoi(argv[loop] + strlen("--output_width="));
				}
				if(strncmp(argv[loop], "--output_height=", strlen("--output_height=")) == 0)
				{
					new_output_height = atoi(argv[loop] + strlen("--output_height="));
				}
				if(strncmp(argv[loop], "--display_width=", strlen("--display_width=")) == 0)
				{
					new_display_width = atoi(argv[loop] + strlen("--display_width="));
				}
				if(strncmp(argv[loop], "--display_height=", strlen("--display_height=")) == 0)
				{
					new_display_height = atoi(argv[loop] + strlen("--display_height="));
				}
				if(strncmp(argv[loop], "--fps=", strlen("--fps=")) == 0)
				{
					new_fps = atoi(argv[loop] + strlen("--fps="));
				}
				if(strncmp(argv[loop], "--interval=", strlen("--interval=")) == 0)
				{
					new_interval = atof(argv[loop] + strlen("--interval="));
				}
				if(strncmp(argv[loop], "--split", strlen("--split")) == 0)
				{
					new_split = 1;
				}
				if(strncmp(argv[loop], "--detail", strlen("--detail")) == 0)
				{
					new_main = 0;
				}
				if(strncmp(argv[loop], "--container=", strlen("--container=")) == 0)
				{
					char *cp = argv[loop] + strlen("--container=");
					strcpy(new_mux_format, cp);
				}
				if(strncmp(argv[loop], "--buffered", strlen("--buffered")) == 0)
				{
					new_muxing = 0;
				}
				if(strncmp(argv[loop], "--unbuffered", strlen("--unbuffered")) == 0)
				{
					new_direct_recording = 1;
				}
				if(strncmp(argv[loop], "--no_audio", strlen("--no_audio")) == 0)
				{
					if(new_muxing == 0)
					{
						use_audio = 0;
					}
				}
				if(strncmp(argv[loop], "--flip=", strlen("--flip=")) == 0)
				{
					char *cp = argv[loop] + strlen("--flip=");
					if(strcmp(cp, "horizontal") == 0)
					{
						new_flip |= 1;
					}
					if(strcmp(cp, "vertical") == 0)
					{
						new_flip |= 2;
					}
				}
				if(strncmp(argv[loop], "--old", strlen("--old")) == 0)
				{
					use_old = 1;
				}
				if(strncmp(argv[loop], "--no_scan", strlen("--no_scan")) == 0)
				{
					use_no_scan = 1;
				}
				if(strncmp(argv[loop], "--no_audio_scan", strlen("--no_audio_scan")) == 0)
				{
					use_no_audio_scan = 1;
				}
				if(strncmp(argv[loop], "--scan_for_ptz", strlen("--scan_for_ptz")) == 0)
				{
					scan_for_ptz = 1;
				}
				if(strncmp(argv[loop], "--record_main_window", strlen("--record_main_window")) == 0)
				{
					use_record_all = 1;
				}
				if(strncmp(argv[loop], "--record_desktop", strlen("--record_desktop")) == 0)
				{
					use_record_desktop = 1;
					if(strncmp(argv[loop], "--record_desktop=", strlen("--record_desktop=")) == 0)
					{
						char *cp = argv[loop] + strlen("--record_desktop=");
						use_desktop_x = atoi(cp);
						while((*cp != ',') && (*cp != '\0')) cp++;
						if(*cp == ',')
						{
							cp++;
							use_desktop_y = atoi(cp);
							while((*cp != ',') && (*cp != '\0')) cp++;
							if(*cp == ',')
							{
								cp++;
								use_desktop_w = atoi(cp);
								while((*cp != ',') && (*cp != '\0')) cp++;
								if(*cp == ',')
								{
									cp++;
									use_desktop_h = atoi(cp);
								}
							}
						}
					}
				}
				if(strncmp(argv[loop], "--multi_stream", strlen("--multi_stream")) == 0)
				{
					use_single_stream = 0;
				}
				if(strncmp(argv[loop], "--display_recording_camera", strlen("--display_recording_camera")) == 0)
				{
					use_display_recording_camera = 1;
				}
				if(strncmp(argv[loop], "--transition=", strlen("--transition=")) == 0)
				{
					char *cp = argv[loop] + strlen("--transition=");
					if(strcmp(cp, "blend") == 0)
					{
						use_transition = TRANSITION_BLEND;
					}
					else if(strcmp(cp, "wipe_l2r") == 0)
					{
						use_transition = TRANSITION_L2R_WIPE;
					}
					else if(strcmp(cp, "wipe_r2l") == 0)
					{
						use_transition = TRANSITION_R2L_WIPE;
					}
					else if(strcmp(cp, "wipe_t2b") == 0)
					{
						use_transition = TRANSITION_T2B_WIPE;
					}
					else if(strcmp(cp, "wipe_b2t") == 0)
					{
						use_transition = TRANSITION_B2T_WIPE;
					}
					else if(strcmp(cp, "fade2black") == 0)
					{
						use_transition = TRANSITION_FADE_TO_BLACK;
					}
				}
				if(strncmp(argv[loop], "--ptz=", strlen("--ptz=")) == 0)
				{
					if(use_ptz_device_path_cnt < NUMBER_OF_INTERFACES)
					{
						char lock_alias[4092];
						char alias[4092];
						strcpy(lock_alias, "");
						strcpy(alias, "");
						char *orig_cp = argv[loop] + strlen("--ptz=");
						char *cp = orig_cp;
						while(*cp != '\0')
						{
							if(strncmp(cp, "[lock=", strlen("[lock=")) == 0)
							{
								*cp = '\0';
								cp += strlen("[lock=");
								char *cp2 = cp;
								while((*cp != '\0') && (*cp != ']'))
								{
									cp++;
								}
								if(*cp == ']')
								{
									*cp = '\0';
								}
								strcpy(lock_alias, cp2);
							}
							if(strncmp(cp, "[alias=", strlen("[alias=")) == 0)
							{
								*cp = '\0';
								cp += strlen("[alias=");
								char *cp2 = cp;
								while((*cp != '\0') && (*cp != ']'))
								{
									cp++;
								}
								if(*cp == ']')
								{
									*cp = '\0';
								}
								strcpy(alias, cp2);
							}
							if(*cp != '\0')
							{
								cp++;
							}
						}
						int rr = TestPTZPort(orig_cp);
						if(rr == 1)
						{
							use_ptz_lock_alias[use_ptz_device_path_cnt] = strdup(lock_alias);
							use_ptz_alias[use_ptz_device_path_cnt] = strdup(alias);
							use_ptz_device_path[use_ptz_device_path_cnt] = strdup(orig_cp);
							use_ptz_device_path_cnt++;
						}
					}
				}
				if(strncmp(argv[loop], "--detect", strlen("--detect")) == 0)
				{
					use_detect = 1;
				}
				if(strncmp(argv[loop], "--ptz_home", strlen("--ptz_home")) == 0)
				{
					use_ptz_home_on_launch = 1;
				}
				if(strncmp(argv[loop], "--yolo_cfg=", strlen("--yolo_cfg=")) == 0)
				{
					use_yolo_cfg = argv[loop] + strlen("--yolo_cfg=");
				}
				if(strncmp(argv[loop], "--yolo_weights=", strlen("--yolo_weights=")) == 0)
				{
					use_yolo_weights = argv[loop] + strlen("--yolo_weights=");
				}
				if(strncmp(argv[loop], "--yolo_names=", strlen("--yolo_names=")) == 0)
				{
					use_yolo_names = argv[loop] + strlen("--yolo_names=");
				}
				if(strncmp(argv[loop], "--yolo_model=", strlen("--yolo_model=")) == 0)
				{
					char *cp = argv[loop] + strlen("--yolo_model=");
					if(strcasecmp(cp, "coco") == 0)
					{
						use_yolo_model = USE_YOLO_MODEL_COCO;
					}
				}
				if(strncmp(argv[loop], "--jpeg_streaming=", strlen("--jpeg_streaming=")) == 0)
				{
					char *cp = argv[loop] + strlen("--jpeg_streaming=");
					use_jpeg_streaming = strdup(cp);
				}
				if(strncmp(argv[loop], "--streaming=", strlen("--streaming=")) == 0)
				{
					char *cp = argv[loop] + strlen("--streaming=");
					use_stream_url = strdup(cp);
					use_streaming = 1;
					new_muxing = 1;
					use_audio = 1;
				}
				if(strncmp(argv[loop], "--streaming_only", strlen("--streaming_only")) == 0)
				{
					use_stream_only = 1;
				}
				if(strncmp(argv[loop], "--streaming_audio_quality=", strlen("--streaming_audio_quality=")) == 0)
				{
					char *cp = argv[loop] + strlen("--streaming_audio_quality=");
					if(strcmp(cp, "good") == 0)
					{
						use_streaming_audio_quality = 11025;
					}
					else if(strcmp(cp, "better") == 0)
					{
						use_streaming_audio_quality = 22050;
					}
					else if(strcmp(cp, "best") == 0)
					{
						use_streaming_audio_quality = 44100;
					}
				}
				if(strncmp(argv[loop], "--embed_pip", strlen("--embed_pip")) == 0)
				{
					use_embed_pip = 1;
				}
				if(strncmp(argv[loop], "--pip_position=", strlen("--pip_position=")) == 0)
				{
					char *cp = argv[loop] + strlen("--pip_position=");
					use_pip_x_position = atof(cp);
					while((*cp != ',') && (*cp != '\0'))
					{
						cp++;
					}
					if(*cp == ',')
					{
						cp++;
						use_pip_y_position = atof(cp);
					}
				}
				if(strncmp(argv[loop], "--pip_highlight=", strlen("--pip_highlight=")) == 0)
				{
					char *cp = argv[loop] + strlen("--pip_highlight=");
					use_pip_red = atof(cp);
					while((*cp != ',') && (*cp != '\0'))
					{
						cp++;
					}
					if(*cp == ',')
					{
						cp++;
						use_pip_green = atof(cp);
						while((*cp != ',') && (*cp != '\0'))
						{
							cp++;
						}
						if(*cp == ',')
						{
							cp++;
							use_pip_blue = atof(cp);
						}
					}
				}
				if(strncmp(argv[loop], "--pip_size=", strlen("--pip_size=")) == 0)
				{
					char *cp = argv[loop] + strlen("--pip_size=");
					use_pip_size = atof(cp);
				}
				if(strncmp(argv[loop], "--main_width=", strlen("--main_width=")) == 0)
				{
					char *cp = argv[loop] + strlen("--main_width=");
					default_window_width = atof(cp);
				}
				if(strncmp(argv[loop], "--main_height=", strlen("--main_height=")) == 0)
				{
					char *cp = argv[loop] + strlen("--main_height=");
					default_window_height = atof(cp);
				}
				if(strncmp(argv[loop], "--grid_size=", strlen("--grid_size=")) == 0)
				{
					char *cp = argv[loop] + strlen("--grid_size=");
					use_grid_size = atof(cp);
				}
				if(strncmp(argv[loop], "--desktop_monitor=", strlen("--desktop_monitor=")) == 0)
				{
					char *cp = argv[loop] + strlen("--desktop_monitor=");
					use_desktop_monitor = strdup(cp);
				}
				if(strncmp(argv[loop], "--multipip=", strlen("--multipip=")) == 0)
				{
					use_multipip = MULTIPIP_SIDE_RIGHT;
					char *cp = argv[loop] + strlen("--multipip=");
					if(strcmp(cp, "right") == 0)
					{
						use_multipip = MULTIPIP_SIDE_RIGHT;
					}
					else if(strcmp(cp, "left") == 0)
					{
						use_multipip = MULTIPIP_SIDE_LEFT;
					}
					else if(strcmp(cp, "top") == 0)
					{
						use_multipip = MULTIPIP_SIDE_TOP;
					}
					else if(strcmp(cp, "bottom") == 0)
					{
						use_multipip = MULTIPIP_SIDE_BOTTOM;
					}
				}
				if(strncmp(argv[loop], "--test_codecs", strlen("--test_codecs")) == 0)
				{
					test_codecs = 1;
				}
				if(strncmp(argv[loop], "--query_codecs", strlen("--query_codecs")) == 0)
				{
					query_codecs = 1;
				}
				if(strncmp(argv[loop], "--timestamp", strlen("--timestamp")) == 0)
				{
					timestamp = 1;
				}
				if(strncmp(argv[loop], "--disregard_settings", strlen("--disregard_settings")) == 0)
				{
					use_disregard_settings = 1;
				}
				if(strncmp(argv[loop], "--no_frame_scaling", strlen("--no_frame_scaling")) == 0)
				{
					frame_scaling = 0;
				}
				if(strncmp(argv[loop], "--crop_output", strlen("--crop_output")) == 0)
				{
					crop_output = 1;
				}
				if(strncmp(argv[loop], "--scale_gui", strlen("--scale_gui")) == 0)
				{
					scale_gui = 1;
				}
				if(strncmp(argv[loop], "--auto_scale", strlen("--auto_scale")) == 0)
				{
					auto_scale = 1;
				}
				if(strncmp(argv[loop], "--retain_commands", strlen("--retain_commands")) == 0)
				{
					use_retain_commands = 1;
				}
				if(strncmp(argv[loop], "--retain_cameras", strlen("--retain_cameras")) == 0)
				{
					use_retain_cameras = 1;
				}
				if(strncmp(argv[loop], "--retain_audio", strlen("--retain_audio")) == 0)
				{
					use_retain_audio = 1;
				}
				if(strncmp(argv[loop], "--retain_ptz", strlen("--retain_ptz")) == 0)
				{
					use_retain_ptz = 1;
				}
				if(strncmp(argv[loop], "--lock_panels", strlen("--lock_panels")) == 0)
				{
					use_retain_commands = 1;
					use_retain_cameras = 1;
					use_retain_audio = 1;
					use_retain_ptz = 1;
				}
				if(strncmp(argv[loop], "--hide_status", strlen("--hide_status")) == 0)
				{
					use_hide_status = 1;
				}
				if(strncmp(argv[loop], "--forced_scale=", strlen("--forced_scale=")) == 0)
				{
					char *cp = argv[loop] + strlen("--forced_scale=");
					screen_scaling = atof(cp);
					if((screen_scaling < 0.01) || (screen_scaling > 100.0)) screen_scaling = 1.0;
				}
				if(strncmp(argv[loop], "--load=", strlen("--load=")) == 0)
				{
					char *cp = argv[loop] + strlen("--load=");
					load_file = strdup(cp);
				}
				if(strncmp(argv[loop], "--filter_plugin=", strlen("--filter_plugin=")) == 0)
				{
					if(global_filter_plugin_cnt < 1024)
					{
						char *cp = argv[loop] + strlen("--filter_plugin=");
						global_filter_plugin[global_filter_plugin_cnt] = strdup(cp);
						global_filter_plugin_cnt++;
					}
				}
				if(strncmp(argv[loop], "--audio_filter_plugin=", strlen("--audio_filter_plugin=")) == 0)
				{
					if(global_audio_filter_plugin_cnt < 1024)
					{
						char *cp = argv[loop] + strlen("--audio_filter_plugin=");
						global_filter_plugin[global_audio_filter_plugin_cnt] = strdup(cp);
						global_audio_filter_plugin_cnt++;
					}
				}
				if(strncmp(argv[loop], "--filter_plugin_file=", strlen("--filter_plugin_file=")) == 0)
				{
					if(global_filter_plugin_file_cnt < 1024)
					{
						char *cp = argv[loop] + strlen("--filter_plugin_file=");
						global_filter_plugin_file[global_filter_plugin_file_cnt] = strdup(cp);
						global_filter_plugin_file_cnt++;
					}
				}
				if(strncmp(argv[loop], "--capture_plugin_file=", strlen("--capture_plugin_file=")) == 0)
				{
					char *cp = argv[loop] + strlen("--capture_plugin_file=");
					strcpy(global_capture_plugin_file, cp);
				}
			}
		}
	}
	start_win->Update("Opening plugins");
	global_capture_plugin_handle = dlopen(global_capture_plugin_file, RTLD_NOW);
	if(global_capture_plugin_handle != NULL)
	{
		void_capture_init_capture = (void *)dlsym(global_capture_plugin_handle, "init_capture");
		void_capture_capture = (void *)dlsym(global_capture_plugin_handle, "capture");
		void_capture_finish_capture = (void *)dlsym(global_capture_plugin_handle, "finish_capture");
		if((void_capture_init_capture != NULL)
		&& (void_capture_capture != NULL)	
		&& (void_capture_finish_capture != NULL))
		{
			int (*capture_init)();
			capture_init = (int (*)())void_capture_init_capture;
			int nn = capture_init();
		}
	}
	int cnt = 0;
	for(outer = 0;outer < global_filter_plugin_file_cnt;outer++)
	{
		global_plugin_handle[outer] = dlopen(global_filter_plugin_file[outer], RTLD_NOW);
		if(global_plugin_handle[outer] != NULL)
		{
			void_pseudo_camera = (void *)dlsym(global_plugin_handle[outer], "pseudo_camera");
			void_handle_events = (void *)dlsym(global_plugin_handle[outer], "handle_events");
			for(loop = 0;loop < global_filter_plugin_cnt;loop++)
			{
				void_filter_plugin[cnt] = (void *)dlsym(global_plugin_handle[outer], global_filter_plugin[loop]);
				if(void_filter_plugin[cnt] != NULL)
				{
					cnt++;
				}
			}
			for(loop = 0;loop < global_audio_filter_plugin_cnt;loop++)
			{
				void_audio_filter_plugin[cnt] = (void *)dlsym(global_plugin_handle[outer], global_audio_filter_plugin[loop]);
				if(void_audio_filter_plugin[cnt] != NULL)
				{
					cnt++;
				}
			}
		}
	}
	if(scan_for_ptz == 1)
	{
		start_win->Update("Scanning for PTZ");
		char *final[256];
		int nn = ScanViableTTYPorts(final);
		for(loop = 0;loop < nn;loop++)
		{
			use_ptz_lock_alias[use_ptz_device_path_cnt] = strdup("");
			use_ptz_alias[use_ptz_device_path_cnt] = strdup("");
			use_ptz_device_path[use_ptz_device_path_cnt] = strdup(final[loop]);
			use_ptz_device_path_cnt++;
			free(final[loop]);
		}
	}
	start_win->Update("Setting scale");
	Fl::set_color(FL_YELLOW, 255, 249, 156);
	global_filter_plugin_cnt = cnt;
	list_shared_exports("Plugins");

	if(auto_scale == 1)
	{
		double use_scale = (double)Fl::h() / 1080.0;
		double current_scale = Fl::screen_scale(0);
		double final_scale = use_scale * current_scale;
		Fl::screen_scale(0, final_scale);
	}
	else if(screen_scaling != 1.0)
	{
		Fl::screen_scale(0, screen_scaling);
	}
	if(default_window_width < 960)
	{
		default_window_width = Fl::w();
	}
	if(default_window_height < 540)
	{
		default_window_height = Fl::h();
	}
	MyWin *win = new MyWin(
		default_window_width
		, default_window_height
		, source_cnt
		, source
		, audio_source_cnt
		, audio_source
		, new_direct_recording
		, new_width
		, new_height
		, new_output_width
		, new_output_height
		, new_display_width
		, new_display_height
		, new_fps
		, new_interval
		, new_split
		, new_main
		, new_muxing
		, new_flip
		, use_audio
		, new_mux_format
		, use_old
		, use_no_scan
		, use_no_audio_scan
		, use_record_all
		, use_record_desktop
		, use_desktop_x
		, use_desktop_y
		, use_desktop_w
		, use_desktop_h
		, use_single_stream
		, use_display_recording_camera
		, use_transition
		, use_ptz_device_path_cnt
		, use_ptz_device_path
		, use_ptz_lock_alias
		, use_ptz_alias
		, use_ptz_home_on_launch
		, use_yolo_model
		, use_yolo_cfg
		, use_yolo_weights
		, use_yolo_names
		, use_jpeg_streaming
		, use_streaming
		, use_stream_url
		, use_stream_only
		, use_streaming_audio_quality
		, use_embed_pip
		, use_pip_x_position
		, use_pip_y_position
		, use_pip_red
		, use_pip_green
		, use_pip_blue
		, use_pip_size
		, use_multipip
		, use_grid_size
		, use_desktop_monitor
		, use_detect
		, timestamp
		, frame_scaling
		, scale_gui
		, load_file
		, use_retain_commands
		, use_retain_cameras
		, use_retain_audio
		, use_retain_ptz
		, use_hide_status
		, auto_scale
		, crop_output
		, use_disregard_settings
		, "Cowcam");
	win->color(FL_WHITE);
	win->end();
	win->show();
	win->callback(quit_cb, win);
	if((new_width == Fl::w()) && (new_height == Fl::h()))
	{
		win->detail = new DetailWin(Fl::w() / 4, Fl::h() / 4, "Detail");
		win->detail->end();
		win->detail->hide();
		win->detail->set_non_modal();
		win->detail->resize(win->x() + 100, win->h() - 100, Fl::w() / 4, Fl::h() / 4);
	}
	else
	{
		win->detail = NULL;
		win->stream = 1;
	}
	start_win->Update("Opening supplemental windows");
	TriggerWindow *tw = new TriggerWindow(win);
	win->trigger_window = tw;
	win->add(tw);
	tw->hide();

	TransitionWindow *transition = new TransitionWindow(win);
	transition->hide();
	win->transitions_window = transition;

	PseudoCameraWindow *pseudo_camera = new PseudoCameraWindow(win);
	pseudo_camera->hide();
	win->pseudo_camera_window = pseudo_camera;

	FilterPluginsWindow *filter_built_in = new FilterPluginsWindow(win, FILTER_TYPE_VIDEO_BUILT_IN);
	filter_built_in->hide();
	win->filter_built_in_window = filter_built_in;

	FilterPluginsWindow *filter_plugins = new FilterPluginsWindow(win, FILTER_TYPE_VIDEO);
	filter_plugins->hide();
	win->filter_plugins_window = filter_plugins;

	FilterPluginsWindow *audio_filter_plugins = new FilterPluginsWindow(win, FILTER_TYPE_AUDIO);
	audio_filter_plugins->hide();
	win->audio_filter_plugins_window = audio_filter_plugins;

	ImmediateDrawingWindow *immediate_drawing_window = new ImmediateDrawingWindow(win, 400, 150, 120, 420, "Immediate Drawing");
	immediate_drawing_window->hide();
	win->immediate_drawing_window = immediate_drawing_window;

	win->fltk_plugin_window = new FltkPluginWindow(win);
	win->fltk_plugin_window->hide();

	global_window = win;

	win->MakeNewSourceWindow();
	win->MakeAliasWindow();

	win->command_key_settings = new CommandKeySettingsWindow(win, 370, 800);
	win->embed_app_settings = new EmbedAppSettings(win);

	Fl::add_timeout(0.1, my_window_cb, win);
	if((global_my_format_cnt == 0) && (query_codecs == 1))
	{
		start_win->Update("Querying CODECS");
		enumerate_codecs();
		if(test_codecs == 1)
		{
			if(new_output_width == -1)
				new_output_width = new_width;
			if(new_output_height == -1)
				new_output_height = new_height;
			enumerate_test(NULL, new_output_width, new_output_height, (int)new_fps, use_streaming_audio_quality);
		}
	}
	start_win->Update("Constructing settings windows");
	SettingWindow *sw = new SettingWindow(win);
	sw->hide();
	win->settings_window = sw;

	SnapshotSettingWindow *ssw = new SnapshotSettingWindow(win);
	ssw->hide();
	win->snapshot_settings_window = ssw;

	start_win->Update("Building Select Output Window");
	win->BuildSelectOutputWindow();

	start_win->Update("Building Set Output Window");
	win->BuildSetOutputWindow();

	win->gui_settings_window = new GUI_SettingsWindow(win);
	win->gui_settings_window->hide();

	win->original_w = win->w();
	win->original_h = win->h();

	Fl::focus(win);

	return(0);
}

StartWindow::StartWindow(int xx, int yy, int ww, int hh, int in_argc, char *lbl) : Fl_Double_Window(xx, yy, ww, hh, lbl)
{
	argc = in_argc;
	text = new Fl_Box(0, 0, ww, hh, "");
	text->box(FL_FLAT_BOX);
	text->color(FL_BLACK);
	text->labelcolor(FL_WHITE);
	int nn = 32 * (hh / 1080);
	text->labelsize(nn);
	image_mat_cnt = 0;
	end();
}

void	StartWindow::draw()
{
int	loop;

	Fl_Double_Window::draw();
	int start_x = (Fl::w() / 2) - ((image_mat_cnt * 160) / 2);
	int start_y = (Fl::h() / 2) + 140;
	for(loop = 0;loop < image_mat_cnt;loop++)
	{
		fl_draw_image(image_mat[loop].ptr(), start_x + (loop * 160), start_y, image_mat[loop].cols, image_mat[loop].rows, 4);
	}
}

void	StartWindow::Update(char *str)
{
	text->label(str);
	text->redraw();
	redraw();
	Fl::flush();
	Fl::check();
	usleep(250000);
}

int	x11_handler(Display *d, XErrorEvent *e)
{
#ifdef DEBUG
	printf("X11 ERROR: %d\n", e->error_code);
#endif
	return(0);
}

void	start_cb(void *v)
{
	StartWindow *w = (StartWindow *)v;
	XSetErrorHandler(x11_handler);
	w->Update("Starting...");
	StartMain();
	w->hide();
}

int	main(int argc, char **argv)
{
int		loop;

	int html = 0;
	for(loop = 0;loop < argc;loop++)
	{
		if(strncmp(argv[loop], "--html_renderer", strlen("--html_renderer")) == 0)
		{
			global_html = 1;
		}
		global_argv[loop] = strdup(argv[loop]);
		global_argc = argc;
	}
	initialize_cef(global_html, argc, argv);
	int do_auto_scale = 0;
	int no_go = 0;
	for(loop = 0;loop < argc;loop++)
	{
		if(strncmp(global_argv[loop], "--auto_scale", strlen("--auto_scale")) == 0)
		{
			do_auto_scale = 1;
		}
		if(strncmp(global_argv[loop], "--help", strlen("--help")) == 0)
		{
			show_help();
			no_go = 1;
		}
	}
	if(no_go == 0)
	{
		Fl::option(Fl::OPTION_ARROW_FOCUS, 0);
		Fl::option(Fl::OPTION_VISIBLE_FOCUS, 0);
		Fl::keyboard_screen_scaling(1);
#ifdef NO_GTK
		Fl::option(Fl::OPTION_FNFC_USES_GTK, 0);
#endif
#ifdef NO_ZENITY
		Fl::option(Fl::OPTION_FNFC_USES_ZENITY, 0);
#endif
		fl_register_images();
		Fl_File_Icon::load_system_icons();
		Fl::set_color(DARK_GRAY, 50, 50, 50);
		Fl::set_color(LIGHT_GRAY, 200, 200, 200);
		Fl::set_color(DARK_RED, 100, 0, 0);
		Fl::set_color(DARK_BLUE, 0, 0, 100);

		int ww = Fl::w();
		int hh = Fl::h();
		if(do_auto_scale == 1)
		{
			double use_scale = (double)Fl::h() / 1080.0;
			double current_scale = Fl::screen_scale(0);
			double final_scale = use_scale * current_scale;
			Fl::screen_scale(0, final_scale);
			ww = 1920;
			hh = 1080;
		}
		global_log_window = new Fl_Window(1200, 800, "Codec Log");
			Fl_Browser *browser = new Fl_Browser(0, 0, 1200, 800);
		global_log_window->end();
		global_log_window->hide();

		start_win = new StartWindow(0, 0, ww, hh, argc + 1, "Starting");
		start_win->box(FL_FLAT_BOX);
		start_win->show();

		Fl::add_timeout(1.0, start_cb, start_win);
		Fl::run();

		if(void_capture_finish_capture != NULL)
		{
			int (*capture_finish)();
			capture_finish = (int (*)())void_capture_finish_capture;
			capture_finish();
		}
		for(loop = 0;loop < global_filter_plugin_file_cnt;loop++)
		{
			if(global_plugin_handle[loop] != NULL)
			{
				dlclose(global_plugin_handle[loop]);
			}
		}
	}
	if(global_html == 1)
	{
		shutdown_cef();
	}
	for(loop = 0;loop < argc;loop++)
	{
		if(global_argv[loop] != NULL)
		{
			free(global_argv[loop]);
		}
	}
}
